##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Oct/2011  23:45:47 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  I:\Amuse\SVN\Siemens\MySMSYS\Mss3\SmsListMenu.cpp    #
#    Command line    =  I:\Amuse\SVN\Siemens\MySMSYS\Mss3\SmsListMenu.cpp    #
#                       -D NEWSGOLD -D S68 -D LANG_CN -lcN                   #
#                       I:\Amuse\SVN\Siemens\MySMSYS\Mss3\Release_S68\List\  #
#                       -o I:\Amuse\SVN\Siemens\MySMSYS\Mss3\Release_S68\Obj #
#                       \ -s9 --no_unroll --cpu_mode arm --endian little     #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --eec++ --dlib_config "D:\Program         #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I "D:\Program     #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  I:\Amuse\SVN\Siemens\MySMSYS\Mss3\Release_S68\List\S #
#                       msListMenu.lst                                       #
#    Object file     =  I:\Amuse\SVN\Siemens\MySMSYS\Mss3\Release_S68\Obj\Sm #
#                       sListMenu.r79                                        #
#                                                                            #
#                                                                            #
##############################################################################

I:\Amuse\SVN\Siemens\MySMSYS\Mss3\SmsListMenu.cpp
      1          #include "include.h"
      2          
      3          #include "SiemensPDU.h"
      4          #include "MyIpcMessage.h"
      5          #include "File.h"
      6          #include "SmsData.h"
      7          #include "CreateMenu.h"
      8          #include "SmsListMenu.h"
      9          #include "TabGUI.h"
     10          
     11          #include "AdrList.h"
     12          #include "NumList.h"
     13          #include "EditGUI.h"
     14          
     15          #include "PopupGUI.h"
     16          
     17          #include "NativeAddressbook.h"
     18          #include "CodeShow.h"
     19          
     20          SOFTKEY_DESC sms_menu_sk[]=
     21          {
     22            {0x0018,0x0000,(int)LGP_NULL},
     23            {0x0001,0x0000,(int)LGP_NULL},
     24            {0x003D,0x0000,(int)LGP_DOIT_PIC}
     25          };
     26          
     27          const SOFTKEYSTAB sms_menu_skt=
     28          {
     29            sms_menu_sk,0
     30          };
     31          
     32          const HEADER_DESC sms_menuhdr={0,0,0,0,NULL,LGP_NULL,LGP_NULL};
     33          
     34          SmsListMenu::~SmsListMenu()
     35          {
     36          }
     37          
     38          SmsListMenu::SmsListMenu()
     39          {
     40            menu.flag=8;
     41            menu.onkey=OnKey;
     42            menu.ghook=GHook;
     43            menu.proc3=NULL;
     44            menu.softkeys=softkeys;
     45            menu.softkeystab=&sms_menu_skt;
     46            menu.flags2=0x11; //icon
     47            menu.itemproc=ItemProc;
     48            menu.items=NULL;
     49            menu.procs=NULL;
     50            menu.n_items=0;
     51            menu.n_lines=1; //2
     52          }
     53          
     54          int SmsListMenu::OnKey(void *data, GUI_MSG *msg)
     55          {
     56            SmsListMenu *slm=(SmsListMenu *)MenuGetUserPointer(data);
     57            int cur=GetCurMenuItem(data);
     58            SDLIST *sdl=SMSDATA->FindSDL(slm->type, cur);
     59            if(msg->keys==1)
     60              return 1;
     61            if(!sdl) return 0;
     62            if(msg->keys==0x3D)
     63            {
     64              {
     65                EditGUI *edg=new EditGUI;
     66                edg->CreateEditGUI(slm->dlg_csm, sdl, ED_VIEW, slm->type, 0);
     67              }
     68            }
     69            else if (msg->keys==0x5)
     70            {
     71              {
     72                EditGUI *edg=new EditGUI;
     73                edg->CreateEditGUI(slm->dlg_csm, sdl, ED_REPLY, slm->type, 0);
     74              }
     75            }
     76            else if (msg->keys==0x18)
     77            {
     78              {
     79                SmsOptionMenu *sop=new SmsOptionMenu;
     80                sop->CreateSmsOptionMenu(slm->dlg_csm, slm->gui_id, slm->type, sdl);
     81              }
     82            }
     83            else if (msg->keys==0x14)
     84            {
     85          #ifdef LANG_CN
     86              unsigned short wscsb[32];
     87              WSHDR *wmsg, *wscs, _wscs;
     88              wmsg=AllocWS(150);
     89              wscs=CreateLocalWS(&_wscs, wscsb, 31);
     90              CodeShow::GetProvAndCity(wscs->wsbody, sdl->number);
     91              wsprintf(wmsg, "%s\n%t:\n%w",
     92                sdl->number,
     93                LGP->lgp.LGP_CODESHOW,
     94                wscs
     95                );
     96              MyShowMsg::MyShow(1, wmsg);
     97          #else
     98              MyShowMsg::MyShow(1, sdl->number);
     99          #endif
    100              //{
    101              //  ShowMSG(1, (int)(sdl->number));
    102              //}
    103            }
    104            if(msg->gbsmsg->msg==KEY_DOWN)
    105            {
    106              int key=msg->gbsmsg->submess;
    107              if(key=='7') //delete
    108              {
    109                if(SMSDATA->DeleteMessage(sdl))
    110                {
    111          	slm->ReCreateMe(data);
    112          	return 1;
    113                }
    114              }
    115              else if (key=='4') //move to archive
    116              {
    117                if (SMSDATA->MoveToArchive(sdl))
    118                {
    119          	slm->ReCreateMe(data);
    120          	return 1;
    121                }
    122              }
    123            }
    124            return 0;
    125          }
    126          
    127          int SLM_HDR_LGPS[]={LGP_NULL,LGP_NULL,LGP_NULL,LGP_NULL,LGP_NULL,LGP_NULL,LGP_NULL};
    128          
    129          void SmsListMenu::GHook(void *data, int cmd)
    130          {
    131            SmsListMenu *slm=(SmsListMenu *)MenuGetUserPointer(data);
    132            if(cmd==0xA)
    133            {
    134              int n=SMSDATA->GetSMSCount(slm->type);
    135              int cur=GetCurMenuItem(data);
    136              if(cur>=n) SetCursorToMenuItem(data, 0);
    137              Menu_SetItemCountDyn(data, n);
    138              DisableIDLETMR();
    139            }
    140            else if(cmd==0x2)
    141            {
    142              WSHDR *hdr_t=AllocWS(64);
    143              void *hdr_p=GetHeaderPointer(data);
    144              void *ma=malloc_adr();
    145              void *mf=mfree_adr();
    146              wsprintf(hdr_t, PERCENT_T, SLM_HDR_LGPS[slm->type<6?slm->type:0]);
    147              SetHeaderText(hdr_p, hdr_t, ma, mf);
    148            }
    149            else if(cmd==0x3)
    150            {
    151              delete slm;
    152            }
    153            else if (cmd==0x5)
    154            {
    155              const char *lgpN;
    156              switch(slm->type)
    157              {
    158              case 0:
    159                lgpN=LGP->lgp.LGP_ALL;
    160                break;
    161              case TYPE_IN_R:
    162                lgpN=LGP->lgp.LGP_IN_R;
    163                break;
    164              case TYPE_IN_N:
    165                lgpN=LGP->lgp.LGP_IN_N;
    166                break;
    167              case TYPE_SENT:
    168                lgpN=LGP->lgp.LGP_SENT;
    169                break;
    170              case TYPE_DRAFT:
    171                lgpN=LGP->lgp.LGP_DRAFT;
    172                break;
    173              case TYPE_IN_ALL:
    174                lgpN=LGP->lgp.LGP_IN_A;
    175                break;
    176              case TYPE_FILTER:
    177                lgpN=LGP->lgp.LGP_FILTER;
    178                break;
    179              default:
    180                lgpN=0;
    181              }
    182              slm->UpdateCSMName(slm->dlg_csm, (int)lgpN);
    183            }
    184          }
    185          
    186          #define MENU_MAX_TXT 32
    187          int SLM_ICONS[8]={ICON_BLANK, ICON_BLANK, ICON_BLANK, ICON_BLANK, ICON_BLANK, ICON_BLANK, ICON_BLANK, 0};
    188          void SmsListMenu::ItemProc(void *data, int curitem, void *user_pointer)
    189          {
    190            SDLIST *sdl;
    191            void *item=AllocMLMenuItem(data);
    192            WSHDR *ws1=AllocMenuWS(data, MENU_MAX_TXT);
    193            WSHDR *ws2=AllocMenuWS(data, 150);
    194            SmsListMenu *slm=(SmsListMenu *)MenuGetUserPointer(data);
    195            if((sdl=SMSDATA->FindSDL(slm->type, curitem)))
    196            {
    197              if(sdl->text)
    198          	{
    199          		wstrncpy(ws1, sdl->text, MENU_MAX_TXT);
    200          		ReplaceNewLineToSpace(ws1);
    201          	}
    202              else goto SL_ERR;
    203              if(!strlen(sdl->number))
    204                CutWSTR(ws2, 0);
    205              else
    206              {
    207                if(!ADRLST->FindName(ws2, sdl->number))
    208          	wsprintf(ws2, PERCENT_S, sdl->number);
    209              }
    210            }
    211            else
    212            {
    213            SL_ERR:
    214              wsprintf(ws1, PERCENT_T, LGP->lgp.LGP_ERR);
    215              CutWSTR(ws2, 0);
    216            }
    217            SetMenuItemIconArray(data, item, SLM_ICONS);
    218            SetMenuItemIcon(data, curitem, (sdl)?(sdl->type):0);
    219            SetMLMenuItemText(data, item, ws1, ws2, curitem);
    220          }
    221          
    222          int SmsListMenu::CreateSmsListMenu(int type, int is_tab, DLG_CSM *dlg_csm)
    223          {
    224            this->type=type;
    225            this->is_tab=is_tab;
    226            this->dlg_csm=dlg_csm;
    227            this->gui_id=CreateMenu(&menu, &sms_menuhdr, 0, SMSDATA->GetSMSCount(type), this);
    228            return this->gui_id;
    229          }
    230          /*
    231          void *SmsListMenu::GetSmsListMenuGUI(int type, int is_tab, DLG_CSM *dlg_csm)
    232          {
    233            void *m_gui;
    234            void *ma=malloc_adr();
    235            void *mf=mfree_adr();
    236            this->type=type;
    237            this->dlg_csm=dlg_csm;
    238            this->gui_id=0;
    239            this->is_tab=is_tab;
    240            m_gui=GetMultiLinesMenuGUI(ma, mf);
    241            SetMenuToGUI(m_gui, &this->menu);
    242            SetMenuItemCount(m_gui, SMSDATA->GetSMSCount(type));
    243            MenuSetUserPointer(m_gui, this);
    244            SetCursorToMenuItem(m_gui, 0);
    245            patch_header(&sms_menuhdr);
    246            SetHeaderToMenu(m_gui, &sms_menuhdr, ma);
    247            return m_gui;
    248          }
    249          */
    250          void * SmsListMenu::GetSmsListMenuGUI(int type, int is_tab, DLG_CSM *dlg_csm, int cur)
    251          {
    252            void *m_gui;
    253            void *ma=malloc_adr();
    254            void *mf=mfree_adr();
    255            this->type=type;
    256            this->dlg_csm=dlg_csm;
    257            this->gui_id=0;
    258            this->is_tab=is_tab;
    259            m_gui=GetMultiLinesMenuGUI(ma, mf);
    260            SetMenuToGUI(m_gui, &this->menu);
    261            SetMenuItemCount(m_gui, SMSDATA->GetSMSCount(type));
    262            MenuSetUserPointer(m_gui, this);
    263            SetCursorToMenuItem(m_gui, cur);
    264            patch_header(&sms_menuhdr);
    265            SetHeaderToMenu(m_gui, &sms_menuhdr, ma);
    266            return m_gui;
    267          }
    268          /*
    269          SOFTKEY_DESC sop_menu_sk[]=
    270          {
    271            {0x0018,0x0000,(int)LGP_NULL},
    272            {0x0001,0x0000,(int)LGP_NULL},
    273            {0x003D,0x0000,(int)LGP_DOIT_PIC}
    274          };
    275          
    276          const SOFTKEYSTAB sop_menu_skt=
    277          {
    278            sop_menu_sk,0
    279          };
    280          */
    281          const HEADER_DESC sop_menuhdr={0,0,0,0,NULL,LGP_NULL,LGP_NULL};
    282          
    283          #define SOP_MENU_ITEM_N 7
    284          SmsOptionMenu::SmsOptionMenu()
    285          {
    286            this->menu.flag=8;
    287            this->menu.onkey=this->OnKey;
    288            this->menu.ghook=this->GHook;
    289            this->menu.proc3=NULL;
    290            this->menu.softkeys=softkeys;
    291            this->menu.softkeystab=&sel_menu_skt;
    292            this->menu.flags2=0x11; //icon
    293            this->menu.itemproc=this->ItemProc;
    294            this->menu.items=NULL;
    295            this->menu.procs=NULL;
    296            this->menu.n_items=0;
    297          }
    298          
    299          SmsOptionMenu::~SmsOptionMenu()
    300          {
    301          }
    302          
    303          int SmsOptionMenu::OnKey(void *data, GUI_MSG *msg)
    304          {
    305            SmsOptionMenu *sop=(SmsOptionMenu *)MenuGetUserPointer(data);
    306            int cur=GetCurMenuItem(data);
    307            if(msg->keys==1)
    308              return 1;
    309            if(msg->keys==0x3D || msg->keys==0x18)
    310            {
    311          DO_OP:
    312              switch(cur)
    313              {
    314              case 0:
    315                {
    316          	EditGUI *edg=new EditGUI;
    317          	edg->CreateEditGUI(sop->dlg_csm, sop->sdl, ED_REPLY, sop->list_type, 0);
    318                }
    319                break;
    320              case 1:
    321                {
    322          	EditGUI *edg=new EditGUI;
    323          	edg->CreateEditGUI(sop->dlg_csm, sop->sdl, ED_EDIT, sop->list_type, 0);
    324                }
    325                break;
    326              case 2:
    327                SMSDATA->DeleteMessage(sop->sdl);
    328                break;
    329              case 3:
    330                if (sop->sdl)
    331                {
    332          	NAbCSM *nab=new NAbCSM;
    333          	nab->CreateNAbCSM(NULL, 0, sop->sdl->number, NAB_SAVE);
    334                }
    335                break;
    336              case 4:
    337                if (sop->sdl
    338          	&& strlen(sop->sdl->number)
    339          	)
    340                {
    341          	MakeVoiceCall(sop->sdl->number,0x10,0x2FFF);
    342                }
    343                break;
    344              case 5:
    345                SMSDATA->MoveToArchive(sop->sdl);
    346                break;
    347              case 6:
    348                if(!sop->slm_id) GeneralFunc_flag1(sop->dlg_csm->gui_id, 1);
    349                else GeneralFunc_flag1(sop->slm_id, 1);
    350                break;
    351              }
    352              return 1;
    353            }
    354            if(msg->gbsmsg->msg==KEY_DOWN)
    355            {
    356              cur=msg->gbsmsg->submess;
    357              if(cur>='1' && cur<='9')
    358              {
    359                cur-='1';
    360                goto DO_OP;
    361              }
    362            }
    363            return 0;
    364          }
    365          
    366          void SmsOptionMenu::GHook(void *data, int cmd)
    367          {
    368            SmsOptionMenu *sop=(SmsOptionMenu *)MenuGetUserPointer(data);
    369            if(cmd==0xA)
    370            {
    371              DisableIDLETMR();
    372            }
    373            else if (cmd==0x3)
    374            {
    375              delete sop;
    376            }
    377            else if (cmd==0x2)
    378            {
    379              WSHDR *hdr_t=AllocWS(32);
    380              wsprintf(hdr_t, PERCENT_T, LGP->lgp.LGP_OPTIONS);
    381              SetHeaderText(GetHeaderPointer(data), hdr_t, malloc_adr(), mfree_adr());
    382            }
    383          }
    384          
    385          int SOP_ITEM_LGPS[SOP_MENU_ITEM_N]=
    386          {
    387            LGP_NULL, //reply
    388              LGP_NULL, //edit
    389              LGP_NULL, //delete
    390              LGP_SAVE_TO_AB,
    391              LGP_NULL, //call
    392              LGP_NULL, //move to archive
    393              LGP_NULL, //leave
    394          };
    395          
    396          const int SOP_ITEM_ICONS[]={ICON_BLANK,0};
    397          void SmsOptionMenu::ItemProc(void *data, int curitem, void *user_pointer)
    398          {
    399            void *item=AllocMenuItem(data);
    400            WSHDR *ws=AllocMenuWS(data, 150);
    401            wsprintf(ws, PERCENT_T, SOP_ITEM_LGPS[curitem]);
    402            SetMenuItemIconArray(data, item, SOP_ITEM_ICONS);
    403            SetMenuItemIcon(data, curitem, 0);
    404            SetMenuItemText(data, item, ws, curitem);
    405          }
    406          
    407          int SmsOptionMenu::CreateSmsOptionMenu(DLG_CSM *dlg_csm, int slm_id, int list_type, SDLIST *sdl)
    408          {
    409            this->dlg_csm=dlg_csm;
    410            this->sdl=sdl;
    411            this->slm_id=slm_id;
    412            this->list_type=list_type;
    413            return CreateMenu30or2(&this->menu, &sop_menuhdr, 0, SOP_MENU_ITEM_N, this);
    414          }
    415          
    416          
    417          
    418          
    419          void SmsListMenu::UpdateCSMName(DLG_CSM *dlg_csm, int lgp)
    420          {
    421            wsprintf(&((DLGCSM_DESC *)dlg_csm->csm_ram.constr)->csm_name, PERCENT_T, lgp);
    422          }
    423          
    424          /*
    425          int SmsListMenu::ReCreateMe(void *data)
    426          {
    427            int cur;
    428            SmsListMenu *slm;
    429            if(!data)
    430              return 0;
    431            cur=GetCurMenuItem(data);
    432            slm=new SmsListMenu;
    433            slm->dlg_csm=this->dlg_csm;
    434            slm->is_tab=this->is_tab;
    435            slm->type=this->type;
    436            slm->gui_id=CreateMenu(&slm->menu, &sms_menuhdr, cur, SMSDATA->GetSMSCount(slm->type), slm);
    437            return slm->gui_id;
    438          }
    439          
    440          int SmsListMenu::ReCreateTab(void *data)
    441          {
    442          }
    443          */
    444          
    445          void SmsListMenu::ReCreateMe(void *data)
    446          {
    447            if(this->is_tab)
    448            {
    449              int id=0;
    450              TabGUI tab;
    451              id=tab.ReCreateTabGUI(this->dlg_csm);
    452              if(id) this->dlg_csm->gui_id=id;
    453            }
    454            else
    455            {
    456              //SmsListMenu *sl=new SmsListMenu;
    457              //id=sl->CreateSmsListMenu(this->type, GetCurMenuItem(data), this->dlg_csm);
    458              SmsListMenu *sl=new SmsListMenu;
    459              sl->type=this->type;
    460              sl->is_tab=this->is_tab;
    461              sl->dlg_csm=this->dlg_csm;
    462              sl->gui_id=CreateMenu(&sl->menu, &sms_menuhdr, GetCurMenuItem(data), SMSDATA->GetSMSCount(this->type), sl);
    463              if(this->dlg_csm->gui_id == this->gui_id && sl->gui_id)
    464                this->dlg_csm->gui_id=sl->gui_id;
    465            }
    466          }

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     SmsListMenu::CreateSmsListMenu(int, int, DLG_CSM *)
                                       12
     SmsListMenu::GHook(void *, int)
                                       28
     SmsListMenu::GetSmsListMenuGUI(int, int, DLG_CSM *, int)
                                       28
     SmsListMenu::ItemProc(void *, int, void *)
                                       32
     SmsListMenu::OnKey(void *, GUI_MSG *)
                                      124
     SmsListMenu::ReCreateMe(void *)
                                       28
     SmsListMenu::SmsListMenu()         0
     SmsListMenu::UpdateCSMName(DLG_CSM *, int)
                                        4
     SmsListMenu::delete ~SmsListMenu(SmsListMenu *)
                                        4
     SmsListMenu::new SmsListMenu()     4
     SmsListMenu::~SmsListMenu()        0
     SmsOptionMenu::CreateSmsOptionMenu(DLG_CSM *, int, int, _SDLIST *)
                                        8
     SmsOptionMenu::GHook(void *, int)
                                       20
     SmsOptionMenu::ItemProc(void *, int, void *)
                                       20
     SmsOptionMenu::OnKey(void *, GUI_MSG *)
                                       24
     SmsOptionMenu::SmsOptionMenu()     0
     SmsOptionMenu::delete ~SmsOptionMenu(SmsOptionMenu *)
                                        4
     SmsOptionMenu::new SmsOptionMenu()
                                        4
     SmsOptionMenu::~SmsOptionMenu()
                                        0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     sms_menu_sk                      24
     sms_menu_skt                      8
     sms_menuhdr                      20
     SmsListMenu::~SmsListMenu()       4
     SmsListMenu::SmsListMenu()      104
     SmsListMenu::OnKey(void *, GUI_MSG *)
                                     428
     SLM_HDR_LGPS                     28
     SmsListMenu::GHook(void *, int)
                                     372
     SLM_ICONS                        32
     SmsListMenu::ItemProc(void *, int, void *)
                                     304
     SmsListMenu::CreateSmsListMenu(int, int, DLG_CSM *)
                                      68
     SmsListMenu::GetSmsListMenuGUI(int, int, DLG_CSM *, int)
                                     188
     sop_menuhdr                      20
     SmsOptionMenu::SmsOptionMenu()   96
     SmsOptionMenu::~SmsOptionMenu()
                                       4
     SmsOptionMenu::OnKey(void *, GUI_MSG *)
                                     380
     SmsOptionMenu::GHook(void *, int)
                                     144
     SOP_ITEM_LGPS                    28
     SOP_ITEM_ICONS                    8
     SmsOptionMenu::ItemProc(void *, int, void *)
                                     120
     SmsOptionMenu::CreateSmsOptionMenu(DLG_CSM *, int, int, _SDLIST *)
                                      56
     SmsListMenu::UpdateCSMName(DLG_CSM *, int)
                                      28
     SmsListMenu::ReCreateMe(void *)
                                     200
     ?<Initializer for sms_menu_sk>   24
     ?<Initializer for SLM_HDR_LGPS>
                                      28
     ?<Initializer for SLM_ICONS>     32
     ?<Initializer for SOP_ITEM_LGPS>
                                      28
     ?<Constant "%s\n%t:\n%w">        12
     SmsOptionMenu::new SmsOptionMenu()
                                      28
     SmsListMenu::delete ~SmsListMenu(SmsListMenu *)
                                      20
     SmsOptionMenu::delete ~SmsOptionMenu(SmsOptionMenu *)
                                      20
     SmsListMenu::new SmsListMenu()   28
     ??DataTable13                     4
     ??DataTable16                     4
     ??DataTable18                     4
     ??DataTable19                     4
     ??DataTable20                     4
      Others                         316

 
 2 916 bytes in segment CODE
    68 bytes in segment DATA_C
   112 bytes in segment DATA_I
   112 bytes in segment DATA_ID
    12 bytes in segment INITTAB
 
 2 612 bytes of CODE  memory (+ 316 bytes shared)
   180 bytes of CONST memory
   112 bytes of DATA  memory

Errors: none
Warnings: none
