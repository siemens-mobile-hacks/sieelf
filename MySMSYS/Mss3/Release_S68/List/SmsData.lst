##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Oct/2011  23:45:46 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  I:\Amuse\SVN\Siemens\MySMSYS\Mss3\SmsData.cpp        #
#    Command line    =  I:\Amuse\SVN\Siemens\MySMSYS\Mss3\SmsData.cpp -D     #
#                       NEWSGOLD -D S68 -D LANG_CN -lcN                      #
#                       I:\Amuse\SVN\Siemens\MySMSYS\Mss3\Release_S68\List\  #
#                       -o I:\Amuse\SVN\Siemens\MySMSYS\Mss3\Release_S68\Obj #
#                       \ -s9 --no_unroll --cpu_mode arm --endian little     #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --eec++ --dlib_config "D:\Program         #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" -I "D:\Program     #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  I:\Amuse\SVN\Siemens\MySMSYS\Mss3\Release_S68\List\S #
#                       msData.lst                                           #
#    Object file     =  I:\Amuse\SVN\Siemens\MySMSYS\Mss3\Release_S68\Obj\Sm #
#                       sData.r79                                            #
#                                                                            #
#                                                                            #
##############################################################################

I:\Amuse\SVN\Siemens\MySMSYS\Mss3\SmsData.cpp
      1          #include "include.h"
      2          
      3          #include "SiemensPDU.h"
      4          #include "MyIpcMessage.h"
      5          #include "File.h"
      6          #include "AdrList.h"
      7          #include "SmsData.h"
      8          
      9          #define MAX_SMS 100
     10          /*
     11          typedef struct _EMS_ADM
     12          {
     13            char unk0;
     14            char unk1;
     15            unsigned short index_id; //0xFFFF, no
     16            char num[12]; //hex, num[0],len
     17            short txt_len;
     18            short w_char[7]; //
     19            char unk2;
     20            char unk3;
     21            short unk_0x160F;
     22            char unk4[8];
     23            int opmsg_id;
     24            unsigned short data_id;//SMS: (data_id-0x2A)*sizeof(PDU)= the position of this sms in sms.dat, EMS: 0xFFF4 ?
     25            short unk5; //0xA800 ?
     26          }EMS_ADM;
     27          */
     28          //sd list---------
     29          
     30          
     31          SDLIST *SmsData::AllocSDL(void)
     32          {
     33            SDLIST *sd=new SDLIST;
     34            zeromem(sd, sizeof(SDLIST));
     35            return sd;
     36          }
     37          
     38          void SmsData::DeleteSDL(SDLIST *sdl)
     39          {
     40            SDLIST *sdn;
     41            SDLIST *sdp;
     42            if(sdl)
     43            {
     44              LockSched();
     45              sdn=(SDLIST *)sdl->next;
     46              sdp=(SDLIST *)sdl->prev;
     47              if(sdp)
     48                sdp->next=sdn;
     49              else
     50                sdltop=sdn;
     51              if(sdn)
     52                sdn->prev=sdp;
     53              UnlockSched();
     54              if((sdl->msg_prop&ISFILE) && sdl->fname)
     55                delete sdl->fname;
     56              if(sdl->text) FreeWS(sdl->text);
     57              delete sdl;
     58            }
     59          }
     60          
     61          void SmsData::FreeAllSDL(void)
     62          {
     63            SDLIST *sdl;
     64            SDLIST *sdx;
     65            LockSched();
     66            sdl=sdltop;
     67            sdltop=0;
     68            UnlockSched();
     69            while(sdl)
     70            {
     71              sdx=(SDLIST *)sdl->next;
     72              if((sdl->msg_prop&ISFILE) && sdl->fname)
     73                delete sdl->fname;
     74              if(sdl->text) FreeWS(sdl->text);
     75              delete sdl;
     76              sdl=sdx;
     77            }
     78          }
     79          
     80          void SmsData::AddByTimeSDL(SDLIST *sdl)
     81          {
     82            SDLIST *sdx;
     83            SDLIST *sdp;
     84            if(!sdl)
     85              return;
     86            if(!(sdx=sdltop))
     87            {
     88              sdltop=sdl;
     89              return;
     90            }
     91            while(sdx)
     92            {
     93              if(strcmp(sdl->time, sdx->time)>=0)
     94              {
     95                sdp=(SDLIST *)sdx->prev;
     96                if(sdp) sdp->next=sdl;
     97                else sdltop=sdl;
     98                sdl->prev=sdp;
     99                sdl->next=sdx;
    100                sdx->prev=sdl;
    101                return;
    102              }
    103              if(!sdx->next)
    104              {
    105                sdx->next=sdl;
    106                sdl->prev=sdx;
    107                return;
    108              }
    109              sdx=(SDLIST *)sdx->next;
    110            }
    111          }
    112          
    113          void SmsData::FreeOneSDL(SDLIST *sdl)
    114          {
    115            if(IsExistSDL(sdl)) return; //if is in list
    116            if(sdl->text)
    117              FreeWS(sdl->text);
    118            if((sdl->msg_prop&ISFILE) && sdl->fname)
    119              delete (sdl->fname);
    120            delete(sdl);
    121          }
    122          
    123          SDLIST *SmsData::CopyOneSDL(SDLIST *sdl)
    124          {
    125            SDLIST *sdx;
    126            if(!sdl) return 0;
    127            sdx=new SDLIST;
    128            memcpy(sdx, sdl, sizeof(SDLIST));
    129            if((sdl->msg_prop&ISFILE) && sdl->fname)
    130            {
    131              sdx->fname=new char[128];
    132              strcpy(sdx->fname, sdl->fname);
    133            }
    134            if(sdl->text)
    135            {
    136              sdx->text=AllocWS(sdl->text->wsbody[0]);
    137              wstrcpy(sdx->text, sdl->text);
    138            }
    139            return sdx;
    140          }
    141          
    142          SDLIST *SmsData::FindSDL(int dat_index)
    143          {
    144            SDLIST *sdl=sdltop;
    145            while(sdl)
    146            {
    147              if(sdl->dat_index==dat_index)
    148                return sdl;
    149              sdl=(SDLIST *)sdl->next;
    150            }
    151            return 0;
    152          }
    153          
    154          SDLIST *SmsData::FindOpmsgSDL(int opmsg_id)
    155          {
    156            RAM_EMS_ADMIN *ram_eam=RAM_EMS_Admin();
    157            SDLIST *sdl=sdltop;
    158            while(sdl)
    159            {
    160              if(sdl->opmsg_id==opmsg_id)
    161                return sdl;
    162              if(!(sdl->msg_prop&ISFILE) && sdl->dat_index)
    163              {
    164                if(opmsg_id==ram_eam->data[sdl->dat_index].opmsg_id)
    165                {
    166          	sdl->opmsg_id=opmsg_id;
    167          	return sdl;
    168                }
    169              }
    170              sdl=(SDLIST *)sdl->next;
    171            }
    172            return 0;
    173          }
    174          
    175          SDLIST *SmsData::FindSDL(WSHDR *text, char *time, char *num)
    176          {
    177            SDLIST *sdl=sdltop;
    178            if(!sdl || !text /*|| !time */|| !num) return 0;
    179            while(sdl)
    180            {
    181              if(!wstrncmp_nocase(sdl->text, text, text->wsbody[0])
    182                 && !strncmp(sdl->number, num, strlen(num)))
    183              {
    184                if(!time || !strlen(time))
    185                  return sdl;
    186                if(!strncmp(sdl->time, time, strlen(time)))
    187                  return sdl;
    188              }
    189              sdl=(SDLIST *)sdl->next;
    190            }
    191            return 0;
    192          }
    193          
    194          SDLIST *SmsData::FindSDL(char *filename)
    195          {
    196            SDLIST *sdl=sdltop;
    197            if(!sdl || !filename) return 0;
    198            while(sdl)
    199            {
    200              if((sdl->msg_prop&ISFILE) && sdl->fname && !strcmp(filename, sdl->fname))
    201                return sdl;
    202              sdl=(SDLIST *)sdl->next;
    203            }
    204            return 0;
    205          }
    206          
    207          int SmsData::GetSMSCount(int type)
    208          {
    209            int i=0;
    210            SDLIST *sdl=sdltop;
    211            if(type>0&&type<5)
    212            {
    213              while(sdl)
    214              {
    215                if(sdl->type==type)
    216                  i++;
    217                sdl=(SDLIST *)sdl->next;
    218              }
    219            }
    220            else if(type==TYPE_IN_ALL)
    221            {
    222              while(sdl)
    223              {
    224                if((sdl->type==TYPE_IN_R)||(sdl->type==TYPE_IN_N)||(sdl->type==TYPE_IN_ALL))
    225                  i++;
    226                sdl=(SDLIST *)sdl->next;
    227              }
    228            }
    229            else if(type==TYPE_FILTER)
    230            {
    231              return (FilterGetCount());
    232            }
    233            else
    234            {
    235              while(sdl)
    236              {
    237                i++;
    238                sdl=(SDLIST *)sdl->next;
    239              }
    240            }
    241            return i;
    242          }
    243          
    244          int SmsData::GetSMSCount(int isfile, int type)
    245          {
    246            int i=0;
    247            SDLIST *sdl=sdltop;
    248            if(type>0&&type<5)
    249            {
    250              while(sdl)
    251              {
    252                if((sdl->type==type) && (sdl->msg_prop&ISFILE)==isfile)
    253          	i++;
    254                sdl=(SDLIST *)sdl->next;
    255              }
    256            }
    257            else if(type==TYPE_IN_ALL)
    258            {
    259              int t;
    260              while(sdl)
    261              {
    262                t=sdl->type;
    263                if(((t==TYPE_IN_R)||(t==TYPE_IN_N)||(t==TYPE_IN_ALL)) && (sdl->msg_prop&ISFILE)==isfile)
    264          	i++;
    265                sdl=(SDLIST *)sdl->next;
    266              }
    267            }
    268            else
    269            {
    270              while(sdl)
    271              {
    272                if((sdl->msg_prop&ISFILE)==isfile)
    273          	i++;
    274                sdl=(SDLIST *)sdl->next;
    275              }
    276            }
    277            return i;
    278          }
    279          
    280          SDLIST *SmsData::FindSDL(int type, int n)
    281          {
    282            int i=0;
    283            SDLIST *sdl=sdltop;
    284            if(type>0&&type<5)
    285            {
    286              while(sdl)
    287              {
    288                if((i==n)&&(sdl->type==type))
    289                  return sdl;
    290                if(sdl->type==type)
    291                  i++;
    292                sdl=(SDLIST *)sdl->next;
    293              }
    294            }
    295            else if(type==TYPE_IN_ALL)
    296            {
    297              while(sdl)
    298              {
    299                if((sdl->type==TYPE_IN_R)||(sdl->type==TYPE_IN_N)||(sdl->type==TYPE_IN_ALL))
    300                {
    301                  if(i==n) return sdl;
    302                  i++;
    303                }
    304                sdl=(SDLIST *)sdl->next;
    305              }
    306            }
    307            else if(type==TYPE_FILTER)
    308            {
    309              return (FilterFindSDL(n));
    310            }
    311            else
    312            {
    313              while(sdl)
    314              {
    315                if(i==n)
    316                  return sdl;
    317                sdl=(SDLIST *)sdl->next;
    318                i++;
    319              }
    320            }
    321            return 0;
    322          }
    323          
    324          //-----------DatReader------------------
    325          /*
    326          int SmsData::ReadDat(void)
    327          {
    328            int fin, res=1;
    329            if(sms_buf) delete sms_buf;
    330          //  if(eam_buf) delete eam_buf;
    331            if((fin=FOpen(sms_dat, A_BIN+A_ReadOnly, P_READ))!=-1)
    332            {
    333              sms_size=LSeek(fin, 0, S_END)-2;
    334              sms_buf=new char[sms_size];
    335              LSeek(fin, 2, S_SET);
    336              if(FRead(fin, sms_buf, sms_size)!=sms_size) res=0;
    337              FClose(fin);
    338            }
    339            else res=0;
    340            return res;
    341          }
    342          */
    343          /*
    344          void GetTime(SDLIST * sd, char *data)
    345          {
    346          	if ((sd->type == TYPE_IN_R)||(sd->type == TYPE_IN_N))
    347          	{
    348          		char *p = data;
    349          		char *pp;
    350          		int c;
    351          		int i;
    352          		p++;
    353          		c = *p++; //number len
    354          		if (c != 0)
    355          		{
    356          			c = ((c&1)?1:0) + (c>>1) +3;
    357          		}
    358          		else
    359          		{
    360          			c = 3;
    361          		}
    362          		p += c; //skip number, text encode type
    363          		pp = sd->time;
    364          		for (i = 0; i < 6; i++)
    365          		{
    366          			*pp++ = p[i]%0x10+'0';
    367          			*pp++ = p[i]/0x10+'0';
    368          			if (i < 2)
    369          				*pp++ = '-';
    370          			if (i == 2)
    371          				*pp++ = ' ';
    372          			if (i>2 && i<5)
    373          				*pp++ = ':';
    374          		}
    375          		*pp = 0;
    376          	}
    377          }
    378          
    379          int ReadSMS(SDLIST * sd, INDEX_ID_DATA * iid)
    380          {
    381          	void *res = NULL;
    382          	int c1;// = 0;
    383          	int i;
    384          	char ubf[0x20];
    385          	int uki;
    386          	int r1;
    387          	void *ud;
    388          	switch (iid->type)
    389          	{
    390          	case 0x00:
    391          		sd->type = TYPE_IN_R;
    392          		break;
    393          	case 0x01:
    394          		sd->type = TYPE_IN_N;
    395          		break;
    396          	case 0x03:
    397          		sd->type = TYPE_SENT;
    398          		break;
    399          	case 0x04:
    400          		sd->type = TYPE_DRAFT;
    401          		break;
    402          	default:
    403          		sd->type = TYPE_UNK;
    404          		sd->msg_prop = sd->msg_prop|ISUNKT;
    405          		sd->text = AllocWS(32);
    406          		wsprintf(sd->text, STR_UNK_TYPE, iid->type);
    407          		return 0;
    408          	}
    409          	GetCPUClock();
    410          	for (i = 1; i <= iid->cnt_received; i++) //start seg from 1
    411          	{
    412          		c1 = 0;
    413          		ud = malloc(0xB4);//((void *(*)(int, int))0xA0E62D85)(0xB4, 0x4);
    414          		zeromem(ud, 0xB4);
    415          		r1 = ((int (*)(int, int, void *, int, char *, char *))0xA0E8E6EF)(iid->index, i, ud, 0xB4, (char *)&c1, ubf);
    416          		if (i == 0)
    417          		{
    418          			//get time
    419          			GetTime(sd, (char *)ud);
    420          		}
    421          		((void (*)(void **, int, void *, int, char *, char, int *))0xA0112677)(&res, 0, ud, r1, ubf, (char)c1, &uki);
    422          	}
    423          	if (res != NULL)
    424          	{
    425          		char *p = ((char **)res)[3];
    426          		if (p != NULL)
    427          		{
    428          			p = *((char **)p);
    429          			if (p != NULL)
    430          			{
    431          				int len = *((short *)p);
    432          				p += 4;
    433          				//text, utf8
    434          				sd->text = AllocWS(len);
    435          				utf8_2ws(sd->text, p, len);
    436          			}
    437          		}
    438          		p = ((char **)res)[6];
    439          		if (p != NULL)
    440          		{
    441          			p += 6;
    442          			//number
    443          			strcpy(sd->number, p);
    444          		}
    445          	}
    446          	((void (*)(void *))0xA0E62949)(res);
    447          	return 0;
    448          }
    449          */
    450          
    451          #define PRE_TXT_LEN 199
    452          int DataDecoder(SDLIST *sd, char *data, int onlytext)
    453          {
    454          	char * p;
    455          	int ttype;
    456          	int skip;
    457          	int i;
    458          	int c;
    459          	int wlen;
    460          	int isplus;
    461          	int isreport;
    462          	WSHDR *wst;
    463          	WSHDR *ws, _ws;
    464          	unsigned short ws_body[PRE_TXT_LEN+1];
    465          	if (sd == NULL
    466          		|| data == NULL)
    467          	{
    468          		return 0;
    469          	}
    470          	p = data;
    471          	ws = CreateLocalWS(&_ws, ws_body, PRE_TXT_LEN);
    472          
    473          	//FirstOctet
    474          	//	04
    475          	//		其二进制代码：00000100
    476          	//		TP-MTI：00
    477          	//		TP-MMS(TP-More-Message-to-Send)：1 短信中心没有更多的消息发送
    478          	//		TP-SRI：0
    479          	//		TP-UDHI：0
    480          	//		TP-RP：0
    481          	c = *p++; //FirstOctet
    482          	if (c == 6)
    483          	{
    484          		isreport = 1;
    485          	}
    486          	if ((c>>4)%2 != 0)
    487          	{
    488          		isplus=1;
    489          	}
    490          	else
    491          	{
    492          		isplus=0;
    493          	}
    494          	if ((sd->type == TYPE_SENT)||(sd->type == TYPE_DRAFT)) //out
    495          	{
    496          		 p++; //unknow byte;
    497          	}
    498          	c = *p++; //number len
    499          	if (c != 0)
    500          	{
    501          		if (onlytext == 0)
    502          		{
    503          			SiememPDU::Hex2Num(p, sd->number, c); //get number
    504          		}
    505          		c = ((c&1)?1:0) + (c>>1) +1;
    506          	}
    507          	else
    508          	{
    509          		c = 1;
    510          		sd->number[0] = '\0';
    511          	}
    512          	p += c; //skip number
    513          	p++; //协议标识, //00	TP-PID	点对点
    514          	ttype = *p++; //编码方式 //	08	TP-DCS	Unicode编码 //00, bit7
    515          	
    516          	if ((sd->type == TYPE_IN_R)||(sd->type == TYPE_IN_N))
    517          	{
    518          		if (onlytext == 0)
    519          		{
    520          			char *pp;
    521          			pp = sd->time;
    522          			for (i = 0; i < 6; i++)
    523          			{
    524          				*pp++ = p[i]%0x10+'0';
    525          				*pp++ = p[i]/0x10+'0';
    526          				if (i < 2)
    527          					*pp++ = '-';
    528          				if (i == 2)
    529          					*pp++ = ' ';
    530          				if (i>2 && i<5)
    531          					*pp++ = ':';
    532          			}
    533          			*pp = 0;
    534          		}
    535          		p += 7; //skip time
    536          	}
    537          	if (isreport != 0)
    538          	{
    539          		sd->msg_prop |= ISREPORT;
    540          		SiememPDU::DoSmsReport(sd, p, ws);
    541          		return 0;
    542          	}
    543          	if ((isplus != 0) &&((sd->type == TYPE_SENT)||(sd->type == TYPE_DRAFT)))
    544          	{
    545          		p++; //unknow
    546          	}
    547          	c = *p++; //用户数据长度
    548          
    549          	if ((sd->msg_prop&ISEMS) != 0) //is ems
    550          	{
    551          		skip = (*p)+1;
    552          		if (ttype != 8)
    553          		{
    554          			skip = ((skip*8)+6)/7;
    555          		}
    556          		else
    557          		{
    558          			p += skip;
    559          			c -= skip;
    560          		}
    561          	}
    562          	if (ttype == 0x8) //ucs32
    563          	{
    564          		SiememPDU::Add2WS(p, ws, c);
    565          	}
    566          	else if(ttype==0x0) //7bit
    567          	{
    568          		SiememPDU::Bit7Decode(ws, p, skip, c);
    569          		sd->msg_prop |= IS7BIT;
    570          		if (wstrlen(ws) > c)
    571          		{
    572          			CutWSTR(ws, c);
    573          		}
    574          	}
    575          	else
    576          	{
    577          		GSMTXT_Decode(ws, p, c, ttype, (void *(*)(int))malloc_adr(), (void (*)())mfree_adr());
    578          		if (ws->wsbody[0] == 0)
    579          		{
    580          			wsprintf(ws, STR_UNK_TXTT, ttype);
    581          			sd->msg_prop |= ISUNKE;
    582          		}
    583          		else
    584          		{
    585          			CutWSTR(ws, c);
    586          		}
    587          	}
    588          	//c = wstrlen(ws);
    589          	//if (c == 0)
    590          	//{
    591          	//	c = 1;
    592          	//}
    593          	//sd->text = AllocWS(c);
    594          	//wstrcpy(sd->text, ws);
    595          	wst = sd->text;
    596          	wlen = wstrlen(ws);
    597          	if (wlen != 0)
    598          	{
    599          		if (wst != NULL)
    600          		{
    601          			wlen += wstrlen(wst);
    602          			sd->text = AllocWS(wlen);
    603          			wstrcpy(sd->text, wst);
    604          			wstrcat(sd->text, ws);
    605          			FreeWS(wst);
    606          		}
    607          		else
    608          		{
    609          			sd->text = AllocWS(wlen);
    610          			wstrcpy(sd->text, ws);
    611          		}
    612          	}
    613          	else
    614          	{
    615          		if (wst == NULL)
    616          		{
    617          			sd->text = AllocWS(1);
    618          		}
    619          	}
    620          	return 0;
    621          }
    622          
    623          int ReadSMS(SDLIST * sd, INDEX_ID_DATA * iid)
    624          {
    625          	int i;
    626          	char dbuf[0xB4]; //sizeof pdu
    627          	int unk_c1; //unknow param
    628          	char unk_buf1[0x20]; //unknow param
    629          	if (sd == NULL
    630          		|| iid == NULL)
    631          	{
    632          		return 0;
    633          	}
    634          	switch (iid->type) //sms type
    635          	{
    636          	case 0x00:
    637          		sd->type = TYPE_IN_R;
    638          		break;
    639          	case 0x01:
    640          		sd->type = TYPE_IN_N;
    641          		break;
    642          	case 0x03:
    643          		sd->type = TYPE_SENT;
    644          		break;
    645          	case 0x04:
    646          		sd->type = TYPE_DRAFT;
    647          		break;
    648          	default:
    649          		sd->type = TYPE_UNK;
    650          		sd->msg_prop = sd->msg_prop|ISUNKT;
    651          		sd->text = AllocWS(32);
    652          		wsprintf(sd->text, STR_UNK_TYPE, sd->type);
    653          		return 0;
    654          	}
    655          	if (iid->cnt_all > 1)
    656          	{
    657          		sd->msg_prop |= ISEMS;
    658          	}
    659          	//GetCPUClock();
    660          	for (i = 1; i <= iid->cnt_received; i++) //segment, from 1
    661          	{
    662          		unk_c1 = 0;
    663          		((int (*)(int, int, void *, int, char *, char *))0xA0E8E6EF)(iid->index, i, dbuf, 0xB4, (char *)&unk_c1, unk_buf1);
    664          		if ((i == 1)
    665          			|| sd->text == NULL
    666          			|| (sd->text != NULL && sd->text->wsbody[0] == 0))
    667          		{
    668          			DataDecoder(sd, dbuf, 0);
    669          		}
    670          		else
    671          		{
    672          			DataDecoder(sd, dbuf, 1);
    673          		}
    674          	}
    675          	return 1;
    676          }
    677          
    678          int SmsData::DeMsgDataList(SMS_DATA_LIST *lst)
    679          {
    680            //SMS_POS_INDEX_DATA sid;
    681            SDLIST *sdx;
    682          //  EMS_ADM *pea;
    683            EAM_DATA *ead;
    684            INDEX_ID_DATA *idd;
    685            //unsigned short *pid;
    686            //char *pd;
    687            int cnt, index, /*i,*/ msg_prop=0;
    688            //char *sms_buf_end;
    689          //  char *eam_buf_end;
    690            //if(!sms_buf ||/* !eam_buf || */!sms_size/* || !eam_size*/) return 0;
    691            //sms_buf_end=sms_buf+sms_size-sizeof(PDU);
    692          //  eam_buf_end=eam_buf+eam_size-sizeof(EMS_ADM);
    693            if(!(idd=lst->index_id_data))
    694              return 0;
    695            //if(!(pid=idd->data_id))
    696            //  return 0;
    697            if(!(cnt=idd->cnt_all))
    698              return 0;
    699            if(cnt!=idd->cnt_received)
    700              msg_prop=msg_prop|ISDES;
    701            index=idd->index;
    702            //if(!index || index>MAX_SMS)
    703            //  return 0;
    704            ead=&RAM_EMS_Admin()->data[index];
    705          //  pea=(EMS_ADM *)(eam_buf+(index-1)*sizeof(EMS_ADM));
    706          //  if(pea>(EMS_ADM *)eam_buf_end)
    707          //    return 0;
    708            sdx=AllocSDL();
    709            sdx->msg_prop=msg_prop;
    710            ReadSMS(sdx, idd);
    711            //i = cnt;
    712            /*
    713            for(i=0;i<cnt;i++)
    714            {
    715              if(pid[i]==0xFFF4) continue;
    716              if(!GetSmsPosIndex(&sid, pid[i])) continue;
    717              if((pd=sms_buf+sid.pos_index*sizeof(PDU))>sms_buf_end) continue;
    718              if(!sdx->text) PduDecodeAll(sdx, pd);
    719              else PduDecodeTxt(sdx, pd);
    720            }
    721            */
    722            if(sdx->text)
    723            {
    724              //if(i>1) sdx->msg_prop=sdx->msg_prop|ISEMS;
    725              //sdx->opmsg_id=pea->opmsg_id;
    726              sdx->opmsg_id=ead->opmsg_id;
    727              sdx->dat_index=index;
    728              sdx->cnt_r=idd->cnt_received;
    729              LockSched();
    730              AddByTimeSDL(sdx);
    731              UnlockSched();
    732              return 1;
    733            }
    734            else
    735            {
    736              FreeOneSDL(sdx);
    737              return 0;
    738            }
    739          }
    740          
    741          int SmsData::ReadAllDatMsg(void)
    742          {
    743            SMS_DATA_ROOT *sdroot=SmsDataRoot();
    744            SMS_DATA_LLIST inll=sdroot->in_msg;
    745            SMS_DATA_LLIST outll=sdroot->out_msg;
    746            SMS_DATA_LIST *lst;
    747            int res=0;
    748            //if(!ReadDat()) return 0;
    749            lst=inll.first;
    750            while(lst)
    751            {
    752              if(DeMsgDataList(lst))
    753              {
    754                res++;
    755                if(!(res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
    756              }
    757              lst=(SMS_DATA_LIST *)lst->next;
    758            }
    759            lst=outll.first;
    760            while(lst)
    761            {
    762              if(DeMsgDataList(lst))
    763              {
    764                res++;
    765                if(!(res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
    766              }
    767              lst=(SMS_DATA_LIST *)lst->next;
    768            }
    769            if((res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
    770            return res;
    771          }
    772          
    773          
    774          SMS_DATA_LIST *SmsData::FindMsgDataL(int dat_index)
    775          {
    776            SMS_DATA_LIST *lst;
    777            SMS_DATA_ROOT *sdroot=SmsDataRoot();
    778            SMS_DATA_LLIST inll=sdroot->in_msg;
    779            SMS_DATA_LLIST outll=sdroot->out_msg;
    780            INDEX_ID_DATA *idd;
    781            if(!dat_index) return 0;
    782            lst=inll.first;
    783            while(lst)
    784            {
    785              if((idd=lst->index_id_data))
    786              {
    787                if(idd->index==dat_index)
    788                {
    789          	return lst;
    790                }
    791              }
    792              lst=(SMS_DATA_LIST *)lst->next;
    793            }
    794            if(!lst) lst=outll.first;
    795            while(lst)
    796            {
    797              if((idd=lst->index_id_data))
    798              {
    799                if(idd->index==dat_index)
    800                {
    801          	return lst;
    802                }
    803              }
    804              lst=(SMS_DATA_LIST *)lst->next;
    805            }
    806            return 0;
    807          }
    808          
    809          int SmsData::ReadMessageOne(int dat_index)
    810          {
    811            int res;
    812            SMS_DATA_LIST *lst;
    813            SDLIST *sdl;
    814            if(!dat_index) return 0;
    815            if(!(lst=FindMsgDataL(dat_index))) return 0;
    816            //if(!ReadDat()) return 0;
    817            if((sdl=FindSDL(dat_index))) DeleteSDL(sdl);
    818            if((res=DeMsgDataList(lst)))
    819              this->n_new=GetSMSCount(TYPE_IN_N);
    820            return res;
    821          }
    822          /*
    823          void SmsData::FreeDatBuf(void)
    824          {
    825            if(sms_buf) delete sms_buf;
    826          //  if(eam_buf) delete eam_buf;
    827            sms_buf=NULL;
    828          //  eam_buf=NULL;
    829            sms_size=0;
    830          //  eam_size=0;
    831          }
    832          */
    833          //-----------FileReader----------
    834          #define ELFNAME "MySMSYS"
    835          int SmsData::ReadMss(char *fname, SDLIST *sdl)
    836          {
    837            int fin;
    838            int size, len=0;
    839            MSS_FILE_P1 msf1;
    840            MSS_FILE_P2 msf2;
    841            int version;
    842            if((fin=FOpen(fname, A_BIN+A_ReadOnly, P_READ))<0)
    843              return 0;
    844            size=LSeek(fin, 0, S_END);
    845            if(size<sizeof(MSS_FILE_P1))
    846              goto ERR_BACK;
    847            LSeek(fin, 8, S_SET);
    848            if(FRead(fin, &version, sizeof(int))!=sizeof(int))
    849            {
    850            ERR_BACK:
    851              FClose(fin);
    852              return 0;
    853            }
    854            LSeek(fin, 0, S_SET);
    855            if(version==1)
    856            {
    857              if(FRead(fin, &msf1, sizeof(MSS_FILE_P1))!=sizeof(MSS_FILE_P1))
    858                goto ERR_BACK;
    859              if(strncmp(msf1.header, ELFNAME, 7))
    860                goto ERR_BACK;
    861              strcpy(sdl->time, msf1.time);
    862              strcpy(sdl->number, msf1.number);
    863            }
    864            else if(version==2)
    865            {
    866              if(FRead(fin, &msf2, sizeof(MSS_FILE_P2))!=sizeof(MSS_FILE_P2))
    867                goto ERR_BACK;
    868              if(strncmp(msf2.header, ELFNAME, 7))
    869                goto ERR_BACK;
    870              strcpy(sdl->time, msf2.time);
    871              strcpy(sdl->number, msf2.number);
    872              sdl->type=msf2.type;
    873            }
    874            else goto ERR_BACK;
    875            if(FRead(fin, &len, 2)!=2) goto ERR_BACK;
    876            sdl->text=AllocWS(len);
    877            if(FRead(fin, sdl->text->wsbody+1, len*2)!=len*2)
    878              goto ERR_BACK;
    879            FClose(fin);
    880            sdl->text->wsbody[0]=len;
    881            sdl->msg_prop|=ISFILE;
    882            sdl->fname=new char[128];
    883            strcpy(sdl->fname, fname);
    884            return 1;
    885          }
    886          
    887          
    888          int SmsData::ReadFolder(int type)
    889          {
    890            const char *folder;
    891            char dir[128];
    892            char fullpath[128];
    893            int n=0,len;//, x;
    894            DIR_ENTRY de;
    895            SDLIST *sdx;
    896            switch(type)
    897            {
    898            case TYPE_DRAFT:
    899              folder=FLDR_DRAFT;
    900              break;
    901            case TYPE_SENT:
    902              folder=FLDR_SENT;
    903              break;
    904            case TYPE_IN_N:
    905            case TYPE_IN_R:
    906            case TYPE_IN_ALL:
    907              folder=FLDR_IN;
    908              break;
    909            default:
    910              folder=FLDR_UNK;
    911              break;
    912            }
    913            strcpy(dir, main_folder);
    914            //if((len=strlen(dir))<=0) return 0;
    915            //x=dir[len-1];
    916            //if((x!='\\')&&(x!='/'))
    917            //{
    918            //  dir[len]='\\';
    919            //  dir[len+1]=0;
    920            //}
    921            strcat(dir, folder);
    922            if(!IsDir(dir))
    923              return 0;
    924            strcat(dir, "*.mss");
    925            if(FindFirstFile(&de, dir))
    926            {
    927              do
    928              {
    929                strcpy(fullpath, de.folder_name);
    930                if((len=strlen(fullpath))<=0) continue;
    931                if(fullpath[len-1]!='\\'&&fullpath[len-1]!='/')
    932                {
    933          	fullpath[len++]='\\';
    934          	fullpath[len]='\0';
    935                }
    936                strcat(fullpath, de.file_name);
    937                sdx=AllocSDL();
    938                if(ReadMss(fullpath, sdx))
    939                {
    940          	n++;
    941          	LockSched();
    942          	AddByTimeSDL(sdx);
    943          	UnlockSched();
    944          	if(!(n%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
    945                }
    946                else FreeOneSDL(sdx);
    947              }
    948              while(FindNextFile(&de));
    949            }
    950            FindClose(&de);
    951            if((n%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
    952            return n;
    953          }
    954          //-----------SmsDataMan--------------
    955          
    956          int SmsData::SaveMss(WSHDR *ws, const char *number, SDLIST *sdl, int type, int need_reload)
    957          {
    958            char path[128];
    959            TTime time;
    960            TDate date;
    961            int f;//, len, x;
    962            const char *folder;
    963            char dir[128];
    964            SDLIST *sdx=0;
    965            MSS_FILE_P2 msf;
    966            if(!ws || !number)
    967              return 0;
    968            switch(type)
    969            {
    970            case TYPE_DRAFT:
    971              folder=FLDR_DRAFT;
    972              break;
    973            case TYPE_SENT:
    974              folder=FLDR_SENT;
    975              break;
    976            case TYPE_IN_N:
    977            case TYPE_IN_R:
    978            case TYPE_IN_ALL:
    979              folder=FLDR_IN;
    980              break;
    981            default:
    982              folder=FLDR_UNK;
    983              break;
    984            }
    985            zeromem(&msf, sizeof(MSS_FILE_P2));
    986            GetDateTime(&date, &time);
    987            strcpy(dir, main_folder);
    988            //if((len=strlen(dir))<=0) return 0;
    989            //x=dir[len-1];
    990            //if((x!='\\')&&(x!='/'))
    991            //{
    992            //  dir[len]='\\';
    993            //  dir[len+1]=0;
    994            //}
    995            if(!IsDir(dir))
    996              MkDir(dir);
    997            strcat(dir, folder);
    998            if(!IsDir(dir))
    999              MkDir(dir);
   1000            if(type==TYPE_DRAFT && sdl && sdl->type==TYPE_DRAFT && (sdl->msg_prop&ISFILE) && sdl->fname)
   1001              strcpy(path, sdl->fname);
   1002            else if(!GetMssPath(path, dir, &time, &date))
   1003              return 0;
   1004            if((f=FOpen(path, A_BIN+A_WriteOnly+A_Create+A_Truncate, P_WRITE))<0)
   1005            {
   1006              return 0;
   1007            }
   1008            strcpy(msf.header, ELFNAME);
   1009            strncpy(msf.number, number, 32);
   1010            msf.type=type;
   1011            msf.version=MSS_VERSION;
   1012            //如果是来短信,直接使用短信中的时间保存
   1013            if(((type==TYPE_IN_N)||(type==TYPE_IN_R)||(type==TYPE_IN_ALL))
   1014               &&(sdl!=0)
   1015                 &&(strlen(sdl->time)))
   1016            {
   1017              strcpy(msf.time, sdl->time);
   1018            }
   1019            else
   1020              sprintf(msf.time, "%02d-%02d-%02d %02d:%02d:%02d",
   1021          	    date.year%2000, // ? //2008 ->08
   1022          	    date.month, date.day,
   1023          	    time.hour, time.min,
   1024          	    time.sec);
   1025            if(FWrite(f, &msf, sizeof(MSS_FILE_P2))!=sizeof(MSS_FILE_P2))
   1026            {
   1027              FClose(f);
   1028              return 0;
   1029            }
   1030            FWrite(f, ws->wsbody, (ws->wsbody[0]+1)*2);
   1031            FClose(f);
   1032            if(need_reload==1)
   1033            {
   1034              SUBPROC((void*)ReadAllMessageCHK, this);
   1035            }
   1036            else if(need_reload==2)
   1037            {
   1038              sdx=AllocSDL();
   1039              if(ReadMss(path, sdx))
   1040              {
   1041                LockSched();
   1042                AddByTimeSDL(sdx);
   1043                UnlockSched();
   1044                return ((int)sdx);
   1045              }
   1046              else FreeOneSDL(sdx);
   1047            }
   1048            return 1;
   1049          }
   1050          
   1051          int SmsData::GetMssPath(char *path, char *folder, TTime *time, TDate *date)
   1052          {
   1053            char temp[128];
   1054            int i=0;
   1055            sprintf(path, "%04d%02d%02d%02d%02d%02d",
   1056          	  date->year,
   1057          	  date->month,
   1058          	  date->day,
   1059          	  time->hour,
   1060          	  time->min,
   1061          	  time->sec);
   1062            strcpy(temp, folder);
   1063            strcat(temp, path);
   1064            strcat(temp, ".mss");
   1065            if(!IsFileExist(temp))
   1066            {
   1067              strcpy(path, temp);
   1068              return 1;
   1069            }
   1070            while(i<MAX_FILE)
   1071            {
   1072              sprintf(temp, "%s%s_%04d%s", folder, path, i, ".mss");
   1073              if(!IsFileExist(temp))
   1074              {
   1075                strcpy(path, temp);
   1076                return 1;
   1077              }
   1078              i++;
   1079            }
   1080            return 0;
   1081          }
   1082          
   1083          int SmsData::DeleteMessage(SDLIST *sdl)
   1084          {
   1085            short cnt;
   1086            if(!sdl) return 0;
   1087            if((sdl->msg_prop&ISFILE) && sdl->fname)
   1088            {
   1089              FDelete(sdl->fname);
   1090            }
   1091            else if(sdl->dat_index)
   1092            {
   1093              if(DeleteSMS(sdl->dat_index, &cnt)!=0x3E8) return 0;
   1094            }
   1095            else return 0;
   1096            if(IsExistSDL(sdl)) DeleteSDL(sdl); //可能已经在onmessage中被删除
   1097            //if(need_reload==1) return (ReadAllMessage());
   1098            return 1;
   1099          }
   1100          
   1101          int SmsData::ReadAllMessage(void)
   1102          {
   1103            int n=0;
   1104            is_reading=1;
   1105            n=ReadAllDatMsg();
   1106            n+=ReadFolder(TYPE_IN_ALL);
   1107            n+=ReadFolder(TYPE_SENT);
   1108            n+=ReadFolder(TYPE_DRAFT);
   1109            SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1110            is_reading=0;
   1111            this->n_new=GetSMSCount(TYPE_IN_N);
   1112            return n;
   1113          }
   1114          
   1115          int SmsData::ReadAllMessageCHK(SmsData *data)
   1116          {
   1117            if(!data->sdltop) return data->ReadAllMessage();
   1118            return 0;
   1119          }
   1120          
   1121          
   1122          int SmsData::ReadAllMessageFRC(SmsData *data)
   1123          {
   1124            return data->ReadAllMessage();
   1125          }
   1126          
   1127          SmsData::SmsData()
   1128          {
   1129            //sms_buf=NULL;
   1130          //  eam_buf=NULL;
   1131            //sms_size=0;
   1132          //  eam_size=0;
   1133            sdltop=NULL;
   1134            is_reading=0;
   1135            this->n_new=0;
   1136            SUBPROC((void *)this->ReadAllMessageCHK, this);
   1137          }
   1138          
   1139          SmsData::~SmsData()
   1140          {
   1141            //if(sms_buf) delete sms_buf;
   1142          //  if(eam_buf) delete eam_buf;
   1143            //sms_size=0;
   1144          //  eam_size=0;
   1145            FreeAllSDL();
   1146          }
   1147          
   1148          
   1149          SmsData *SMSDATA=NULL;
   1150          
   1151          
   1152          int SmsData::IsNewSMS(int dat_index)
   1153          {
   1154            SMS_DATA_ROOT *sdroot=SmsDataRoot();
   1155            SMS_DATA_LLIST inll=sdroot->in_msg;
   1156            SMS_DATA_LIST *lst;
   1157            INDEX_ID_DATA *idd;
   1158            if(!dat_index)
   1159              return 0;
   1160            lst=inll.last;
   1161            while(lst)
   1162            {
   1163              if((idd=lst->index_id_data))
   1164              {
   1165                if(idd->index == dat_index)
   1166                {
   1167          	if(idd->cnt_all != idd->cnt_received)
   1168          	  return 0;
   1169          	if(idd->type==1)
   1170          	  return 1;
   1171          	return 0;
   1172                }
   1173              }
   1174              lst=(SMS_DATA_LIST *)lst->prev;
   1175            }
   1176            return 0;
   1177          }
   1178          
   1179          int SmsData::CheckSMS(int dat_index)
   1180          {
   1181            SDLIST *sdl;
   1182            SMS_DATA_ROOT *sdroot=SmsDataRoot();
   1183            SMS_DATA_LLIST inll=sdroot->in_msg;
   1184            SMS_DATA_LLIST outll=sdroot->out_msg;
   1185            SMS_DATA_LIST *lst;
   1186            INDEX_ID_DATA *idd;
   1187            if(!dat_index)
   1188              return 0;
   1189            lst=inll.first;
   1190            while(lst)
   1191            {
   1192              if((idd=lst->index_id_data))
   1193              {
   1194                if(idd->index==dat_index)
   1195                {
   1196          	if((sdl=FindSDL(dat_index)))
   1197          	{
   1198          	  if(sdl->cnt_r < idd->cnt_received)
   1199          	  {
   1200          	    //DeleteSDL(sdl);
   1201          	    return CHK_RES_RELOAD;
   1202          	  }
   1203          	  if(idd->type==1)
   1204          	  {
   1205          	    if(sdl->type!=TYPE_IN_N)
   1206          	    {
   1207          	      sdl->type=TYPE_IN_N;
   1208          	      return CHK_RES_REFRESH;
   1209          	    }
   1210          	  }
   1211          	  else
   1212          	  {
   1213          	    if(sdl->type==TYPE_IN_N)
   1214          	    {
   1215          	      sdl->type=TYPE_IN_R;
   1216          	      return CHK_RES_REFRESH;
   1217          	    }
   1218          	  }
   1219          	}
   1220          	else return CHK_RES_RELOAD;
   1221          	return CHK_RES_DONOTHING;
   1222                }
   1223              }
   1224              lst=(SMS_DATA_LIST *)lst->next;
   1225            }
   1226            lst=outll.first;
   1227            while(lst)
   1228            {
   1229              if((idd=lst->index_id_data))
   1230              {
   1231                if(idd->index==dat_index)
   1232                {
   1233          	if(!(sdl=FindSDL(dat_index))) return CHK_RES_RELOAD;
   1234          	else if(sdl->cnt_r < idd->cnt_received)
   1235          	{
   1236          	  //DeleteSDL(sdl);
   1237          	  return CHK_RES_RELOAD;
   1238          	}
   1239          	return CHK_RES_DONOTHING;
   1240                }
   1241              }
   1242              lst=(SMS_DATA_LIST *)lst->next;
   1243            }
   1244            //is not exist, del form list
   1245            if((sdl=FindSDL(dat_index)))
   1246            {
   1247              DeleteSDL(sdl);
   1248              return CHK_RES_REFRESH;
   1249            }
   1250            return CHK_RES_DONOTHING;
   1251          }
   1252          
   1253          int SmsData::CheckDat(void)
   1254          {
   1255            SDLIST *sdl;
   1256            SMS_DATA_ROOT *sdroot=SmsDataRoot();
   1257            SMS_DATA_LLIST inll=sdroot->in_msg;
   1258            SMS_DATA_LLIST outll=sdroot->out_msg;
   1259            SMS_DATA_LIST *lst;
   1260            INDEX_ID_DATA *idd;
   1261            int res=0;
   1262            lst=inll.first;
   1263            while(lst)
   1264            {
   1265              if((idd=lst->index_id_data))
   1266              {
   1267                if((sdl=FindSDL(idd->index)))
   1268                {
   1269          	if(sdl->cnt_r < idd->cnt_received)
   1270          	{
   1271          	  DeleteSDL(sdl);
   1272          	  if(ReadMessageOne(idd->index))
   1273          	  {
   1274          	    res++;
   1275          	    if(!(res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1276          	  }
   1277          	  continue;
   1278          	}
   1279          	if(idd->type==1)
   1280          	{
   1281          	  if(sdl->type!=TYPE_IN_N)
   1282          	  {
   1283          	    sdl->type=TYPE_IN_N;
   1284          	    res++;
   1285          	    if(!(res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1286          	    continue;
   1287          	  }
   1288          	}
   1289          	else
   1290          	{
   1291          	  if(sdl->type==TYPE_IN_N)
   1292          	  {
   1293          	    sdl->type=TYPE_IN_R;
   1294          	    res++;
   1295          	    if(!(res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1296          	    continue;
   1297          	  }
   1298          	}
   1299                }
   1300                else
   1301                {
   1302          	if(ReadMessageOne(idd->index))
   1303          	{
   1304          	  res++;
   1305          	  if(!(res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1306          	}
   1307                }
   1308              }
   1309              lst=(SMS_DATA_LIST *)lst->next;
   1310            }
   1311            lst=outll.first;
   1312            while(lst)
   1313            {
   1314              if((idd=lst->index_id_data))
   1315              {
   1316                if(!(sdl=FindSDL(idd->index)) || sdl->cnt_r < idd->cnt_received)
   1317                {
   1318          	if(ReadMessageOne(idd->index))
   1319          	{
   1320          	  res++;
   1321          	  if(res && !(res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1322          	}
   1323                }
   1324              }
   1325              lst=(SMS_DATA_LIST *)lst->next;
   1326            }
   1327            if((res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1328            return res;
   1329          }
   1330          
   1331          int SmsData::CheckFolder(int type)
   1332          {
   1333            char filepath[128];
   1334            const char *folder;
   1335            char dir[128];
   1336            int x, len, res=0;
   1337            DIR_ENTRY de;
   1338            SDLIST *sdx;
   1339            switch(type)
   1340            {
   1341            case TYPE_DRAFT:
   1342              folder=FLDR_DRAFT;
   1343              break;
   1344            case TYPE_SENT:
   1345              folder=FLDR_SENT;
   1346              break;
   1347            case TYPE_IN_N:
   1348            case TYPE_IN_R:
   1349            case TYPE_IN_ALL:
   1350              folder=FLDR_IN;
   1351              break;
   1352            default:
   1353              folder=FLDR_UNK;
   1354              break;
   1355            }
   1356            //if(!IsDir(CFG_MAIN_FOLDER)) return 0;
   1357            strcpy(dir, main_folder);
   1358            //if((len=strlen(dir))<=0) return 0;
   1359            //x=dir[len-1];
   1360            //if((x!='\\')&&(x!='/'))
   1361            //{
   1362            //  dir[len]='\\';
   1363            //  dir[len+1]=0;
   1364            //}
   1365            if(!IsDir(dir)) return 0;
   1366            strcat(dir, folder);
   1367            if(!IsDir(dir)) return 0;
   1368            strcat(dir, "*.mss");
   1369            if(FindFirstFile(&de, dir))
   1370            {
   1371              do
   1372              {
   1373                strcpy(filepath, de.folder_name);
   1374                if((len=strlen(filepath))<=0) continue;
   1375                x=filepath[len-1];
   1376                if((x!='\\')&&(x!='/'))
   1377                {
   1378          	filepath[len]='\\';
   1379          	filepath[len+1]=0;
   1380                }
   1381                strcat(filepath, de.file_name);
   1382                if(!(sdx=FindSDL(filepath)))
   1383                {
   1384          	sdx=AllocSDL();
   1385          	if(ReadMss(filepath, sdx))
   1386          	{
   1387          	  res++;
   1388          	  LockSched();
   1389          	  AddByTimeSDL(sdx);
   1390          	  UnlockSched();
   1391          	  if(!(res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1392          	}
   1393          	else FreeOneSDL(sdx);
   1394                }
   1395              }while(FindNextFile(&de));
   1396            }
   1397            FindClose(&de);
   1398            if((res%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1399            return res;
   1400          }
   1401          
   1402          int SmsData::IsDatExist(int dat_index)
   1403          {
   1404            SMS_DATA_ROOT *sdroot=SmsDataRoot();
   1405            SMS_DATA_LLIST inll=sdroot->in_msg;
   1406            SMS_DATA_LLIST outll=sdroot->out_msg;
   1407            SMS_DATA_LIST *lst;
   1408            INDEX_ID_DATA *idd;
   1409            lst=inll.first;
   1410            while(lst)
   1411            {
   1412              if((idd=lst->index_id_data))
   1413              {
   1414                if(idd->index==dat_index)
   1415          	return 1;
   1416              }
   1417              lst=(SMS_DATA_LIST *)lst->next;
   1418            }
   1419            lst=outll.first;
   1420            while(lst)
   1421            {
   1422              if((idd=lst->index_id_data))
   1423              {
   1424                if(idd->index==dat_index)
   1425          	return 1;
   1426              }
   1427              lst=(SMS_DATA_LIST *)lst->next;
   1428            }
   1429            return 0;
   1430          }
   1431          
   1432          int SmsData::CheckSDList(void)
   1433          {
   1434            SDLIST *sdl=sdltop;
   1435            SDLIST *sdx;
   1436            int n=0;
   1437            while(sdl)
   1438            {
   1439              if((sdl->msg_prop&ISFILE))
   1440              {
   1441                if(sdl->fname)
   1442                {
   1443          	if(!IsFileExist(sdl->fname))
   1444          	{
   1445          	  sdx=sdl;
   1446          	  sdl=(SDLIST *)sdl->next;
   1447          	  DeleteSDL(sdx);
   1448          	  n++;
   1449          	  if(!(n%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1450          	  continue;
   1451          	}
   1452                }
   1453              }
   1454              else if(sdl->dat_index)
   1455              {
   1456                if(!IsDatExist(sdl->dat_index))
   1457                {
   1458          	sdx=sdl;
   1459          	sdl=(SDLIST *)sdl->next;
   1460          	DeleteSDL(sdx);
   1461          	n++;
   1462          	if(!(n%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1463          	continue;
   1464                }
   1465              }
   1466              sdl=(SDLIST *)sdl->next;
   1467            }
   1468            if((n%4)) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1469            return n;
   1470          }
   1471          
   1472          int SmsData::CheckAll(void)
   1473          {
   1474            int res=0;
   1475            res=CheckSDList();
   1476            res+=CheckDat();
   1477            res+=CheckFolder(TYPE_IN_ALL);
   1478            res+=CheckFolder(TYPE_SENT);
   1479            res+=CheckFolder(TYPE_DRAFT);
   1480            SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   1481            this->n_new=GetSMSCount(TYPE_IN_N);
   1482            return res;
   1483          }
   1484          
   1485          int SmsData::CheckAllCHK(SmsData *data)
   1486          {
   1487            if(!data->is_reading)
   1488            {
   1489              return data->CheckAll();
   1490            }
   1491            return 0;
   1492          }
   1493          
   1494          //不支持1版本Mss文件
   1495          int SmsData::NewToReadSMS(SDLIST *sdl)
   1496          {
   1497            if(sdl->type!=TYPE_IN_N) return 0;
   1498            if ((sdl->msg_prop&ISFILE))
   1499            {
   1500              if (sdl->fname)
   1501              {
   1502                int fin;
   1503                int version;
   1504                int type;
   1505                char filepath[128];
   1506                strcpy(filepath, sdl->fname);
   1507                if ((fin=FOpen(filepath, A_BIN+A_ReadWrite, P_READ+P_WRITE))!=-1)
   1508                {
   1509          	LSeek(fin, 8, S_SET);
   1510          	if(FRead(fin, &version, sizeof(int))==sizeof(int))
   1511          	{
   1512          	  if(version==2)
   1513          	  {
   1514          	    type=TYPE_IN_R;
   1515          	    LSeek(fin, 0xC, S_SET);
   1516          	    FWrite(fin, &type, sizeof(int));
   1517          	  }
   1518          	}
   1519          	FClose(fin);
   1520          	sdl->type=TYPE_IN_R;
   1521          	if(this->n_new) this->n_new--;
   1522          	return 1;
   1523                }
   1524                return 0;
   1525              }
   1526              return 0;
   1527            }
   1528            else if (sdl->dat_index)
   1529            {
   1530              if (SetSmsStatus(sdl->dat_index, 1)==0x3E8)
   1531              {
   1532                sdl->type=TYPE_IN_R;
   1533                if(this->n_new) this->n_new--;
   1534                return 1;
   1535              }
   1536              return 0;
   1537            }
   1538            return 0;
   1539          }
   1540          
   1541          
   1542          int SmsData::IsExistSDL(SDLIST *sdl)
   1543          {
   1544            SDLIST *sdx=this->sdltop;
   1545            while(sdx)
   1546            {
   1547              if(sdx==sdl) return 1;
   1548              sdx=(SDLIST *)sdx->next;
   1549            }
   1550            return 0;
   1551          }
   1552          
   1553          
   1554          SDLIST *SmsData::FindNextSDL(SDLIST *sdl, int type)
   1555          {
   1556            if(!sdl) return 0;
   1557            if((type==TYPE_SENT)||(type==TYPE_DRAFT))
   1558            {
   1559              sdl=(SDLIST *)sdl->next;
   1560              while(sdl)
   1561              {
   1562                if(sdl->type==type)
   1563          	return sdl;
   1564                sdl=(SDLIST *)sdl->next;
   1565              }
   1566            }
   1567            else if((type==TYPE_IN_ALL)||(type==TYPE_IN_N)||(type==TYPE_IN_R))
   1568            {
   1569              sdl=(SDLIST *)sdl->next;
   1570              while(sdl)
   1571              {
   1572                if((sdl->type==TYPE_IN_R)||(sdl->type==TYPE_IN_N)||(sdl->type==TYPE_IN_ALL))
   1573          	return sdl;
   1574                sdl=(SDLIST *)sdl->next;
   1575              }
   1576            }
   1577            else if(type==TYPE_FILTER)
   1578            {
   1579              return FilterFindNext(sdl);
   1580            }
   1581            else
   1582            {
   1583              sdl=(SDLIST *)sdl->next;
   1584              return sdl;
   1585            }
   1586            return 0;
   1587          }
   1588          
   1589          SDLIST *SmsData::FindPrevSDL(SDLIST *sdl, int type)
   1590          {
   1591            if(!sdl) return 0;
   1592            if((type==TYPE_SENT)||(type==TYPE_DRAFT))
   1593            {
   1594              sdl=(SDLIST *)sdl->prev;
   1595              while(sdl)
   1596              {
   1597                if(sdl->type==type)
   1598          	return sdl;
   1599                sdl=(SDLIST *)sdl->prev;
   1600              }
   1601            }
   1602            else if((type==TYPE_IN_ALL)||(type==TYPE_IN_N)||(type==TYPE_IN_R))
   1603            {
   1604              sdl=(SDLIST *)sdl->prev;
   1605              while(sdl)
   1606              {
   1607                if((sdl->type==TYPE_IN_R)||(sdl->type==TYPE_IN_N)||(sdl->type==TYPE_IN_ALL))
   1608          	return sdl;
   1609                sdl=(SDLIST *)sdl->prev;
   1610              }
   1611            }
   1612            else if(type==TYPE_FILTER)
   1613            {
   1614              return (FilterFindPrev(sdl));
   1615            }
   1616            else
   1617            {
   1618              sdl=(SDLIST *)sdl->prev;
   1619              return sdl;
   1620            }
   1621            return 0;
   1622          }
   1623          
   1624          
   1625          SDLIST *SmsData::FilterFindSDL(int n)
   1626          {
   1627            switch(CFG_FILTEROP)
   1628            {
   1629            case FILTER_ALL:
   1630              return (FindSDL(0, n));
   1631            case FILTER_NEW:
   1632              return (FindSDL(TYPE_IN_N, n));
   1633            case FILTER_DAT:
   1634              return (FilterFindSDL(0, n));
   1635            case FILTER_FILE:
   1636              return (FilterFindSDL(ISFILE, n));
   1637            case FILTER_NUM:
   1638              return (FilterFindSDL(CFG_STRORNUM, n));
   1639            case FILTER_STR:
   1640              {
   1641                WSHDR *ws, wsn;
   1642                unsigned short wsb[64];
   1643                ws=CreateLocalWS(&wsn, wsb, 63);
   1644                utf8_2ws(ws, CFG_STRORNUM, 63);
   1645                return (FilterFindSDL(ws, n));
   1646              }
   1647            default:
   1648              return 0;
   1649            }
   1650          }
   1651          
   1652          SDLIST *SmsData::FilterFindSDL(int isfile, int n)
   1653          {
   1654            int i=0;
   1655            SDLIST *sdl=sdltop;
   1656            while(sdl)
   1657            {
   1658              if((sdl->msg_prop&ISFILE)==isfile)
   1659              {
   1660                if(i==n) return sdl;
   1661                i++;
   1662              }
   1663              sdl=(SDLIST *)sdl->next;
   1664            }
   1665            return 0;
   1666          }
   1667          
   1668          SDLIST *SmsData::FilterFindSDL(const char *number, int n)
   1669          {
   1670            int i=0;
   1671            SDLIST *sdl=sdltop;
   1672            while(sdl)
   1673            {
   1674              if(NumberMatch(sdl->number, number))
   1675              {
   1676                if(i==n)
   1677          	return sdl;
   1678                i++;
   1679              }
   1680              sdl=(SDLIST *)sdl->next;
   1681            }
   1682            return 0;
   1683          }
   1684          
   1685          SDLIST *SmsData::FilterFindSDL(WSHDR *str, int n)
   1686          {
   1687            int i=0;
   1688            SDLIST *sdl=sdltop;
   1689            while(sdl)
   1690            {
   1691              if(wstrstr(sdl->text, str))
   1692              {
   1693                if(i==n)
   1694          	return sdl;
   1695                i++;
   1696              }
   1697              sdl=(SDLIST *)sdl->next;
   1698            }
   1699            return 0;
   1700          }
   1701          
   1702          
   1703          int SmsData::FilterGetCount(void)
   1704          {
   1705            //GetCPUClock();
   1706            switch(CFG_FILTEROP)
   1707            {
   1708            case FILTER_ALL:
   1709              return (GetSMSCount(0));
   1710            case FILTER_NEW:
   1711              return (GetSMSCount(TYPE_IN_N));
   1712            case FILTER_DAT:
   1713              return (GetSMSCount(0, 0));
   1714            case FILTER_FILE:
   1715              return (GetSMSCount(ISFILE, 0));
   1716            case FILTER_NUM:
   1717              return (FilterGetCount(CFG_STRORNUM));
   1718            case FILTER_STR:
   1719              {
   1720                WSHDR *ws, wsn;
   1721                unsigned short wsb[64];
   1722                ws=CreateLocalWS(&wsn, wsb, 63);
   1723                utf8_2ws(ws, CFG_STRORNUM, 63);
   1724                return (FilterGetCount(ws));
   1725              }
   1726            default:
   1727              return 0;
   1728            }
   1729          }
   1730          
   1731          
   1732          int SmsData::FilterGetCount(const char *number)
   1733          {
   1734            int i=0;
   1735            SDLIST *sdl=sdltop;
   1736            while(sdl)
   1737            {
   1738              if(NumberMatch(sdl->number, number))
   1739              {
   1740                i++;
   1741              }
   1742              sdl=(SDLIST *)sdl->next;
   1743            }
   1744            return i;
   1745          }
   1746          
   1747          int SmsData::FilterGetCount(WSHDR *str)
   1748          {
   1749            int i=0;
   1750            SDLIST *sdl=sdltop;
   1751            while(sdl)
   1752            {
   1753              if(wstrstr(sdl->text, str))
   1754              {
   1755                i++;
   1756              }
   1757              sdl=(SDLIST *)sdl->next;
   1758            }
   1759            return i;
   1760          }
   1761          
   1762          
   1763          SDLIST *SmsData::FilterFindNext(SDLIST *sdl)
   1764          {
   1765            if(!sdl) return 0;
   1766            switch(CFG_FILTEROP)
   1767            {
   1768            case FILTER_ALL:
   1769              return (FindNextSDL(sdl, 0));
   1770            case FILTER_NEW:
   1771              return (FindNextSDL(sdl, TYPE_IN_N));
   1772            case FILTER_DAT:
   1773              sdl=(SDLIST *)sdl->next;
   1774              while(sdl)
   1775              {
   1776                if(!(sdl->msg_prop&ISFILE)) return sdl;
   1777                sdl=(SDLIST *)sdl->next;
   1778              }
   1779              return 0;
   1780            case FILTER_FILE:
   1781              sdl=(SDLIST *)sdl->next;
   1782              while(sdl)
   1783              {
   1784                if((sdl->msg_prop&ISFILE)) return sdl;
   1785                sdl=(SDLIST *)sdl->next;
   1786              }
   1787              return 0;
   1788            case FILTER_NUM:
   1789              return (FilterFindNext(sdl, CFG_STRORNUM));
   1790            case FILTER_STR:
   1791              {
   1792                WSHDR *ws, wsn;
   1793                unsigned short wsb[64];
   1794                ws=CreateLocalWS(&wsn, wsb, 63);
   1795                utf8_2ws(ws, CFG_STRORNUM, 63);
   1796                return (FilterFindNext(sdl, CFG_STRORNUM));
   1797              }
   1798            default:
   1799              return 0;
   1800            }
   1801          }
   1802          SDLIST *SmsData::FilterFindNext(SDLIST *sdl, const char *number)
   1803          {
   1804            if(!sdl) return 0;
   1805            sdl=(SDLIST *)sdl->next;
   1806            while(sdl)
   1807            {
   1808              if(NumberMatch(sdl->number, number))
   1809                return sdl;
   1810              sdl=(SDLIST *)sdl->next;
   1811            }
   1812            return 0;
   1813          }
   1814          SDLIST *SmsData::FilterFindNext(SDLIST *sdl, WSHDR *str)
   1815          {
   1816            if(!sdl) return 0;
   1817            sdl=(SDLIST *)sdl->next;
   1818            while(sdl)
   1819            {
   1820              if(wstrstr(sdl->text, str))
   1821                return sdl;
   1822              sdl=(SDLIST *)sdl->next;
   1823            }
   1824            return 0;
   1825          }
   1826          
   1827          SDLIST *SmsData::FilterFindPrev(SDLIST *sdl)
   1828          {
   1829            if(!sdl) return 0;
   1830            switch(CFG_FILTEROP)
   1831            {
   1832            case FILTER_ALL:
   1833              return (FindPrevSDL(sdl, 0));
   1834            case FILTER_NEW:
   1835              return (FindPrevSDL(sdl, TYPE_IN_N));
   1836            case FILTER_DAT:
   1837              sdl=(SDLIST *)sdl->prev;
   1838              while(sdl)
   1839              {
   1840                if(!(sdl->msg_prop&ISFILE)) return sdl;
   1841                sdl=(SDLIST *)sdl->prev;
   1842              }
   1843              return 0;
   1844            case FILTER_FILE:
   1845              sdl=(SDLIST *)sdl->prev;
   1846              while(sdl)
   1847              {
   1848                if((sdl->msg_prop&ISFILE)) return sdl;
   1849                sdl=(SDLIST *)sdl->prev;
   1850              }
   1851              return 0;
   1852            case FILTER_NUM:
   1853              return (FilterFindPrev(sdl, CFG_STRORNUM));
   1854            case FILTER_STR:
   1855              {
   1856                WSHDR *ws, wsn;
   1857                unsigned short wsb[64];
   1858                ws=CreateLocalWS(&wsn, wsb, 63);
   1859                utf8_2ws(ws, CFG_STRORNUM, 63);
   1860                return (FilterFindPrev(sdl, CFG_STRORNUM));
   1861              }
   1862            default:
   1863              return 0;
   1864            }
   1865          }
   1866          SDLIST *SmsData::FilterFindPrev(SDLIST *sdl, const char *number)
   1867          {
   1868            if(!sdl) return 0;
   1869            sdl=(SDLIST *)sdl->prev;
   1870            while(sdl)
   1871            {
   1872              if(NumberMatch(sdl->number, number))
   1873                return sdl;
   1874              sdl=(SDLIST *)sdl->prev;
   1875            }
   1876            return 0;
   1877          }
   1878          SDLIST *SmsData::FilterFindPrev(SDLIST *sdl, WSHDR *str)
   1879          {
   1880            if(!sdl) return 0;
   1881            sdl=(SDLIST *)sdl->prev;
   1882            while(sdl)
   1883            {
   1884              if(wstrstr(sdl->text, str))
   1885                return sdl;
   1886              sdl=(SDLIST *)sdl->prev;
   1887            }
   1888            return 0;
   1889          }
   1890          
   1891          
   1892          int SmsData::MoveToArchive(SDLIST *sdl) //只支持mss
   1893          {
   1894            char fullpath[128];
   1895            char folder[128];
   1896          //  unsigned int err;
   1897          //  MSS_FILE_P2 msf;
   1898            //int /*fin,*/ len, c;
   1899            TTime time;
   1900            TDate date;
   1901            if(!sdl || !(sdl->msg_prop&ISFILE))
   1902              return 0;
   1903            GetDateTime(&date, &time);
   1904            strcpy(folder, main_folder);
   1905            //len=strlen(folder);
   1906            //c=folder[len-1];
   1907            //if(c!='\\' && c!='/')
   1908            //{
   1909            //  folder[len]='\\';
   1910            //  folder[len+1]=0;
   1911            //}
   1912            if(!IsDir(folder))
   1913              MkDir(folder);
   1914            strcat(folder, FLDR_ARCHIVE);
   1915            if(!strncmp(sdl->fname, folder, strlen(folder))) //判断是否已经在档案柜文件夹中
   1916              return 0;
   1917            if(!IsDir(folder))
   1918              MkDir(folder);
   1919            if(strlen(sdl->time)>4)
   1920            {
   1921              strcpy(fullpath, "20");
   1922              strncat(fullpath, sdl->time, 5);
   1923              fullpath[7]='\\';
   1924              fullpath[8]='\0';
   1925              //sprintf(fullpath, "20%05s\\", sdl->time);
   1926              StrClearChr(fullpath, '-');
   1927            }
   1928            else sprintf(fullpath, "%04d%02d\\", date.year, date.month); //借用~_~ , 按月份存储
   1929            strcat(folder, fullpath);
   1930            if(!IsDir(folder))
   1931              MkDir(folder);
   1932            switch(sdl->type)
   1933            {
   1934            case TYPE_DRAFT:
   1935              strcat(folder, FLDR_DRAFT);
   1936              break;
   1937            case TYPE_SENT:
   1938              strcat(folder, FLDR_SENT);
   1939              break;
   1940            case TYPE_IN_N:
   1941            case TYPE_IN_R:
   1942            case TYPE_IN_ALL:
   1943              strcat(folder, FLDR_IN);
   1944              break;
   1945            default:
   1946              strcat(folder, FLDR_UNK);
   1947              break;
   1948            }
   1949            if(!IsDir(folder))
   1950              MkDir(folder);
   1951            if(!GetFilePathSDL(sdl, folder, fullpath, FTYPE_MSS))
   1952              return 0;
   1953            if (sdl->fname)
   1954            {
   1955              if(FMove(sdl->fname, fullpath))
   1956              {
   1957                DeleteSDL(sdl);
   1958                return 1;
   1959              }
   1960            }
   1961            return 0;
   1962          }
   1963          
   1964          int SmsData::GetFilePathSDL(SDLIST *sdl, char *folder, char *filepath, int ftype)
   1965          {
   1966            int hasname;
   1967            WSHDR *wname, nm;
   1968            unsigned short nmb[64];
   1969            char sname[65];
   1970            char temp[128];
   1971            TTime time;
   1972            TDate date;
   1973            int i=0;
   1974            GetDateTime(&date, &time);
   1975            wname=CreateLocalWS(&nm, nmb, 63);
   1976            if(strlen(sdl->number))
   1977            {
   1978              if(!ADRLST->FindName(wname, sdl->number))
   1979              {
   1980                hasname=0;
   1981              }
   1982              else
   1983              {
   1984                hasname=1;
   1985                ws_2str(wname, sname, 64);
   1986              }
   1987            }
   1988            else
   1989            {
   1990              hasname=1;
   1991              strcpy(sname, "Unk");
   1992            }
   1993            if(strlen(sdl->time))
   1994            {
   1995              snprintf(filepath, 128, "%s_%s", (hasname)?sname:sdl->number, sdl->time/*, (ftype==FTYPE_MSS)?"mss":"txt"*/);
   1996            }
   1997            else
   1998              snprintf(filepath, 128, "%s_%02d-%02d-%02d %02d%02d%02d", (hasname)?sname:sdl->number,
   1999          	    date.year%2000,
   2000          	    date.month,
   2001          	    date.day,
   2002          	    time.hour,
   2003          	    time.min,
   2004          	    time.sec
   2005          	      );
   2006            StrClearChr(filepath, ':');
   2007            StrClearChr(filepath, '*');
   2008            StrClearChr(filepath, '?');
   2009            StrClearChr(filepath, '<');
   2010            StrClearChr(filepath, '>');
   2011            StrClearChr(filepath, '|');
   2012            StrClearChr(filepath, '\\');
   2013            StrClearChr(filepath, '/');
   2014            strcpy(temp, folder);
   2015            strcat(temp, filepath);
   2016            strcat(temp, (ftype==FTYPE_MSS)?".mss":".txt");
   2017            if(!IsFileExist(temp))
   2018            {
   2019              strcpy(filepath, temp);
   2020              return 1;
   2021            }
   2022            while(i<MAX_FILE)
   2023            {
   2024              sprintf(temp, "%s%s_%04d%s", folder, filepath, i, (ftype==FTYPE_MSS)?".mss":".txt");
   2025              if(!IsFileExist(temp))
   2026              {
   2027                strcpy(filepath, temp);
   2028                return 1;
   2029              }
   2030              i++;
   2031            }
   2032            return 0;
   2033          }
   2034          
   2035          int SmsData::MoveAllToArchive(void)
   2036          {
   2037            int res=0;
   2038            SDLIST *sdx;
   2039            SDLIST *sdl=this->sdltop;
   2040            while(sdl)
   2041            {
   2042              sdx=(SDLIST *)sdl->next;
   2043              if(MoveToArchive(sdl))
   2044              {
   2045                res++;
   2046                if(res%4) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   2047              }
   2048              sdl=sdx;
   2049            }
   2050            return res;
   2051          }
   2052          
   2053          void SmsData::MoveAllToArchiveBG(SmsData *data)
   2054          {
   2055            char msgt[64];
   2056            int res=data->MoveAllToArchive();
   2057            sprintf(msgt, LGP->lgp.LGP_MOVE_MSSARCHIVER_N,res);
   2058            ShowMSG(1, (int)msgt);
   2059          }
   2060          
   2061          
   2062          
   2063          
   2064          SDLIST * SmsData::FindLastNew(void)
   2065          {
   2066            SDLIST *sdl=this->sdltop;
   2067            while(sdl)
   2068            {
   2069              if(sdl->type==TYPE_IN_N)
   2070                return sdl;
   2071              sdl=sdl->next;
   2072            }
   2073            return 0;
   2074          }
   2075          /*
   2076          int SmsData::ExportText(SDLIST *sdl)
   2077          {
   2078          	if(!sdl)
   2079          		return 0;
   2080          	char *buf;
   2081          	char folder[128];
   2082          	char filepath[128];
   2083          	char sname[64];
   2084          	int len;
   2085          	int c;
   2086          	int fin;
   2087          	strcpy(folder, CFG_MAIN_FOLDER);
   2088          	if(!(len=strlen(folder)))
   2089          		return 0;
   2090          	c=folder[len-1];
   2091          	if(c!='\\' && c!='/')
   2092          	{
   2093          		folder[len]='\\';
   2094          		folder[le]='\0';
   2095          	}
   2096          	if(!IsDir(folder))
   2097          		MkDir(folder);
   2098          	strcat(folder, "Text\\");
   2099          	if(!IsDir(folder))
   2100          		MkDir(folder);
   2101          	if(GetFilePathSDL(sdl, folder, filepath, FTYPE_TXT))
   2102          		return 0;
   2103          	if((fin=FOpen(filepath, A_BIN+A_WriteOnly+A_Create+A_Truncate, P_WRITE))==-1)
   2104          		return 0;
   2105          	len=sdl->text->wsbody[0]*3+4;
   2106          	buf=new char[len];
   2107          	buf[0]=0xEF;
   2108          	buf[1]=0xBB;
   2109          	buf[2]=0xBF;
   2110          	if(FWrite(fin, buf, 3)!=3)
   2111          	{
   2112          		delete buf;
   2113          		return 0;
   2114          	}
   2115          	ws_2utf8(sdl->text, buf, len);
   2116          }*/
   2117          
   2118          const char *utf8_hdr="\xEF\xBB\xBF";
   2119          int SmsData::ExportAllToText()
   2120          {
   2121            int fin;
   2122            int res=0;
   2123            //int c;
   2124            int len;
   2125            int utf8_res_len;
   2126            char *buf;
   2127            char folder[128];
   2128            char filename[128];
   2129            char temp[256];
   2130            char sname[64];
   2131            TTime time;
   2132            TDate date;
   2133            SDLIST *sdl;
   2134            strcpy(folder, main_folder);
   2135            //if(!(len=strlen(folder)))
   2136            //  return 0;
   2137            //c=folder[len-1];
   2138            //if(c!='\\' && c!='/')
   2139            //{
   2140            //  folder[len++]='\\';
   2141            //  folder[len]='\0';
   2142            //}
   2143            if(!IsDir(folder))
   2144              MkDir(folder);
   2145            strcat(folder, "Text\\");
   2146            if(!IsDir(folder))
   2147              MkDir(folder);
   2148            GetDateTime(&date, &time);
   2149            sprintf(filename, "%s%04d%02d%02d_%02d%02d.txt",
   2150              folder,
   2151              date.year,
   2152              date.month,
   2153              date.day,
   2154              time.hour,
   2155              time.min);
   2156            if(IsFileExist(filename))
   2157              return 0;
   2158            if((fin=FOpen(filename, A_BIN+A_WriteOnly+A_Create+A_Truncate, P_WRITE))==-1)
   2159              return 0;
   2160            if(FWrite(fin, utf8_hdr, 3)!=3)
   2161            {
   2162              FClose(fin);
   2163              return 0;
   2164            }
   2165            sdl=this->sdltop;
   2166            buf=new char[MAX_TEXT*3];
   2167            while(sdl)
   2168            {
   2169              CLIST *cl;
   2170              if((cl=ADRLST->FindCList(sdl->number))
   2171                && cl->name
   2172                )
   2173              {
   2174                ws_2utf8(cl->name, sname, &utf8_res_len, 64);
   2175              }
   2176              else
   2177              {
   2178                strcpy(sname, sdl->number);
   2179              }
   2180              sprintf(temp, "%s: %s\r\n%s: %s\r\n%s: %s\r\n%s:\r\n",
   2181                (sdl->type==TYPE_SENT||sdl->type==TYPE_DRAFT)?STR_TO_UTF8:STR_FROM_UTF8,
   2182                sname,
   2183                STR_NUMBER_UTF8,
   2184                sdl->number,
   2185                STR_TIME_UTF8,
   2186                (strlen(sdl->time))?sdl->time:STR_UNK_UTF8,
   2187                STR_TEXT_UTF8
   2188                );
   2189              len=strlen(temp);
   2190              if(FWrite(fin, temp, len)!=len)
   2191                break;
   2192              ws_2utf8(sdl->text, buf, &utf8_res_len, MAX_TEXT*3);
   2193              strcat(buf, "\r\n\r\n");
   2194              len=strlen(buf);
   2195              if(FWrite(fin, buf, len)!=len)
   2196                break;
   2197              res++;
   2198              sdl=sdl->next;
   2199            }
   2200            delete buf;
   2201            FClose(fin);
   2202            return res;
   2203          }
   2204          
   2205          void SmsData::ExportAllToTextBG(SmsData *smsdata)
   2206          {
   2207            char msgt[64];
   2208            int res=smsdata->ExportAllToText();
   2209            sprintf(msgt, LGP->lgp.LGP_EXPORT_N, res);
   2210            ShowMSG(1, (int)msgt);
   2211          }
   2212          
   2213          int SmsData::DeleteAllMss()
   2214          {
   2215            int res=0;
   2216            SDLIST *s0;
   2217            SDLIST *sdl=this->sdltop;
   2218            while(sdl)
   2219            {
   2220              s0=sdl->next;
   2221              if(
   2222                (sdl->msg_prop&ISFILE)
   2223                && sdl->fname
   2224                && FDelete(sdl->fname)
   2225                )
   2226              {
   2227                DeleteSDL(sdl);
   2228                res++;
   2229                if(res%4) SendMyIpc(SMSYS_IPC_SMS_DATA_UPDATE);
   2230              }
   2231              sdl=s0;
   2232            }
   2233            return res;
   2234          }
   2235          
   2236          void SmsData::DeleteAllMssBG(SmsData *smsdata)
   2237          {
   2238            char msgt[64];
   2239            int res=smsdata->DeleteAllMss();
   2240            sprintf(msgt, LGP->lgp.LGP_DEL_N, res);
   2241            ShowMSG(1, (int)msgt);
   2242          }

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     DataDecoder(_SDLIST *, char *, int)
                                      472
     ReadSMS(_SDLIST *, INDEX_ID_DATA *)
                                      240
     SmsData::AddByTimeSDL(_SDLIST *)
                                       16
     SmsData::AllocSDL()                8
     SmsData::CheckAll()               12
     SmsData::CheckAllCHK(SmsData *)
                                        4
     SmsData::CheckDat()               36
     SmsData::CheckFolder(int)       1112
     SmsData::CheckSDList()            24
     SmsData::CheckSMS(int)            16
     SmsData::CopyOneSDL(_SDLIST *)    12
     SmsData::DeMsgDataList(SMS_DATA_LIST *)
                                       28
     SmsData::DeleteAllMss()           20
     SmsData::DeleteAllMssBG(SmsData *)
                                       68
     SmsData::DeleteMessage(_SDLIST *)
                                       16
     SmsData::DeleteSDL(_SDLIST *)     12
     SmsData::ExportAllToText()       652
     SmsData::ExportAllToTextBG(SmsData *)
                                       68
     SmsData::FilterFindNext(_SDLIST *)
                                      164
     SmsData::FilterFindNext(_SDLIST *, WSHDR *)
                                       12
     SmsData::FilterFindNext(_SDLIST *, char const *)
                                       12
     SmsData::FilterFindPrev(_SDLIST *)
                                      164
     SmsData::FilterFindPrev(_SDLIST *, WSHDR *)
                                       12
     SmsData::FilterFindPrev(_SDLIST *, char const *)
                                       12
     SmsData::FilterFindSDL(WSHDR *, int)
                                       20
     SmsData::FilterFindSDL(char const *, int)
                                       20
     SmsData::FilterFindSDL(int)      168
     SmsData::FilterFindSDL(int, int)
                                        0
     SmsData::FilterGetCount()        164
     SmsData::FilterGetCount(WSHDR *)
                                       16
     SmsData::FilterGetCount(char const *)
                                       16
     SmsData::FindLastNew()             0
     SmsData::FindMsgDataL(int)         8
     SmsData::FindNextSDL(_SDLIST *, int)
                                        4
     SmsData::FindOpmsgSDL(int)        12
     SmsData::FindPrevSDL(_SDLIST *, int)
                                        4
     SmsData::FindSDL(WSHDR *, char *, char *)
                                       20
     SmsData::FindSDL(char *)          12
     SmsData::FindSDL(int)              0
     SmsData::FindSDL(int, int)         4
     SmsData::FreeAllSDL()             12
     SmsData::FreeOneSDL(_SDLIST *)     8
     SmsData::GetFilePathSDL(_SDLIST *, char *, char *, int)
                                      420
     SmsData::GetMssPath(char *, char *, TTime *, TDate *)
                                      168
     SmsData::GetSMSCount(int)          4
     SmsData::GetSMSCount(int, int)     0
     SmsData::IsDatExist(int)           8
     SmsData::IsExistSDL(_SDLIST *)     0
     SmsData::IsNewSMS(int)             8
     SmsData::MoveAllToArchive()       16
     SmsData::MoveAllToArchiveBG(SmsData *)
                                       68
     SmsData::MoveToArchive(_SDLIST *)
                                      288
     SmsData::NewToReadSMS(_SDLIST *)
                                      156
     SmsData::ReadAllDatMsg()          24
     SmsData::ReadAllMessage()         12
     SmsData::ReadAllMessageCHK(SmsData *)
                                        4
     SmsData::ReadAllMessageFRC(SmsData *)
                                        4
     SmsData::ReadFolder(int)        1112
     SmsData::ReadMessageOne(int)      16
     SmsData::ReadMss(char *, _SDLIST *)
                                      188
     SmsData::SaveMss(WSHDR *, char const *, _SDLIST *, int, int)
                                      404
     SmsData::SmsData()                 8
     SmsData::delete ~SmsData(SmsData *)
                                        8
     SmsData::new SmsData()             4
     SmsData::~SmsData()                4


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     SmsData::AllocSDL()              32
     SmsData::DeleteSDL(_SDLIST *)   104
     SmsData::FreeAllSDL()           100
     SmsData::AddByTimeSDL(_SDLIST *)
                                     116
     SmsData::FreeOneSDL(_SDLIST *)   72
     SmsData::CopyOneSDL(_SDLIST *)  124
     SmsData::FindSDL(int)            32
     SmsData::FindOpmsgSDL(int)       96
     SmsData::FindSDL(WSHDR *, char *, char *)
                                     180
     SmsData::FindSDL(char *)         88
     SmsData::GetSMSCount(int)       140
     SmsData::GetSMSCount(int, int)  164
     SmsData::FindSDL(int, int)      180
     DataDecoder(_SDLIST *, char *, int)
                                     800
     ReadSMS(_SDLIST *, INDEX_ID_DATA *)
                                     336
     SmsData::DeMsgDataList(SMS_DATA_LIST *)
                                     168
     SmsData::ReadAllDatMsg()        212
     SmsData::FindMsgDataL(int)      112
     SmsData::ReadMessageOne(int)    112
     SmsData::ReadMss(char *, _SDLIST *)
                                     516
     SmsData::ReadFolder(int)        432
     SmsData::SaveMss(WSHDR *, char const *, _SDLIST *, int, int)
                                     752
     SmsData::GetMssPath(char *, char *, TTime *, TDate *)
                                     260
     SmsData::DeleteMessage(_SDLIST *)
                                     128
     SmsData::ReadAllMessage()       120
     SmsData::ReadAllMessageCHK(SmsData *)
                                      24
     SmsData::ReadAllMessageFRC(SmsData *)
                                       4
     SmsData::SmsData()               44
     SmsData::~SmsData()               4
     SMSDATA                           4
     SmsData::IsNewSMS(int)           96
     SmsData::CheckSMS(int)          296
     SmsData::CheckDat()             448
     SmsData::CheckFolder(int)       472
     SmsData::IsDatExist(int)        108
     SmsData::CheckSDList()          200
     SmsData::CheckAll()             112
     SmsData::CheckAllCHK(SmsData *)
                                      24
     SmsData::NewToReadSMS(_SDLIST *)
                                     288
     SmsData::IsExistSDL(_SDLIST *)   36
     SmsData::FindNextSDL(_SDLIST *, int)
                                     156
     SmsData::FindPrevSDL(_SDLIST *, int)
                                     156
     SmsData::FilterFindSDL(int)     208
     SmsData::FilterFindSDL(int, int)
                                      56
     SmsData::FilterFindSDL(char const *, int)
                                      84
     SmsData::FilterFindSDL(WSHDR *, int)
                                      84
     SmsData::FilterGetCount()       188
     SmsData::FilterGetCount(char const *)
                                      64
     SmsData::FilterGetCount(WSHDR *)
                                      64
     SmsData::FilterFindNext(_SDLIST *)
                                     228
     SmsData::FilterFindNext(_SDLIST *, char const *)
                                      68
     SmsData::FilterFindNext(_SDLIST *, WSHDR *)
                                      68
     SmsData::FilterFindPrev(_SDLIST *)
                                     228
     SmsData::FilterFindPrev(_SDLIST *, char const *)
                                      68
     SmsData::FilterFindPrev(_SDLIST *, WSHDR *)
                                      68
     SmsData::MoveToArchive(_SDLIST *)
                                     528
     SmsData::GetFilePathSDL(_SDLIST *, char *, char *, int)
                                     604
     SmsData::MoveAllToArchive()      96
     SmsData::MoveAllToArchiveBG(SmsData *)
                                      56
     SmsData::FindLastNew()           32
     utf8_hdr                          4
     SmsData::ExportAllToText()      668
     SmsData::ExportAllToTextBG(SmsData *)
                                      56
     SmsData::DeleteAllMss()         128
     SmsData::DeleteAllMssBG(SmsData *)
                                      56
     ?<Initializer for utf8_hdr>       4
     ?<Constant "\357\273\277">        4
     ?<Constant "Text\\">             76
     ?<Constant "MySMSYS">            40
     ?<Constant "%04d%02d%02d%02d%02d%02d">
                                      96
     ?<Constant "*.mss">               8
     ?<Constant "Unk">                 4
     ?<Constant "20">                  3
     ?<Constant "%04d%02d\\">         12
     SmsData::new SmsData()           28
     SmsData::delete ~SmsData(SmsData *)
                                      28
     ??DataTable12                     4
     ??DataTable13                     4
     ??DataTable15                     4
     ??DataTable16                     4
     ??DataTable17                     4
     ??DataTable18                     4
     ??DataTable19                     4
     ??DataTable20                     4
     ??DataTable21                     4
     ??DataTable22                     4
     ??DataTable29                     4
     ??DataTable30                     4
     ??DataTable32                     4
     ??DataTable33                     4
     ??DataTable34                     4
     ??DataTable35                     4
     ??DataTable37                     4
     ??DataTable38                     4
     ??DataTable40                     4
     ??DataTable41                     4
     ??DataTable43                     4
      Others                         608

 
 12 268 bytes in segment CODE
    243 bytes in segment DATA_C
      4 bytes in segment DATA_I
      4 bytes in segment DATA_ID
      4 bytes in segment DATA_Z
     24 bytes in segment INITTAB
 
 11 684 bytes of CODE  memory (+ 608 bytes shared)
    247 bytes of CONST memory
      8 bytes of DATA  memory

Errors: none
Warnings: none
