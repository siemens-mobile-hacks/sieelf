##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    14/Feb/2012  15:39:18 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDE #
#                       C\AAC_FILE (17).c                                    #
#    Command line    =  "D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACD #
#                       EC\AAC_FILE (17).c" -D NDEBUG -lC                    #
#                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\ -lA D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\ #
#                       Release\List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player #
#                       \Player\Release\Obj\ -s9 --cpu_mode arm --endian     #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None --dlib_config "D:\Program              #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude       #
#                       swilib.h -I "D:\Program Files\IAR\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=16                                #
#    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\AAC_FILE (17).lst                                #
#    Object file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\O #
#                       bj\AAC_FILE (17).r79                                 #
#                                                                            #
#                                                                            #
##############################################################################

D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDEC\AAC_FILE (17).c
      1          /* ***** BEGIN LICENSE BLOCK *****  
      2           * Source last modified: $Id: dequant.c,v 1.1 2005/02/26 01:47:34 jrecker Exp $ 
      3           *   
      4           * Portions Copyright (c) 1995-2005 RealNetworks, Inc. All Rights Reserved.  
      5           *       
      6           * The contents of this file, and the files included with this file, 
      7           * are subject to the current version of the RealNetworks Public 
      8           * Source License (the "RPSL") available at 
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed 
     10           * the file under the current version of the RealNetworks Community 
     11           * Source License (the "RCSL") available at 
     12           * http://www.helixcommunity.org/content/rcsl, in which case the RCSL 
     13           * will apply. You may also obtain the license terms directly from 
     14           * RealNetworks.  You may not use this file except in compliance with 
     15           * the RPSL or, if you have a valid RCSL with RealNetworks applicable 
     16           * to this file, the RCSL.  Please see the applicable RPSL or RCSL for 
     17           * the rights, obligations and limitations governing use of the 
     18           * contents of the file. 
     19           *   
     20           * This file is part of the Helix DNA Technology. RealNetworks is the 
     21           * developer of the Original Code and owns the copyrights in the 
     22           * portions it created. 
     23           *   
     24           * This file, and the files included with this file, is distributed 
     25           * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY 
     26           * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS 
     27           * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES 
     28           * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET 
     29           * ENJOYMENT OR NON-INFRINGEMENT. 
     30           *  
     31           * Technology Compatibility Kit Test Suite(s) Location:  
     32           *    http://www.helixcommunity.org/content/tck  
     33           *  
     34           * Contributor(s):  
     35           *   
     36           * ***** END LICENSE BLOCK ***** */  
     37          
     38          /**************************************************************************************
     39           * Fixed-point HE-AAC decoder
     40           * Jon Recker (jrecker@real.com), Ken Cooke (kenc@real.com)
     41           * February 2005
     42           *
     43           * dequant.c - transform coefficient dequantization and short-block deinterleaving
     44           **************************************************************************************/
     45          
     46          #include "coder_aac.h"
     47          #include "assembly_aac.h"
     48          
     49          #define	SF_OFFSET			100
     50          
     51          /* pow(2, i/4.0) for i = [0,1,2,3], format = Q30 */

   \                                 In segment DATA_C, align 4, align-sorted
     52          static const int pow14[4] = { 
   \                     pow14:
   \   00000000   0000004029F8       DC32 1073741824, 1276901417, 1518500250, 1805811301
   \              1B4C9A79825A
   \              657EA26B    
   \   00000010   0E0000000D00       DC32 14, 13, 11, 10, 9, 7, 6, 5
   \              00000B000000
   \              0A0000000900
   \              000007000000
   \              060000000500
   \              0000        
   \   00000030   94FA9765E68B       DC32 1704458900, 1352829926, 2147483647, 1704458900, 1352829926
   \              A250FFFFFF7F
   \              94FA9765E68B
   \              A250        
   \   00000044   FFFFFF7F94FA       DC32 2147483647, 1704458900, 1352829926
   \              9765E68BA250
   \   00000050   FAA22814D61B       DC32 338207482, 366681046, 395718700, 425299333, 455403707, 486014202
   \              DB152C309617
   \              858D5919BBE8
   \              241BFAFCF71C
   \   00000068   F28AD21E2A58       DC32 517114610, 548689962, 580726382, 613210965, 646131674, 679477248
   \              B4206E2E9D22
   \              55DB8C24DA2F
   \              832600008028
   \   00000080   8722832AA870       DC32 713237127, 747401384, 781960664, 816906137, 852229450, 887922689
   \              8C2CD8C59B2E
   \              99FFB0304AFD
   \              CB3201A0EC34
   \   00000098   62CA12378860       DC32 923978338, 960389256, 997148640, 1034250007, 1071687164
   \              3E39E0476F3B
   \              1767A53DFCA5
   \              E03F        
   \   000000AC   72ED20425827       DC32 1109454194, 1147545432, 1185955452, 1224679047, 1263711219
   \              66447C3EB046
   \              871EFF48F3B3
   \              524B        
   \   000000C0   FDEBAA4D97B4       DC32 1303047165, 1342682263, 1382612066, 1422832284, 1463338785
   \              075062FC6852
   \              9CB2CE5421C7
   \              3857        
   \   000000D4   592AA75935CD       DC32 1504127577, 1545194805, 1586536745, 1628149793, 1670030463
   \              195C29A1905E
   \              21980B617FA4
   \              8A63        
   \   000000E8   0FB90D660BC9       DC32 1712175375, 1754581259, 1797244940, 1840163341, 1883333472
   \              94680CC81F6B
   \              0DAAAE6D6063
   \              4170        
   \   000000FC   B0E8D772F92E       DC32 1926752432, 1970417401, 2014325637, 2058474476, 2102861321
   \              7275852B1078
   \              ECD3B17A091E
   \              577D        
   \   00000110   000000000000       DC32 0, 268435456, 676414963, 1161452763, 213057363, 286886358
   \              0010F3455128
   \              DB5C3A4553FF
   \              B20CD6891911
   \   00000128   C831CE1503F2       DC32 365834696, 449311235, 536870912, 628164281, 722908323, 820868276
   \              C71A00000020
   \              B9067125A3B4
   \              162BB474ED30
   \   00000140   A53FF236D37B       DC32 921845669, 1025670099, 1132193366, 1241285180, 0, 319225354
   \              223D56E67B43
   \              3C82FC490000
   \              00000AFE0613
   \   00000158   AF21F22F528F       DC32 804397487, 1381207890, 253369332, 341167298, 435053224, 534324118
   \              5352F41B1A0F
   \              C2CC5514A862
   \              EE199623D91F
   \   00000170   14FC0D26D894       DC32 638450708, 747017432, 859687721, 976182394, 1096265429, 1219734179
   \              862C29CB3D33
   \              7A5C2F3AD5AE
   \              5741A3AAB348
   \   00000188   769F40501030       DC32 1346412406, 1476145168, 0, 379625062, 956595215, 1642542250
   \              FC5700000000
   \              669EA0160F7C
   \              0439AA34E761
   \   000001A0   C49AF51133C6       DC32 301308612, 405718579, 517368389, 635422042, 759250125, 888358445
   \              2E18456AD61E
   \              5AC5DF25CD3C
   \              412D2D46F334
   \   000001B8   03C6EF3C69AB       DC32 1022346755, 1160883049, 1303686648, 1450516564, 1601163213
   \              3145F8ADB44D
   \              54207556CDCF
   \              6F5F        
   \   000001CC   A1ECA1680000       DC32 1755442337, 0, 451452825, 1137589835, 1953322930, 358318345
   \              0000999FE81A
   \              4B3ECE43B257
   \              6D7409815B15
   \   000001E4   DC1CC21C3918       DC32 482483420, 615258169, 755648414, 902905651, 1056442184, 1215782035
   \              AC249E470A2D
   \              333FD1354807
   \              F83E935C7748
   \   000001FC   CD3849521D84       DC32 1380530381, 1550353437, 1724964618, 1904114686, 2087584517
   \              685C0ADFD066
   \              FE7B7E710503
   \              6E7C        
   \   00000210   A9BDA0292848       DC32 698400169, -1339144152, 1498917403, 594299277, -11003815
   \              2EB01BAA5759
   \              8D496C235918
   \              58FF        
   \   00000224   63218510A4F6       DC32 277160291, -751569244, 1189691531, 667078384, -17467468
   \              33D38B40E946
   \              F0CEC227B477
   \              F5FE        
     53          	0x40000000, 0x4c1bf829, 0x5a82799a, 0x6ba27e65
     54          };
     55          
     56          /* pow(2, i/4.0) * pow(j, 4.0/3.0) for i = [0,1,2,3],  j = [0,1,2,...,15]
     57           * format = Q28 for j = [0-3], Q25 for j = [4-15]
     58           */
     59          static const int pow43_14[4][16] = {
     60          	{
     61          	0x00000000, 0x10000000, 0x285145f3, 0x453a5cdb, /* Q28 */
     62          	0x0cb2ff53, 0x111989d6, 0x15ce31c8, 0x1ac7f203, /* Q25 */
     63          	0x20000000, 0x257106b9, 0x2b16b4a3, 0x30ed74b4, /* Q25 */
     64          	0x36f23fa5, 0x3d227bd3, 0x437be656, 0x49fc823c, /* Q25 */
     65          	},
     66          	{
     67          	0x00000000, 0x1306fe0a, 0x2ff221af, 0x52538f52, 
     68          	0x0f1a1bf4, 0x1455ccc2, 0x19ee62a8, 0x1fd92396, 
     69          	0x260dfc14, 0x2c8694d8, 0x333dcb29, 0x3a2f5c7a, 
     70          	0x4157aed5, 0x48b3aaa3, 0x50409f76, 0x57fc3010, 
     71          	},
     72          	{
     73          	0x00000000, 0x16a09e66, 0x39047c0f, 0x61e734aa, 
     74          	0x11f59ac4, 0x182ec633, 0x1ed66a45, 0x25dfc55a, 
     75          	0x2d413ccd, 0x34f3462d, 0x3cefc603, 0x4531ab69, 
     76          	0x4db4adf8, 0x56752054, 0x5f6fcfcd, 0x68a1eca1, 
     77          	},
     78          	{
     79          	0x00000000, 0x1ae89f99, 0x43ce3e4b, 0x746d57b2, 
     80          	0x155b8109, 0x1cc21cdc, 0x24ac1839, 0x2d0a479e, 
     81          	0x35d13f33, 0x3ef80748, 0x48775c93, 0x524938cd, 
     82          	0x5c68841d, 0x66d0df0a, 0x717e7bfe, 0x7c6e0305, 
     83          	},
     84          };
     85          
     86          /* pow(j, 4.0 / 3.0) for j = [16,17,18,...,63], format = Q23 */
     87          static const int pow43[48] = {
     88          	0x1428a2fa, 0x15db1bd6, 0x1796302c, 0x19598d85, 
     89          	0x1b24e8bb, 0x1cf7fcfa, 0x1ed28af2, 0x20b4582a, 
     90          	0x229d2e6e, 0x248cdb55, 0x26832fda, 0x28800000, 
     91          	0x2a832287, 0x2c8c70a8, 0x2e9bc5d8, 0x30b0ff99, 
     92          	0x32cbfd4a, 0x34eca001, 0x3712ca62, 0x393e6088, 
     93          	0x3b6f47e0, 0x3da56717, 0x3fe0a5fc, 0x4220ed72, 
     94          	0x44662758, 0x46b03e7c, 0x48ff1e87, 0x4b52b3f3, 
     95          	0x4daaebfd, 0x5007b497, 0x5268fc62, 0x54ceb29c, 
     96          	0x5738c721, 0x59a72a59, 0x5c19cd35, 0x5e90a129, 
     97          	0x610b9821, 0x638aa47f, 0x660db90f, 0x6894c90b, 
     98          	0x6b1fc80c, 0x6daeaa0d, 0x70416360, 0x72d7e8b0, 
     99          	0x75722ef9, 0x78102b85, 0x7ab1d3ec, 0x7d571e09, 
    100          };
    101          
    102          /* sqrt(0.5), format = Q31 */
    103          #define SQRTHALF 0x5a82799a
    104          
    105          /* Minimax polynomial approximation to pow(x, 4/3), over the range
    106           *  poly43lo: x = [0.5, 0.7071]
    107           *  poly43hi: x = [0.7071, 1.0]
    108           *
    109           * Relative error < 1E-7
    110           * Coefs are scaled by 4, 2, 1, 0.5, 0.25
    111           */
    112          static const int poly43lo[5] = { 0x29a0bda9, 0xb02e4828, 0x5957aa1b, 0x236c498d, 0xff581859 };
    113          static const int poly43hi[5] = { 0x10852163, 0xd333f6a4, 0x46e9408b, 0x27c2cef0, 0xfef577b4 };
    114          
    115          /* pow2exp[i] = pow(2, i*4/3) exponent */
    116          static const int pow2exp[8]  = { 14, 13, 11, 10, 9, 7, 6, 5 };
    117          
    118          /* pow2exp[i] = pow(2, i*4/3) fraction */
    119          static const int pow2frac[8] = {
    120          	0x6597fa94, 0x50a28be6, 0x7fffffff, 0x6597fa94, 
    121          	0x50a28be6, 0x7fffffff, 0x6597fa94, 0x50a28be6
    122          };
    123          
    124          /**************************************************************************************
    125           * Function:    DequantBlock
    126           *
    127           * Description: dequantize one block of transform coefficients (in-place)
    128           *
    129           * Inputs:      quantized transform coefficients, range = [0, 8191]
    130           *              number of samples to dequantize
    131           *              scalefactor for this block of data, range = [0, 256]
    132           *
    133           * Outputs:     dequantized transform coefficients in Q(FBITS_OUT_DQ_OFF)
    134           *
    135           * Return:      guard bit mask (OR of abs value of all dequantized coefs)
    136           *
    137           * Notes:       applies dequant formula y = pow(x, 4.0/3.0) * pow(2, (scale - 100)/4.0)
    138           *                * pow(2, FBITS_OUT_DQ_OFF)
    139           *              clips outputs to Q(FBITS_OUT_DQ_OFF)
    140           *              output has >= 1 guard bit
    141           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    142          static int DequantBlock(int *inbuf, int nSamps, int scale)
    143          {
   \                     DequantBlock:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
   \   00000004   1CD04DE2           SUB      SP,SP,#+28
   \   00000008   0180A0E1           MOV      R8,R1
    144          	int iSamp, scalef, scalei, x, y, gbMask, shift, tab4[4];
    145          	const int *tab16, *coef;
    146          
    147          	if (nSamps <= 0)
   \   0000000C   010058E3           CMP      R8,#+1
    148          		return 0;
   \   00000010   0000A0B3           MOVLT    R0,#+0
   \   00000014   A30000BA           BLT      ??DequantBlock_0
    149          
    150          	scale -= SF_OFFSET;	/* new range = [-100, 156] */
   \   00000018   640042E2           SUB      R0,R2,#+100
    151          
    152          	/* with two's complement numbers, scalei/scalef factorization works for pos and neg values of scale:
    153          	 *  [+4...+7] >> 2 = +1, [ 0...+3] >> 2 = 0, [-4...-1] >> 2 = -1, [-8...-5] >> 2 = -2 ...
    154          	 *  (-1 & 0x3) = 3, (-2 & 0x3) = 2, (-3 & 0x3) = 1, (0 & 0x3) = 0
    155          	 *
    156          	 * Example: 2^(-5/4) = 2^(-1) * 2^(-1/4) = 2^-2 * 2^(3/4)
    157          	 */
    158          	tab16 = pow43_14[scale & 0x3];
   \   0000001C   8C229FE5           LDR      R2,??DequantBlock_1  ;; pow14
   \   00000020   033000E2           AND      R3,R0,#0x3
   \   00000024   033382E0           ADD      R3,R2,R3, LSL #+6
   \   00000028   443F83E2           ADD      R3,R3,#+272
   \   0000002C   00308DE5           STR      R3,[SP, #+0]
    159          	scalef = pow14[scale & 0x3];
   \   00000030   033000E2           AND      R3,R0,#0x3
   \   00000034   033192E7           LDR      R3,[R2, +R3, LSL #+2]
   \   00000038   18308DE5           STR      R3,[SP, #+24]
    160          	scalei = (scale >> 2) + FBITS_OUT_DQ_OFF;
   \   0000003C   0530A0E3           MOV      R3,#+5
   \   00000040   400183E0           ADD      R0,R3,R0, ASR #+2
   \   00000044   04008DE5           STR      R0,[SP, #+4]
    161          
    162          	/* cache first 4 values:
    163          	 * tab16[j] = Q28 for j = [0,3]
    164          	 * tab4[x] = x^(4.0/3.0) * 2^(0.25*scale), Q(FBITS_OUT_DQ_OFF)
    165          	 */
    166          	shift = 28 - scalei;	
   \   00000048   1C3060E2           RSB      R3,R0,#+28
   \   0000004C   200053E3           CMP      R3,#+32
   \   00000050   060000BA           BLT      ??DequantBlock_2
    167          	if (shift > 31) {
    168          		tab4[0] = tab4[1] = tab4[2] = tab4[3] = 0;
   \   00000054   0000A0E3           MOV      R0,#+0
   \   00000058   14008DE5           STR      R0,[SP, #+20]
   \   0000005C   10008DE5           STR      R0,[SP, #+16]
   \   00000060   0C008DE5           STR      R0,[SP, #+12]
   \   00000064   0010A0E3           MOV      R1,#+0
   \   00000068   08108DE5           STR      R1,[SP, #+8]
   \   0000006C   200000EA           B        ??DequantBlock_3
    169          	} else if (shift <= 0) {
   \                     ??DequantBlock_2:
   \   00000070   010053E3           CMP      R3,#+1
   \   00000074   100000AA           BGE      ??DequantBlock_4
    170          		shift = -shift;
   \   00000078   003063E2           RSB      R3,R3,#+0
    171          		if (shift > 31)
   \   0000007C   200053E3           CMP      R3,#+32
    172          			shift = 31;
   \   00000080   1F30A0A3           MOVGE    R3,#+31
    173          		for (x = 0; x < 4; x++) {
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   040000EA           B        ??DequantBlock_5
    174          			y = tab16[x];
    175          			if (y > (0x3fffffff >> shift))
    176          				y = 0x3fffffff;		/* clip (rare), guarantees at least 1 gb */
    177          			else
    178          				y <<= shift;
    179          			tab4[x] = y;
   \                     ??DequantBlock_6:
   \   0000008C   08408DE2           ADD      R4,SP,#+8
   \   00000090   001184E7           STR      R1,[R4, +R0, LSL #+2]
   \   00000094   010080E2           ADD      R0,R0,#+1
   \   00000098   040050E3           CMP      R0,#+4
   \   0000009C   140000AA           BGE      ??DequantBlock_3
   \                     ??DequantBlock_5:
   \   000000A0   00109DE5           LDR      R1,[SP, #+0]
   \   000000A4   C044E0E3           MVN      R4,#-1073741824
   \   000000A8   001191E7           LDR      R1,[R1, +R0, LSL #+2]
   \   000000AC   540351E1           CMP      R1,R4, ASR R3
   \   000000B0   1113A0D1           LSLLE    R1,R1,R3
   \   000000B4   0410A0C1           MOVGT    R1,R4
   \   000000B8   F3FFFFEA           B        ??DequantBlock_6
    180          		}
    181          	} else {
    182          		tab4[0] = 0;
   \                     ??DequantBlock_4:
   \   000000BC   0010A0E3           MOV      R1,#+0
   \   000000C0   08108DE5           STR      R1,[SP, #+8]
    183          		tab4[1] = tab16[1] >> shift;
   \   000000C4   00109DE5           LDR      R1,[SP, #+0]
   \   000000C8   041091E5           LDR      R1,[R1, #+4]
   \   000000CC   5113A0E1           ASR      R1,R1,R3
   \   000000D0   0C108DE5           STR      R1,[SP, #+12]
    184          		tab4[2] = tab16[2] >> shift;
   \   000000D4   00109DE5           LDR      R1,[SP, #+0]
   \   000000D8   081091E5           LDR      R1,[R1, #+8]
   \   000000DC   5113A0E1           ASR      R1,R1,R3
   \   000000E0   10108DE5           STR      R1,[SP, #+16]
    185          		tab4[3] = tab16[3] >> shift;
   \   000000E4   00109DE5           LDR      R1,[SP, #+0]
   \   000000E8   0C1091E5           LDR      R1,[R1, #+12]
   \   000000EC   5113A0E1           ASR      R1,R1,R3
   \   000000F0   14108DE5           STR      R1,[SP, #+20]
    186          	}
    187          
    188          	gbMask = 0;
   \                     ??DequantBlock_3:
   \   000000F4   00E0A0E3           MOV      LR,#+0
    189          	do {
    190          		iSamp = *inbuf;
   \                     ??DequantBlock_7:
   \   000000F8   1C009DE5           LDR      R0,[SP, #+28]
   \   000000FC   00C090E5           LDR      R12,[R0, #+0]
   \   00000100   CC0FA0E1           ASR      R0,R12,#+31
    191          		x = FASTABS(iSamp);
   \   00000104   0C1020E0           EOR      R1,R0,R12
   \   00000108   000041E0           SUB      R0,R1,R0
    192          
    193          		if (x < 4) {
   \   0000010C   040050E3           CMP      R0,#+4
    194          			y = tab4[x];
   \   00000110   08108DB2           ADDLT    R1,SP,#+8
   \   00000114   001191B7           LDRLT    R1,[R1, +R0, LSL #+2]
   \   00000118   580000BA           BLT      ??DequantBlock_8
    195          		} else  {
    196          
    197          			if (x < 16) {
   \   0000011C   100050E3           CMP      R0,#+16
   \   00000120   040000AA           BGE      ??DequantBlock_9
    198          				/* result: y = Q25 (tab16 = Q25) */
    199          				y = tab16[x];
   \   00000124   00109DE5           LDR      R1,[SP, #+0]
   \   00000128   004191E7           LDR      R4,[R1, +R0, LSL #+2]
    200          				shift = 25 - scalei;
   \   0000012C   04009DE5           LDR      R0,[SP, #+4]
   \   00000130   193060E2           RSB      R3,R0,#+25
   \   00000134   440000EA           B        ??DequantBlock_10
    201          			} else if (x < 64) {
   \                     ??DequantBlock_9:
   \   00000138   18A09DE5           LDR      R10,[SP, #+24]
   \   0000013C   400050E3           CMP      R0,#+64
   \   00000140   CABFA0E1           ASR      R11,R10,#+31
   \   00000144   090000AA           BGE      ??DequantBlock_11
    202          				/* result: y = Q21 (pow43tab[j] = Q23, scalef = Q30) */
    203          				y = pow43[x-16];	
    204          				shift = 21 - scalei;
   \   00000148   04109DE5           LDR      R1,[SP, #+4]
    205          				y = MULSHIFT32(y, scalef);
   \   0000014C   000182E0           ADD      R0,R2,R0, LSL #+2
   \   00000150   100090E5           LDR      R0,[R0, #+16]
   \   00000154   153061E2           RSB      R3,R1,#+21
   \   00000158   C01FA0E1           ASR      R1,R0,#+31
   \   0000015C   904A85E0           UMULL    R4,R5,R0,R10
   \   00000160   905B25E0           MLA      R5,R0,R11,R5
   \   00000164   915A25E0           MLA      R5,R1,R10,R5
   \   00000168   0540A0E1           MOV      R4,R5
   \   0000016C   360000EA           B        ??DequantBlock_10
    206          			} else {
    207          				/* normalize to [0x40000000, 0x7fffffff]
    208          				 * input x = [64, 8191] = [64, 2^13-1]
    209          				 * ranges:
    210          				 *  shift = 7:   64 -  127
    211          				 *  shift = 6:  128 -  255
    212          				 *  shift = 5:  256 -  511
    213          				 *  shift = 4:  512 - 1023
    214          				 *  shift = 3: 1024 - 2047
    215          				 *  shift = 2: 2048 - 4095
    216          				 *  shift = 1: 4096 - 8191
    217          				 */
    218          				x <<= 17;
    219          				shift = 0;
    220          				if (x < 0x08000000)
    221          					x <<= 4, shift += 4;
    222          				if (x < 0x20000000)
    223          					x <<= 2, shift += 2;
    224          				if (x < 0x40000000)
    225          					x <<= 1, shift += 1;
    226          
    227          				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
   \                     ??DequantBlock_11:
   \   00000170   3C319FE5           LDR      R3,??DequantBlock_1+0x4  ;; 0x5a82799a
   \   00000174   8008A0E1           LSL      R0,R0,#+17
   \   00000178   0010A0E3           MOV      R1,#+0
   \   0000017C   800650E3           CMP      R0,#+134217728
   \   00000180   0002A0B1           LSLLT    R0,R0,#+4
   \   00000184   0410A0B3           MOVLT    R1,#+4
   \   00000188   800550E3           CMP      R0,#+536870912
   \   0000018C   0001A0B1           LSLLT    R0,R0,#+2
   \   00000190   021081B2           ADDLT    R1,R1,#+2
   \   00000194   400450E3           CMP      R0,#+1073741824
   \   00000198   8000A0B1           LSLLT    R0,R0,#+1
   \   0000019C   011081B2           ADDLT    R1,R1,#+1
   \   000001A0   030050E1           CMP      R0,R3
   \   000001A4   843F82B2           ADDLT    R3,R2,#+528
   \   000001A8   893F82A2           ADDGE    R3,R2,#+548
    228          
    229          				/* polynomial */
    230          				y = coef[0];
    231          				y = MULSHIFT32(y, x) + coef[1];
    232          				y = MULSHIFT32(y, x) + coef[2];
    233          				y = MULSHIFT32(y, x) + coef[3];
    234          				y = MULSHIFT32(y, x) + coef[4];
    235          				y = MULSHIFT32(y, pow2frac[shift]) << 3;
    236          
    237          				/* fractional scale 
    238          				 * result: y = Q21 (pow43tab[j] = Q23, scalef = Q30)
    239          				 */
    240          				y = MULSHIFT32(y, scalef);	/* now y is Q24 */
   \   000001AC   004093E5           LDR      R4,[R3, #+0]
   \   000001B0   019182E0           ADD      R9,R2,R1, LSL #+2
   \   000001B4   C01FA0E1           ASR      R1,R0,#+31
   \   000001B8   C45FA0E1           ASR      R5,R4,#+31
   \   000001BC   946087E0           UMULL    R6,R7,R4,R0
   \   000001C0   947127E0           MLA      R7,R4,R1,R7
   \   000001C4   044093E5           LDR      R4,[R3, #+4]
   \   000001C8   957027E0           MLA      R7,R5,R0,R7
   \   000001CC   074084E0           ADD      R4,R4,R7
   \   000001D0   C45FA0E1           ASR      R5,R4,#+31
   \   000001D4   946087E0           UMULL    R6,R7,R4,R0
   \   000001D8   947127E0           MLA      R7,R4,R1,R7
   \   000001DC   084093E5           LDR      R4,[R3, #+8]
   \   000001E0   957027E0           MLA      R7,R5,R0,R7
   \   000001E4   074084E0           ADD      R4,R4,R7
   \   000001E8   C45FA0E1           ASR      R5,R4,#+31
   \   000001EC   946087E0           UMULL    R6,R7,R4,R0
   \   000001F0   947127E0           MLA      R7,R4,R1,R7
   \   000001F4   0C4093E5           LDR      R4,[R3, #+12]
   \   000001F8   957027E0           MLA      R7,R5,R0,R7
   \   000001FC   074084E0           ADD      R4,R4,R7
   \   00000200   C45FA0E1           ASR      R5,R4,#+31
   \   00000204   946087E0           UMULL    R6,R7,R4,R0
   \   00000208   947127E0           MLA      R7,R4,R1,R7
   \   0000020C   304099E5           LDR      R4,[R9, #+48]
   \   00000210   957027E0           MLA      R7,R5,R0,R7
   \   00000214   100093E5           LDR      R0,[R3, #+16]
   \   00000218   073080E0           ADD      R3,R0,R7
   \   0000021C   9304C1E0           SMULL    R0,R1,R3,R4
   \   00000220   0100A0E1           MOV      R0,R1
   \   00000224   8001A0E1           LSL      R0,R0,#+3
   \   00000228   C01FA0E1           ASR      R1,R0,#+31
   \   0000022C   904A85E0           UMULL    R4,R5,R0,R10
   \   00000230   905B25E0           MLA      R5,R0,R11,R5
    241          				shift = 24 - scalei - pow2exp[shift];
   \   00000234   04009DE5           LDR      R0,[SP, #+4]
   \   00000238   915A25E0           MLA      R5,R1,R10,R5
   \   0000023C   101099E5           LDR      R1,[R9, #+16]
   \   00000240   0540A0E1           MOV      R4,R5
   \   00000244   180060E2           RSB      R0,R0,#+24
   \   00000248   013040E0           SUB      R3,R0,R1
    242          			}
    243          
    244          			/* integer scale */
    245          			if (shift <= 0) {
   \                     ??DequantBlock_10:
   \   0000024C   010053E3           CMP      R3,#+1
   \   00000250   070000AA           BGE      ??DequantBlock_12
    246          				shift = -shift;
   \   00000254   003063E2           RSB      R3,R3,#+0
    247          				if (shift > 31)
   \   00000258   200053E3           CMP      R3,#+32
    248          					shift = 31;
   \   0000025C   1F30A0A3           MOVGE    R3,#+31
    249          
    250          				if (y > (0x3fffffff >> shift))
   \   00000260   C004E0E3           MVN      R0,#-1073741824
   \   00000264   500354E1           CMP      R4,R0, ASR R3
   \   00000268   1413A0D1           LSLLE    R1,R4,R3
    251          					y = 0x3fffffff;		/* clip (rare), guarantees at least 1 gb */
   \   0000026C   0010A0C1           MOVGT    R1,R0
   \   00000270   020000EA           B        ??DequantBlock_8
    252          				else
    253          					y <<= shift;
    254          			} else {
    255          				if (shift > 31)
   \                     ??DequantBlock_12:
   \   00000274   200053E3           CMP      R3,#+32
    256          					shift = 31;
   \   00000278   1F30A0A3           MOVGE    R3,#+31
    257          				y >>= shift;
   \   0000027C   5413A0E1           ASR      R1,R4,R3
    258          			}
    259          		}
    260          
    261          		/* sign and store (gbMask used to count GB's) */
    262          		gbMask |= y;
   \                     ??DequantBlock_8:
   \   00000280   0EE081E1           ORR      LR,R1,LR
    263          
    264          		/* apply sign */
    265          		iSamp >>= 31;
   \   00000284   CC0FA0E1           ASR      R0,R12,#+31
    266          		y ^= iSamp;
    267          		y -= iSamp;
    268          
    269          		*inbuf++ = y;
   \   00000288   011020E0           EOR      R1,R0,R1
   \   0000028C   000041E0           SUB      R0,R1,R0
   \   00000290   1C109DE5           LDR      R1,[SP, #+28]
    270          	} while (--nSamps);
   \   00000294   018058E2           SUBS     R8,R8,#+1
   \   00000298   ........           STR      R0,[R1], #+4
   \   0000029C   1C108DE5           STR      R1,[SP, #+28]
   \   000002A0   94FFFF1A           BNE      ??DequantBlock_7
    271          
    272          	return gbMask;
   \   000002A4   0E00A0E1           MOV      R0,LR
   \                     ??DequantBlock_0:
   \   000002A8   20D08DE2           ADD      SP,SP,#+32       ;; stack cleaning
   \   000002AC   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??DequantBlock_1:
   \   000002B0   ........           DC32     pow14
   \   000002B4   9A79825A           DC32     0x5a82799a
    273          }
    274          
    275          /**************************************************************************************
    276           * Function:    Dequantize
    277           *
    278           * Description: dequantize all transform coefficients for one channel
    279           *
    280           * Inputs:      valid AACDecInfo struct (including unpacked, quantized coefficients)
    281           *              index of current channel
    282           *
    283           * Outputs:     dequantized coefficients, including short-block deinterleaving
    284           *              flags indicating if intensity and/or PNS is active
    285           *              minimum guard bit count for dequantized coefficients
    286           *
    287           * Return:      0 if successful, error code (< 0) if error
    288           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    289          int aacDequantize(AACDecInfo *aacDecInfo, int ch)
    290          {
   \                     aacDequantize:
   \   00000000   F14F2DE9           PUSH     {R0,R4-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
    291          	int gp, cb, sfb, win, width, nSamps, gbMask;
    292          	int *coef;
    293          	const short *sfbTab;
    294          	unsigned char *sfbCodeBook;
    295          	short *scaleFactors;
    296          	PSInfoBase *psi;
    297          	ICSInfo *icsInfo;
    298          
    299          	/* validate pointers */
    300          	if (!aacDecInfo || !aacDecInfo->psInfoBase)
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   00009015           LDRNE    R0,[R0, #+0]
   \   00000010   00005013           CMPNE    R0,#+0
    301          		return ERR_AAC_NULL_POINTER;
   \   00000014   0100E003           MVNEQ    R0,#+1
   \   00000018   9200000A           BEQ      ??aacDequantize_0
    302          	psi = (PSInfoBase *)(aacDecInfo->psInfoBase);
    303          	icsInfo = (ch == 1 && psi->commonWin == 1) ? &(psi->icsInfo[0]) : &(psi->icsInfo[ch]);
   \   0000001C   010051E3           CMP      R1,#+1
   \   00000020   F0389005           LDREQ    R3,[R0, #+2288]
   \   00000024   7C20A0E3           MOV      R2,#+124
   \   00000028   01005303           CMPEQ    R3,#+1
   \   0000002C   3A30A013           MOVNE    R3,#+58
   \   00000030   93012410           MLANE    R4,R3,R1,R0
    304          		
    305          	if (icsInfo->winSequence == 2) {
   \   00000034   783890E5           LDR      R3,[R0, #+2168]
   \   00000038   802E82E3           ORR      R2,R2,#0x800
   \   0000003C   00608200           ADDEQ    R6,R2,R0
   \   00000040   04608210           ADDNE    R6,R2,R4
   \   00000044   0120D6E5           LDRB     R2,[R6, #+1]
   \   00000048   020052E3           CMP      R2,#+2
   \   0000004C   0600001A           BNE      ??aacDequantize_1
    306          		sfbTab = sfBandTabShort + sfBandTabShortOffset[psi->sampRateIdx];
   \   00000050   18429FE5           LDR      R4,??aacDequantize_2  ;; raac_sfBandTabShortOffset
   \   00000054   033194E7           LDR      R3,[R4, +R3, LSL #+2]
   \   00000058   14429FE5           LDR      R4,??aacDequantize_2+0x4  ;; raac_sfBandTabShort
   \   0000005C   833084E0           ADD      R3,R4,R3, LSL #+1
   \   00000060   00308DE5           STR      R3,[SP, #+0]
    307          		nSamps = NSAMPS_SHORT;
   \   00000064   8030A0E3           MOV      R3,#+128
   \   00000068   050000EA           B        ??aacDequantize_3
    308          	} else {
    309          		sfbTab = sfBandTabLong + sfBandTabLongOffset[psi->sampRateIdx];
   \                     ??aacDequantize_1:
   \   0000006C   04429FE5           LDR      R4,??aacDequantize_2+0x8  ;; raac_sfBandTabLongOffset
   \   00000070   033194E7           LDR      R3,[R4, +R3, LSL #+2]
   \   00000074   00429FE5           LDR      R4,??aacDequantize_2+0xC  ;; raac_sfBandTabLong
   \   00000078   833084E0           ADD      R3,R4,R3, LSL #+1
   \   0000007C   00308DE5           STR      R3,[SP, #+0]
    310          		nSamps = NSAMPS_LONG;
   \   00000080   403EA0E3           MOV      R3,#+1024
    311          	}
    312          	coef = psi->coef[ch];
    313          	sfbCodeBook = psi->sfbCodeBook[ch];
   \                     ??aacDequantize_3:
   \   00000084   7840A0E3           MOV      R4,#+120
   \   00000088   940125E0           MLA      R5,R4,R1,R0
   \   0000008C   0C308DE5           STR      R3,[SP, #+12]
   \   00000090   4820A0E3           MOV      R2,#+72
   \   00000094   402D82E3           ORR      R2,R2,#0x1000
   \   00000098   013680E0           ADD      R3,R0,R1, LSL #+12
   \   0000009C   037082E0           ADD      R7,R2,R3
   \   000000A0   D430A0E3           MOV      R3,#+212
   \   000000A4   A03E83E3           ORR      R3,R3,#0xA00
   \   000000A8   053083E0           ADD      R3,R3,R5
    314          	scaleFactors = psi->scaleFactors[ch];
   \   000000AC   F040A0E3           MOV      R4,#+240
   \   000000B0   940125E0           MLA      R5,R4,R1,R0
   \   000000B4   04308DE5           STR      R3,[SP, #+4]
   \   000000B8   F430A0E3           MOV      R3,#+244
   \   000000BC   803E83E3           ORR      R3,R3,#0x800
   \   000000C0   053083E0           ADD      R3,R3,R5
   \   000000C4   08308DE5           STR      R3,[SP, #+8]
    315          
    316          	psi->intensityUsed[ch] = 0;
   \   000000C8   472E42E2           SUB      R2,R2,#+1136
   \   000000CC   010180E0           ADD      R0,R0,R1, LSL #+2
   \   000000D0   005082E0           ADD      R5,R2,R0
   \   000000D4   0000A0E3           MOV      R0,#+0
   \   000000D8   0C0085E5           STR      R0,[R5, #+12]
    317          	psi->pnsUsed[ch] = 0;
   \   000000DC   000085E5           STR      R0,[R5, #+0]
    318          	gbMask = 0;
    319          	for (gp = 0; gp < icsInfo->numWinGroup; gp++) {
   \   000000E0   0080A0E1           MOV      R8,R0
   \   000000E4   3100D6E5           LDRB     R0,[R6, #+49]
   \   000000E8   0040A0E3           MOV      R4,#+0
   \   000000EC   000050E3           CMP      R0,#+0
   \   000000F0   1100001A           BNE      ??aacDequantize_4
    320          		for (win = 0; win < icsInfo->winGroupLen[gp]; win++) {
    321          			for (sfb = 0; sfb < icsInfo->maxSFB; sfb++) {
    322          				/* dequantize one scalefactor band (not necessary if codebook is intensity or PNS) 
    323          				 * for zero codebook, still run dequantizer in case non-zero pulse data was added
    324          				 */
    325          				cb = (int)(sfbCodeBook[sfb]);
    326          				width = sfbTab[sfb+1] - sfbTab[sfb];
    327          				if (cb >= 0 && cb <= 11)
    328          					gbMask |= DequantBlock(coef, width, scaleFactors[sfb]);
    329          				else if (cb == 13)
    330          					psi->pnsUsed[ch] = 1;
    331          				else if (cb == 14 || cb == 15)
    332          					psi->intensityUsed[ch] = 1;	/* should only happen if ch == 1 */
    333          				coef += width;
    334          			}
    335          			coef += (nSamps - sfbTab[icsInfo->maxSFB]);
    336          		}
    337          		sfbCodeBook += icsInfo->maxSFB;
    338          		scaleFactors += icsInfo->maxSFB;
    339          	}
    340          	aacDecInfo->pnsUsed |= psi->pnsUsed[ch];	/* set flag if PNS used for any channel */
   \                     ??aacDequantize_5:
   \   000000F4   10009DE5           LDR      R0,[SP, #+16]
   \   000000F8   002095E5           LDR      R2,[R5, #+0]
   \   000000FC   581090E5           LDR      R1,[R0, #+88]
    341          
    342          	/* calculate number of guard bits in dequantized data */
    343          	psi->gbCurrent[ch] = CLZ(gbMask) - 1;
   \   00000100   000054E3           CMP      R4,#+0
   \   00000104   011082E1           ORR      R1,R2,R1
   \   00000108   581080E5           STR      R1,[R0, #+88]
   \   0000010C   4400001A           BNE      ??aacDequantize_6
   \   00000110   2000A0E3           MOV      R0,#+32
   \   00000114   500000EA           B        ??aacDequantize_7
   \                     ??aacDequantize_8:
   \   00000118   0310D6E5           LDRB     R1,[R6, #+3]
   \   0000011C   04209DE5           LDR      R2,[SP, #+4]
   \   00000120   018088E2           ADD      R8,R8,#+1
   \   00000124   021081E0           ADD      R1,R1,R2
   \   00000128   04108DE5           STR      R1,[SP, #+4]
   \   0000012C   0310D6E5           LDRB     R1,[R6, #+3]
   \   00000130   08209DE5           LDR      R2,[SP, #+8]
   \   00000134   811082E0           ADD      R1,R2,R1, LSL #+1
   \   00000138   08108DE5           STR      R1,[SP, #+8]
   \                     ??aacDequantize_4:
   \   0000013C   3100D6E5           LDRB     R0,[R6, #+49]
   \   00000140   000058E1           CMP      R8,R0
   \   00000144   EAFFFFAA           BGE      ??aacDequantize_5
   \   00000148   060088E0           ADD      R0,R8,R6
   \   0000014C   3200D0E5           LDRB     R0,[R0, #+50]
   \   00000150   0090A0E3           MOV      R9,#+0
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   0800001A           BNE      ??aacDequantize_9
   \   0000015C   EDFFFFEA           B        ??aacDequantize_8
   \                     ??aacDequantize_10:
   \   00000160   0310D6E5           LDRB     R1,[R6, #+3]
   \   00000164   00209DE5           LDR      R2,[SP, #+0]
   \   00000168   0C009DE5           LDR      R0,[SP, #+12]
   \   0000016C   811082E0           ADD      R1,R2,R1, LSL #+1
   \   00000170   F010D1E1           LDRSH    R1,[R1, #+0]
   \   00000174   019089E2           ADD      R9,R9,#+1
   \   00000178   010040E0           SUB      R0,R0,R1
   \   0000017C   007187E0           ADD      R7,R7,R0, LSL #+2
   \                     ??aacDequantize_9:
   \   00000180   060088E0           ADD      R0,R8,R6
   \   00000184   3200D0E5           LDRB     R0,[R0, #+50]
   \   00000188   000059E1           CMP      R9,R0
   \   0000018C   E1FFFFAA           BGE      ??aacDequantize_8
   \   00000190   0300D6E5           LDRB     R0,[R6, #+3]
   \   00000194   00A0A0E3           MOV      R10,#+0
   \   00000198   000050E3           CMP      R0,#+0
   \   0000019C   0500001A           BNE      ??aacDequantize_11
   \   000001A0   EEFFFFEA           B        ??aacDequantize_10
   \                     ??aacDequantize_12:
   \   000001A4   0E0050E3           CMP      R0,#+14
   \   000001A8   0F005013           CMPNE    R0,#+15
   \   000001AC   0C108505           STREQ    R1,[R5, #+12]
   \                     ??aacDequantize_13:
   \   000001B0   0B7187E0           ADD      R7,R7,R11, LSL #+2
   \   000001B4   01A08AE2           ADD      R10,R10,#+1
   \                     ??aacDequantize_11:
   \   000001B8   0300D6E5           LDRB     R0,[R6, #+3]
   \   000001BC   00005AE1           CMP      R10,R0
   \   000001C0   E6FFFFAA           BGE      ??aacDequantize_10
   \   000001C4   04009DE5           LDR      R0,[SP, #+4]
   \   000001C8   00109DE5           LDR      R1,[SP, #+0]
   \   000001CC   0000DAE7           LDRB     R0,[R10, +R0]
   \   000001D0   8A1081E0           ADD      R1,R1,R10, LSL #+1
   \   000001D4   F220D1E1           LDRSH    R2,[R1, #+2]
   \   000001D8   F010D1E1           LDRSH    R1,[R1, #+0]
   \   000001DC   000050E3           CMP      R0,#+0
   \   000001E0   01B042E0           SUB      R11,R2,R1
   \   000001E4   0900004A           BMI      ??aacDequantize_14
   \   000001E8   0C0050E3           CMP      R0,#+12
   \   000001EC   070000AA           BGE      ??aacDequantize_14
   \   000001F0   08009DE5           LDR      R0,[SP, #+8]
   \   000001F4   0B10A0E1           MOV      R1,R11
   \   000001F8   8A0080E0           ADD      R0,R0,R10, LSL #+1
   \   000001FC   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000200   0700A0E1           MOV      R0,R7
   \   00000204   ........           BL       DequantBlock
   \   00000208   044080E1           ORR      R4,R0,R4
   \   0000020C   E7FFFFEA           B        ??aacDequantize_13
   \                     ??aacDequantize_14:
   \   00000210   0110A0E3           MOV      R1,#+1
   \   00000214   0D0050E3           CMP      R0,#+13
   \   00000218   E1FFFF1A           BNE      ??aacDequantize_12
   \   0000021C   001085E5           STR      R1,[R5, #+0]
   \   00000220   E2FFFFEA           B        ??aacDequantize_13
   \                     ??aacDequantize_6:
   \   00000224   0100A0E3           MOV      R0,#+1
   \   00000228   2418B0E1           LSRS     R1,R4,#+16
   \   0000022C   1100A003           MOVEQ    R0,#+17
   \   00000230   0448A001           LSLEQ    R4,R4,#+16
   \   00000234   241CB0E1           LSRS     R1,R4,#+24
   \   00000238   08008002           ADDEQ    R0,R0,#+8
   \   0000023C   0444A001           LSLEQ    R4,R4,#+8
   \   00000240   241EB0E1           LSRS     R1,R4,#+28
   \   00000244   04008002           ADDEQ    R0,R0,#+4
   \   00000248   0442A001           LSLEQ    R4,R4,#+4
   \   0000024C   241FB0E1           LSRS     R1,R4,#+30
   \   00000250   02008002           ADDEQ    R0,R0,#+2
   \   00000254   0441A001           LSLEQ    R4,R4,#+2
   \   00000258   A40F40E0           SUB      R0,R0,R4, LSR #+31
   \                     ??aacDequantize_7:
   \   0000025C   010040E2           SUB      R0,R0,#+1
   \   00000260   680485E5           STR      R0,[R5, #+1128]
    344          
    345          	return ERR_AAC_NONE;
   \   00000264   0000A0E3           MOV      R0,#+0
   \                     ??aacDequantize_0:
   \   00000268   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   0000026C   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??aacDequantize_2:
   \   00000270   ........           DC32     raac_sfBandTabShortOffset
   \   00000274   ........           DC32     raac_sfBandTabShort
   \   00000278   ........           DC32     raac_sfBandTabLongOffset
   \   0000027C   ........           DC32     raac_sfBandTabLong
    346          }
    347          
    348          /**************************************************************************************
    349           * Function:    DeinterleaveShortBlocks
    350           *
    351           * Description: deinterleave transform coefficients in short blocks for one channel
    352           *
    353           * Inputs:      valid AACDecInfo struct (including unpacked, quantized coefficients)
    354           *              index of current channel
    355           *
    356           * Outputs:     deinterleaved coefficients (window groups into 8 separate windows)
    357           *
    358           * Return:      0 if successful, error code (< 0) if error
    359           *
    360           * Notes:       only necessary if deinterleaving not part of Huffman decoding
    361           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    362          int DeinterleaveShortBlocks(AACDecInfo *aacDecInfo, int ch)
    363          {
    364          	/* not used for this implementation - short block deinterleaving performed during Huffman decoding */
    365          	return ERR_AAC_NONE;
   \                     raac_DeinterleaveShortBlocks:
   \   00000000   0000A0E3           MOV      R0,#+0
   \   00000004   1EFF2FE1           BX       LR               ;; return
    366          }

   Maximum stack usage in bytes:

     Function                     CSTACK
     --------                     ------
     DequantBlock                    68
     aacDequantize                   56
     raac_DeinterleaveShortBlocks     0


   Segment part sizes:

     Function/Label               Bytes
     --------------               -----
     pow14                         568
     DequantBlock                  696
     aacDequantize                 640
     raac_DeinterleaveShortBlocks    8
      Others                        12

 
 1 356 bytes in segment CODE
   568 bytes in segment DATA_C
 
 1 344 bytes of CODE  memory (+ 12 bytes shared)
   568 bytes of CONST memory

Errors: none
Warnings: none
