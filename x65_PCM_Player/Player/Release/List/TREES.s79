//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   14/Feb/2012  15:36:00 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\zlib\TRE /
//                       ES.C                                                /
//    Command line    =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\zlib\TRE /
//                       ES.C -D NDEBUG -lC D:\SVN\SieELF\SieELF\x65_PCM_Pla /
//                       yer\Player\Release\List\ -lA                        /
//                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player\Player /
//                       \Release\Obj\ -s9 --cpu_mode arm --endian little    /
//                       --cpu ARM926EJ-S --stack_align 4 --interwork -e     /
//                       --fpu None --dlib_config "D:\Program                /
//                       Files\IAR\Embedded Workbench 4.0                    /
//                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude      /
//                       swilib.h -I "D:\Program Files\IAR\Embedded          /
//                       Workbench 4.0 Evaluation\ARM\INC\"                  /
//                       --inline_threshold=16                               /
//    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\TREES.s79                                      /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME TREES

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        PUBWEAK `?*?DATA_ID`
??DataTable0 EQU 0
??DataTable2 EQU 0
        MULTWEAK ??_tr_align??rT
        MULTWEAK ??_tr_flush_block??rT
        MULTWEAK ??_tr_init??rT
        MULTWEAK ??_tr_stored_block??rT
        MULTWEAK ??_tr_tally??rT
        PUBWEAK ?init?tab?DATA_I
        PUBLIC _dist_code
        PUBLIC _length_code
        PUBLIC _tr_align
        FUNCTION _tr_align,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC _tr_flush_block
        FUNCTION _tr_flush_block,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC _tr_init
        FUNCTION _tr_init,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC _tr_stored_block
        FUNCTION _tr_stored_block,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC _tr_tally
        FUNCTION _tr_tally,0203H
        LOCFRAME CSTACK, 8, STACK
        FUNCTION bi_flush,0203H
        FUNCTION bi_windup,0203H
        FUNCTION build_bl_tree,0203H
        LOCFRAME CSTACK, 12, STACK
        FUNCTION build_tree,0203H
        LOCFRAME CSTACK, 36, STACK
        FUNCTION compress_block,0203H
        LOCFRAME CSTACK, 36, STACK
        FUNCTION copy_block,0203H
        LOCFRAME CSTACK, 20, STACK
        FUNCTION gen_bitlen,0203H
        LOCFRAME CSTACK, 44, STACK
        FUNCTION gen_codes,0203H
        LOCFRAME CSTACK, 48, STACK
        FUNCTION init_block,0203H
        FUNCTION pqdownheap,0203H
        LOCFRAME CSTACK, 28, STACK
        FUNCTION scan_tree,0203H
        LOCFRAME CSTACK, 20, STACK
        FUNCTION send_all_trees,0203H
        LOCFRAME CSTACK, 24, STACK
        FUNCTION send_tree,0203H
        LOCFRAME CSTACK, 40, STACK
        FUNCTION set_data_type,0203H
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
_tr_align           SYMBOL "_tr_align"
??_tr_align??rT     SYMBOL "??rT", _tr_align
_tr_flush_block     SYMBOL "_tr_flush_block"
??_tr_flush_block??rT SYMBOL "??rT", _tr_flush_block
_tr_init            SYMBOL "_tr_init"
??_tr_init??rT      SYMBOL "??rT", _tr_init
_tr_stored_block    SYMBOL "_tr_stored_block"
??_tr_stored_block??rT SYMBOL "??rT", _tr_stored_block
_tr_tally           SYMBOL "_tr_tally"
??_tr_tally??rT     SYMBOL "??rT", _tr_tally

// D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\zlib\TREES.C
//    1 /* trees.c -- output deflated data using Huffman coding
//    2  * Copyright (C) 1995-2005 Jean-loup Gailly
//    3  * For conditions of distribution and use, see copyright notice in zlib.h
//    4  */
//    5 
//    6 /*
//    7  *  ALGORITHM
//    8  *
//    9  *      The "deflation" process uses several Huffman trees. The more
//   10  *      common source values are represented by shorter bit sequences.
//   11  *
//   12  *      Each code tree is stored in a compressed form which is itself
//   13  * a Huffman encoding of the lengths of all the code strings (in
//   14  * ascending order by source values).  The actual code strings are
//   15  * reconstructed from the lengths in the inflate process, as described
//   16  * in the deflate specification.
//   17  *
//   18  *  REFERENCES
//   19  *
//   20  *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
//   21  *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
//   22  *
//   23  *      Storer, James A.
//   24  *          Data Compression:  Methods and Theory, pp. 49-50.
//   25  *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
//   26  *
//   27  *      Sedgewick, R.
//   28  *          Algorithms, p290.
//   29  *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
//   30  */
//   31 
//   32 /* @(#) $Id$ */
//   33 
//   34 /* #define GEN_TREES_H */
//   35 
//   36 #include "deflate.h"
//   37 
//   38 #ifdef DEBUG
//   39 //#  include <ctype.h>
//   40 #endif
//   41 
//   42 /* ===========================================================================
//   43  * Constants
//   44  */
//   45 
//   46 #define MAX_BL_BITS 7
//   47 /* Bit length codes must not exceed MAX_BL_BITS bits */
//   48 
//   49 #define END_BLOCK 256
//   50 /* end of block literal code */
//   51 
//   52 #define REP_3_6      16
//   53 /* repeat previous bit length 3-6 times (2 bits of repeat count) */
//   54 
//   55 #define REPZ_3_10    17
//   56 /* repeat a zero length 3-10 times  (3 bits of repeat count) */
//   57 
//   58 #define REPZ_11_138  18
//   59 /* repeat a zero length 11-138 times  (7 bits of repeat count) */
//   60 

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//   61 local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
//   62    = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
//   63 
//   64 local const int extra_dbits[D_CODES] /* extra bits for each distance code */
//   65    = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
//   66 
//   67 local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
//   68    = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
//   69 
//   70 local const uch bl_order[BL_CODES]
//   71    = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
//   72 /* The lengths of the bit length codes are sent in order of decreasing
//   73  * probability, to avoid transmitting the lengths for unused bit length codes.
//   74  */
//   75 
//   76 #define Buf_size (8 * 2*sizeof(char))
//   77 /* Number of bits used within bi_buf. (bi_buf might be implemented on
//   78  * more than 16 bits on some systems.)
//   79  */
//   80 
//   81 /* ===========================================================================
//   82  * Local data. These are initialized only once.
//   83  */
//   84 
//   85 #define DIST_CODE_LEN  512 /* see definition of array dist_code below */
//   86 
//   87 #if defined(GEN_TREES_H) || !defined(STDC)
//   88 /* non ANSI compilers may not accept trees.h */
//   89 
//   90 local ct_data static_ltree[L_CODES+2];
//   91 /* The static literal tree. Since the bit lengths are imposed, there is no
//   92  * need for the L_CODES extra codes used during heap construction. However
//   93  * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
//   94  * below).
//   95  */
//   96 
//   97 local ct_data static_dtree[D_CODES];
//   98 /* The static distance tree. (Actually a trivial tree since all codes use
//   99  * 5 bits.)
//  100  */
//  101 
//  102 uch _dist_code[DIST_CODE_LEN];
//  103 /* Distance codes. The first 256 values correspond to the distances
//  104  * 3 .. 258, the last 256 values correspond to the top 8 bits of
//  105  * the 15 bit distances.
//  106  */
//  107 
//  108 uch _length_code[MAX_MATCH-MIN_MATCH+1];
//  109 /* length code for each normalized match length (0 == MIN_MATCH) */
//  110 
//  111 local int base_length[LENGTH_CODES];
//  112 /* First normalized length for each code (0 = MIN_MATCH) */
//  113 
//  114 local int base_dist[D_CODES];
//  115 /* First normalized distance for each code (0 = distance of 1) */
//  116 
//  117 #else
//  118 #  include "trees.h"
// unsigned char const __data _dist_code[512]
_dist_code:
        DATA
        DC8 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8
        DC8 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10
        DC8 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11
        DC8 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12
        DC8 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12
        DC8 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13
        DC8 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13
        DC8 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14
        DC8 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14
        DC8 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14
        DC8 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15
        DC8 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15
        DC8 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15
        DC8 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15
        DC8 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19
        DC8 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22
        DC8 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24
        DC8 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25
        DC8 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26
        DC8 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26
        DC8 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27
        DC8 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27
        DC8 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28
        DC8 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28
        DC8 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28
        DC8 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29
        DC8 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
        DC8 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
        DC8 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
        DC8 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
extra_lbits:
        DC32 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4
        DC32 4, 4, 5, 5, 5, 5, 0
extra_dbits:
        DC32 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9
        DC32 10, 10, 11, 11, 12, 12, 13, 13
        DC32 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48
        DC32 56, 64, 80, 96, 112, 128, 160, 192, 224, 0
        DC32 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256
        DC32 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288
        DC32 16384, 24576
// unsigned char const __data _length_code[256]
_length_code:
        DC8 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12
        DC8 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16
        DC8 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18
        DC8 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20
        DC8 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21
        DC8 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22
        DC8 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23
        DC8 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
        DC8 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
        DC8 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25
        DC8 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25
        DC8 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26
        DC8 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26
        DC8 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27
        DC8 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28

        RSEG DATA_C:CONST:SORT:NOROOT(2)
extra_blbits:
        DATA
        DC32 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7

        RSEG DATA_C:CONST:SORT:NOROOT(2)
bl_order:
        DATA
        DC8 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
// static struct ct_data_s const __data static_ltree[288]
static_ltree:
        DATA
        DC16 12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8
        DC16 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8, 130, 8
        DC16 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8
        DC16 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202
        DC16 8, 42, 8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58
        DC16 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166
        DC16 8, 102, 8, 230, 8, 22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8
        DC16 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110
        DC16 8, 238, 8, 30, 8, 158, 8, 94, 8, 222, 8, 62, 8, 190, 8, 126, 8
        DC16 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8
        DC16 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113, 8, 241, 8, 9, 8
        DC16 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153
        DC16 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8, 69
        DC16 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8
        DC16 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205
        DC16 8, 45, 8, 173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61
        DC16 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9
        DC16 339, 9, 211, 9, 467, 9, 51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371
        DC16 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9
        DC16 203, 9, 459, 9, 43, 9, 299, 9, 171, 9, 427, 9, 107, 9, 363, 9, 235
        DC16 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9
        DC16 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379, 9, 251, 9, 507
        DC16 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39
        DC16 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23, 9
        DC16 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311
        DC16 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9
        DC16 143, 9, 399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175
        DC16 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9
        DC16 415, 9, 95, 9, 351, 9, 223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447
        DC16 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16
        DC16 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7, 40, 7, 104, 7, 24, 7, 88, 7
        DC16 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7
        DC16 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8, 99, 8, 227, 8
// static struct ct_data_s const __data static_dtree[30]
static_dtree:
        DC16 0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5
        DC16 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5, 25, 5
        DC16 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5
//  119 #endif /* GEN_TREES_H */
//  120 
//  121 struct static_tree_desc_s {
//  122     const ct_data *static_tree;  /* static tree or NULL */
//  123     const intf *extra_bits;      /* extra bits for each code or NULL */
//  124     int     extra_base;          /* base index for extra_bits */
//  125     int     elems;               /* max number of elements in the tree */
//  126     int     max_length;          /* max bit length for the codes */
//  127 };
//  128 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//  129 local static_tree_desc  static_l_desc =
static_l_desc:
        DS8 20
        REQUIRE `?<Initializer for static_l_desc>`
        DS8 20
        REQUIRE `?<Initializer for static_d_desc>`
        DS8 20
        REQUIRE `?<Initializer for static_bl_desc>`

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??_tr_init??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE _tr_init
//  130 {static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
//  131 
//  132 local static_tree_desc  static_d_desc =
//  133 {static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
//  134 
//  135 local static_tree_desc  static_bl_desc =
//  136 {(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
//  137 
//  138 /* ===========================================================================
//  139  * Local (static) routines in this file.
//  140  */
//  141 
//  142 local void tr_static_init OF((void));
//  143 local void init_block     OF((deflate_state *s));
//  144 local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
//  145 local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
//  146 local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
//  147 local void build_tree     OF((deflate_state *s, tree_desc *desc));
//  148 local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
//  149 local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
//  150 local int  build_bl_tree  OF((deflate_state *s));
//  151 local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
//  152                               int blcodes));
//  153 local void compress_block OF((deflate_state *s, ct_data *ltree,
//  154                               ct_data *dtree));
//  155 local void set_data_type  OF((deflate_state *s));
//  156 local unsigned bi_reverse OF((unsigned value, int length));
//  157 local void bi_windup      OF((deflate_state *s));
//  158 local void bi_flush       OF((deflate_state *s));
//  159 local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
//  160                               int header));
//  161 
//  162 #ifdef GEN_TREES_H
//  163 local void gen_trees_header OF((void));
//  164 #endif
//  165 
//  166 #ifndef DEBUG
//  167 #  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
//  168    /* Send a code of the given tree. c and tree must not have side effects */
//  169 
//  170 #else /* DEBUG */
//  171 #  define send_code(s, c, tree) \ 
//  172      { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \ 
//  173        send_bits(s, tree[c].Code, tree[c].Len); }
//  174 #endif
//  175 
//  176 /* ===========================================================================
//  177  * Output a short LSB first on the stream.
//  178  * IN assertion: there is enough room in pendingBuf.
//  179  */
//  180 #define put_short(s, w) { \ 
//  181     put_byte(s, (uch)((w) & 0xff)); \ 
//  182     put_byte(s, (uch)((ush)(w) >> 8)); \ 
//  183 }
//  184 
//  185 /* ===========================================================================
//  186  * Send a value on a given number of bits.
//  187  * IN assertion: length <= 16 and value fits in length bits.
//  188  */
//  189 #ifdef DEBUG
//  190 local void send_bits      OF((deflate_state *s, int value, int length));
//  191 
//  192 local void send_bits(s, value, length)
//  193     deflate_state *s;
//  194     int value;  /* value to send */
//  195     int length; /* number of bits */
//  196 {
//  197     Tracevv((stderr," l %2d v %4x ", length, value));
//  198     Assert(length > 0 && length <= 15, "invalid length");
//  199     s->bits_sent += (ulg)length;
//  200 
//  201     /* If not enough room in bi_buf, use (valid) bits from bi_buf and
//  202      * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
//  203      * unused bits in value.
//  204      */
//  205     if (s->bi_valid > (int)Buf_size - length) {
//  206         s->bi_buf |= (value << s->bi_valid);
//  207         put_short(s, s->bi_buf);
//  208         s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
//  209         s->bi_valid += length - Buf_size;
//  210     } else {
//  211         s->bi_buf |= value << s->bi_valid;
//  212         s->bi_valid += length;
//  213     }
//  214 }
//  215 #else /* !DEBUG */
//  216 
//  217 #define send_bits(s, value, length) \ 
//  218 { int len = length;\ 
//  219   if (s->bi_valid > (int)Buf_size - len) {\ 
//  220     int val = value;\ 
//  221     s->bi_buf |= (val << s->bi_valid);\ 
//  222     put_short(s, s->bi_buf);\ 
//  223     s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\ 
//  224     s->bi_valid += len - Buf_size;\ 
//  225   } else {\ 
//  226     s->bi_buf |= (value) << s->bi_valid;\ 
//  227     s->bi_valid += len;\ 
//  228   }\ 
//  229 }
//  230 #endif /* DEBUG */
//  231 
//  232 
//  233 /* the arguments must not have side effects */
//  234 
//  235 /* ===========================================================================
//  236  * Initialize the various 'constant' tables.
//  237  */
//  238 local void tr_static_init()
//  239 {
//  240 #if defined(GEN_TREES_H) || !defined(STDC)
//  241     static int static_init_done = 0;
//  242     int n;        /* iterates over tree elements */
//  243     int bits;     /* bit counter */
//  244     int length;   /* length value */
//  245     int code;     /* code value */
//  246     int dist;     /* distance index */
//  247     ush bl_count[MAX_BITS+1];
//  248     /* number of codes at each bit length for an optimal tree */
//  249 
//  250     if (static_init_done) return;
//  251 
//  252     /* For some embedded targets, global variables are not initialized: */
//  253     static_l_desc.static_tree = static_ltree;
//  254     static_l_desc.extra_bits = extra_lbits;
//  255     static_d_desc.static_tree = static_dtree;
//  256     static_d_desc.extra_bits = extra_dbits;
//  257     static_bl_desc.extra_bits = extra_blbits;
//  258 
//  259     /* Initialize the mapping length (0..255) -> length code (0..28) */
//  260     length = 0;
//  261     for (code = 0; code < LENGTH_CODES-1; code++) {
//  262         base_length[code] = length;
//  263         for (n = 0; n < (1<<extra_lbits[code]); n++) {
//  264             _length_code[length++] = (uch)code;
//  265         }
//  266     }
//  267     Assert (length == 256, "tr_static_init: length != 256");
//  268     /* Note that the length 255 (match length 258) can be represented
//  269      * in two different ways: code 284 + 5 bits or code 285, so we
//  270      * overwrite length_code[255] to use the best encoding:
//  271      */
//  272     _length_code[length-1] = (uch)code;
//  273 
//  274     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
//  275     dist = 0;
//  276     for (code = 0 ; code < 16; code++) {
//  277         base_dist[code] = dist;
//  278         for (n = 0; n < (1<<extra_dbits[code]); n++) {
//  279             _dist_code[dist++] = (uch)code;
//  280         }
//  281     }
//  282     Assert (dist == 256, "tr_static_init: dist != 256");
//  283     dist >>= 7; /* from now on, all distances are divided by 128 */
//  284     for ( ; code < D_CODES; code++) {
//  285         base_dist[code] = dist << 7;
//  286         for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
//  287             _dist_code[256 + dist++] = (uch)code;
//  288         }
//  289     }
//  290     Assert (dist == 256, "tr_static_init: 256+dist != 512");
//  291 
//  292     /* Construct the codes of the static literal tree */
//  293     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
//  294     n = 0;
//  295     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
//  296     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
//  297     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
//  298     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
//  299     /* Codes 286 and 287 do not exist, but we must include them in the
//  300      * tree construction to get a canonical Huffman tree (longest code
//  301      * all ones)
//  302      */
//  303     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
//  304 
//  305     /* The static distance tree is trivial: */
//  306     for (n = 0; n < D_CODES; n++) {
//  307         static_dtree[n].Len = 5;
//  308         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
//  309     }
//  310     static_init_done = 1;
//  311 
//  312 #  ifdef GEN_TREES_H
//  313     gen_trees_header();
//  314 #  endif
//  315 #endif /* defined(GEN_TREES_H) || !defined(STDC) */
//  316 }
//  317 
//  318 /* ===========================================================================
//  319  * Genererate the file trees.h describing the static trees.
//  320  */
//  321 #ifdef GEN_TREES_H
//  322 #  ifndef DEBUG
//  323 //#    include <stdio.h>
//  324 #  endif
//  325 
//  326 #  define SEPARATOR(i, last, width) \ 
//  327       ((i) == (last)? "\n};\n\n" :    \ 
//  328        ((i) % (width) == (width)-1 ? ",\n" : ", "))
//  329 
//  330 void gen_trees_header()
//  331 {
//  332     FILE *header = fopen("trees.h", "w");
//  333     int i;
//  334 
//  335     Assert (header != NULL, "Can't open trees.h");
//  336     fprintf(header,
//  337             "/* header created automatically with -DGEN_TREES_H */\n\n");
//  338 
//  339     fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
//  340     for (i = 0; i < L_CODES+2; i++) {
//  341         fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
//  342                 static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
//  343     }
//  344 
//  345     fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
//  346     for (i = 0; i < D_CODES; i++) {
//  347         fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
//  348                 static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
//  349     }
//  350 
//  351     fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
//  352     for (i = 0; i < DIST_CODE_LEN; i++) {
//  353         fprintf(header, "%2u%s", _dist_code[i],
//  354                 SEPARATOR(i, DIST_CODE_LEN-1, 20));
//  355     }
//  356 
//  357     fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
//  358     for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
//  359         fprintf(header, "%2u%s", _length_code[i],
//  360                 SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
//  361     }
//  362 
//  363     fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
//  364     for (i = 0; i < LENGTH_CODES; i++) {
//  365         fprintf(header, "%1u%s", base_length[i],
//  366                 SEPARATOR(i, LENGTH_CODES-1, 20));
//  367     }
//  368 
//  369     fprintf(header, "local const int base_dist[D_CODES] = {\n");
//  370     for (i = 0; i < D_CODES; i++) {
//  371         fprintf(header, "%5u%s", base_dist[i],
//  372                 SEPARATOR(i, D_CODES-1, 10));
//  373     }
//  374 
//  375     fclose(header);
//  376 }
//  377 #endif /* GEN_TREES_H */
//  378 
//  379 /* ===========================================================================
//  380  * Initialize the tree data structures for a new zlib stream.
//  381  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function _tr_init
        ARM
//  382 void _tr_init(s)
//  383     deflate_state *s;
//  384 {
_tr_init:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        MOV      R1,#+24
        ORR      R1,R1,#0xB00
        ADD      R1,R1,R0
        ADD      R2,R0,#+148
        STR      R2,[R1, #+0]
//  385     tr_static_init();
//  386 
//  387     s->l_desc.dyn_tree = s->dyn_ltree;
//  388     s->l_desc.stat_desc = &static_l_desc;
        LDR      R2,??_tr_init_0  ;; static_l_desc
//  389 
//  390     s->d_desc.dyn_tree = s->dyn_dtree;
        MOV      R3,#+136
        STR      R2,[R1, #+8]
        ORR      R3,R3,#0x900
        ADD      R3,R3,R0
        STR      R3,[R1, #+12]
//  391     s->d_desc.stat_desc = &static_d_desc;
        ADD      R3,R2,#+20
        STR      R3,[R1, #+20]
//  392 
//  393     s->bl_desc.dyn_tree = s->bl_tree;
        MOV      R3,#+124
        ORR      R3,R3,#0xA00
        ADD      R3,R3,R0
        STR      R3,[R1, #+24]
//  394     s->bl_desc.stat_desc = &static_bl_desc;
        ADD      R2,R2,#+40
        STR      R2,[R1, #+32]
        MOV      R2,#+184
        ORR      R2,R2,#0x1600
        ADD      R2,R2,R0
        MOV      R3,#+0
        STRH     R3,[R2, #+0]
//  395 
//  396     s->bi_buf = 0;
//  397     s->bi_valid = 0;
        STR      R3,[R2, #+4]
//  398     s->last_eob_len = 8; /* enough lookahead for inflate */
        MOV      R2,#+8
        STR      R2,[R1, #+2972]
//  399 #ifdef DEBUG
//  400     s->compressed_len = 0L;
//  401     s->bits_sent = 0L;
//  402 #endif
//  403 
//  404     /* Initialize the first block of the first file: */
//  405     init_block(s);
        BL       init_block
//  406 }
        POP      {PC}             ;; return
        DATA
??_tr_init_0:
        DC32     static_l_desc
        CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??init_block??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE init_block
//  407 
//  408 /* ===========================================================================
//  409  * Initialize a new block.
//  410  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function init_block
        ARM
//  411 local void init_block(s)
//  412     deflate_state *s;
//  413 {
//  414     int n; /* iterates over tree elements */
//  415 
//  416     /* Initialize the trees. */
//  417     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
init_block:
        MOV      R2,#+0
        MOV      R3,#+30
        ORR      R3,R3,#0x100
        MOV      R1,#+0
??init_block_0:
        ADD      R12,R0,R2, LSL #+2
        STRH     R1,[R12, #+148]
        ADD      R2,R2,#+1
        CMP      R2,R3
        BLT      ??init_block_0
//  418     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
        MOV      R2,#+0
        MOV      R3,#+136
        ORR      R3,R3,#0x900
??init_block_1:
        ADD      R12,R0,R2, LSL #+2
        STRH     R1,[R3, +R12]
        ADD      R2,R2,#+1
        CMP      R2,#+30
        BLT      ??init_block_1
//  419     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
        MOV      R2,#+0
        ADD      R3,R3,#+244
??init_block_2:
        ADD      R12,R0,R2, LSL #+2
        STRH     R1,[R3, +R12]
        ADD      R2,R2,#+1
        CMP      R2,#+19
        BLT      ??init_block_2
//  420 
//  421     s->dyn_ltree[END_BLOCK].Freq = 1;
        MOV      R2,#+148
        ORR      R2,R2,#0x400
        MOV      R3,#+1
        STRH     R3,[R2, +R0]
        MOV      R2,#+160
        ORR      R2,R2,#0x1600
        ADD      R0,R2,R0
        STR      R1,[R0, #+12]
        MOV      R2,#+0
        STR      R2,[R0, #+8]
//  422     s->opt_len = s->static_len = 0L;
//  423     s->last_lit = s->matches = 0;
        STR      R1,[R0, #+16]
        STR      R1,[R0, #+0]
//  424 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??pqdownheap??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE pqdownheap
//  425 
//  426 #define SMALLEST 1
//  427 /* Index within the heap array of least frequent node in the Huffman tree */
//  428 
//  429 
//  430 /* ===========================================================================
//  431  * Remove the smallest element from the heap and recreate the heap with
//  432  * one less element. Updates heap and heap_len.
//  433  */
//  434 #define pqremove(s, tree, top) \ 
//  435 {\ 
//  436     top = s->heap[SMALLEST]; \ 
//  437     s->heap[SMALLEST] = s->heap[s->heap_len--]; \ 
//  438     pqdownheap(s, tree, SMALLEST); \ 
//  439 }
//  440 
//  441 /* ===========================================================================
//  442  * Compares to subtrees, using the tree depth as tie breaker when
//  443  * the subtrees have equal frequency. This minimizes the worst case length.
//  444  */
//  445 #define smaller(tree, n, m, depth) \ 
//  446    (tree[n].Freq < tree[m].Freq || \ 
//  447    (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
//  448 
//  449 /* ===========================================================================
//  450  * Restore the heap property by moving down the tree starting at node k,
//  451  * exchanging a node with the smallest of its two sons if necessary, stopping
//  452  * when the heap property is re-established (each father smaller than its
//  453  * two sons).
//  454  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function pqdownheap
        ARM
//  455 local void pqdownheap(s, tree, k)
//  456     deflate_state *s;
//  457     ct_data *tree;  /* the tree to restore */
//  458     int k;               /* node to move down */
//  459 {
pqdownheap:
        PUSH     {R4-R10}
        CFI R10 Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
//  460     int v = s->heap[k];
        ADD      R3,R0,R2, LSL #+2
        LDR      R3,[R3, #+2908]
//  461     int j = k << 1;  /* left son of k */
        LSL      R12,R2,#+1
        MOV      R4,#+80
        ORR      R4,R4,#0x1400
        ADD      R4,R4,R0
        B        ??pqdownheap_0
//  462     while (j <= s->heap_len) {
//  463         /* Set j to the smallest of the two sons: */
//  464         if (j < s->heap_len &&
//  465             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
//  466             j++;
//  467         }
//  468         /* Exit if v is smaller than both sons */
//  469         if (smaller(tree, v, s->heap[j], s->depth)) break;
//  470 
//  471         /* Exchange v with the smallest son */
//  472         s->heap[k] = s->heap[j];  k = j;
??pqdownheap_1:
        LDR      R5,[R6, #+2908]
        STR      R5,[R2, #+2908]
        MOV      R2,R12
//  473 
//  474         /* And continue down the tree, setting j to the left son of k */
//  475         j <<= 1;
        LSL      R12,R12,#+1
??pqdownheap_0:
        LDR      R5,[R4, #+0]
        ADD      R2,R0,R2, LSL #+2
        CMP      R5,R12
        BLT      ??pqdownheap_2
        LDR      R6,[R4, #+0]
        MOV      R5,#+88
        ORR      R5,R5,#0x1400
        CMP      R12,R6
        BGE      ??pqdownheap_3
        ADD      R6,R12,#+1
        ADD      R7,R0,R6, LSL #+2
        LDR      R9,[R7, #+2908]
        ADD      R8,R0,R12, LSL #+2
        LDR      R10,[R8, #+2908]
        ADD      R9,R1,R9, LSL #+2
        LDRH     R9,[R9, #+0]
        ADD      R10,R1,R10, LSL #+2
        LDRH     R10,[R10, #+0]
        CMP      R9,R10
        BCC      ??pqdownheap_4
        LDR      R9,[R7, #+2908]
        LDR      R10,[R8, #+2908]
        ADD      R9,R1,R9, LSL #+2
        LDRH     R9,[R9, #+0]
        ADD      R10,R1,R10, LSL #+2
        LDRH     R10,[R10, #+0]
        CMP      R9,R10
        BNE      ??pqdownheap_3
        LDR      R8,[R8, #+2908]
        LDR      R7,[R7, #+2908]
        ADD      R8,R8,R0
        LDRB     R8,[R5, +R8]
        ADD      R7,R7,R0
        LDRB     R7,[R5, +R7]
        CMP      R8,R7
        BCC      ??pqdownheap_3
??pqdownheap_4:
        MOV      R12,R6
??pqdownheap_3:
        ADD      R6,R0,R12, LSL #+2
        LDR      R9,[R6, #+2908]
        ADD      R7,R1,R3, LSL #+2
        LDRH     R8,[R7, #+0]
        ADD      R9,R1,R9, LSL #+2
        LDRH     R9,[R9, #+0]
        CMP      R8,R9
        BCC      ??pqdownheap_2
        BNE      ??pqdownheap_1
        LDR      R7,[R6, #+2908]
        ADD      R8,R3,R0
        ADD      R7,R7,R0
        LDRB     R7,[R5, +R7]
        LDRB     R5,[R5, +R8]
        CMP      R7,R5
        BCC      ??pqdownheap_1
//  476     }
//  477     s->heap[k] = v;
??pqdownheap_2:
        STR      R3,[R2, #+2908]
//  478 }
        POP      {R4-R10}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??gen_bitlen??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE gen_bitlen
//  479 
//  480 /* ===========================================================================
//  481  * Compute the optimal bit lengths for a tree and update the total bit length
//  482  * for the current block.
//  483  * IN assertion: the fields freq and dad are set, heap[heap_max] and
//  484  *    above are the tree nodes sorted by increasing frequency.
//  485  * OUT assertions: the field len is set to the optimal bit length, the
//  486  *     array bl_count contains the frequencies for each bit length.
//  487  *     The length opt_len is updated; static_len is also updated if stree is
//  488  *     not null.
//  489  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function gen_bitlen
        ARM
//  490 local void gen_bitlen(s, desc)
//  491     deflate_state *s;
//  492     tree_desc *desc;    /* the tree descriptor */
//  493 {
gen_bitlen:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+8
        CFI CFA R13+44
        MOV      R2,R0
        MOV      R0,R1
//  494     ct_data *tree        = desc->dyn_tree;
        LDR      R1,[R0, #+0]
//  495     int max_code         = desc->max_code;
        LDR      R3,[R0, #+4]
//  496     const ct_data *stree = desc->stat_desc->static_tree;
        LDR      R0,[R0, #+8]
//  497     const intf *extra    = desc->stat_desc->extra_bits;
//  498     int base             = desc->stat_desc->extra_base;
//  499     int max_length       = desc->stat_desc->max_length;
//  500     int h;              /* heap index */
//  501     int n, m;           /* iterate over the tree elements */
//  502     int bits;           /* bit length */
//  503     int xbits;          /* extra bits */
//  504     ush f;              /* frequency */
//  505     int overflow = 0;   /* number of elements with bit length too large */
        MOV      R10,#+0
        LDR      R5,[R0, #+0]
//  506 
//  507     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
        MOV      R9,#+0
        STR      R5,[SP, #+0]
        LDR      R5,[R0, #+4]
        STR      R5,[SP, #+4]
        LDR      R12,[R0, #+8]
        LDR      R4,[R0, #+16]
        MOV      R0,R9
        MOV      R5,#+60
        ORR      R5,R5,#0xB00
??gen_bitlen_0:
        ADD      R6,R2,R9, LSL #+1
        STRH     R0,[R5, +R6]
        ADD      R9,R9,#+1
        CMP      R9,#+16
        BLT      ??gen_bitlen_0
        MOV      R6,#+84
        ORR      R6,R6,#0x1400
        ADD      R6,R6,R2
        LDR      R7,[R6, #+0]
        ADD      R7,R2,R7, LSL #+2
        LDR      R7,[R7, #+2908]
        ADD      R7,R1,R7, LSL #+2
        STRH     R0,[R7, #+2]
//  508 
//  509     /* In a first pass, compute the optimal bit lengths (which may
//  510      * overflow in the case of the bit length tree).
//  511      */
//  512     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
//  513 
//  514     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        LDR      R0,[R6, #+0]
        ADD      R7,R0,#+1
        MOV      R0,#+61
        ORR      R0,R0,#0x200
        CMP      R7,R0
        POPGE    {R0,R1,R4-R11,PC}
//  515         n = s->heap[h];
??gen_bitlen_1:
        ADD      R0,R2,R7, LSL #+2
        LDR      R8,[R0, #+2908]
//  516         bits = tree[tree[n].Dad].Len + 1;
        ADD      R0,R1,R8, LSL #+2
        LDRH     R9,[R0, #+2]
        ADD      R9,R1,R9, LSL #+2
        LDRH     R9,[R9, #+2]
        ADD      R9,R9,#+1
//  517         if (bits > max_length) bits = max_length, overflow++;
        CMP      R4,R9
        MOVLT    R9,R4
        ADDLT    R10,R10,#+1
//  518         tree[n].Len = (ush)bits;
        STRH     R9,[R0, #+2]
//  519         /* We overwrite tree[n].Dad which is no longer needed */
//  520 
//  521         if (n > max_code) continue; /* not a leaf node */
        CMP      R3,R8
        BLT      ??gen_bitlen_2
//  522 
//  523         s->bl_count[bits]++;
        ADD      R11,R2,R9, LSL #+1
        LDRH     LR,[R5, +R11]
//  524         xbits = 0;
//  525         if (n >= base) xbits = extra[n-base];
        CMP      R8,R12
        ADD      LR,LR,#+1
        STRH     LR,[R5, +R11]
        LDRGE    LR,[SP, #+4]
//  526         f = tree[n].Freq;
        LDRH     R0,[R0, #+0]
        MOV      R11,#+0
        SUBGE    R11,R8,R12
        LDRGE    R11,[LR, +R11, LSL #+2]
//  527         s->opt_len += (ulg)f * (bits + xbits);
        LDR      LR,[R6, #+596]
        ADD      R9,R11,R9
        MLA      LR,R9,R0,LR
        STR      LR,[R6, #+596]
//  528         if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
        LDR      R9,[SP, #+0]
        CMP      R9,#+0
        BEQ      ??gen_bitlen_2
        LDR      LR,[SP, #+0]
        LDR      R9,[R6, #+600]
        ADD      R8,LR,R8, LSL #+2
        LDRH     R8,[R8, #+2]
        ADD      R8,R11,R8
        MLA      R0,R8,R0,R9
        STR      R0,[R6, #+600]
//  529     }
??gen_bitlen_2:
        ADD      R7,R7,#+1
        MOV      R0,#+61
        ORR      R0,R0,#0x200
        CMP      R7,R0
        BLT      ??gen_bitlen_1
//  530     if (overflow == 0) return;
        CMP      R10,#+0
        POPEQ    {R0,R1,R4-R11,PC}
//  531 
//  532     Trace((stderr,"\nbit length overflow\n"));
//  533     /* This happens for example on obj2 and pic of the Calgary corpus */
//  534 
//  535     /* Find the first bit length which could increase: */
//  536     do {
//  537         bits = max_length-1;
??gen_bitlen_3:
        SUB      R9,R4,#+1
        ADD      R0,R2,R9, LSL #+1
        LDRH     R0,[R5, +R0]
        CMP      R0,#+0
        BEQ      ??gen_bitlen_4
        B        ??gen_bitlen_5
//  538         while (s->bl_count[bits] == 0) bits--;
??gen_bitlen_6:
        SUB      R9,R9,#+1
??gen_bitlen_4:
        ADD      R0,R2,R9, LSL #+1
        LDRH     R0,[R5, +R0]
        CMP      R0,#+0
        BEQ      ??gen_bitlen_6
//  539         s->bl_count[bits]--;      /* move one leaf down the tree */
??gen_bitlen_5:
        ADD      R8,R2,R9, LSL #+1
        LDRH     R11,[R5, +R8]
        MOV      R0,#+255
        ORR      R0,R0,#0xFF00
        ADD      R11,R0,R11
        STRH     R11,[R5, +R8]
        ADD      R8,R9,#+1
        ADD      R8,R2,R8, LSL #+1
        LDRH     R9,[R5, +R8]
//  540         s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
//  541         s->bl_count[max_length]--;
//  542         /* The brother of the overflow item also moves one step up,
//  543          * but this does not affect bl_count[max_length]
//  544          */
//  545         overflow -= 2;
        SUB      R10,R10,#+2
//  546     } while (overflow > 0);
        CMP      R10,#+1
        ADD      R9,R9,#+2
        STRH     R9,[R5, +R8]
        ADD      R8,R2,R4, LSL #+1
        LDRH     R9,[R5, +R8]
        ADD      R0,R0,R9
        STRH     R0,[R5, +R8]
        BGE      ??gen_bitlen_3
//  547 
//  548     /* Now recompute all bit lengths, scanning in increasing frequency.
//  549      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
//  550      * lengths instead of fixing only the wrong ones. This idea is taken
//  551      * from 'ar' written by Haruhiko Okumura.)
//  552      */
//  553     for (bits = max_length; bits != 0; bits--) {
        MOVS     R9,R4
        POPEQ    {R0,R1,R4-R11,PC}
//  554         n = s->bl_count[bits];
??gen_bitlen_7:
        ADD      R0,R2,R9, LSL #+1
        LDRH     R8,[R5, +R0]
        CMP      R8,#+0
        BEQ      ??gen_bitlen_8
//  555         while (n != 0) {
//  556             m = s->heap[--h];
??gen_bitlen_9:
        SUB      R7,R7,#+1
        ADD      R0,R2,R7, LSL #+2
        LDR      R0,[R0, #+2908]
//  557             if (m > max_code) continue;
        CMP      R3,R0
        BLT      ??gen_bitlen_10
//  558             if ((unsigned) tree[m].Len != (unsigned) bits) {
        ADD      R0,R1,R0, LSL #+2
        LDRH     R4,[R0, #+2]
        CMP      R4,R9
        BEQ      ??gen_bitlen_11
//  559                 Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
//  560                 s->opt_len += ((long)bits - (long)tree[m].Len)
//  561                               *(long)tree[m].Freq;
        LDRH     R10,[R0, #+2]
        LDRH     R11,[R0, #+0]
        LDR      R4,[R6, #+596]
        SUB      R10,R9,R10
        MLA      R4,R11,R10,R4
        STR      R4,[R6, #+596]
//  562                 tree[m].Len = (ush)bits;
        STRH     R9,[R0, #+2]
//  563             }
//  564             n--;
??gen_bitlen_11:
        SUB      R8,R8,#+1
//  565         }
??gen_bitlen_10:
        CMP      R8,#+0
        BNE      ??gen_bitlen_9
//  566     }
??gen_bitlen_8:
        SUBS     R9,R9,#+1
        BNE      ??gen_bitlen_7
        POP      {R0,R1,R4-R11,PC}  ;; return
        CFI EndBlock cfiBlock7
//  567 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??gen_codes??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE gen_codes
//  568 
//  569 /* ===========================================================================
//  570  * Generate the codes for a given tree and bit counts (which need not be
//  571  * optimal).
//  572  * IN assertion: the array bl_count contains the bit length statistics for
//  573  * the given tree and the field len is set for all tree elements.
//  574  * OUT assertion: the field code is set for all tree elements of non
//  575  *     zero code length.
//  576  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function gen_codes
        ARM
//  577 local void gen_codes (tree, max_code, bl_count)
//  578     ct_data *tree;             /* the tree to decorate */
//  579     int max_code;              /* largest code with non zero frequency */
//  580     ushf *bl_count;            /* number of codes at each bit length */
//  581 {
gen_codes:
        PUSH     {R4-R7}
        CFI R7 Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
        SUB      SP,SP,#+32
        CFI CFA R13+48
//  582     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
//  583     ush code = 0;              /* running code value */
        MOV      R12,#+0
//  584     int bits;                  /* bit index */
//  585     int n;                     /* code index */
//  586 
//  587     /* The distribution counts are first used to generate the code values
//  588      * without bit reversal.
//  589      */
//  590     for (bits = 1; bits <= MAX_BITS; bits++) {
        MOV      R4,#+1
//  591         next_code[bits] = code = (code + bl_count[bits-1]) << 1;
??gen_codes_0:
        ADD      R5,R2,R4, LSL #+1
        LDRH     R5,[R5, #-2]
        ADD      R5,R5,R12
        LSL      R12,R5,#+1
        MOV      R12,R12, LSL #+16
        MOV      R12,R12, LSR #+16
        MOV      R5,SP
        ADD      R5,R5,R4, LSL #+1
        STRH     R12,[R5, #+0]
//  592     }
        ADD      R4,R4,#+1
        CMP      R4,#+16
        BLT      ??gen_codes_0
//  593     /* Check that the bit counts in bl_count are consistent. The last code
//  594      * must be all ones.
//  595      */
//  596     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
//  597             "inconsistent bit counts");
//  598     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
//  599 
//  600     for (n = 0;  n <= max_code; n++) {
        MOV      R2,#+0
        CMP      R1,#+0
        BPL      ??gen_codes_1
        B        ??gen_codes_2
//  601         int len = tree[n].Len;
??gen_codes_3:
        ADD      R4,R0,R2, LSL #+2
        LDRH     R12,[R4, #+2]
//  602         if (len == 0) continue;
        CMP      R12,#+0
        BEQ      ??gen_codes_4
//  603         /* Now reverse the bits */
//  604         tree[n].Code = bi_reverse(next_code[len]++, len);
        MOV      R5,SP
        ADD      R5,R5,R12, LSL #+1
        LDRH     R6,[R5, #+0]
        ADD      R7,R6,#+1
        STRH     R7,[R5, #+0]
        MOV      R5,#+0
??gen_codes_5:
        AND      R7,R6,#0x1
        ORR      R5,R7,R5
        LSR      R6,R6,#+1
        LSL      R5,R5,#+1
        SUB      R12,R12,#+1
        CMP      R12,#+1
        BGE      ??gen_codes_5
        LSR      R5,R5,#+1
        STRH     R5,[R4, #+0]
//  605 
//  606         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
//  607              n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
//  608     }
??gen_codes_4:
        ADD      R2,R2,#+1
??gen_codes_1:
        CMP      R1,R2
        BGE      ??gen_codes_3
//  609 }
??gen_codes_2:
        ADD      SP,SP,#+32
        CFI CFA R13+16
        POP      {R4-R7}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??build_tree??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE build_tree
//  610 
//  611 /* ===========================================================================
//  612  * Construct one Huffman tree and assigns the code bit strings and lengths.
//  613  * Update the total bit length for the current block.
//  614  * IN assertion: the field freq is set for all tree elements.
//  615  * OUT assertions: the fields len and code are set to the optimal bit length
//  616  *     and corresponding code. The length opt_len is updated; static_len is
//  617  *     also updated if stree is not null. The field max_code is set.
//  618  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function build_tree
        ARM
//  619 local void build_tree(s, desc)
//  620     deflate_state *s;
//  621     tree_desc *desc; /* the tree descriptor */
//  622 {
build_tree:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        MOV      R5,R1
//  623     ct_data *tree         = desc->dyn_tree;
//  624     const ct_data *stree  = desc->stat_desc->static_tree;
        LDR      R1,[R5, #+8]
        LDR      R6,[R5, #+0]
//  625     int elems             = desc->stat_desc->elems;
        LDR      R11,[R1, #+12]
        MOV      R4,R0
        LDR      R0,[R1, #+0]
//  626     int n, m;          /* iterate over heap elements */
//  627     int max_code = -1; /* largest code with non zero frequency */
        MVN      R9,#+0
//  628     int node;          /* new node being created */
//  629 
//  630     /* Construct the initial heap, with least frequent element in
//  631      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
//  632      * heap[0] is not used.
//  633      */
//  634     s->heap_len = 0, s->heap_max = HEAP_SIZE;
        MOV      R1,#+92
        ORR      R1,R1,#0xB00
        ADD      R7,R1,R4
        MOV      R1,#+0
        STR      R1,[R7, #+2292]
        MOV      R2,#+61
        ORR      R2,R2,#0x200
        STR      R2,[R7, #+2296]
//  635 
//  636     for (n = 0; n < elems; n++) {
        MOV      R2,#+0
        MOV      R8,#+88
        ORR      R8,R8,#0x1400
        CMP      R11,#+1
        BGE      ??build_tree_0
        B        ??build_tree_1
//  637         if (tree[n].Freq != 0) {
//  638             s->heap[++(s->heap_len)] = max_code = n;
//  639             s->depth[n] = 0;
//  640         } else {
//  641             tree[n].Len = 0;
??build_tree_2:
        STRH     R1,[R3, #+2]
//  642         }
??build_tree_3:
        ADD      R2,R2,#+1
??build_tree_0:
        CMP      R2,R11
        BGE      ??build_tree_1
        ADD      R3,R6,R2, LSL #+2
        LDRH     R10,[R3, #+0]
        CMP      R10,#+0
        BEQ      ??build_tree_2
        LDR      R3,[R7, #+2292]
        MOV      R9,R2
        ADD      R3,R3,#+1
        STR      R3,[R7, #+2292]
        ADD      R3,R4,R3, LSL #+2
        STR      R9,[R3, #+2908]
        ADD      R3,R2,R4
        STRB     R1,[R8, +R3]
        B        ??build_tree_3
//  643     }
//  644 
//  645     /* The pkzip format requires that at least one distance code exists,
//  646      * and that at least one bit should be sent even if there is only one
//  647      * possible code. So to avoid special checks later on we force at least
//  648      * two codes of non zero frequency.
//  649      */
//  650     while (s->heap_len < 2) {
//  651         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
??build_tree_4:
        ADD      R3,R4,R3, LSL #+2
        STR      R2,[R3, #+2908]
//  652         tree[node].Freq = 1;
        ADD      R3,R6,R2, LSL #+2
        MOV      R10,#+1
        STRH     R10,[R3, #+0]
//  653         s->depth[node] = 0;
        ADD      R3,R2,R4
        STRB     R1,[R8, +R3]
//  654         s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        LDR      R3,[R7, #+2892]
        CMP      R0,#+0
        SUB      R3,R3,#+1
        STR      R3,[R7, #+2892]
        BEQ      ??build_tree_1
        LDR      R3,[R7, #+2896]
        ADD      R2,R0,R2, LSL #+2
        LDRH     R2,[R2, #+2]
        SUB      R2,R3,R2
        STR      R2,[R7, #+2896]
??build_tree_1:
        LDR      R2,[R7, #+2292]
        CMP      R2,#+2
        BGE      ??build_tree_5
        ADD      R3,R2,#+1
        STR      R3,[R7, #+2292]
        CMP      R9,#+2
        MOVGE    R2,#+0
        ADDLT    R9,R9,#+1
        MOVLT    R2,R9
        B        ??build_tree_4
//  655         /* node is 0 or 1 so it does not have extra bits */
//  656     }
//  657     desc->max_code = max_code;
??build_tree_5:
        STR      R9,[R5, #+4]
//  658 
//  659     /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
//  660      * establish sub-heaps of increasing lengths:
//  661      */
//  662     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
        LDR      R0,[R7, #+2292]
        ADD      R0,R0,R0, LSR #+31
        ASR      R10,R0,#+1
        CMP      R10,#+1
        BLT      ??build_tree_6
??build_tree_7:
        MOV      R2,R10
        MOV      R1,R6
        MOV      R0,R4
        BL       pqdownheap
        SUB      R10,R10,#+1
        CMP      R10,#+1
        BGE      ??build_tree_7
//  663 
//  664     /* Construct the Huffman tree by repeatedly combining the least two
//  665      * frequent nodes.
//  666      */
//  667     node = elems;              /* next internal node of the tree */
//  668     do {
//  669         pqremove(s, tree, n);  /* n = node of least frequency */
??build_tree_6:
        LDR      R0,[R7, #+2292]
        LDR      R10,[R7, #+4]
        SUB      R1,R0,#+1
        STR      R1,[R7, #+2292]
        LDR      R0,[R7, +R0, LSL #+2]
        MOV      R2,#+1
        STR      R0,[R7, #+4]
        MOV      R1,R6
        MOV      R0,R4
        BL       pqdownheap
//  670         m = s->heap[SMALLEST]; /* m = node of next least frequency */
//  671 
//  672         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        LDR      R1,[R7, #+2296]
        LDR      R0,[R7, #+4]
        SUB      R1,R1,#+1
        STR      R1,[R7, #+2296]
        STR      R10,[R7, +R1, LSL #+2]
//  673         s->heap[--(s->heap_max)] = m;
        LDR      R1,[R7, #+2296]
//  674 
//  675         /* Create a new node father of n and m */
//  676         tree[node].Freq = tree[n].Freq + tree[m].Freq;
        ADD      R2,R6,R10, LSL #+2
        SUB      R1,R1,#+1
        STR      R1,[R7, #+2296]
        STR      R0,[R7, +R1, LSL #+2]
        LDRH     R2,[R2, #+0]
        ADD      R3,R6,R0, LSL #+2
        LDRH     R3,[R3, #+0]
        ADD      R1,R6,R11, LSL #+2
        ADD      R2,R3,R2
        STRH     R2,[R1, #+0]
//  677         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
//  678                                 s->depth[n] : s->depth[m]) + 1);
        MOV      R1,#+252
        ORR      R1,R1,#0x800
        ADD      R1,R1,R7
        LDRB     R1,[R10, +R1]
        MOV      R2,#+252
        ORR      R2,R2,#0x800
        ADD      R2,R2,R7
        LDRB     R2,[R0, +R2]
        CMP      R1,R2
        ADDCS    R1,R10,R4
        LDRBCS   R1,[R8, +R1]
        MOVCC    R1,R2
        MOV      R2,#+252
        ORR      R2,R2,#0x800
        ADD      R2,R2,R7
        ADD      R1,R1,#+1
        STRB     R1,[R11, +R2]
//  679         tree[n].Dad = tree[m].Dad = (ush)node;
        ADD      R1,R6,#+2
        ADD      R0,R1,R0, LSL #+2
        STRH     R11,[R0, #+0]
        LDRH     R0,[R0, #+0]
        ADD      R1,R1,R10, LSL #+2
//  680 #ifdef DUMP_BL_TREE
//  681         if (tree == s->bl_tree) {
//  682             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
//  683                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
//  684         }
//  685 #endif
//  686         /* and insert the new node in the heap */
//  687         s->heap[SMALLEST] = node++;
//  688         pqdownheap(s, tree, SMALLEST);
        MOV      R2,#+1
        STRH     R0,[R1, #+0]
        STR      R11,[R7, #+4]
        MOV      R1,R6
        MOV      R0,R4
        BL       pqdownheap
//  689 
//  690     } while (s->heap_len >= 2);
        LDR      R0,[R7, #+2292]
        ADD      R11,R11,#+1
        CMP      R0,#+2
        BGE      ??build_tree_6
//  691 
//  692     s->heap[--(s->heap_max)] = s->heap[SMALLEST];
        LDR      R0,[R7, #+2296]
        SUB      R0,R0,#+1
        STR      R0,[R7, #+2296]
        LDR      R1,[R7, #+4]
        ADD      R0,R4,R0, LSL #+2
        STR      R1,[R0, #+2908]
//  693 
//  694     /* At this point, the fields freq and dad are set. We can now
//  695      * generate the bit lengths.
//  696      */
//  697     gen_bitlen(s, (tree_desc *)desc);
        MOV      R1,R5
        MOV      R0,R4
        BL       gen_bitlen
//  698 
//  699     /* The field len is now set, we can generate the bit codes */
//  700     gen_codes ((ct_data *)tree, max_code, s->bl_count);
        MOV      R0,#+60
        ORR      R0,R0,#0xB00
        ADD      R2,R0,R4
        MOV      R1,R9
        MOV      R0,R6
        BL       gen_codes
//  701 }
        POP      {R4-R11,PC}      ;; return
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??scan_tree??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE scan_tree
//  702 
//  703 /* ===========================================================================
//  704  * Scan a literal or distance tree to determine the frequencies of the codes
//  705  * in the bit length tree.
//  706  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function scan_tree
        ARM
//  707 local void scan_tree (s, tree, max_code)
//  708     deflate_state *s;
//  709     ct_data *tree;   /* the tree to be scanned */
//  710     int max_code;    /* and its largest code of non zero frequency */
//  711 {
scan_tree:
        PUSH     {R4-R8}
        CFI R8 Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  712     int n;                     /* iterates over all tree elements */
//  713     int prevlen = -1;          /* last emitted length */
//  714     int curlen;                /* length of current code */
//  715     int nextlen = tree[0].Len; /* length of next code */
        LDRH     R4,[R1, #+2]
        MVN      R3,#+0
//  716     int count = 0;             /* repeat count of the current code */
        MOV      R12,#+0
//  717     int max_count = 7;         /* max repeat count */
        MOV      R7,#+7
//  718     int min_count = 4;         /* min repeat count */
        MOV      R8,#+4
//  719 
//  720     if (nextlen == 0) max_count = 138, min_count = 3;
        CMP      R4,#+0
        MOVEQ    R7,#+138
        MOVEQ    R8,#+3
//  721     tree[max_code+1].Len = (ush)0xffff; /* guard */
        ADD      R5,R1,R2, LSL #+2
        MOV      R6,R3, LSR #+16
        STRH     R6,[R5, #+6]
//  722 
//  723     for (n = 0; n <= max_code; n++) {
        MOV      R5,#+0
        CMP      R2,#+0
        BMI      ??scan_tree_0
//  724         curlen = nextlen; nextlen = tree[n+1].Len;
??scan_tree_1:
        MOV      R6,R4
        ADD      R4,R1,R5, LSL #+2
        LDRH     R4,[R4, #+6]
//  725         if (++count < max_count && curlen == nextlen) {
        ADD      R12,R12,#+1
        CMP      R12,R7
        BGE      ??scan_tree_2
        CMP      R6,R4
        BEQ      ??scan_tree_3
//  726             continue;
//  727         } else if (count < min_count) {
??scan_tree_2:
        ADD      R7,R0,R6, LSL #+2
        CMP      R12,R8
        BGE      ??scan_tree_4
//  728             s->bl_tree[curlen].Freq += count;
        MOV      R3,#+124
        ORR      R3,R3,#0xA00
        LDRH     R8,[R3, +R7]
        ADD      R8,R12,R8
        STRH     R8,[R3, +R7]
        B        ??scan_tree_5
//  729         } else if (curlen != 0) {
??scan_tree_4:
        MOV      R8,#+188
        ORR      R8,R8,#0xA00
        ADD      R8,R8,R0
        CMP      R6,#+0
        BEQ      ??scan_tree_6
//  730             if (curlen != prevlen) s->bl_tree[curlen].Freq++;
        CMP      R6,R3
        BEQ      ??scan_tree_7
        MOV      R3,#+124
        ORR      R3,R3,#0xA00
        LDRH     R12,[R3, +R7]
        ADD      R12,R12,#+1
        STRH     R12,[R3, +R7]
//  731             s->bl_tree[REP_3_6].Freq++;
??scan_tree_7:
        LDRH     R3,[R8, #+0]
        ADD      R3,R3,#+1
        STRH     R3,[R8, #+0]
        B        ??scan_tree_5
//  732         } else if (count <= 10) {
??scan_tree_6:
        CMP      R12,#+11
        BGE      ??scan_tree_8
//  733             s->bl_tree[REPZ_3_10].Freq++;
        LDRH     R3,[R8, #+4]
        ADD      R3,R3,#+1
        STRH     R3,[R8, #+4]
        B        ??scan_tree_5
//  734         } else {
//  735             s->bl_tree[REPZ_11_138].Freq++;
??scan_tree_8:
        LDRH     R3,[R8, #+8]
        ADD      R3,R3,#+1
        STRH     R3,[R8, #+8]
//  736         }
//  737         count = 0; prevlen = curlen;
??scan_tree_5:
        MOV      R12,#+0
        MOV      R3,R6
//  738         if (nextlen == 0) {
        CMP      R4,#+0
        BNE      ??scan_tree_9
//  739             max_count = 138, min_count = 3;
        MOV      R7,#+138
??scan_tree_10:
        MOV      R8,#+3
        B        ??scan_tree_3
//  740         } else if (curlen == nextlen) {
??scan_tree_9:
        CMP      R6,R4
//  741             max_count = 6, min_count = 3;
        MOVEQ    R7,#+6
        BEQ      ??scan_tree_10
//  742         } else {
//  743             max_count = 7, min_count = 4;
        MOV      R7,#+7
        MOV      R8,#+4
//  744         }
//  745     }
??scan_tree_3:
        ADD      R5,R5,#+1
        CMP      R2,R5
        BGE      ??scan_tree_1
//  746 }
??scan_tree_0:
        POP      {R4-R8}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??send_tree??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock14
        REQUIRE send_tree
//  747 
//  748 /* ===========================================================================
//  749  * Send a literal or distance tree in compressed form, using the codes in
//  750  * bl_tree.
//  751  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI Function send_tree
        ARM
//  752 local void send_tree (s, tree, max_code)
//  753     deflate_state *s;
//  754     ct_data *tree; /* the tree to be scanned */
//  755     int max_code;       /* and its largest code of non zero frequency */
//  756 {
send_tree:
        PUSH     {R1,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
//  757     int n;                     /* iterates over all tree elements */
//  758     int prevlen = -1;          /* last emitted length */
//  759     int curlen;                /* length of current code */
//  760     int nextlen = tree[0].Len; /* length of next code */
        LDRH     R12,[R1, #+2]
        MVN      R8,#+0
//  761     int count = 0;             /* repeat count of the current code */
        MOV      R4,#+0
//  762     int max_count = 7;         /* max repeat count */
        MOV      R5,#+7
//  763     int min_count = 4;         /* min repeat count */
        MOV      R7,#+4
//  764 
//  765     /* tree[max_code+1].Len = -1; */  /* guard already set */
//  766     if (nextlen == 0) max_count = 138, min_count = 3;
        CMP      R12,#+0
        MOVEQ    R5,#+138
        MOVEQ    R7,#+3
//  767 
//  768     for (n = 0; n <= max_code; n++) {
        MOV      R1,#+0
        CMP      R2,#+0
        POPMI    {R0,R4-R11,PC}
//  769         curlen = nextlen; nextlen = tree[n+1].Len;
??send_tree_0:
        LDR      R6,[SP, #+0]
        MOV      R3,R12
        ADD      R6,R6,R1, LSL #+2
        LDRH     R12,[R6, #+6]
//  770         if (++count < max_count && curlen == nextlen) {
        ADD      R4,R4,#+1
        CMP      R4,R5
        BGE      ??send_tree_1
        CMP      R3,R12
        BEQ      ??send_tree_2
//  771             continue;
//  772         } else if (count < min_count) {
??send_tree_1:
        MOV      R5,#+124
        ORR      R5,R5,#0xA00
        ADD      R6,R0,R3, LSL #+2
        ADD      R9,R5,R6
        ADD      R5,R0,#+8
        MOV      R6,#+184
        ORR      R6,R6,#0x1600
        ADD      R6,R6,R0
        CMP      R4,R7
        BLT      ??send_tree_3
        MOV      R7,#+188
        ORR      R7,R7,#0xA00
        ADD      R7,R7,R0
        CMP      R3,#+0
        BEQ      ??send_tree_4
//  773             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
//  774 
//  775         } else if (curlen != 0) {
//  776             if (curlen != prevlen) {
        CMP      R3,R8
        BEQ      ??send_tree_5
//  777                 send_code(s, curlen, s->bl_tree); count--;
        LDRH     R8,[R9, #+2]
        LDR      R11,[R6, #+4]
        RSB      R10,R8,#+16
        CMP      R10,R11
        BGE      ??send_tree_6
        LDRH     R9,[R9, #+0]
        LDRH     R10,[R6, #+0]
        LSL      R11,R9,R11
        ORR      R10,R11,R10
        STRH     R10,[R6, #+0]
        LDR      R10,[R5, #+12]
        ADD      R11,R10,#+1
        STR      R11,[R5, #+12]
        LDRH     LR,[R6, #+0]
        LDR      R11,[R5, #+0]
        STRB     LR,[R10, +R11]
        LDR      R10,[R5, #+12]
        ADD      R11,R10,#+1
        STR      R11,[R5, #+12]
        LDRH     LR,[R6, #+0]
        LDR      R11,[R5, #+0]
        LSR      LR,LR,#+8
        STRB     LR,[R10, +R11]
        LDR      R10,[R6, #+4]
        RSB      R10,R10,#+16
        ASR      R9,R9,R10
        STRH     R9,[R6, #+0]
        LDR      R9,[R6, #+4]
        ADD      R8,R9,R8
        SUB      R8,R8,#+16
        B        ??send_tree_7
??send_tree_8:
        LDRH     R8,[R6, #+0]
        LDRH     R10,[R9, #+0]
        LDR      R11,[R6, #+4]
        LSL      R10,R10,R11
        ORR      R8,R10,R8
        STRH     R8,[R6, #+0]
        ADD      R7,R7,R11
??send_tree_9:
        STR      R7,[R6, #+4]
        SUBS     R4,R4,#+1
        BEQ      ??send_tree_10
??send_tree_3:
        LDRH     R7,[R9, #+2]
        LDR      R10,[R6, #+4]
        RSB      R8,R7,#+16
        CMP      R8,R10
        BGE      ??send_tree_8
        LDRH     R8,[R9, #+0]
        LDRH     R10,[R6, #+0]
        LDR      R11,[R6, #+4]
        LSL      R11,R8,R11
        ORR      R10,R11,R10
        STRH     R10,[R6, #+0]
        LDR      R10,[R5, #+12]
        ADD      R11,R10,#+1
        STR      R11,[R5, #+12]
        LDRH     LR,[R6, #+0]
        LDR      R11,[R5, #+0]
        STRB     LR,[R10, +R11]
        LDR      R10,[R5, #+12]
        ADD      R11,R10,#+1
        STR      R11,[R5, #+12]
        LDRH     LR,[R6, #+0]
        LDR      R11,[R5, #+0]
        LSR      LR,LR,#+8
        STRB     LR,[R10, +R11]
        LDR      R10,[R6, #+4]
        RSB      R10,R10,#+16
        ASR      R8,R8,R10
        STRH     R8,[R6, #+0]
        LDR      R8,[R6, #+4]
        ADD      R7,R8,R7
        SUB      R7,R7,#+16
        B        ??send_tree_9
??send_tree_6:
        LDRH     R10,[R6, #+0]
        LDRH     R9,[R9, #+0]
        ADD      R8,R8,R11
        LSL      R9,R9,R11
        ORR      R9,R9,R10
        STRH     R9,[R6, #+0]
??send_tree_7:
        STR      R8,[R6, #+4]
        SUB      R4,R4,#+1
//  778             }
//  779             Assert(count >= 3 && count <= 6, " 3_6?");
//  780             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
??send_tree_5:
        LDRH     R8,[R7, #+2]
        LDR      R10,[R6, #+4]
        RSB      R9,R8,#+16
        CMP      R9,R10
        BGE      ??send_tree_11
        LDRH     R7,[R7, #+0]
        LDRH     R9,[R6, #+0]
        LSL      R10,R7,R10
        ORR      R9,R10,R9
        STRH     R9,[R6, #+0]
        LDR      R9,[R5, #+12]
        ADD      R10,R9,#+1
        STR      R10,[R5, #+12]
        LDRH     R11,[R6, #+0]
        LDR      R10,[R5, #+0]
        STRB     R11,[R9, +R10]
        LDR      R9,[R5, #+12]
        ADD      R10,R9,#+1
        STR      R10,[R5, #+12]
        LDRH     R11,[R6, #+0]
        LDR      R10,[R5, #+0]
        LSR      R11,R11,#+8
        STRB     R11,[R9, +R10]
        LDR      R9,[R6, #+4]
        RSB      R9,R9,#+16
        ASR      R7,R7,R9
        STRH     R7,[R6, #+0]
        LDR      R7,[R6, #+4]
        ADD      R7,R7,R8
        SUB      R7,R7,#+16
        B        ??send_tree_12
??send_tree_11:
        LDRH     R9,[R6, #+0]
        LDRH     R7,[R7, #+0]
        LSL      R7,R7,R10
        ORR      R7,R7,R9
        STRH     R7,[R6, #+0]
        ADD      R7,R8,R10
??send_tree_12:
        STR      R7,[R6, #+4]
        LDR      R7,[R6, #+4]
        SUB      R4,R4,#+3
        CMP      R7,#+15
        BLT      ??send_tree_13
        LDRH     R7,[R6, #+0]
        LDR      R8,[R6, #+4]
        LSL      R8,R4,R8
        ORR      R7,R8,R7
        STRH     R7,[R6, #+0]
        LDR      R7,[R5, #+12]
        MOV      R4,R4, LSL #+16
        ADD      R8,R7,#+1
        STR      R8,[R5, #+12]
        LDRH     R9,[R6, #+0]
        LDR      R8,[R5, #+0]
        MOV      R4,R4, LSR #+16
        STRB     R9,[R7, +R8]
        LDR      R7,[R5, #+12]
        ADD      R8,R7,#+1
        STR      R8,[R5, #+12]
        LDRH     R8,[R6, #+0]
        LDR      R5,[R5, #+0]
        LSR      R8,R8,#+8
        STRB     R8,[R7, +R5]
        LDR      R5,[R6, #+4]
        RSB      R5,R5,#+16
        ASR      R4,R4,R5
        STRH     R4,[R6, #+0]
        LDR      R4,[R6, #+4]
        SUB      R4,R4,#+14
        B        ??send_tree_14
??send_tree_13:
        LDRH     R5,[R6, #+0]
        LSL      R4,R4,R7
        ORR      R4,R4,R5
        STRH     R4,[R6, #+0]
        ADD      R4,R7,#+2
        B        ??send_tree_14
//  781 
//  782         } else if (count <= 10) {
??send_tree_4:
        CMP      R4,#+11
        BGE      ??send_tree_15
//  783             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
        LDRH     R8,[R7, #+6]
        LDR      R10,[R6, #+4]
        RSB      R9,R8,#+16
        CMP      R9,R10
        BGE      ??send_tree_16
        LDRH     R7,[R7, #+4]
        LDRH     R9,[R6, #+0]
        LSL      R10,R7,R10
        ORR      R9,R10,R9
        STRH     R9,[R6, #+0]
        LDR      R9,[R5, #+12]
        ADD      R10,R9,#+1
        STR      R10,[R5, #+12]
        LDRH     R11,[R6, #+0]
        LDR      R10,[R5, #+0]
        STRB     R11,[R9, +R10]
        LDR      R9,[R5, #+12]
        ADD      R10,R9,#+1
        STR      R10,[R5, #+12]
        LDRH     R11,[R6, #+0]
        LDR      R10,[R5, #+0]
        LSR      R11,R11,#+8
        STRB     R11,[R9, +R10]
        LDR      R9,[R6, #+4]
        RSB      R9,R9,#+16
        ASR      R7,R7,R9
        STRH     R7,[R6, #+0]
        LDR      R7,[R6, #+4]
        ADD      R7,R7,R8
        SUB      R7,R7,#+16
        B        ??send_tree_17
??send_tree_16:
        LDRH     R9,[R6, #+0]
        LDRH     R7,[R7, #+4]
        LSL      R7,R7,R10
        ORR      R7,R7,R9
        STRH     R7,[R6, #+0]
        ADD      R7,R8,R10
??send_tree_17:
        STR      R7,[R6, #+4]
        LDR      R7,[R6, #+4]
        SUB      R4,R4,#+3
        CMP      R7,#+14
        BLT      ??send_tree_18
        LDRH     R7,[R6, #+0]
        LDR      R8,[R6, #+4]
        LSL      R8,R4,R8
        ORR      R7,R8,R7
        STRH     R7,[R6, #+0]
        LDR      R7,[R5, #+12]
        MOV      R4,R4, LSL #+16
        ADD      R8,R7,#+1
        STR      R8,[R5, #+12]
        LDRH     R9,[R6, #+0]
        LDR      R8,[R5, #+0]
        MOV      R4,R4, LSR #+16
        STRB     R9,[R7, +R8]
        LDR      R7,[R5, #+12]
        ADD      R8,R7,#+1
        STR      R8,[R5, #+12]
        LDRH     R8,[R6, #+0]
        LDR      R5,[R5, #+0]
        LSR      R8,R8,#+8
        STRB     R8,[R7, +R5]
        LDR      R5,[R6, #+4]
        RSB      R5,R5,#+16
        ASR      R4,R4,R5
        STRH     R4,[R6, #+0]
        LDR      R4,[R6, #+4]
        SUB      R4,R4,#+13
        B        ??send_tree_14
??send_tree_18:
        LDRH     R5,[R6, #+0]
        LSL      R4,R4,R7
        ORR      R4,R4,R5
        STRH     R4,[R6, #+0]
        ADD      R4,R7,#+3
        B        ??send_tree_14
//  784 
//  785         } else {
//  786             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
??send_tree_15:
        LDRH     R8,[R7, #+10]
        LDR      R10,[R6, #+4]
        RSB      R9,R8,#+16
        CMP      R9,R10
        BGE      ??send_tree_19
        LDRH     R7,[R7, #+8]
        LDRH     R9,[R6, #+0]
        LSL      R10,R7,R10
        ORR      R9,R10,R9
        STRH     R9,[R6, #+0]
        LDR      R9,[R5, #+12]
        ADD      R10,R9,#+1
        STR      R10,[R5, #+12]
        LDRH     R11,[R6, #+0]
        LDR      R10,[R5, #+0]
        STRB     R11,[R9, +R10]
        LDR      R9,[R5, #+12]
        ADD      R10,R9,#+1
        STR      R10,[R5, #+12]
        LDRH     R11,[R6, #+0]
        LDR      R10,[R5, #+0]
        LSR      R11,R11,#+8
        STRB     R11,[R9, +R10]
        LDR      R9,[R6, #+4]
        RSB      R9,R9,#+16
        ASR      R7,R7,R9
        STRH     R7,[R6, #+0]
        LDR      R7,[R6, #+4]
        ADD      R7,R7,R8
        SUB      R7,R7,#+16
        B        ??send_tree_20
??send_tree_19:
        LDRH     R9,[R6, #+0]
        LDRH     R7,[R7, #+8]
        LSL      R7,R7,R10
        ORR      R7,R7,R9
        STRH     R7,[R6, #+0]
        ADD      R7,R8,R10
??send_tree_20:
        STR      R7,[R6, #+4]
        LDR      R7,[R6, #+4]
        SUB      R4,R4,#+11
        CMP      R7,#+10
        BLT      ??send_tree_21
        LDRH     R7,[R6, #+0]
        LDR      R8,[R6, #+4]
        LSL      R8,R4,R8
        ORR      R7,R8,R7
        STRH     R7,[R6, #+0]
        LDR      R7,[R5, #+12]
        MOV      R4,R4, LSL #+16
        ADD      R8,R7,#+1
        STR      R8,[R5, #+12]
        LDRH     R9,[R6, #+0]
        LDR      R8,[R5, #+0]
        MOV      R4,R4, LSR #+16
        STRB     R9,[R7, +R8]
        LDR      R7,[R5, #+12]
        ADD      R8,R7,#+1
        STR      R8,[R5, #+12]
        LDRH     R8,[R6, #+0]
        LDR      R5,[R5, #+0]
        LSR      R8,R8,#+8
        STRB     R8,[R7, +R5]
        LDR      R5,[R6, #+4]
        RSB      R5,R5,#+16
        ASR      R4,R4,R5
        STRH     R4,[R6, #+0]
        LDR      R4,[R6, #+4]
        SUB      R4,R4,#+9
        B        ??send_tree_14
??send_tree_21:
        LDRH     R5,[R6, #+0]
        LSL      R4,R4,R7
        ORR      R4,R4,R5
        STRH     R4,[R6, #+0]
        ADD      R4,R7,#+7
??send_tree_14:
        STR      R4,[R6, #+4]
//  787         }
//  788         count = 0; prevlen = curlen;
        MOV      R4,#+0
??send_tree_10:
        MOV      R8,R3
//  789         if (nextlen == 0) {
        CMP      R12,#+0
        BNE      ??send_tree_22
//  790             max_count = 138, min_count = 3;
        MOV      R5,#+138
??send_tree_23:
        MOV      R7,#+3
        B        ??send_tree_2
//  791         } else if (curlen == nextlen) {
??send_tree_22:
        CMP      R3,R12
//  792             max_count = 6, min_count = 3;
        MOVEQ    R5,#+6
        BEQ      ??send_tree_23
//  793         } else {
//  794             max_count = 7, min_count = 4;
        MOV      R5,#+7
        MOV      R7,#+4
//  795         }
//  796     }
??send_tree_2:
        ADD      R1,R1,#+1
        CMP      R2,R1
        BGE      ??send_tree_0
//  797 }
        POP      {R0,R4-R11,PC}   ;; return
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??build_bl_tree??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock16
        REQUIRE build_bl_tree
//  798 
//  799 /* ===========================================================================
//  800  * Construct the Huffman tree for the bit lengths and return the index in
//  801  * bl_order of the last bit length code to send.
//  802  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI Function build_bl_tree
        ARM
//  803 local int build_bl_tree(s)
//  804     deflate_state *s;
//  805 {
build_bl_tree:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
        MOV      R4,R0
        MOV      R0,#+28
        ORR      R0,R0,#0xB00
        ADD      R5,R0,R4
        LDR      R2,[R5, #+0]
        ADD      R1,R4,#+148
        MOV      R0,R4
//  806     int max_blindex;  /* index of last bit length code of non zero freq */
//  807 
//  808     /* Determine the bit length frequencies for literal and distance trees */
//  809     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
        BL       scan_tree
//  810     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
        LDR      R2,[R5, #+12]
        MOV      R0,#+136
        ORR      R0,R0,#0x900
        ADD      R1,R0,R4
        MOV      R0,R4
        BL       scan_tree
//  811 
//  812     /* Build the bit length tree: */
//  813     build_tree(s, (tree_desc *)(&(s->bl_desc)));
        ADD      R1,R4,#+2864
        MOV      R0,R4
        BL       build_tree
//  814     /* opt_len now includes the length of the tree representations, except
//  815      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
//  816      */
//  817 
//  818     /* Determine the number of bit length codes to send. The pkzip format
//  819      * requires that at least 4 bit length codes be sent. (appnote.txt says
//  820      * 3 but the actual value used is 4.)
//  821      */
//  822     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        MOV      R0,#+18
//  823         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
??build_bl_tree_0:
        LDR      R2,??DataTable1  ;; bl_order
        MOV      R1,#+126
        LDRB     R2,[R0, +R2]
        ORR      R1,R1,#0xA00
        ADD      R2,R4,R2, LSL #+2
        LDRH     R1,[R1, +R2]
        CMP      R1,#+0
        BNE      ??build_bl_tree_1
//  824     }
        SUB      R0,R0,#+1
        CMP      R0,#+3
        BGE      ??build_bl_tree_0
//  825     /* Update opt_len to include the bit length tree and counts */
//  826     s->opt_len += 3*(max_blindex+1) + 5+5+4;
??build_bl_tree_1:
        LDR      R1,[R5, #+2956]
        ADD      R2,R0,R0, LSL #+1
        ADD      R2,R2,#+17
        ADD      R1,R2,R1
        STR      R1,[R5, #+2956]
//  827     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
//  828             s->opt_len, s->static_len));
//  829 
//  830     return max_blindex;
        POP      {R4,R5,PC}       ;; return
        CFI EndBlock cfiBlock17
//  831 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??send_all_trees??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock18
        REQUIRE send_all_trees
//  832 
//  833 /* ===========================================================================
//  834  * Send the header for a block using dynamic Huffman trees: the counts, the
//  835  * lengths of the bit length codes, the literal tree and the distance tree.
//  836  * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
//  837  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon1
        CFI Function send_all_trees
        ARM
//  838 local void send_all_trees(s, lcodes, dcodes, blcodes)
//  839     deflate_state *s;
//  840     int lcodes, dcodes, blcodes; /* number of codes for each tree */
//  841 {
send_all_trees:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
        MOV      R5,R0
//  842     int rank;                    /* index in bl_order */
//  843 
//  844     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
//  845     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
//  846             "too many codes");
//  847     Tracev((stderr, "\nbl counts: "));
//  848     send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
        MOV      R6,#+184
        ORR      R6,R6,#0x1600
        ADD      R12,R6,R5
        LDR      R6,[R12, #+4]
        ADD      R0,R5,#+8
        MVN      R4,#+256
        ADD      R4,R4,R1
        CMP      R6,#+12
        LDRH     R6,[R12, #+0]
        BLT      ??send_all_trees_0
        LDR      LR,[R12, #+4]
        LSL      LR,R4,LR
        ORR      R6,LR,R6
        STRH     R6,[R12, #+0]
        LDR      LR,[R0, #+12]
        MOV      R4,R4, LSL #+16
        ADD      R6,LR,#+1
        STR      R6,[R0, #+12]
        LDRH     R7,[R12, #+0]
        LDR      R6,[R0, #+0]
        MOV      R4,R4, LSR #+16
        STRB     R7,[LR, +R6]
        LDR      LR,[R0, #+12]
        ADD      R6,LR,#+1
        STR      R6,[R0, #+12]
        LDRH     R7,[R12, #+0]
        LDR      R6,[R0, #+0]
        LSR      R7,R7,#+8
        STRB     R7,[LR, +R6]
        LDR      R6,[R12, #+4]
        RSB      R6,R6,#+16
        ASR      R4,R4,R6
        STRH     R4,[R12, #+0]
        LDR      R4,[R12, #+4]
        SUB      R4,R4,#+11
        B        ??send_all_trees_1
??send_all_trees_0:
        LDR      R7,[R12, #+4]
        LSL      R4,R4,R7
        ORR      R4,R4,R6
        STRH     R4,[R12, #+0]
        ADD      R4,R7,#+5
??send_all_trees_1:
        STR      R4,[R12, #+4]
//  849     send_bits(s, dcodes-1,   5);
        SUB      R4,R2,#+1
        LDR      R2,[R12, #+4]
        CMP      R2,#+12
        BLT      ??send_all_trees_2
        LDRH     R6,[R12, #+0]
        MOV      R7,R2
        LSL      R7,R4,R7
        ORR      R6,R7,R6
        STRH     R6,[R12, #+0]
        LDR      LR,[R0, #+12]
        MOV      R2,R4, LSL #+16
        ADD      R6,LR,#+1
        STR      R6,[R0, #+12]
        LDRH     R7,[R12, #+0]
        LDR      R6,[R0, #+0]
        MOV      R2,R2, LSR #+16
        STRB     R7,[LR, +R6]
        LDR      LR,[R0, #+12]
        ADD      R6,LR,#+1
        STR      R6,[R0, #+12]
        LDRH     R7,[R12, #+0]
        LDR      R6,[R0, #+0]
        LSR      R7,R7,#+8
        STRB     R7,[LR, +R6]
        LDR      R6,[R12, #+4]
        RSB      R6,R6,#+16
        ASR      R2,R2,R6
        STRH     R2,[R12, #+0]
        LDR      R2,[R12, #+4]
        SUB      R2,R2,#+11
        B        ??send_all_trees_3
??send_all_trees_2:
        LDRH     R2,[R12, #+0]
        LDR      R6,[R12, #+4]
        LSL      R6,R4,R6
        ORR      R2,R6,R2
        STRH     R2,[R12, #+0]
        LDR      R2,[R12, #+4]
        ADD      R2,R2,#+5
??send_all_trees_3:
        STR      R2,[R12, #+4]
//  850     send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
        LDR      R6,[R12, #+4]
        LDR      R7,[R12, #+4]
        SUB      R2,R3,#+4
        CMP      R6,#+13
        LDRH     R6,[R12, #+0]
        BLT      ??send_all_trees_4
        LSL      R7,R2,R7
        ORR      R6,R7,R6
        STRH     R6,[R12, #+0]
        LDR      LR,[R0, #+12]
        MOV      R2,R2, LSL #+16
        ADD      R6,LR,#+1
        STR      R6,[R0, #+12]
        LDRH     R7,[R12, #+0]
        LDR      R6,[R0, #+0]
        MOV      R2,R2, LSR #+16
        STRB     R7,[LR, +R6]
        LDR      LR,[R0, #+12]
        ADD      R6,LR,#+1
        STR      R6,[R0, #+12]
        LDRH     R7,[R12, #+0]
        LDR      R6,[R0, #+0]
        LSR      R7,R7,#+8
        STRB     R7,[LR, +R6]
        LDR      R6,[R12, #+4]
        RSB      R6,R6,#+16
        ASR      R2,R2,R6
        STRH     R2,[R12, #+0]
        LDR      R2,[R12, #+4]
        SUB      R2,R2,#+12
        B        ??send_all_trees_5
??send_all_trees_4:
        LSL      R2,R2,R7
        ORR      R2,R2,R6
        STRH     R2,[R12, #+0]
        ADD      R2,R7,#+4
??send_all_trees_5:
        STR      R2,[R12, #+4]
//  851     for (rank = 0; rank < blcodes; rank++) {
        MOV      R2,#+0
        CMP      R3,#+1
        BGE      ??send_all_trees_6
//  852         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
//  853         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
//  854     }
//  855     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
//  856 
//  857     send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
??send_all_trees_7:
        SUB      R2,R1,#+1
        ADD      R1,R5,#+148
        MOV      R0,R5
        BL       send_tree
//  858     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
//  859 
//  860     send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
        MOV      R2,R4
        MOV      R0,#+136
        ORR      R0,R0,#0x900
        ADD      R1,R0,R5
        MOV      R0,R5
        BL       send_tree
//  861     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
//  862 }
        POP      {R4-R8,PC}       ;; return
??send_all_trees_8:
        LDRH     R6,[R12, #+0]
        MOV      R7,#+126
        ORR      R7,R7,#0xA00
        LDRH     R7,[R7, +LR]
        LDR      LR,[R12, #+4]
        LSL      R7,R7,LR
        ORR      R6,R7,R6
        STRH     R6,[R12, #+0]
        ADD      R6,LR,#+3
??send_all_trees_9:
        STR      R6,[R12, #+4]
        ADD      R2,R2,#+1
??send_all_trees_6:
        CMP      R2,R3
        BGE      ??send_all_trees_7
        LDR      R6,??DataTable1  ;; bl_order
        LDRB     R6,[R2, +R6]
        ADD      LR,R5,R6, LSL #+2
        LDR      R6,[R12, #+4]
        CMP      R6,#+14
        BLT      ??send_all_trees_8
        LDR      R7,[R12, #+4]
        MOV      R6,#+126
        ORR      R6,R6,#0xA00
        LDRH     LR,[R6, +LR]
        LDRH     R6,[R12, #+0]
        LSL      R7,LR,R7
        ORR      R6,R7,R6
        STRH     R6,[R12, #+0]
        LDR      R6,[R0, #+12]
        ADD      R7,R6,#+1
        STR      R7,[R0, #+12]
        LDRH     R8,[R12, #+0]
        LDR      R7,[R0, #+0]
        STRB     R8,[R6, +R7]
        LDR      R6,[R0, #+12]
        ADD      R7,R6,#+1
        STR      R7,[R0, #+12]
        LDRH     R8,[R12, #+0]
        LDR      R7,[R0, #+0]
        LSR      R8,R8,#+8
        STRB     R8,[R6, +R7]
        LDR      R6,[R12, #+4]
        RSB      R6,R6,#+16
        ASR      R6,LR,R6
        STRH     R6,[R12, #+0]
        LDR      R6,[R12, #+4]
        SUB      R6,R6,#+13
        B        ??send_all_trees_9
        CFI EndBlock cfiBlock19

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable1:
        DC32     bl_order

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??_tr_stored_block??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock20
        REQUIRE _tr_stored_block
//  863 
//  864 /* ===========================================================================
//  865  * Send a stored block
//  866  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI Function _tr_stored_block
        ARM
//  867 void _tr_stored_block(s, buf, stored_len, eof)
//  868     deflate_state *s;
//  869     charf *buf;       /* input block */
//  870     ulg stored_len;   /* length of input block */
//  871     int eof;          /* true if this is the last block for a file */
//  872 {
_tr_stored_block:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        MOV      R4,#+184
        ORR      R4,R4,#0x1600
        ADD      R12,R4,R0
        LDR      R5,[R12, #+4]
        LDRH     R4,[R12, #+0]
        CMP      R5,#+14
        BLT      ??_tr_stored_block_0
//  873     send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
        LSL      R5,R3,R5
        ORR      R4,R5,R4
        STRH     R4,[R12, #+0]
        ADD      R5,R0,#+8
        LDR      R6,[R5, #+12]
        MOV      R3,R3, LSL #+16
        ADD      R7,R6,#+1
        STR      R7,[R5, #+12]
        LDR      R7,[R5, #+0]
        MOV      R3,R3, LSR #+16
        STRB     R4,[R6, +R7]
        LDR      R4,[R5, #+12]
        ADD      R6,R4,#+1
        STR      R6,[R5, #+12]
        LDRH     R6,[R12, #+0]
        LDR      R5,[R5, #+0]
        LSR      R6,R6,#+8
        STRB     R6,[R4, +R5]
        LDR      R4,[R12, #+4]
        MOV      R5,R4
        RSB      R5,R5,#+16
        ASR      R3,R3,R5
        SUB      R4,R4,#+13
        B        ??_tr_stored_block_1
??_tr_stored_block_0:
        LSL      R3,R3,R5
        ORR      R3,R3,R4
        ADD      R4,R5,#+3
??_tr_stored_block_1:
        STR      R4,[R12, #+4]
        STRH     R3,[R12, #+0]
//  874 #ifdef DEBUG
//  875     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
//  876     s->compressed_len += (stored_len + 4) << 3;
//  877 #endif
//  878     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
        MOV      R3,#+1
        BL       copy_block
//  879 }
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock21

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon0
        CFI NoFunction
        THUMB
??_tr_align??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock22
        REQUIRE _tr_align
//  880 
//  881 /* ===========================================================================
//  882  * Send one empty static block to give enough lookahead for inflate.
//  883  * This takes 10 bits, of which 7 may remain in the bit buffer.
//  884  * The current inflate code requires 9 bits of lookahead. If the
//  885  * last two codes for the previous block (real code plus EOB) were coded
//  886  * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
//  887  * the last real code. In this case we send two empty static blocks instead
//  888  * of one. (There are no problems if the previous block is stored or fixed.)
//  889  * To simplify the code, we assume the worst case of last real code encoded
//  890  * on one bit only.
//  891  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon1
        CFI Function _tr_align
        ARM
//  892 void _tr_align(s)
//  893     deflate_state *s;
//  894 {
_tr_align:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
        MOV      R4,R0
        MOV      R0,#+180
        ORR      R0,R0,#0x1600
        ADD      R5,R0,R4
        LDR      R1,[R5, #+8]
        LDRH     R0,[R5, #+4]
        ADD      R6,R4,#+8
        MOV      R7,#+2
        CMP      R1,#+14
        BLT      ??_tr_align_0
//  895     send_bits(s, STATIC_TREES<<1, 3);
        LSL      R1,R7,R1
        ORR      R0,R1,R0
        STRH     R0,[R5, #+4]
        LDR      R1,[R6, #+12]
        ADD      R2,R1,#+1
        STR      R2,[R6, #+12]
        LDR      R2,[R6, #+0]
        STRB     R0,[R1, +R2]
        LDR      R0,[R6, #+12]
        ADD      R1,R0,#+1
        STR      R1,[R6, #+12]
        LDRH     R2,[R5, #+4]
        LDR      R1,[R6, #+0]
        LSR      R2,R2,#+8
        STRB     R2,[R0, +R1]
        LDR      R0,[R5, #+8]
        MOV      R1,R0
        RSB      R1,R1,#+16
        ASR      R2,R7,R1
        SUB      R0,R0,#+13
        B        ??_tr_align_1
??_tr_align_0:
        LSL      R2,R7,R1
        ORR      R2,R2,R0
        ADD      R0,R1,#+3
??_tr_align_1:
        STR      R0,[R5, #+8]
//  896     send_code(s, END_BLOCK, static_ltree);
        LDR      R0,[R5, #+8]
        MOV      R8,#+0
        LSL      R1,R8,R0
        ORR      R1,R1,R2
        CMP      R0,#+10
        BLT      ??_tr_align_2
        STRH     R1,[R5, #+4]
        LDR      R0,[R6, #+12]
        ADD      R2,R0,#+1
        STR      R2,[R6, #+12]
        LDR      R2,[R6, #+0]
        STRB     R1,[R0, +R2]
        LDR      R0,[R6, #+12]
        ADD      R1,R0,#+1
        STR      R1,[R6, #+12]
        LDRH     R2,[R5, #+4]
        LDR      R1,[R6, #+0]
        LSR      R2,R2,#+8
        STRB     R2,[R0, +R1]
        LDR      R0,[R5, #+8]
        MOV      R1,R0
        RSB      R1,R1,#+16
        ASR      R1,R8,R1
        SUB      R0,R0,#+9
        B        ??_tr_align_3
??_tr_align_2:
        ADD      R0,R0,#+7
??_tr_align_3:
        STR      R0,[R5, #+8]
        STRH     R1,[R5, #+4]
//  897 #ifdef DEBUG
//  898     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
//  899 #endif
//  900     bi_flush(s);
        MOV      R0,R4
        BL       bi_flush
//  901     /* Of the 10 bits for the empty block, we have already sent
//  902      * (10 - bi_valid) bits. The lookahead for the last real code (before
//  903      * the EOB of the previous block) was thus at least one plus the length
//  904      * of the EOB plus what we have just sent of the empty static block.
//  905      */
//  906     if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
        LDR      R0,[R5, #+8]
        LDR      R1,[R5, #+0]
        ADD      R1,R1,#+11
        SUB      R1,R1,R0
        CMP      R1,#+9
        BGE      ??_tr_align_4
//  907         send_bits(s, STATIC_TREES<<1, 3);
        LDRH     R1,[R5, #+4]
        CMP      R0,#+14
        BLT      ??_tr_align_5
        LSL      R0,R7,R0
        ORR      R0,R0,R1
        STRH     R0,[R5, #+4]
        LDR      R1,[R6, #+12]
        ADD      R2,R1,#+1
        STR      R2,[R6, #+12]
        LDR      R2,[R6, #+0]
        STRB     R0,[R1, +R2]
        LDR      R0,[R6, #+12]
        ADD      R1,R0,#+1
        STR      R1,[R6, #+12]
        LDRH     R2,[R5, #+4]
        LDR      R1,[R6, #+0]
        LSR      R2,R2,#+8
        STRB     R2,[R0, +R1]
        LDR      R0,[R5, #+8]
        MOV      R1,R0
        RSB      R1,R1,#+16
        ASR      R1,R7,R1
        SUB      R0,R0,#+13
        B        ??_tr_align_6
??_tr_align_5:
        LSL      R2,R7,R0
        ORR      R1,R2,R1
        ADD      R0,R0,#+3
??_tr_align_6:
        STR      R0,[R5, #+8]
//  908         send_code(s, END_BLOCK, static_ltree);
        LDR      R0,[R5, #+8]
        LSL      R2,R8,R0
        ORR      R1,R2,R1
        CMP      R0,#+10
        BLT      ??_tr_align_7
        STRH     R1,[R5, #+4]
        LDR      R0,[R6, #+12]
        ADD      R2,R0,#+1
        STR      R2,[R6, #+12]
        LDR      R2,[R6, #+0]
        STRB     R1,[R0, +R2]
        LDR      R0,[R6, #+12]
        ADD      R1,R0,#+1
        STR      R1,[R6, #+12]
        LDRH     R2,[R5, #+4]
        LDR      R1,[R6, #+0]
        LSR      R2,R2,#+8
        STRB     R2,[R0, +R1]
        LDR      R0,[R5, #+8]
        MOV      R1,R0
        RSB      R1,R1,#+16
        ASR      R1,R8,R1
        SUB      R0,R0,#+9
        B        ??_tr_align_8
??_tr_align_7:
        ADD      R0,R0,#+7
??_tr_align_8:
        STR      R0,[R5, #+8]
        STRH     R1,[R5, #+4]
//  909 #ifdef DEBUG
//  910         s->compressed_len += 10L;
//  911 #endif
//  912         bi_flush(s);
        MOV      R0,R4
        BL       bi_flush
//  913     }
//  914     s->last_eob_len = 7;
??_tr_align_4:
        MOV      R0,#+7
        STR      R0,[R5, #+0]
//  915 }
        POP      {R4-R8,PC}       ;; return
        CFI EndBlock cfiBlock23

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??_tr_flush_block??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock24
        REQUIRE _tr_flush_block
//  916 
//  917 /* ===========================================================================
//  918  * Determine the best encoding for the current block: dynamic trees, static
//  919  * trees or store, and output the encoded block to the zip file.
//  920  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI Function _tr_flush_block
        ARM
//  921 void _tr_flush_block(s, buf, stored_len, eof)
//  922     deflate_state *s;
//  923     charf *buf;       /* input block, or NULL if too old */
//  924     ulg stored_len;   /* length of input block */
//  925     int eof;          /* true if this is the last block for a file */
//  926 {
_tr_flush_block:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
        MOV      R4,R0
        MOV      R7,R1
//  927     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
//  928     int max_blindex = 0;  /* index of last bit length code of non zero freq */
        MOV      R1,#+168
        ORR      R1,R1,#0x1600
        ADD      R6,R1,R4
        LDR      R1,[R4, #+132]
        MOV      R8,R2
        MOV      R5,R3
        MOV      R0,#+0
        CMP      R1,#+1
        BLT      ??_tr_flush_block_0
//  929 
//  930     /* Build the Huffman trees unless a stored block is forced */
//  931     if (s->level > 0) {
//  932 
//  933         /* Check if the file is binary or text */
//  934         if (stored_len > 0 && s->strm->data_type == Z_UNKNOWN)
        CMP      R8,#+0
        BEQ      ??_tr_flush_block_1
        LDR      R0,[R4, #+0]
        LDR      R0,[R0, #+44]
        CMP      R0,#+2
        BNE      ??_tr_flush_block_1
//  935             set_data_type(s);
        MOV      R0,R4
        BL       set_data_type
//  936 
//  937         /* Construct the literal and distance trees */
//  938         build_tree(s, (tree_desc *)(&(s->l_desc)));
??_tr_flush_block_1:
        MOV      R0,#+24
        ORR      R0,R0,#0xB00
        ADD      R1,R0,R4
        MOV      R0,R4
        BL       build_tree
//  939         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
//  940                 s->static_len));
//  941 
//  942         build_tree(s, (tree_desc *)(&(s->d_desc)));
        MOV      R0,#+36
        ORR      R0,R0,#0xB00
        ADD      R1,R0,R4
        MOV      R0,R4
        BL       build_tree
//  943         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
//  944                 s->static_len));
//  945         /* At this point, opt_len and static_len are the total bit lengths of
//  946          * the compressed block data, excluding the tree representations.
//  947          */
//  948 
//  949         /* Build the bit length tree for the above two trees, and get the index
//  950          * in bl_order of the last bit length code to send.
//  951          */
//  952         max_blindex = build_bl_tree(s);
        MOV      R0,R4
        BL       build_bl_tree
//  953 
//  954         /* Determine the best encoding. Compute the block lengths in bytes. */
//  955         opt_lenb = (s->opt_len+3+7)>>3;
        LDR      R1,[R6, #+0]
        ADD      R1,R1,#+10
        LSR      R2,R1,#+3
//  956         static_lenb = (s->static_len+3+7)>>3;
        LDR      R1,[R6, #+4]
        ADD      R1,R1,#+10
        LSR      R3,R1,#+3
//  957 
//  958         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
//  959                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
//  960                 s->last_lit));
//  961 
//  962         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
        CMP      R2,R3
        BCC      ??_tr_flush_block_2
        B        ??_tr_flush_block_3
//  963 
//  964     } else {
//  965         Assert(buf != (char*)0, "lost buf");
//  966         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
??_tr_flush_block_0:
        ADD      R3,R8,#+5
??_tr_flush_block_3:
        MOV      R2,R3
//  967     }
//  968 
//  969 #ifdef FORCE_STORED
//  970     if (buf != (char*)0) { /* force stored block */
//  971 #else
//  972     if (stored_len+4 <= opt_lenb && buf != (char*)0) {
??_tr_flush_block_2:
        ADD      R1,R8,#+4
        CMP      R2,R1
        BCC      ??_tr_flush_block_4
        CMP      R7,#+0
        BEQ      ??_tr_flush_block_4
//  973                        /* 4: two words for the lengths */
//  974 #endif
//  975         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
//  976          * Otherwise we can't have processed more than WSIZE input bytes since
//  977          * the last block flush, because compression would have been
//  978          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
//  979          * transform a block into a stored block.
//  980          */
//  981         _tr_stored_block(s, buf, stored_len, eof);
        MOV      R3,R5
        MOV      R2,R8
        MOV      R1,R7
        MOV      R0,R4
        BL       _tr_stored_block
        B        ??_tr_flush_block_5
//  982 
//  983 #ifdef FORCE_STATIC
//  984     } else if (static_lenb >= 0) { /* force static trees */
//  985 #else
//  986     } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
??_tr_flush_block_4:
        LDR      R8,[R4, #+136]
        LDRH     R7,[R6, #+16]
        LDR      R1,[R6, #+20]
        CMP      R8,#+4
        CMPNE    R3,R2
        BNE      ??_tr_flush_block_6
//  987 #endif
//  988         send_bits(s, (STATIC_TREES<<1)+eof, 3);
        ADD      R0,R5,#+2
        LSL      R2,R0,R1
        ORR      R2,R2,R7
        CMP      R1,#+14
        STRH     R2,[R6, #+16]
        BLT      ??_tr_flush_block_7
        LDR      R1,[R4, #+20]
        MOV      R0,R0, LSL #+16
        ADD      R3,R1,#+1
        STR      R3,[R4, #+20]
        LDR      R3,[R4, #+8]
        MOV      R0,R0, LSR #+16
        STRB     R2,[R1, +R3]
        LDR      R1,[R4, #+20]
        ADD      R2,R1,#+1
        STR      R2,[R4, #+20]
        LDRH     R3,[R6, #+16]
        LDR      R2,[R4, #+8]
        LSR      R3,R3,#+8
        STRB     R3,[R1, +R2]
        LDR      R1,[R6, #+20]
        MOV      R2,R1
        RSB      R2,R2,#+16
        ASR      R0,R0,R2
        STRH     R0,[R6, #+16]
        SUB      R0,R1,#+13
        B        ??_tr_flush_block_8
??_tr_flush_block_7:
        ADD      R0,R1,#+3
//  989         compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
??_tr_flush_block_8:
        LDR      R1,??_tr_flush_block_9  ;; static_ltree
        STR      R0,[R6, #+20]
        ADD      R2,R1,#+1152
        B        ??_tr_flush_block_10
//  990 #ifdef DEBUG
//  991         s->compressed_len += 3 + s->static_len;
//  992 #endif
//  993     } else {
//  994         send_bits(s, (DYN_TREES<<1)+eof, 3);
??_tr_flush_block_6:
        ADD      R2,R5,#+4
        LSL      R3,R2,R1
        ORR      R3,R3,R7
        CMP      R1,#+14
        STRH     R3,[R6, #+16]
        BLT      ??_tr_flush_block_11
        LDR      R1,[R4, #+20]
        MOV      R2,R2, LSL #+16
        ADD      R7,R1,#+1
        STR      R7,[R4, #+20]
        LDR      R7,[R4, #+8]
        MOV      R2,R2, LSR #+16
        STRB     R3,[R1, +R7]
        LDR      R1,[R4, #+20]
        ADD      R3,R1,#+1
        STR      R3,[R4, #+20]
        LDRH     R7,[R6, #+16]
        LDR      R3,[R4, #+8]
        LSR      R7,R7,#+8
        STRB     R7,[R1, +R3]
        LDR      R1,[R6, #+20]
        MOV      R3,R1
        RSB      R3,R3,#+16
        ASR      R2,R2,R3
        STRH     R2,[R6, #+16]
        SUB      R1,R1,#+13
        B        ??_tr_flush_block_12
??_tr_flush_block_11:
        ADD      R1,R1,#+3
??_tr_flush_block_12:
        STR      R1,[R6, #+20]
//  995         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
//  996                        max_blindex+1);
        ADD      R3,R0,#+1
        LDR      R0,[R4, #+2856]
        ADD      R2,R0,#+1
        LDR      R0,[R4, #+2844]
        ADD      R1,R0,#+1
        MOV      R0,R4
        BL       send_all_trees
//  997         compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
        MOV      R0,#+136
        ORR      R0,R0,#0x900
        ADD      R2,R0,R4
        ADD      R1,R4,#+148
??_tr_flush_block_10:
        MOV      R0,R4
        BL       compress_block
//  998 #ifdef DEBUG
//  999         s->compressed_len += 3 + s->opt_len;
// 1000 #endif
// 1001     }
// 1002     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
// 1003     /* The above check is made mod 2^32, for files larger than 512 MB
// 1004      * and uLong implemented on 32 bits.
// 1005      */
// 1006     init_block(s);
??_tr_flush_block_5:
        MOV      R0,R4
        BL       init_block
// 1007 
// 1008     if (eof) {
        CMP      R5,#+0
        POPEQ    {R4-R8,PC}
// 1009         bi_windup(s);
        MOV      R0,R4
        BL       bi_windup
// 1010 #ifdef DEBUG
// 1011         s->compressed_len += 7;  /* align on byte boundary */
// 1012 #endif
// 1013     }
// 1014     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
// 1015            s->compressed_len-7*eof));
// 1016 }
        POP      {R4-R8,PC}       ;; return
        DATA
??_tr_flush_block_9:
        DC32     static_ltree
        CFI EndBlock cfiBlock25

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon0
        CFI NoFunction
        THUMB
??_tr_tally??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock26
        REQUIRE _tr_tally
// 1017 
// 1018 /* ===========================================================================
// 1019  * Save the match info and tally the frequency counts. Return true if
// 1020  * the current block must be flushed.
// 1021  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock27 Using cfiCommon1
        CFI Function _tr_tally
        ARM
// 1022 int _tr_tally (s, dist, lc)
// 1023     deflate_state *s;
// 1024     unsigned dist;  /* distance of matched string */
// 1025     unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
// 1026 {
_tr_tally:
        PUSH     {R4,R5}
        CFI R5 Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOV      R3,#+152
        ORR      R3,R3,#0x1600
        ADD      R3,R3,R0
        LDR      R4,[R3, #+8]
        LDR      R12,[R3, #+12]
// 1027     s->d_buf[s->last_lit] = (ush)dist;
// 1028     s->l_buf[s->last_lit++] = (uch)lc;
// 1029     if (dist == 0) {
        CMP      R1,#+0
        ADD      R4,R12,R4, LSL #+1
        STRH     R1,[R4, #+0]
        LDR      R12,[R3, #+8]
        ADD      R4,R12,#+1
        STR      R4,[R3, #+8]
        LDR      R4,[R3, #+0]
        STRB     R2,[R12, +R4]
        BNE      ??_tr_tally_0
// 1030         /* lc is the unmatched char */
// 1031         s->dyn_ltree[lc].Freq++;
        ADD      R0,R0,R2, LSL #+2
        LDRH     R1,[R0, #+148]
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+148]
        B        ??_tr_tally_1
// 1032     } else {
// 1033         s->matches++;
??_tr_tally_0:
        LDR      R4,[R3, #+24]
// 1034         /* Here, lc is the match length - MIN_MATCH */
// 1035         dist--;             /* dist = match distance - 1 */
// 1036         Assert((ush)dist < (ush)MAX_DIST(s) &&
// 1037                (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
// 1038                (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
// 1039 
// 1040         s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        LDR      R12,??DataTable3  ;; _dist_code
        ADD      R4,R4,#+1
        STR      R4,[R3, #+24]
        ADD      R2,R2,R12
        LDRB     R2,[R2, #+984]
        MOV      R4,#+152
        ORR      R4,R4,#0x400
        ADD      R2,R0,R2, LSL #+2
        LDRH     R5,[R4, +R2]
        SUB      R1,R1,#+1
// 1041         s->dyn_dtree[d_code(dist)].Freq++;
        CMP      R1,#+256
        ADD      R5,R5,#+1
        STRH     R5,[R4, +R2]
        LDRBCC   R1,[R1, +R12]
        ADDCS    R1,R12,R1, LSR #+7
        LDRBCS   R1,[R1, #+256]
        ADD      R0,R0,R1, LSL #+2
        ADD      R1,R4,#+1264
        LDRH     R2,[R1, +R0]
        ADD      R2,R2,#+1
        STRH     R2,[R1, +R0]
// 1042     }
// 1043 
// 1044 #ifdef TRUNCATE_BLOCK
// 1045     /* Try to guess if it is profitable to stop the current block here */
// 1046     if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
// 1047         /* Compute an upper bound for the compressed length */
// 1048         ulg out_length = (ulg)s->last_lit*8L;
// 1049         ulg in_length = (ulg)((long)s->strstart - s->block_start);
// 1050         int dcode;
// 1051         for (dcode = 0; dcode < D_CODES; dcode++) {
// 1052             out_length += (ulg)s->dyn_dtree[dcode].Freq *
// 1053                 (5L+extra_dbits[dcode]);
// 1054         }
// 1055         out_length >>= 3;
// 1056         Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
// 1057                s->last_lit, in_length, out_length,
// 1058                100L - out_length*100L/in_length));
// 1059         if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
// 1060     }
// 1061 #endif
// 1062     return (s->last_lit == s->lit_bufsize-1);
??_tr_tally_1:
        LDR      R0,[R3, #+8]
        LDR      R1,[R3, #+4]
        POP      {R4,R5}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI CFA R13+0
        SUB      R1,R1,#+1
        CMP      R0,R1
        MOVEQ    R0,#+1
        MOVNE    R0,#+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock27
// 1063     /* We avoid equality with lit_bufsize because of wraparound at 64K
// 1064      * on 16 bit machines and because stored blocks are restricted to
// 1065      * 64K-1 bytes.
// 1066      */
// 1067 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock28 Using cfiCommon0
        CFI NoFunction
        THUMB
??compress_block??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock28
        REQUIRE compress_block
// 1068 
// 1069 /* ===========================================================================
// 1070  * Send the block data compressed using the given Huffman trees
// 1071  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock29 Using cfiCommon1
        CFI Function compress_block
        ARM
// 1072 local void compress_block(s, ltree, dtree)
// 1073     deflate_state *s;
// 1074     ct_data *ltree; /* literal tree */
// 1075     ct_data *dtree; /* distance tree */
// 1076 {
compress_block:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
// 1077     unsigned dist;      /* distance of matched string */
// 1078     int lc;             /* match length or unmatched char (if dist == 0) */
// 1079     unsigned lx = 0;    /* running index in l_buf */
// 1080     unsigned code;      /* the code to send */
// 1081     int extra;          /* number of extra bits to send */
// 1082 
// 1083     if (s->last_lit != 0) do {
        ADD      R3,R0,#+8
        MOV      R4,#+152
        ORR      R4,R4,#0x1600
        ADD      R4,R4,R0
        LDR      R0,[R4, #+8]
        MOV      R12,#+0
        CMP      R0,#+0
        BEQ      ??compress_block_0
// 1084         dist = s->d_buf[lx];
??compress_block_1:
        LDR      R0,[R4, #+12]
// 1085         lc = s->l_buf[lx++];
        LDR      R5,[R4, #+0]
// 1086         if (dist == 0) {
        LDRH     R6,[R4, #+32]
        LDRB     R8,[R12, +R5]
        LDR      R7,[R4, #+36]
        ADD      R0,R0,R12, LSL #+1
        LDRH     R0,[R0, #+0]
        ADD      R12,R12,#+1
        CMP      R0,#+0
        BNE      ??compress_block_2
// 1087             send_code(s, lc, ltree); /* send a literal byte */
        ADD      R5,R1,R8, LSL #+2
        LDRH     R0,[R5, #+2]
        LDRH     R5,[R5, #+0]
        RSB      R8,R0,#+16
        CMP      R8,R7
        BGE      ??compress_block_3
        LSL      R7,R5,R7
        ORR      R6,R7,R6
        STRH     R6,[R4, #+32]
        LDR      R7,[R3, #+12]
        ADD      R8,R7,#+1
        STR      R8,[R3, #+12]
        LDR      R8,[R3, #+0]
        STRB     R6,[R7, +R8]
        LDR      R6,[R3, #+12]
        ADD      R7,R6,#+1
        STR      R7,[R3, #+12]
        LDRH     R8,[R4, #+32]
        LDR      R7,[R3, #+0]
        LSR      R8,R8,#+8
        STRB     R8,[R6, +R7]
        LDR      R6,[R4, #+36]
        MOV      R7,R6
        RSB      R7,R7,#+16
        ASR      R5,R5,R7
        STRH     R5,[R4, #+32]
        ADD      R0,R6,R0
??compress_block_4:
        SUB      R0,R0,#+16
        B        ??compress_block_5
??compress_block_3:
        LSL      R5,R5,R7
        ORR      R5,R5,R6
        STRH     R5,[R4, #+32]
        ADD      R0,R0,R7
        B        ??compress_block_5
// 1088             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
// 1089         } else {
// 1090             /* Here, lc is the match length - MIN_MATCH */
// 1091             code = _length_code[lc];
??compress_block_2:
        LDR      R5,??DataTable3  ;; _dist_code
// 1092             send_code(s, code+LITERALS+1, ltree); /* send the length code */
        MOV      R10,#+4
        ADD      R9,R8,R5
        LDRB     R9,[R9, #+984]
        ORR      R10,R10,#0x400
        ADD      R11,R1,R9, LSL #+2
        ADD      R11,R10,R11
        LDRH     R10,[R11, #+2]
        LDRH     R11,[R11, #+0]
        RSB      LR,R10,#+16
        CMP      LR,R7
        BGE      ??compress_block_6
        LSL      R7,R11,R7
        ORR      R6,R7,R6
        STRH     R6,[R4, #+32]
        LDR      R7,[R3, #+12]
        ADD      LR,R7,#+1
        STR      LR,[R3, #+12]
        LDR      LR,[R3, #+0]
        STRB     R6,[R7, +LR]
        LDR      R6,[R3, #+12]
        ADD      R7,R6,#+1
        STR      R7,[R3, #+12]
        LDRH     LR,[R4, #+32]
        LDR      R7,[R3, #+0]
        LSR      LR,LR,#+8
        STRB     LR,[R6, +R7]
        LDR      R6,[R4, #+36]
        MOV      R7,R6
        RSB      R7,R7,#+16
        ASR      R7,R11,R7
        STRH     R7,[R4, #+32]
        ADD      R6,R6,R10
        SUB      R6,R6,#+16
        B        ??compress_block_7
??compress_block_6:
        LSL      R11,R11,R7
        ORR      R6,R11,R6
        STRH     R6,[R4, #+32]
        ADD      R6,R10,R7
??compress_block_7:
        STR      R6,[R4, #+36]
// 1093             extra = extra_lbits[code];
// 1094             if (extra != 0) {
        LDRH     R7,[R4, #+32]
        ADD      R9,R5,R9, LSL #+2
        LDR      R6,[R9, #+512]
        CMP      R6,#+0
        BEQ      ??compress_block_8
// 1095                 lc -= base_length[code];
        LDR      R9,[R9, #+748]
// 1096                 send_bits(s, lc, extra);       /* send the extra length bits */
        RSB      R10,R6,#+16
        SUB      R8,R8,R9
        LDR      R9,[R4, #+36]
        CMP      R10,R9
        BGE      ??compress_block_9
        LSL      R9,R8,R9
        ORR      R7,R9,R7
        STRH     R7,[R4, #+32]
        LDR      R9,[R3, #+12]
        MOV      R8,R8, LSL #+16
        ADD      R10,R9,#+1
        STR      R10,[R3, #+12]
        LDR      R10,[R3, #+0]
        MOV      R8,R8, LSR #+16
        STRB     R7,[R9, +R10]
        LDR      R7,[R3, #+12]
        ADD      R9,R7,#+1
        STR      R9,[R3, #+12]
        LDRH     R10,[R4, #+32]
        LDR      R9,[R3, #+0]
        LSR      R10,R10,#+8
        STRB     R10,[R7, +R9]
        LDR      R9,[R4, #+36]
        MOV      R7,R9
        RSB      R7,R7,#+16
        ASR      R7,R8,R7
        ADD      R6,R9,R6
        SUB      R6,R6,#+16
        B        ??compress_block_10
??compress_block_9:
        LSL      R8,R8,R9
        ORR      R7,R8,R7
        ADD      R6,R6,R9
??compress_block_10:
        STR      R6,[R4, #+36]
??compress_block_8:
        STRH     R7,[R4, #+32]
// 1097             }
// 1098             dist--; /* dist is now the match distance - 1 */
// 1099             code = d_code(dist);
// 1100             Assert (code < D_CODES, "bad d_code");
// 1101 
// 1102             send_code(s, code, dtree);       /* send the distance code */
        LDR      R10,[R4, #+36]
        LDRH     R9,[R4, #+32]
        SUB      R0,R0,#+1
        CMP      R0,#+256
        LDRBCC   R6,[R0, +R5]
        ADDCS    R6,R5,R0, LSR #+7
        LDRBCS   R6,[R6, #+256]
        ADD      R8,R2,R6, LSL #+2
        LDRH     R7,[R8, #+2]
        LDRH     R8,[R8, #+0]
        RSB      R11,R7,#+16
        CMP      R11,R10
        BGE      ??compress_block_11
        LSL      R10,R8,R10
        ORR      R9,R10,R9
        STRH     R9,[R4, #+32]
        LDR      R10,[R3, #+12]
        ADD      R11,R10,#+1
        STR      R11,[R3, #+12]
        LDR      R11,[R3, #+0]
        STRB     R9,[R10, +R11]
        LDR      R9,[R3, #+12]
        ADD      R10,R9,#+1
        STR      R10,[R3, #+12]
        LDRH     R11,[R4, #+32]
        LDR      R10,[R3, #+0]
        LSR      R11,R11,#+8
        STRB     R11,[R9, +R10]
        LDR      R9,[R4, #+36]
        MOV      R10,R9
        RSB      R10,R10,#+16
        ASR      R8,R8,R10
        STRH     R8,[R4, #+32]
        ADD      R7,R9,R7
        SUB      R7,R7,#+16
        B        ??compress_block_12
??compress_block_11:
        LSL      R8,R8,R10
        ORR      R8,R8,R9
        STRH     R8,[R4, #+32]
        ADD      R7,R7,R10
??compress_block_12:
        STR      R7,[R4, #+36]
// 1103             extra = extra_dbits[code];
        ADD      R6,R5,R6, LSL #+2
        LDR      R5,[R6, #+628]
// 1104             if (extra != 0) {
        CMP      R5,#+0
        BEQ      ??compress_block_13
// 1105                 dist -= base_dist[code];
        LDR      R6,[R6, #+864]
// 1106                 send_bits(s, dist, extra);   /* send the extra distance bits */
        LDR      R7,[R4, #+36]
        SUB      R0,R0,R6
        LDRH     R6,[R4, #+32]
        RSB      R8,R5,#+16
        CMP      R8,R7
        BGE      ??compress_block_14
        LSL      R7,R0,R7
        ORR      R6,R7,R6
        STRH     R6,[R4, #+32]
        LDR      R7,[R3, #+12]
        MOV      R0,R0, LSL #+16
        ADD      R8,R7,#+1
        STR      R8,[R3, #+12]
        LDR      R8,[R3, #+0]
        MOV      R0,R0, LSR #+16
        STRB     R6,[R7, +R8]
        LDR      R6,[R3, #+12]
        ADD      R7,R6,#+1
        STR      R7,[R3, #+12]
        LDRH     R8,[R4, #+32]
        LDR      R7,[R3, #+0]
        LSR      R8,R8,#+8
        STRB     R8,[R6, +R7]
        LDR      R6,[R4, #+36]
        MOV      R7,R6
        RSB      R7,R7,#+16
        ASR      R0,R0,R7
        STRH     R0,[R4, #+32]
        ADD      R0,R6,R5
        B        ??compress_block_4
??compress_block_14:
        LSL      R0,R0,R7
        ORR      R0,R0,R6
        STRH     R0,[R4, #+32]
        ADD      R0,R5,R7
??compress_block_5:
        STR      R0,[R4, #+36]
// 1107             }
// 1108         } /* literal or match pair ? */
// 1109 
// 1110         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
// 1111         Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
// 1112                "pendingBuf overflow");
// 1113 
// 1114     } while (lx < s->last_lit);
??compress_block_13:
        LDR      R0,[R4, #+8]
        CMP      R12,R0
        BCC      ??compress_block_1
// 1115 
// 1116     send_code(s, END_BLOCK, ltree);
??compress_block_0:
        LDRH     R5,[R4, #+32]
        LDR      R6,[R4, #+36]
        ADD      R0,R1,#+1024
        LDRH     R1,[R0, #+2]
        RSB      R2,R1,#+16
        CMP      R2,R6
        LDRH     R2,[R0, #+0]
        BGE      ??compress_block_15
        LSL      R6,R2,R6
        ORR      R5,R6,R5
        STRH     R5,[R4, #+32]
        LDR      R6,[R3, #+12]
        ADD      R7,R6,#+1
        STR      R7,[R3, #+12]
        LDR      R7,[R3, #+0]
        STRB     R5,[R6, +R7]
        LDR      R5,[R3, #+12]
        ADD      R6,R5,#+1
        STR      R6,[R3, #+12]
        LDRH     R6,[R4, #+32]
        LDR      R3,[R3, #+0]
        LSR      R6,R6,#+8
        STRB     R6,[R5, +R3]
        LDR      R3,[R4, #+36]
        MOV      R5,R3
        RSB      R5,R5,#+16
        ASR      R2,R2,R5
        STRH     R2,[R4, #+32]
        ADD      R1,R1,R3
        SUB      R1,R1,#+16
        B        ??compress_block_16
??compress_block_15:
        ADD      R1,R1,R6
        LSL      R2,R2,R6
        ORR      R2,R2,R5
        STRH     R2,[R4, #+32]
??compress_block_16:
        STR      R1,[R4, #+36]
// 1117     s->last_eob_len = ltree[END_BLOCK].Len;
        LDRH     R0,[R0, #+2]
        STR      R0,[R4, #+28]
// 1118 }
        POP      {R4-R11,PC}      ;; return
        CFI EndBlock cfiBlock29

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable3:
        DC32     _dist_code

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock30 Using cfiCommon0
        CFI NoFunction
        THUMB
??set_data_type??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock30
        REQUIRE set_data_type
// 1119 
// 1120 /* ===========================================================================
// 1121  * Set the data type to BINARY or TEXT, using a crude approximation:
// 1122  * set it to Z_TEXT if all symbols are either printable characters (33 to 255)
// 1123  * or white spaces (9 to 13, or 32); or set it to Z_BINARY otherwise.
// 1124  * IN assertion: the fields Freq of dyn_ltree are set.
// 1125  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock31 Using cfiCommon1
        CFI Function set_data_type
        ARM
// 1126 local void set_data_type(s)
// 1127     deflate_state *s;
// 1128 {
// 1129     int n;
// 1130 
// 1131     for (n = 0; n < 9; n++)
set_data_type:
        MOV      R1,#+0
// 1132         if (s->dyn_ltree[n].Freq != 0)
??set_data_type_0:
        ADD      R2,R0,R1, LSL #+2
        LDRH     R2,[R2, #+148]
        CMP      R2,#+0
        BNE      ??set_data_type_1
        ADD      R1,R1,#+1
        CMP      R1,#+9
        BLT      ??set_data_type_0
// 1133             break;
// 1134     if (n == 9)
        BNE      ??set_data_type_1
// 1135         for (n = 14; n < 32; n++)
        MOV      R1,#+14
// 1136             if (s->dyn_ltree[n].Freq != 0)
??set_data_type_2:
        ADD      R2,R0,R1, LSL #+2
        LDRH     R2,[R2, #+148]
        CMP      R2,#+0
        BNE      ??set_data_type_3
        ADD      R1,R1,#+1
        CMP      R1,#+32
        BLT      ??set_data_type_2
// 1137                 break;
// 1138     s->strm->data_type = (n == 32) ? Z_TEXT : Z_BINARY;
??set_data_type_1:
        CMP      R1,#+32
        MOVEQ    R1,#+1
        BEQ      ??set_data_type_4
??set_data_type_3:
        MOV      R1,#+0
??set_data_type_4:
        LDR      R0,[R0, #+0]
        STR      R1,[R0, #+44]
// 1139 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock31

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock32 Using cfiCommon0
        CFI NoFunction
        THUMB
??bi_flush??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock32
        REQUIRE bi_flush
// 1140 
// 1141 /* ===========================================================================
// 1142  * Reverse the first len bits of a code, using straightforward code (a faster
// 1143  * method would use a table)
// 1144  * IN assertion: 1 <= len <= 15
// 1145  */
// 1146 local unsigned bi_reverse(code, len)
// 1147     unsigned code; /* the value to invert */
// 1148     int len;       /* its bit length */
// 1149 {
// 1150     register unsigned res = 0;
// 1151     do {
// 1152         res |= code & 1;
// 1153         code >>= 1, res <<= 1;
// 1154     } while (--len > 0);
// 1155     return res >> 1;
// 1156 }
// 1157 
// 1158 /* ===========================================================================
// 1159  * Flush the bit buffer, keeping at most 7 bits in it.
// 1160  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock33 Using cfiCommon1
        CFI Function bi_flush
        ARM
// 1161 local void bi_flush(s)
// 1162     deflate_state *s;
// 1163 {
// 1164     if (s->bi_valid == 16) {
bi_flush:
        ADD      R1,R0,#+8
        LDR      R2,[R1, #+12]
        MOV      R3,#+184
        ORR      R3,R3,#0x1600
        ADD      R0,R3,R0
        LDR      R3,[R0, #+4]
        CMP      R3,#+16
        BNE      ??bi_flush_0
// 1165         put_short(s, s->bi_buf);
        ADD      R3,R2,#+1
        STR      R3,[R1, #+12]
        LDRH     R12,[R0, #+0]
        LDR      R3,[R1, #+0]
        STRB     R12,[R2, +R3]
        LDR      R2,[R1, #+12]
        ADD      R3,R2,#+1
        STR      R3,[R1, #+12]
        LDRH     R3,[R0, #+0]
        LDR      R1,[R1, #+0]
        LSR      R3,R3,#+8
        STRB     R3,[R2, +R1]
// 1166         s->bi_buf = 0;
        MOV      R1,#+0
        STRH     R1,[R0, #+0]
// 1167         s->bi_valid = 0;
        B        ??bi_flush_1
// 1168     } else if (s->bi_valid >= 8) {
??bi_flush_0:
        CMP      R3,#+8
        BXLT     LR
// 1169         put_byte(s, (Byte)s->bi_buf);
        ADD      R3,R2,#+1
        STR      R3,[R1, #+12]
        LDRH     R3,[R0, #+0]
        LDR      R1,[R1, #+0]
        STRB     R3,[R2, +R1]
// 1170         s->bi_buf >>= 8;
        LDRH     R1,[R0, #+0]
        LSR      R1,R1,#+8
        STRH     R1,[R0, #+0]
// 1171         s->bi_valid -= 8;
        LDR      R1,[R0, #+4]
        SUB      R1,R1,#+8
??bi_flush_1:
        STR      R1,[R0, #+4]
// 1172     }
// 1173 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock33

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock34 Using cfiCommon0
        CFI NoFunction
        THUMB
??bi_windup??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock34
        REQUIRE bi_windup
// 1174 
// 1175 /* ===========================================================================
// 1176  * Flush the bit buffer and align the output on a byte boundary
// 1177  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock35 Using cfiCommon1
        CFI Function bi_windup
        ARM
// 1178 local void bi_windup(s)
// 1179     deflate_state *s;
// 1180 {
// 1181     if (s->bi_valid > 8) {
bi_windup:
        ADD      R1,R0,#+8
        LDR      R2,[R1, #+12]
        MOV      R3,#+184
        ORR      R3,R3,#0x1600
        ADD      R0,R3,R0
        LDR      R3,[R0, #+4]
        CMP      R3,#+9
        BLT      ??bi_windup_0
// 1182         put_short(s, s->bi_buf);
        ADD      R3,R2,#+1
        STR      R3,[R1, #+12]
        LDRH     R12,[R0, #+0]
        LDR      R3,[R1, #+0]
        STRB     R12,[R2, +R3]
        LDR      R2,[R1, #+12]
        ADD      R3,R2,#+1
        STR      R3,[R1, #+12]
        LDRH     R3,[R0, #+0]
        LDR      R1,[R1, #+0]
        LSR      R3,R3,#+8
        B        ??bi_windup_1
// 1183     } else if (s->bi_valid > 0) {
??bi_windup_0:
        CMP      R3,#+1
        BLT      ??bi_windup_2
// 1184         put_byte(s, (Byte)s->bi_buf);
        ADD      R3,R2,#+1
        STR      R3,[R1, #+12]
        LDR      R1,[R1, #+0]
        LDRH     R3,[R0, #+0]
??bi_windup_1:
        STRB     R3,[R2, +R1]
// 1185     }
// 1186     s->bi_buf = 0;
??bi_windup_2:
        MOV      R1,#+0
        STRH     R1,[R0, #+0]
// 1187     s->bi_valid = 0;
        STR      R1,[R0, #+4]
// 1188 #ifdef DEBUG
// 1189     s->bits_sent = (s->bits_sent+7) & ~7;
// 1190 #endif
// 1191 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock35

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock36 Using cfiCommon0
        CFI NoFunction
        THUMB
??copy_block??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock36
        REQUIRE copy_block
// 1192 
// 1193 /* ===========================================================================
// 1194  * Copy a stored block, storing first the length and its
// 1195  * one's complement if requested.
// 1196  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock37 Using cfiCommon1
        CFI Function copy_block
        ARM
// 1197 local void copy_block(s, buf, len, header)
// 1198     deflate_state *s;
// 1199     charf    *buf;    /* the input data */
// 1200     unsigned len;     /* its length */
// 1201     int      header;  /* true if block header must be written */
// 1202 {
copy_block:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        MOV      R4,R1
        MOV      R6,R0
        MOV      R5,R2
        MOV      R7,R3
// 1203     bi_windup(s);        /* align on byte boundary */
        BL       bi_windup
// 1204     s->last_eob_len = 8; /* enough lookahead for inflate */
        MOV      R0,#+180
        ORR      R0,R0,#0x1600
        MOV      R1,#+8
        STR      R1,[R0, +R6]
// 1205 
// 1206     if (header) {
        ADD      R0,R6,#+8
        CMP      R7,#+0
        BEQ      ??copy_block_0
// 1207         put_short(s, (ush)len);
        LDR      R1,[R0, #+12]
        LSR      R3,R5,#+8
        ADD      R2,R1,#+1
        STR      R2,[R0, #+12]
        LDR      R2,[R0, #+0]
        STRB     R5,[R1, +R2]
        LDR      R1,[R0, #+12]
        ADD      R2,R1,#+1
        STR      R2,[R0, #+12]
        LDR      R2,[R0, #+0]
        STRB     R3,[R1, +R2]
// 1208         put_short(s, (ush)~len);
        LDR      R1,[R0, #+12]
        ADD      R2,R1,#+1
        STR      R2,[R0, #+12]
        LDR      R3,[R0, #+0]
        MOV      R2,R5
        MVN      R2,R2
        STRB     R2,[R1, +R3]
        LDR      R1,[R0, #+12]
        LSR      R2,R2,#+8
        ADD      R3,R1,#+1
        STR      R3,[R0, #+12]
        LDR      R3,[R0, #+0]
        STRB     R2,[R1, +R3]
        B        ??copy_block_0
// 1209 #ifdef DEBUG
// 1210         s->bits_sent += 2*16;
// 1211 #endif
// 1212     }
// 1213 #ifdef DEBUG
// 1214     s->bits_sent += (ulg)len<<3;
// 1215 #endif
// 1216     while (len--) {
// 1217         put_byte(s, *buf++);
??copy_block_1:
        LDR      R1,[R0, #+12]
        ADD      R2,R1,#+1
        STR      R2,[R0, #+12]
        LDRB     R3,[R4], #+1
        LDR      R2,[R0, #+0]
        STRB     R3,[R1, +R2]
// 1218     }
??copy_block_0:
        MOV      R1,R5
        SUB      R5,R1,#+1
        CMP      R1,#+0
        BNE      ??copy_block_1
// 1219 }
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock37

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for static_l_desc>`:
        DATA
        DC32 static_ltree, extra_lbits, 257, 286, 15
`?<Initializer for static_d_desc>`:
        DC32 static_dtree, extra_dbits, 0, 30, 15
`?<Initializer for static_bl_desc>`:
        DC32 0H, extra_blbits, 0, 19, 7

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        END
// 
// 7 624 bytes in segment CODE
// 2 608 bytes in segment DATA_C
//    60 bytes in segment DATA_I
//    60 bytes in segment DATA_ID
//    12 bytes in segment INITTAB
// 
// 7 548 bytes of CODE  memory (+ 88 bytes shared)
// 2 668 bytes of CONST memory
//    60 bytes of DATA  memory
//
//Errors: none
//Warnings: none
