##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    14/Feb/2012  15:39:37 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\dec_a #
#                       celp.c                                               #
#    Command line    =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\dec_a #
#                       celp.c -D NDEBUG -lC D:\SVN\SieELF\SieELF\x65_PCM_Pl #
#                       ayer\Player\Release\List\ -lA                        #
#                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\R #
#                       elease\Obj\ -s9 --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "D:\Program                 #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude       #
#                       swilib.h -I "D:\Program Files\IAR\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=16                                #
#    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\dec_acelp.lst                                    #
#    Object file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\O #
#                       bj\dec_acelp.r79                                     #
#                                                                            #
#                                                                            #
##############################################################################

D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\dec_acelp.c
      1          /*
      2           *===================================================================
      3           *  3GPP AMR Wideband Floating-point Speech Codec
      4           *===================================================================
      5           */
      6          #include "typedef.h"

  #endif
        ^
"D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\typedef.h",19  Warning[Pe001]: 
          last line of file ends without a newline
      7          #include "dec_util.h"

  #endif
        ^
"D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\typedef.h",19  Warning[Pe001]: 
          last line of file ends without a newline

  #endif
        ^
"D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\typedef.h",19  Warning[Pe001]: 
          last line of file ends without a newline

  #endif
        ^
"D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\typedef.h",19  Warning[Pe001]: 
          last line of file ends without a newline
      8          
      9          #define L_SUBFR      64    /* Subframe size              */
     10          #define PRED_ORDER   4
     11          #define MEAN_ENER    30    /* average innovation energy  */
     12          extern const Word16 D_ROM_ph_imp_low[];
     13          extern const Word16 D_ROM_ph_imp_mid[];
     14          
     15          
     16          /*
     17           * D_ACELP_add_pulse
     18           *
     19           * Parameters:
     20           *    pos         I: position of pulse
     21           *    nb_pulse    I: number of pulses
     22           *    track       I: track
     23           *    code        O: fixed codebook
     24           *
     25           * Function:
     26           *    Add pulses to fixed codebook
     27           *
     28           * Returns:
     29           *    void
     30           */
     31          static void D_ACELP_add_pulse(Word32 pos[], Word32 nb_pulse,
     32                                        Word32 track, Word16 code[])
     33          {
     34             Word32 i, k;
     35          
     36             for(k = 0; k < nb_pulse; k++)
     37             {
     38                /* i = ((pos[k] & (16-1))*NB_TRACK) + track; */
     39                i = ((pos[k] & (16 - 1)) << 2) + track;
     40          
     41                if((pos[k] & 16) == 0)
     42                {
     43                   code[i] = (Word16)(code[i] + 512);
     44                }
     45                else
     46                {
     47                   code[i] = (Word16)(code[i] - 512);
     48                }
     49             }
     50          
     51             return;
     52          }
     53          
     54          
     55          /*
     56           * D_ACELP_decode_1p_N1
     57           *
     58           * Parameters:
     59           *    index    I: pulse index
     60           *    N        I: number of bits for position
     61           *    offset   I: offset
     62           *    pos      O: position of the pulse
     63          
     64           *
     65           * Function:
     66           *    Decode 1 pulse with N+1 bits
     67           *
     68           * Returns:
     69           *    void
     70           */
     71          static void D_ACELP_decode_1p_N1(Word32 index, Word32 N,
     72                                           Word32 offset, Word32 pos[])
     73          {
     74             Word32 i, pos1, mask;
     75          
     76             mask = ((1 << N) - 1);
     77          
     78             /*
     79              * Decode 1 pulse with N+1 bits
     80              */
     81             pos1 = ((index & mask) + offset);
     82             i = ((index >> N) & 1);
     83          
     84             if(i == 1)
     85             {
     86                pos1 += 16;
     87             }
     88          
     89             pos[0] = pos1;
     90          
     91             return;
     92          }
     93          
     94          
     95          /*
     96           * D_ACELP_decode_2p_2N1
     97           *
     98           * Parameters:
     99           *    index    I: pulse index
    100           *    N        I: number of bits for position
    101           *    offset   I: offset
    102           *    pos      O: position of the pulse
    103           *
    104           * Function:
    105           *    Decode 2 pulses with 2*N+1 bits
    106           *
    107           * Returns:
    108           *    void
    109           */
    110          static void D_ACELP_decode_2p_2N1(Word32 index, Word32 N,
    111                                            Word32 offset, Word32 pos[])
    112          {
    113             Word32 i, pos1, pos2;
    114             Word32 mask;
    115          
    116             mask = ((1 << N) - 1);
    117          
    118             /*
    119              * Decode 2 pulses with 2*N+1 bits
    120              */
    121             pos1 = (((index >> N) & mask) + offset);
    122             i = (index >> (2 * N)) & 1;
    123             pos2 = ((index & mask) + offset);
    124          
    125             if((pos2 - pos1) < 0)
    126             {
    127                if(i == 1)
    128                {
    129                   pos1 += 16;
    130                }
    131                else
    132                {
    133                   pos2 += 16;
    134                }
    135             }
    136             else
    137             {
    138                if(i == 1)
    139                {
    140                   pos1 += 16;
    141                   pos2 += 16;
    142                }
    143             }
    144          
    145             pos[0] = pos1;
    146             pos[1] = pos2;
    147          
    148             return;
    149          }
    150          
    151          
    152          /*
    153           * D_ACELP_decode_3p_3N1
    154           *
    155           * Parameters:
    156           *    index    I: pulse index
    157           *    N        I: number of bits for position
    158           *    offset   I: offset
    159           *    pos      O: position of the pulse
    160           *
    161           * Function:
    162           *    Decode 3 pulses with 3*N+1 bits
    163           *
    164           * Returns:
    165           *    void
    166           */

   \                                 In segment CODE, align 4, keep-with-next
    167          static void D_ACELP_decode_3p_3N1(Word32 index, Word32 N,
    168                                            Word32 offset, Word32 pos[])
    169          {
   \                     D_ACELP_decode_3p_3N1:
   \   00000000   F0012DE9           PUSH     {R4-R8}
    170             Word32 j, mask, idx;
    171          
    172             /*
    173              * Decode 3 pulses with 3*N+1 bits
    174              */
    175             mask = ((1 << ((2 * N) - 1)) - 1);
    176             idx = index & mask;
    177             j = offset;
   \   00000004   0240A0E1           MOV      R4,R2
   \   00000008   8150A0E1           LSL      R5,R1,#+1
   \   0000000C   016045E2           SUB      R6,R5,#+1
   \   00000010   01C0A0E3           MOV      R12,#+1
   \   00000014   5056A0E1           ASR      R5,R0,R6
   \   00000018   010015E3           TST      R5,#0x1
    178          
    179             if(((index >> ((2 * N) - 1)) & 1) == 1)
    180             {
    181                j += (1 << (N - 1));
   \   0000001C   01504112           SUBNE    R5,R1,#+1
   \   00000020   1C458410           ADDNE    R4,R4,R12, LSL R5
    182             }
    183          
    184             D_ACELP_decode_2p_2N1(idx, N - 1, j, pos);
   \   00000024   015041E2           SUB      R5,R1,#+1
   \   00000028   1C66A0E1           LSL      R6,R12,R6
   \   0000002C   016046E2           SUB      R6,R6,#+1
   \   00000030   006006E0           AND      R6,R6,R0
   \   00000034   1C75A0E1           LSL      R7,R12,R5
   \   00000038   018047E2           SUB      R8,R7,#+1
   \   0000003C   567508E0           AND      R7,R8,R6, ASR R5
   \   00000040   077084E0           ADD      R7,R4,R7
   \   00000044   8550A0E1           LSL      R5,R5,#+1
   \   00000048   56550CE0           AND      R5,R12,R6, ASR R5
   \   0000004C   066008E0           AND      R6,R8,R6
   \   00000050   064084E0           ADD      R4,R4,R6
   \   00000054   076054E0           SUBS     R6,R4,R7
   \   00000058   0300005A           BPL      ??D_ACELP_decode_3p_3N1_0
   \   0000005C   010055E3           CMP      R5,#+1
   \   00000060   0400001A           BNE      ??D_ACELP_decode_3p_3N1_1
   \   00000064   107087E2           ADD      R7,R7,#+16
   \   00000068   030000EA           B        ??D_ACELP_decode_3p_3N1_2
   \                     ??D_ACELP_decode_3p_3N1_0:
   \   0000006C   010055E3           CMP      R5,#+1
   \   00000070   0100001A           BNE      ??D_ACELP_decode_3p_3N1_2
   \   00000074   107087E2           ADD      R7,R7,#+16
   \                     ??D_ACELP_decode_3p_3N1_1:
   \   00000078   104084E2           ADD      R4,R4,#+16
   \                     ??D_ACELP_decode_3p_3N1_2:
   \   0000007C   007083E5           STR      R7,[R3, #+0]
   \   00000080   044083E5           STR      R4,[R3, #+4]
    185             mask = ((1 << (N + 1)) - 1);
    186             idx = (index >> (2 * N)) & mask;
    187             D_ACELP_decode_1p_N1(idx, N, offset, pos + 2);
   \   00000084   0140A0E1           MOV      R4,R1
   \   00000088   8440A0E1           LSL      R4,R4,#+1
   \   0000008C   015081E2           ADD      R5,R1,#+1
   \   00000090   1C55A0E1           LSL      R5,R12,R5
   \   00000094   015045E2           SUB      R5,R5,#+1
   \   00000098   500405E0           AND      R0,R5,R0, ASR R4
   \   0000009C   1C41A0E1           LSL      R4,R12,R1
   \   000000A0   014044E2           SUB      R4,R4,#+1
   \   000000A4   004004E0           AND      R4,R4,R0
   \   000000A8   042082E0           ADD      R2,R2,R4
   \   000000AC   5001A0E1           ASR      R0,R0,R1
   \   000000B0   010010E3           TST      R0,#0x1
   \   000000B4   10208212           ADDNE    R2,R2,#+16
   \   000000B8   082083E5           STR      R2,[R3, #+8]
    188          
    189             return;
   \   000000BC   F001BDE8           POP      {R4-R8}
   \   000000C0   1EFF2FE1           BX       LR               ;; return
    190          }
    191          
    192          
    193          /*
    194           * D_ACELP_decode_4p_4N1
    195           *
    196           * Parameters:
    197           *    index    I: pulse index
    198           *    N        I: number of bits for position
    199           *    offset   I: offset
    200           *    pos      O: position of the pulse
    201           *
    202           * Function:
    203           *    Decode 4 pulses with 4*N+1 bits
    204           *
    205           * Returns:
    206           *    void
    207           */

   \                                 In segment CODE, align 4, keep-with-next
    208          static void D_ACELP_decode_4p_4N1(Word32 index, Word32 N,
    209                                            Word32 offset, Word32 pos[])
    210          {
   \                     D_ACELP_decode_4p_4N1:
   \   00000000   F0072DE9           PUSH     {R4-R10}
    211             Word32 j, mask, idx;
    212          
    213             /*
    214              * Decode 4 pulses with 4*N+1 bits
    215              */
    216             mask = ((1 << ((2 * N) - 1)) - 1);
    217             idx = index & mask;
    218             j = offset;
   \   00000004   0250A0E1           MOV      R5,R2
    219          
    220             if(((index >> ((2 * N) - 1)) & 1) == 1)
   \   00000008   81C0A0E1           LSL      R12,R1,#+1
   \   0000000C   01704CE2           SUB      R7,R12,#+1
   \   00000010   0140A0E3           MOV      R4,#+1
   \   00000014   5067A0E1           ASR      R6,R0,R7
   \   00000018   010016E3           TST      R6,#0x1
    221             {
    222                j += (1 << (N - 1));
   \   0000001C   01604112           SUBNE    R6,R1,#+1
   \   00000020   14568510           ADDNE    R5,R5,R4, LSL R6
    223             }
    224          
    225             D_ACELP_decode_2p_2N1(idx, N - 1, j, pos);
   \   00000024   016041E2           SUB      R6,R1,#+1
   \   00000028   1477A0E1           LSL      R7,R4,R7
   \   0000002C   017047E2           SUB      R7,R7,#+1
   \   00000030   007007E0           AND      R7,R7,R0
   \   00000034   1486A0E1           LSL      R8,R4,R6
   \   00000038   018048E2           SUB      R8,R8,#+1
   \   0000003C   579608E0           AND      R9,R8,R7, ASR R6
   \   00000040   099085E0           ADD      R9,R5,R9
   \   00000044   8660A0E1           LSL      R6,R6,#+1
   \   00000048   01A0A0E3           MOV      R10,#+1
   \   0000004C   57660AE0           AND      R6,R10,R7, ASR R6
   \   00000050   077008E0           AND      R7,R8,R7
   \   00000054   075085E0           ADD      R5,R5,R7
   \   00000058   097055E0           SUBS     R7,R5,R9
   \   0000005C   0300005A           BPL      ??D_ACELP_decode_4p_4N1_0
   \   00000060   010056E3           CMP      R6,#+1
   \   00000064   0400001A           BNE      ??D_ACELP_decode_4p_4N1_1
   \   00000068   109089E2           ADD      R9,R9,#+16
   \   0000006C   030000EA           B        ??D_ACELP_decode_4p_4N1_2
   \                     ??D_ACELP_decode_4p_4N1_0:
   \   00000070   010056E3           CMP      R6,#+1
   \   00000074   0100001A           BNE      ??D_ACELP_decode_4p_4N1_2
   \   00000078   109089E2           ADD      R9,R9,#+16
   \                     ??D_ACELP_decode_4p_4N1_1:
   \   0000007C   105085E2           ADD      R5,R5,#+16
   \                     ??D_ACELP_decode_4p_4N1_2:
   \   00000080   009083E5           STR      R9,[R3, #+0]
   \   00000084   045083E5           STR      R5,[R3, #+4]
    226             mask = ((1 << ((2 * N) + 1)) - 1);
    227             idx = (index >> (2 * N)) & mask;
    228             D_ACELP_decode_2p_2N1(idx, N, offset, pos + 2);
   \   00000088   083083E2           ADD      R3,R3,#+8
   \   0000008C   0150A0E1           MOV      R5,R1
   \   00000090   8550A0E1           LSL      R5,R5,#+1
   \   00000094   01608CE2           ADD      R6,R12,#+1
   \   00000098   1466A0E1           LSL      R6,R4,R6
   \   0000009C   016046E2           SUB      R6,R6,#+1
   \   000000A0   500506E0           AND      R0,R6,R0, ASR R5
   \   000000A4   1441A0E1           LSL      R4,R4,R1
   \   000000A8   014044E2           SUB      R4,R4,#+1
   \   000000AC   501104E0           AND      R1,R4,R0, ASR R1
   \   000000B0   011082E0           ADD      R1,R2,R1
   \   000000B4   50550AE0           AND      R5,R10,R0, ASR R5
   \   000000B8   000004E0           AND      R0,R4,R0
   \   000000BC   000082E0           ADD      R0,R2,R0
   \   000000C0   012050E0           SUBS     R2,R0,R1
   \   000000C4   0300005A           BPL      ??D_ACELP_decode_4p_4N1_3
   \   000000C8   010055E3           CMP      R5,#+1
   \   000000CC   0400001A           BNE      ??D_ACELP_decode_4p_4N1_4
   \   000000D0   101081E2           ADD      R1,R1,#+16
   \   000000D4   030000EA           B        ??D_ACELP_decode_4p_4N1_5
   \                     ??D_ACELP_decode_4p_4N1_3:
   \   000000D8   010055E3           CMP      R5,#+1
   \   000000DC   0100001A           BNE      ??D_ACELP_decode_4p_4N1_5
   \   000000E0   101081E2           ADD      R1,R1,#+16
   \                     ??D_ACELP_decode_4p_4N1_4:
   \   000000E4   100080E2           ADD      R0,R0,#+16
   \                     ??D_ACELP_decode_4p_4N1_5:
   \   000000E8   001083E5           STR      R1,[R3, #+0]
   \   000000EC   040083E5           STR      R0,[R3, #+4]
    229          
    230             return;
   \   000000F0   F007BDE8           POP      {R4-R10}
   \   000000F4   1EFF2FE1           BX       LR               ;; return
    231          }
    232          
    233          
    234          /*
    235           * D_ACELP_decode_4p_4N
    236           *
    237           * Parameters:
    238           *    index    I: pulse index
    239           *    N        I: number of bits for position
    240           *    offset   I: offset
    241           *    pos      O: position of the pulse
    242           *
    243           * Function:
    244           *    Decode 4 pulses with 4*N bits
    245           *
    246           * Returns:
    247           *    void
    248           */

   \                                 In segment CODE, align 4, keep-with-next
    249          static void D_ACELP_decode_4p_4N(Word32 index, Word32 N,
    250                                           Word32 offset, Word32 pos[])
    251          {
   \                     D_ACELP_decode_4p_4N:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0350A0E1           MOV      R5,R3
    252             Word32 j, n_1;
    253          
    254             /*
    255              * Decode 4 pulses with 4*N bits
    256              */
    257             n_1 = N - 1;
   \   0000000C   016041E2           SUB      R6,R1,#+1
    258             j = offset + (1 << n_1);
   \   00000010   0100A0E3           MOV      R0,#+1
   \   00000014   1086A0E1           LSL      R8,R0,R6
   \   00000018   027088E0           ADD      R7,R8,R2
    259          
    260             switch((index >> ((4 * N) - 2)) & 3)
   \   0000001C   0101A0E1           LSL      R0,R1,#+2
   \   00000020   020040E2           SUB      R0,R0,#+2
   \   00000024   5400A0E1           ASR      R0,R4,R0
   \   00000028   030010E2           ANDS     R0,R0,#0x3
   \   0000002C   0600000A           BEQ      ??D_ACELP_decode_4p_4N_0
   \   00000030   010050E2           SUBS     R0,R0,#+1
   \   00000034   0D00000A           BEQ      ??D_ACELP_decode_4p_4N_1
   \   00000038   010050E2           SUBS     R0,R0,#+1
   \   0000003C   1B00000A           BEQ      ??D_ACELP_decode_4p_4N_2
   \   00000040   010050E2           SUBS     R0,R0,#+1
   \   00000044   4700000A           BEQ      ??D_ACELP_decode_4p_4N_3
   \   00000048   F081BDE8           POP      {R4-R8,PC}
    261             {
    262             case 0:
    263                if(((index >> ((4 * n_1) + 1)) & 1) == 0)
   \                     ??D_ACELP_decode_4p_4N_0:
   \   0000004C   0100A0E3           MOV      R0,#+1
   \   00000050   060180E0           ADD      R0,R0,R6, LSL #+2
   \   00000054   5400A0E1           ASR      R0,R4,R0
   \   00000058   010010E3           TST      R0,#0x1
    264                {
    265                   D_ACELP_decode_4p_4N1(index, n_1, offset, pos);
    266                }
    267                else
    268                {
    269                   D_ACELP_decode_4p_4N1(index, n_1, j, pos);
   \   0000005C   0720A011           MOVNE    R2,R7
   \   00000060   0610A0E1           MOV      R1,R6
   \   00000064   0400A0E1           MOV      R0,R4
   \   00000068   ........           BL       D_ACELP_decode_4p_4N1
   \   0000006C   F081BDE8           POP      {R4-R8,PC}
    270                }
    271                break;
    272          
    273             case 1:
    274                D_ACELP_decode_1p_N1((index >> ((3 * n_1) + 1)), n_1, offset, pos);
   \                     ??D_ACELP_decode_4p_4N_1:
   \   00000070   860086E0           ADD      R0,R6,R6, LSL #+1
   \   00000074   010080E2           ADD      R0,R0,#+1
   \   00000078   5400A0E1           ASR      R0,R4,R0
   \   0000007C   011048E2           SUB      R1,R8,#+1
   \   00000080   001001E0           AND      R1,R1,R0
   \   00000084   011082E0           ADD      R1,R2,R1
   \   00000088   5006A0E1           ASR      R0,R0,R6
   \   0000008C   010010E3           TST      R0,#0x1
   \   00000090   10108112           ADDNE    R1,R1,#+16
   \   00000094   001085E5           STR      R1,[R5, #+0]
    275                D_ACELP_decode_3p_3N1(index, n_1, j, pos + 1);
   \   00000098   043085E2           ADD      R3,R5,#+4
   \   0000009C   0720A0E1           MOV      R2,R7
   \   000000A0   0610A0E1           MOV      R1,R6
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   ........           BL       D_ACELP_decode_3p_3N1
   \   000000AC   F081BDE8           POP      {R4-R8,PC}
    276                break;
    277          
    278             case 2:
    279                D_ACELP_decode_2p_2N1((index >> ((2 * n_1) + 1)), n_1, offset, pos);
   \                     ??D_ACELP_decode_4p_4N_2:
   \   000000B0   0100A0E3           MOV      R0,#+1
   \   000000B4   860080E0           ADD      R0,R0,R6, LSL #+1
   \   000000B8   54C0A0E1           ASR      R12,R4,R0
   \   000000BC   010048E2           SUB      R0,R8,#+1
   \   000000C0   5C1600E0           AND      R1,R0,R12, ASR R6
   \   000000C4   013082E0           ADD      R3,R2,R1
   \   000000C8   0610A0E1           MOV      R1,R6
   \   000000CC   8110A0E1           LSL      R1,R1,#+1
   \   000000D0   0180A0E3           MOV      R8,#+1
   \   000000D4   5C8108E0           AND      R8,R8,R12, ASR R1
   \   000000D8   0CC000E0           AND      R12,R0,R12
   \   000000DC   0C2082E0           ADD      R2,R2,R12
   \   000000E0   03C052E0           SUBS     R12,R2,R3
   \   000000E4   0300005A           BPL      ??D_ACELP_decode_4p_4N_4
   \   000000E8   010058E3           CMP      R8,#+1
   \   000000EC   0400001A           BNE      ??D_ACELP_decode_4p_4N_5
   \   000000F0   103083E2           ADD      R3,R3,#+16
   \   000000F4   030000EA           B        ??D_ACELP_decode_4p_4N_6
   \                     ??D_ACELP_decode_4p_4N_4:
   \   000000F8   010058E3           CMP      R8,#+1
   \   000000FC   0100001A           BNE      ??D_ACELP_decode_4p_4N_6
   \   00000100   103083E2           ADD      R3,R3,#+16
   \                     ??D_ACELP_decode_4p_4N_5:
   \   00000104   102082E2           ADD      R2,R2,#+16
   \                     ??D_ACELP_decode_4p_4N_6:
   \   00000108   003085E5           STR      R3,[R5, #+0]
   \   0000010C   042085E5           STR      R2,[R5, #+4]
    280                D_ACELP_decode_2p_2N1(index, n_1, j, pos + 2);
   \   00000110   082085E2           ADD      R2,R5,#+8
   \   00000114   543600E0           AND      R3,R0,R4, ASR R6
   \   00000118   033087E0           ADD      R3,R7,R3
   \   0000011C   0150A0E3           MOV      R5,#+1
   \   00000120   541105E0           AND      R1,R5,R4, ASR R1
   \   00000124   040000E0           AND      R0,R0,R4
   \   00000128   000087E0           ADD      R0,R7,R0
   \   0000012C   034050E0           SUBS     R4,R0,R3
   \   00000130   0500005A           BPL      ??D_ACELP_decode_4p_4N_7
   \   00000134   010051E3           CMP      R1,#+1
   \   00000138   0600001A           BNE      ??D_ACELP_decode_4p_4N_8
   \   0000013C   103083E2           ADD      R3,R3,#+16
   \   00000140   003082E5           STR      R3,[R2, #+0]
   \   00000144   040082E5           STR      R0,[R2, #+4]
   \   00000148   F081BDE8           POP      {R4-R8,PC}
   \                     ??D_ACELP_decode_4p_4N_7:
   \   0000014C   010051E3           CMP      R1,#+1
   \   00000150   0100001A           BNE      ??D_ACELP_decode_4p_4N_9
   \   00000154   103083E2           ADD      R3,R3,#+16
   \                     ??D_ACELP_decode_4p_4N_8:
   \   00000158   100080E2           ADD      R0,R0,#+16
   \                     ??D_ACELP_decode_4p_4N_9:
   \   0000015C   003082E5           STR      R3,[R2, #+0]
   \   00000160   040082E5           STR      R0,[R2, #+4]
   \   00000164   F081BDE8           POP      {R4-R8,PC}
    281                break;
    282          
    283             case 3:
    284                D_ACELP_decode_3p_3N1((index >> (n_1 + 1)), n_1, offset, pos);
   \                     ??D_ACELP_decode_4p_4N_3:
   \   00000168   0610A0E1           MOV      R1,R6
   \   0000016C   010086E2           ADD      R0,R6,#+1
   \   00000170   5400A0E1           ASR      R0,R4,R0
   \   00000174   ........           BL       D_ACELP_decode_3p_3N1
    285                D_ACELP_decode_1p_N1(index, n_1, j, pos + 3);
   \   00000178   010048E2           SUB      R0,R8,#+1
   \   0000017C   040000E0           AND      R0,R0,R4
   \   00000180   000087E0           ADD      R0,R7,R0
   \   00000184   5416A0E1           ASR      R1,R4,R6
   \   00000188   010011E3           TST      R1,#0x1
   \   0000018C   10008012           ADDNE    R0,R0,#+16
   \   00000190   0C0085E5           STR      R0,[R5, #+12]
    286                break;
    287             }
    288          
    289             return;
   \   00000194   F081BDE8           POP      {R4-R8,PC}       ;; return
    290          }
    291          
    292          
    293          /*
    294           * D_ACELP_decode_5p_5N
    295           *
    296           * Parameters:
    297           *    index    I: pulse index
    298           *    N        I: number of bits for position
    299           *    offset   I: offset
    300           *    pos      O: position of the pulse
    301           *
    302           * Function:
    303           *    Decode 5 pulses with 5*N bits
    304           *
    305           * Returns:
    306           *    void
    307           */

   \                                 In segment CODE, align 4, keep-with-next
    308          static void D_ACELP_decode_5p_5N(Word32 index, Word32 N,
    309                                           Word32 offset, Word32 pos[])
    310          {
   \                     D_ACELP_decode_5p_5N:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   0040A0E1           MOV      R4,R0
   \   00000008   0150A0E1           MOV      R5,R1
   \   0000000C   0260A0E1           MOV      R6,R2
    311             Word32 j, n_1;
    312             Word32 idx;
    313          
    314             /*
    315              * Decode 5 pulses with 5*N bits
    316              */
    317             n_1 = N - 1;
   \   00000010   011045E2           SUB      R1,R5,#+1
    318             j = offset + (1 << n_1);
    319             idx = (index >> ((2 * N) + 1));
   \   00000014   0100A0E3           MOV      R0,#+1
   \   00000018   850080E0           ADD      R0,R0,R5, LSL #+1
   \   0000001C   5400A0E1           ASR      R0,R4,R0
    320          
    321             if(((index >> ((5 * N) - 1)) & 1) == 0)
   \   00000020   0520A0E1           MOV      R2,R5
   \   00000024   8220A0E1           LSL      R2,R2,#+1
   \   00000028   0170A0E3           MOV      R7,#+1
   \   0000002C   547207E0           AND      R7,R7,R4, ASR R2
   \   00000030   0120A0E3           MOV      R2,#+1
   \   00000034   1285A0E1           LSL      R8,R2,R5
   \   00000038   018048E2           SUB      R8,R8,#+1
   \   0000003C   0C9083E2           ADD      R9,R3,#+12
   \   00000040   05C185E0           ADD      R12,R5,R5, LSL #+2
   \   00000044   01C04CE2           SUB      R12,R12,#+1
   \   00000048   54CCA0E1           ASR      R12,R4,R12
   \   0000004C   01001CE3           TST      R12,#0x1
   \   00000050   0F00001A           BNE      ??D_ACELP_decode_5p_5N_0
    322             {
    323                D_ACELP_decode_3p_3N1(idx, n_1, offset, pos);
   \   00000054   0620A0E1           MOV      R2,R6
   \   00000058   ........           BL       D_ACELP_decode_3p_3N1
    324                D_ACELP_decode_2p_2N1(index, N, offset, pos + 3);
   \   0000005C   540508E0           AND      R0,R8,R4, ASR R5
   \   00000060   000086E0           ADD      R0,R6,R0
   \   00000064   041008E0           AND      R1,R8,R4
   \   00000068   011086E0           ADD      R1,R6,R1
   \   0000006C   002051E0           SUBS     R2,R1,R0
   \   00000070   0200005A           BPL      ??D_ACELP_decode_5p_5N_1
   \   00000074   010057E3           CMP      R7,#+1
   \   00000078   0300001A           BNE      ??D_ACELP_decode_5p_5N_2
   \   0000007C   0E0000EA           B        ??D_ACELP_decode_5p_5N_3
   \                     ??D_ACELP_decode_5p_5N_1:
   \   00000080   010057E3           CMP      R7,#+1
   \   00000084   1400001A           BNE      ??D_ACELP_decode_5p_5N_4
   \   00000088   100080E2           ADD      R0,R0,#+16
   \                     ??D_ACELP_decode_5p_5N_2:
   \   0000008C   101081E2           ADD      R1,R1,#+16
   \   00000090   0A0000EA           B        ??D_ACELP_decode_5p_5N_5
    325             }
    326             else
    327             {
    328                D_ACELP_decode_3p_3N1(idx, n_1, j, pos);
   \                     ??D_ACELP_decode_5p_5N_0:
   \   00000094   122186E0           ADD      R2,R6,R2, LSL R1
   \   00000098   ........           BL       D_ACELP_decode_3p_3N1
    329                D_ACELP_decode_2p_2N1(index, N, offset, pos + 3);
   \   0000009C   540508E0           AND      R0,R8,R4, ASR R5
   \   000000A0   000086E0           ADD      R0,R6,R0
   \   000000A4   041008E0           AND      R1,R8,R4
   \   000000A8   011086E0           ADD      R1,R6,R1
   \   000000AC   002051E0           SUBS     R2,R1,R0
   \   000000B0   0500005A           BPL      ??D_ACELP_decode_5p_5N_6
   \   000000B4   010057E3           CMP      R7,#+1
   \   000000B8   0600001A           BNE      ??D_ACELP_decode_5p_5N_7
   \                     ??D_ACELP_decode_5p_5N_3:
   \   000000BC   100080E2           ADD      R0,R0,#+16
   \                     ??D_ACELP_decode_5p_5N_5:
   \   000000C0   000089E5           STR      R0,[R9, #+0]
   \   000000C4   041089E5           STR      R1,[R9, #+4]
   \   000000C8   F083BDE8           POP      {R4-R9,PC}
   \                     ??D_ACELP_decode_5p_5N_6:
   \   000000CC   010057E3           CMP      R7,#+1
   \   000000D0   0100001A           BNE      ??D_ACELP_decode_5p_5N_4
   \   000000D4   100080E2           ADD      R0,R0,#+16
   \                     ??D_ACELP_decode_5p_5N_7:
   \   000000D8   101081E2           ADD      R1,R1,#+16
   \                     ??D_ACELP_decode_5p_5N_4:
   \   000000DC   000089E5           STR      R0,[R9, #+0]
   \   000000E0   041089E5           STR      R1,[R9, #+4]
    330             }
    331          
    332             return;
   \   000000E4   F083BDE8           POP      {R4-R9,PC}       ;; return
    333          }
    334          
    335          
    336          /*
    337           * D_ACELP_decode_6p_6N_2
    338           *
    339           * Parameters:
    340           *    index    I: pulse index
    341           *    N        I: number of bits for position
    342           *    offset   I: offset
    343           *    pos      O: position of the pulse
    344           *
    345           * Function:
    346           *    Decode 6 pulses with 6*N-2 bits
    347           *
    348           * Returns:
    349           *    void
    350           */

   \                                 In segment CODE, align 4, keep-with-next
    351          static void D_ACELP_decode_6p_6N_2(Word32 index, Word32 N,
    352                                             Word32 offset, Word32 pos[])
    353          {
   \                     D_ACELP_decode_6p_6N_2:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   08D04DE2           SUB      SP,SP,#+8
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0350A0E1           MOV      R5,R3
    354             Word32 j, n_1, offsetA, offsetB;
    355          
    356             n_1 = N - 1;
   \   00000010   016041E2           SUB      R6,R1,#+1
    357             j = offset + (1 << n_1);
   \   00000014   0100A0E3           MOV      R0,#+1
   \   00000018   1076A0E1           LSL      R7,R0,R6
    358             offsetA = offsetB = j;
    359          
    360             if(((index >> ((6 * N) - 5)) & 1) == 0)
   \   0000001C   0600A0E3           MOV      R0,#+6
   \   00000020   900103E0           MUL      R3,R0,R1
    361             {
    362                offsetA = offset;
    363             }
    364             else
    365             {
    366                offsetB = offset;
   \   00000024   01B047E2           SUB      R11,R7,#+1
   \   00000028   04B00BE0           AND      R11,R11,R4
   \   0000002C   00B08DE5           STR      R11,[SP, #+0]
   \   00000030   00B09DE5           LDR      R11,[SP, #+0]
   \   00000034   028087E0           ADD      R8,R7,R2
   \   00000038   08A0A0E1           MOV      R10,R8
   \   0000003C   0A90A0E1           MOV      R9,R10
   \   00000040   050043E2           SUB      R0,R3,#+5
   \   00000044   5400A0E1           ASR      R0,R4,R0
   \   00000048   010010E3           TST      R0,#0x1
   \   0000004C   0290A001           MOVEQ    R9,R2
   \   00000050   02A0A011           MOVNE    R10,R2
   \   00000054   0BB08AE0           ADD      R11,R10,R11
   \   00000058   04B08DE5           STR      R11,[SP, #+4]
   \   0000005C   54B6A0E1           ASR      R11,R4,R6
   \   00000060   5401A0E1           ASR      R0,R4,R1
   \   00000064   041043E2           SUB      R1,R3,#+4
   \   00000068   5411A0E1           ASR      R1,R4,R1
   \   0000006C   031011E2           ANDS     R1,R1,#0x3
   \   00000070   0600000A           BEQ      ??D_ACELP_decode_6p_6N_2_0
   \   00000074   011051E2           SUBS     R1,R1,#+1
   \   00000078   0B00000A           BEQ      ??D_ACELP_decode_6p_6N_2_1
   \   0000007C   011051E2           SUBS     R1,R1,#+1
   \   00000080   1200000A           BEQ      ??D_ACELP_decode_6p_6N_2_2
   \   00000084   011051E2           SUBS     R1,R1,#+1
   \   00000088   2E00000A           BEQ      ??D_ACELP_decode_6p_6N_2_3
   \   0000008C   F38FBDE8           POP      {R0,R1,R4-R11,PC}
    367             }
    368          
    369             switch((index >> ((6 * N) - 4)) & 3)
    370             {
    371                case 0:
    372                   D_ACELP_decode_5p_5N(index >> N, n_1, offsetA, pos);
   \                     ??D_ACELP_decode_6p_6N_2_0:
   \   00000090   0530A0E1           MOV      R3,R5
   \   00000094   0920A0E1           MOV      R2,R9
   \   00000098   0610A0E1           MOV      R1,R6
   \   0000009C   ........           BL       D_ACELP_decode_5p_5N
    373                   D_ACELP_decode_1p_N1(index, n_1, offsetA, pos + 5);
   \   000000A0   00009DE5           LDR      R0,[SP, #+0]
   \   000000A4   000089E0           ADD      R0,R9,R0
   \   000000A8   040000EA           B        ??D_ACELP_decode_6p_6N_2_4
    374                   break;
    375          
    376                case 1:
    377                   D_ACELP_decode_5p_5N(index >> N, n_1, offsetA, pos);
   \                     ??D_ACELP_decode_6p_6N_2_1:
   \   000000AC   0530A0E1           MOV      R3,R5
   \   000000B0   0920A0E1           MOV      R2,R9
   \   000000B4   0610A0E1           MOV      R1,R6
   \   000000B8   ........           BL       D_ACELP_decode_5p_5N
    378                   D_ACELP_decode_1p_N1(index, n_1, offsetB, pos + 5);
   \   000000BC   04009DE5           LDR      R0,[SP, #+4]
   \                     ??D_ACELP_decode_6p_6N_2_4:
   \   000000C0   01001BE3           TST      R11,#0x1
   \   000000C4   10008012           ADDNE    R0,R0,#+16
   \   000000C8   140085E5           STR      R0,[R5, #+20]
   \   000000CC   F38FBDE8           POP      {R0,R1,R4-R11,PC}
    379                   break;
    380          
    381                case 2:
    382                   D_ACELP_decode_4p_4N(index >> ((2 * n_1) + 1), n_1, offsetA, pos);
   \                     ??D_ACELP_decode_6p_6N_2_2:
   \   000000D0   0530A0E1           MOV      R3,R5
   \   000000D4   0920A0E1           MOV      R2,R9
   \   000000D8   0610A0E1           MOV      R1,R6
   \   000000DC   0100A0E3           MOV      R0,#+1
   \   000000E0   860080E0           ADD      R0,R0,R6, LSL #+1
   \   000000E4   5400A0E1           ASR      R0,R4,R0
   \   000000E8   ........           BL       D_ACELP_decode_4p_4N
    383                   D_ACELP_decode_2p_2N1(index, n_1, offsetB, pos + 4);
   \   000000EC   8620A0E1           LSL      R2,R6,#+1
   \   000000F0   0130A0E3           MOV      R3,#+1
   \   000000F4   542203E0           AND      R2,R3,R4, ASR R2
   \   000000F8   04309DE5           LDR      R3,[SP, #+4]
   \   000000FC   100085E2           ADD      R0,R5,#+16
   \   00000100   011047E2           SUB      R1,R7,#+1
   \   00000104   0B1001E0           AND      R1,R1,R11
   \   00000108   01108AE0           ADD      R1,R10,R1
   \   0000010C   014053E0           SUBS     R4,R3,R1
   \   00000110   0500005A           BPL      ??D_ACELP_decode_6p_6N_2_5
   \   00000114   010052E3           CMP      R2,#+1
   \   00000118   0600001A           BNE      ??D_ACELP_decode_6p_6N_2_6
   \   0000011C   101081E2           ADD      R1,R1,#+16
   \   00000120   001080E5           STR      R1,[R0, #+0]
   \   00000124   043080E5           STR      R3,[R0, #+4]
   \   00000128   F38FBDE8           POP      {R0,R1,R4-R11,PC}
   \                     ??D_ACELP_decode_6p_6N_2_5:
   \   0000012C   010052E3           CMP      R2,#+1
   \   00000130   0100001A           BNE      ??D_ACELP_decode_6p_6N_2_7
   \   00000134   101081E2           ADD      R1,R1,#+16
   \                     ??D_ACELP_decode_6p_6N_2_6:
   \   00000138   103083E2           ADD      R3,R3,#+16
   \                     ??D_ACELP_decode_6p_6N_2_7:
   \   0000013C   001080E5           STR      R1,[R0, #+0]
   \   00000140   043080E5           STR      R3,[R0, #+4]
   \   00000144   F38FBDE8           POP      {R0,R1,R4-R11,PC}
    384                   break;
    385          
    386                case 3:
    387                   D_ACELP_decode_3p_3N1(index >> ((3 * n_1) + 1), n_1, offset, pos);
   \                     ??D_ACELP_decode_6p_6N_2_3:
   \   00000148   0530A0E1           MOV      R3,R5
   \   0000014C   0610A0E1           MOV      R1,R6
   \   00000150   860086E0           ADD      R0,R6,R6, LSL #+1
   \   00000154   010080E2           ADD      R0,R0,#+1
   \   00000158   5400A0E1           ASR      R0,R4,R0
   \   0000015C   ........           BL       D_ACELP_decode_3p_3N1
    388                   D_ACELP_decode_3p_3N1(index, n_1, j, pos + 3);
   \   00000160   0C3085E2           ADD      R3,R5,#+12
   \   00000164   0820A0E1           MOV      R2,R8
   \   00000168   0610A0E1           MOV      R1,R6
   \   0000016C   0400A0E1           MOV      R0,R4
   \   00000170   ........           BL       D_ACELP_decode_3p_3N1
    389                   break;
    390             }
    391          
    392             return;
   \   00000174   F38FBDE8           POP      {R0,R1,R4-R11,PC}  ;; return
    393          }
    394          
    395          
    396          /*
    397           * D_ACELP_decode_2t
    398           *
    399           * Parameters:
    400           *    index          I: 12 bits index
    401           *    code           O: (Q9) algebraic (fixed) codebook excitation
    402           *
    403           * Function:
    404           *    12 bits algebraic codebook decoder.
    405           *    2 tracks x 32 positions per track = 64 samples.
    406           *
    407           *    12 bits --> 2 pulses in a frame of 64 samples.
    408           *
    409           *    All pulses can have two (2) possible amplitudes: +1 or -1.
    410           *    Each pulse can have 32 possible positions.
    411           *
    412           *    codevector length    64
    413           *    number of track      2
    414           *    number of position   32
    415           *
    416           * Returns:
    417           *    void
    418           */

   \                                 In segment CODE, align 4, keep-with-next
    419          void D_ACELP_decode_2t(Word16 index, Word16 code[])
    420          {
   \                     D_ACELP_decode_2t:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    421             Word32 i0, i1;
    422          
    423             memset(code, 0, 64 * sizeof(Word16));
   \   00000004   8020A0E3           MOV      R2,#+128
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   0010A0E3           MOV      R1,#+0
   \   00000014   0500A0E1           MOV      R0,R5
   \   00000018   BB0000EF           SWI      +187
    424          
    425             /* decode the positions and signs of pulses and build the codeword */
    426             i0 = (index >> 5) & 0x0000003E;
   \   0000001C   0400A0E1           MOV      R0,R4
   \   00000020   3E10A0E3           MOV      R1,#+62
   \   00000024   C01201E0           AND      R1,R1,R0, ASR #+5
    427             i1 = ((index & 0x0000001F) << 1) + 1;
   \   00000028   1F2000E2           AND      R2,R0,#0x1F
   \   0000002C   0130A0E3           MOV      R3,#+1
   \   00000030   822083E0           ADD      R2,R3,R2, LSL #+1
    428          
    429             if(((index >> 6) & 32) == 0)
   \   00000034   803FA0E3           MOV      R3,#+512
   \   00000038   00C063E2           RSB      R12,R3,#+0
   \   0000003C   4003A0E1           ASR      R0,R0,#+6
   \   00000040   200010E3           TST      R0,#0x20
   \   00000044   810085E0           ADD      R0,R5,R1, LSL #+1
    430             {
    431                code[i0] = 512;
   \   00000048   B030C001           STRHEQ   R3,[R0, #+0]
    432             }
    433             else
    434             {
    435                code[i0] = -512;
   \   0000004C   B0C0C011           STRHNE   R12,[R0, #+0]
    436             }
    437          
    438             if((index & 32) == 0)
   \   00000050   820085E0           ADD      R0,R5,R2, LSL #+1
   \   00000054   200014E3           TST      R4,#0x20
    439             {
    440                code[i1] = 512;
   \   00000058   B030C001           STRHEQ   R3,[R0, #+0]
   \   0000005C   3080BD08           POPEQ    {R4,R5,PC}
    441             }
    442             else
    443             {
    444                code[i1] = -512;
   \   00000060   B0C0C0E1           STRH     R12,[R0, #+0]
    445             }
    446          
    447             return;
   \   00000064   3080BDE8           POP      {R4,R5,PC}       ;; return
    448          }
    449          
    450          
    451          /*
    452           * D_ACELP_decode_4t
    453           *
    454           * Parameters:
    455           *    index          I: index
    456           *    mode           I: speech mode
    457           *    code           I: (Q9) algebraic (fixed) codebook excitation
    458           *
    459           * Function:
    460           *    20, 36, 44, 52, 64, 72, 88 bits algebraic codebook.
    461           *    4 tracks x 16 positions per track = 64 samples.
    462           *
    463           *    20 bits 5+5+5+5 --> 4 pulses in a frame of 64 samples.
    464           *    36 bits 9+9+9+9 --> 8 pulses in a frame of 64 samples.
    465           *    44 bits 13+9+13+9 --> 10 pulses in a frame of 64 samples.
    466           *    52 bits 13+13+13+13 --> 12 pulses in a frame of 64 samples.
    467           *    64 bits 2+2+2+2+14+14+14+14 --> 16 pulses in a frame of 64 samples.
    468           *    72 bits 10+2+10+2+10+14+10+14 --> 18 pulses in a frame of 64 samples.
    469           *    88 bits 11+11+11+11+11+11+11+11 --> 24 pulses in a frame of 64 samples.
    470           *
    471           *    All pulses can have two (2) possible amplitudes: +1 or -1.
    472           *    Each pulse can sixteen (16) possible positions.
    473           *
    474           *    codevector length    64
    475           *    number of track      4
    476           *    number of position   16
    477           *
    478           * Returns:
    479           *    void
    480           */

   \                                 In segment CODE, align 4, keep-with-next
    481          void D_ACELP_decode_4t(Word16 index[], Word16 nbbits, Word16 code[])
    482          {
   \                     D_ACELP_decode_4t:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0250A0E1           MOV      R5,R2
    483             Word32 k, L_index, pos[6];
    484          
    485             memset(code, 0, 64 * sizeof(Word16));
   \   00000014   8020A0E3           MOV      R2,#+128
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   BB0000EF           SWI      +187
    486          
    487             /* decode the positions and signs of pulses and build the codeword */
    488             if(nbbits == 20)
   \   00000024   140056E3           CMP      R6,#+20
   \   00000028   1B00001A           BNE      ??D_ACELP_decode_4t_0
    489             {
    490                for(k = 0; k < 4; k++)
   \   0000002C   0060A0E3           MOV      R6,#+0
   \   00000030   FF30E0E3           MVN      R3,#+255
   \   00000034   403FC3E3           BIC      R3,R3,#0x100
   \   00000038   060000EA           B        ??D_ACELP_decode_4t_1
    491                {
   \                     ??D_ACELP_decode_4t_2:
   \   0000003C   B020C0E1           STRH     R2,[R0, #+0]
   \   00000040   011081E2           ADD      R1,R1,#+1
   \   00000044   010051E3           CMP      R1,#+1
   \   00000048   090000BA           BLT      ??D_ACELP_decode_4t_3
    492                   L_index = index[k];
    493                   D_ACELP_decode_1p_N1(L_index, 4, 0, pos);
    494                   D_ACELP_add_pulse(pos, 1, k, code);
   \   0000004C   016086E2           ADD      R6,R6,#+1
   \   00000050   040056E3           CMP      R6,#+4
   \   00000054   180100AA           BGE      ??D_ACELP_decode_4t_4
   \                     ??D_ACELP_decode_4t_1:
   \   00000058   860084E0           ADD      R0,R4,R6, LSL #+1
   \   0000005C   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000060   0F1000E2           AND      R1,R0,#0xF
   \   00000064   100010E3           TST      R0,#0x10
   \   00000068   10108112           ADDNE    R1,R1,#+16
   \   0000006C   00108DE5           STR      R1,[SP, #+0]
   \   00000070   0010A0E3           MOV      R1,#+0
   \                     ??D_ACELP_decode_4t_3:
   \   00000074   0D00A0E1           MOV      R0,SP
   \   00000078   012190E7           LDR      R2,[R0, +R1, LSL #+2]
   \   0000007C   0F0002E2           AND      R0,R2,#0xF
   \   00000080   000186E0           ADD      R0,R6,R0, LSL #+2
   \   00000084   100012E3           TST      R2,#0x10
   \   00000088   800085E0           ADD      R0,R5,R0, LSL #+1
   \   0000008C   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000090   02208310           ADDNE    R2,R3,R2
   \   00000094   802F8202           ADDEQ    R2,R2,#+512
   \   00000098   E7FFFFEA           B        ??D_ACELP_decode_4t_2
    495                }
    496             }
    497             else if(nbbits == 36)
   \                     ??D_ACELP_decode_4t_0:
   \   0000009C   240056E3           CMP      R6,#+36
   \   000000A0   2800001A           BNE      ??D_ACELP_decode_4t_5
    498             {
    499                for(k = 0; k < 4; k++)
   \   000000A4   0060A0E3           MOV      R6,#+0
   \   000000A8   060000EA           B        ??D_ACELP_decode_4t_6
    500                {
   \                     ??D_ACELP_decode_4t_7:
   \   000000AC   B020C0E1           STRH     R2,[R0, #+0]
   \   000000B0   011081E2           ADD      R1,R1,#+1
   \   000000B4   020051E3           CMP      R1,#+2
   \   000000B8   180000BA           BLT      ??D_ACELP_decode_4t_8
    501                   L_index = index[k];
    502                   D_ACELP_decode_2p_2N1(L_index, 4, 0, pos);
    503                   D_ACELP_add_pulse(pos, 2, k, code);
   \   000000BC   016086E2           ADD      R6,R6,#+1
   \   000000C0   040056E3           CMP      R6,#+4
   \   000000C4   FC0000AA           BGE      ??D_ACELP_decode_4t_4
   \                     ??D_ACELP_decode_4t_6:
   \   000000C8   860084E0           ADD      R0,R4,R6, LSL #+1
   \   000000CC   F000D0E1           LDRSH    R0,[R0, #+0]
   \   000000D0   0F10A0E3           MOV      R1,#+15
   \   000000D4   0120A0E3           MOV      R2,#+1
   \   000000D8   401201E0           AND      R1,R1,R0, ASR #+4
   \   000000DC   402402E0           AND      R2,R2,R0, ASR #+8
   \   000000E0   0F0000E2           AND      R0,R0,#0xF
   \   000000E4   013050E0           SUBS     R3,R0,R1
   \   000000E8   0300005A           BPL      ??D_ACELP_decode_4t_9
   \   000000EC   010052E3           CMP      R2,#+1
   \   000000F0   0400001A           BNE      ??D_ACELP_decode_4t_10
   \   000000F4   101081E2           ADD      R1,R1,#+16
   \   000000F8   030000EA           B        ??D_ACELP_decode_4t_11
   \                     ??D_ACELP_decode_4t_9:
   \   000000FC   010052E3           CMP      R2,#+1
   \   00000100   0100001A           BNE      ??D_ACELP_decode_4t_11
   \   00000104   101081E2           ADD      R1,R1,#+16
   \                     ??D_ACELP_decode_4t_10:
   \   00000108   100080E2           ADD      R0,R0,#+16
   \                     ??D_ACELP_decode_4t_11:
   \   0000010C   00108DE5           STR      R1,[SP, #+0]
   \   00000110   04008DE5           STR      R0,[SP, #+4]
   \   00000114   0010A0E3           MOV      R1,#+0
   \   00000118   FF30E0E3           MVN      R3,#+255
   \   0000011C   403FC3E3           BIC      R3,R3,#0x100
   \                     ??D_ACELP_decode_4t_8:
   \   00000120   0D00A0E1           MOV      R0,SP
   \   00000124   012190E7           LDR      R2,[R0, +R1, LSL #+2]
   \   00000128   0F0002E2           AND      R0,R2,#0xF
   \   0000012C   000186E0           ADD      R0,R6,R0, LSL #+2
   \   00000130   100012E3           TST      R2,#0x10
   \   00000134   800085E0           ADD      R0,R5,R0, LSL #+1
   \   00000138   F020D0E1           LDRSH    R2,[R0, #+0]
   \   0000013C   02208310           ADDNE    R2,R3,R2
   \   00000140   802F8202           ADDEQ    R2,R2,#+512
   \   00000144   D8FFFFEA           B        ??D_ACELP_decode_4t_7
    504                }
    505             }
    506             else if(nbbits == 44)
   \                     ??D_ACELP_decode_4t_5:
   \   00000148   2C0056E3           CMP      R6,#+44
   \   0000014C   4200001A           BNE      ??D_ACELP_decode_4t_12
    507             {
    508                for(k = 0; k < 4 - 2; k++)
   \   00000150   0060A0E3           MOV      R6,#+0
    509                {
    510                   L_index = index[k];
    511                   D_ACELP_decode_3p_3N1(L_index, 4, 0, pos);
   \                     ??D_ACELP_decode_4t_13:
   \   00000154   860084E0           ADD      R0,R4,R6, LSL #+1
   \   00000158   F000D0E1           LDRSH    R0,[R0, #+0]
   \   0000015C   0D30A0E1           MOV      R3,SP
   \   00000160   0020A0E3           MOV      R2,#+0
   \   00000164   0410A0E3           MOV      R1,#+4
   \   00000168   ........           BL       D_ACELP_decode_3p_3N1
    512                   D_ACELP_add_pulse(pos, 3, k, code);
   \   0000016C   0000A0E3           MOV      R0,#+0
   \   00000170   FF30E0E3           MVN      R3,#+255
   \   00000174   403FC3E3           BIC      R3,R3,#0x100
   \                     ??D_ACELP_decode_4t_14:
   \   00000178   0D10A0E1           MOV      R1,SP
   \   0000017C   001191E7           LDR      R1,[R1, +R0, LSL #+2]
   \   00000180   0F2001E2           AND      R2,R1,#0xF
   \   00000184   022186E0           ADD      R2,R6,R2, LSL #+2
   \   00000188   100011E3           TST      R1,#0x10
   \   0000018C   821085E0           ADD      R1,R5,R2, LSL #+1
   \   00000190   F020D1E1           LDRSH    R2,[R1, #+0]
   \   00000194   010080E2           ADD      R0,R0,#+1
   \   00000198   802F8202           ADDEQ    R2,R2,#+512
   \   0000019C   02208310           ADDNE    R2,R3,R2
   \   000001A0   B020C1E1           STRH     R2,[R1, #+0]
   \   000001A4   030050E3           CMP      R0,#+3
   \   000001A8   F2FFFFBA           BLT      ??D_ACELP_decode_4t_14
    513                }
   \   000001AC   016086E2           ADD      R6,R6,#+1
   \   000001B0   020056E3           CMP      R6,#+2
   \   000001B4   E6FFFFBA           BLT      ??D_ACELP_decode_4t_13
    514          
    515                for(k = 2; k < 4; k++)
   \   000001B8   0260A0E3           MOV      R6,#+2
   \   000001BC   060000EA           B        ??D_ACELP_decode_4t_15
    516                {
   \                     ??D_ACELP_decode_4t_16:
   \   000001C0   B020C0E1           STRH     R2,[R0, #+0]
   \   000001C4   011081E2           ADD      R1,R1,#+1
   \   000001C8   020051E3           CMP      R1,#+2
   \   000001CC   180000BA           BLT      ??D_ACELP_decode_4t_17
    517                   L_index = index[k];
    518                   D_ACELP_decode_2p_2N1(L_index, 4, 0, pos);
    519                   D_ACELP_add_pulse(pos, 2, k, code);
   \   000001D0   016086E2           ADD      R6,R6,#+1
   \   000001D4   040056E3           CMP      R6,#+4
   \   000001D8   B70000AA           BGE      ??D_ACELP_decode_4t_4
   \                     ??D_ACELP_decode_4t_15:
   \   000001DC   860084E0           ADD      R0,R4,R6, LSL #+1
   \   000001E0   F000D0E1           LDRSH    R0,[R0, #+0]
   \   000001E4   0F10A0E3           MOV      R1,#+15
   \   000001E8   0120A0E3           MOV      R2,#+1
   \   000001EC   401201E0           AND      R1,R1,R0, ASR #+4
   \   000001F0   402402E0           AND      R2,R2,R0, ASR #+8
   \   000001F4   0F0000E2           AND      R0,R0,#0xF
   \   000001F8   013050E0           SUBS     R3,R0,R1
   \   000001FC   0300005A           BPL      ??D_ACELP_decode_4t_18
   \   00000200   010052E3           CMP      R2,#+1
   \   00000204   0400001A           BNE      ??D_ACELP_decode_4t_19
   \   00000208   101081E2           ADD      R1,R1,#+16
   \   0000020C   030000EA           B        ??D_ACELP_decode_4t_20
   \                     ??D_ACELP_decode_4t_18:
   \   00000210   010052E3           CMP      R2,#+1
   \   00000214   0100001A           BNE      ??D_ACELP_decode_4t_20
   \   00000218   101081E2           ADD      R1,R1,#+16
   \                     ??D_ACELP_decode_4t_19:
   \   0000021C   100080E2           ADD      R0,R0,#+16
   \                     ??D_ACELP_decode_4t_20:
   \   00000220   00108DE5           STR      R1,[SP, #+0]
   \   00000224   04008DE5           STR      R0,[SP, #+4]
   \   00000228   0010A0E3           MOV      R1,#+0
   \   0000022C   FF30E0E3           MVN      R3,#+255
   \   00000230   403FC3E3           BIC      R3,R3,#0x100
   \                     ??D_ACELP_decode_4t_17:
   \   00000234   0D00A0E1           MOV      R0,SP
   \   00000238   012190E7           LDR      R2,[R0, +R1, LSL #+2]
   \   0000023C   0F0002E2           AND      R0,R2,#0xF
   \   00000240   000186E0           ADD      R0,R6,R0, LSL #+2
   \   00000244   100012E3           TST      R2,#0x10
   \   00000248   800085E0           ADD      R0,R5,R0, LSL #+1
   \   0000024C   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000250   02208310           ADDNE    R2,R3,R2
   \   00000254   802F8202           ADDEQ    R2,R2,#+512
   \   00000258   D8FFFFEA           B        ??D_ACELP_decode_4t_16
    520                }
    521             }
    522             else if(nbbits == 52)
   \                     ??D_ACELP_decode_4t_12:
   \   0000025C   340056E3           CMP      R6,#+52
   \   00000260   1B00001A           BNE      ??D_ACELP_decode_4t_21
    523             {
    524                for(k = 0; k < 4; k++)
   \   00000264   0060A0E3           MOV      R6,#+0
   \   00000268   060000EA           B        ??D_ACELP_decode_4t_22
    525                {
   \                     ??D_ACELP_decode_4t_23:
   \   0000026C   B020C0E1           STRH     R2,[R0, #+0]
   \   00000270   011081E2           ADD      R1,R1,#+1
   \   00000274   030051E3           CMP      R1,#+3
   \   00000278   0B0000BA           BLT      ??D_ACELP_decode_4t_24
    526                   L_index = index[k];
    527                   D_ACELP_decode_3p_3N1(L_index, 4, 0, pos);
    528                   D_ACELP_add_pulse(pos, 3, k, code);
   \   0000027C   016086E2           ADD      R6,R6,#+1
   \   00000280   040056E3           CMP      R6,#+4
   \   00000284   8C0000AA           BGE      ??D_ACELP_decode_4t_4
   \                     ??D_ACELP_decode_4t_22:
   \   00000288   0D30A0E1           MOV      R3,SP
   \   0000028C   0020A0E3           MOV      R2,#+0
   \   00000290   0410A0E3           MOV      R1,#+4
   \   00000294   860084E0           ADD      R0,R4,R6, LSL #+1
   \   00000298   F000D0E1           LDRSH    R0,[R0, #+0]
   \   0000029C   ........           BL       D_ACELP_decode_3p_3N1
   \   000002A0   0010A0E3           MOV      R1,#+0
   \   000002A4   FF30E0E3           MVN      R3,#+255
   \   000002A8   403FC3E3           BIC      R3,R3,#0x100
   \                     ??D_ACELP_decode_4t_24:
   \   000002AC   0D00A0E1           MOV      R0,SP
   \   000002B0   012190E7           LDR      R2,[R0, +R1, LSL #+2]
   \   000002B4   0F0002E2           AND      R0,R2,#0xF
   \   000002B8   000186E0           ADD      R0,R6,R0, LSL #+2
   \   000002BC   100012E3           TST      R2,#0x10
   \   000002C0   800085E0           ADD      R0,R5,R0, LSL #+1
   \   000002C4   F020D0E1           LDRSH    R2,[R0, #+0]
   \   000002C8   02208310           ADDNE    R2,R3,R2
   \   000002CC   802F8202           ADDEQ    R2,R2,#+512
   \   000002D0   E5FFFFEA           B        ??D_ACELP_decode_4t_23
    529                }
    530             }
    531             else if(nbbits == 64)
   \                     ??D_ACELP_decode_4t_21:
   \   000002D4   400056E3           CMP      R6,#+64
   \   000002D8   1D00001A           BNE      ??D_ACELP_decode_4t_25
    532             {
    533                for(k = 0; k < 4; k++)
   \   000002DC   0060A0E3           MOV      R6,#+0
   \   000002E0   060000EA           B        ??D_ACELP_decode_4t_26
    534                {
   \                     ??D_ACELP_decode_4t_27:
   \   000002E4   B020C0E1           STRH     R2,[R0, #+0]
   \   000002E8   011081E2           ADD      R1,R1,#+1
   \   000002EC   040051E3           CMP      R1,#+4
   \   000002F0   0D0000BA           BLT      ??D_ACELP_decode_4t_28
    535                   L_index = ((index[k] << 14) + index[k + 4]);
    536                   D_ACELP_decode_4p_4N(L_index, 4, 0, pos);
    537                   D_ACELP_add_pulse(pos, 4, k, code);
   \   000002F4   016086E2           ADD      R6,R6,#+1
   \   000002F8   040056E3           CMP      R6,#+4
   \   000002FC   6E0000AA           BGE      ??D_ACELP_decode_4t_4
   \                     ??D_ACELP_decode_4t_26:
   \   00000300   860084E0           ADD      R0,R4,R6, LSL #+1
   \   00000304   F0C0D0E1           LDRSH    R12,[R0, #+0]
   \   00000308   F800D0E1           LDRSH    R0,[R0, #+8]
   \   0000030C   0D30A0E1           MOV      R3,SP
   \   00000310   0020A0E3           MOV      R2,#+0
   \   00000314   0410A0E3           MOV      R1,#+4
   \   00000318   0C0780E0           ADD      R0,R0,R12, LSL #+14
   \   0000031C   ........           BL       D_ACELP_decode_4p_4N
   \   00000320   0010A0E3           MOV      R1,#+0
   \   00000324   FF30E0E3           MVN      R3,#+255
   \   00000328   403FC3E3           BIC      R3,R3,#0x100
   \                     ??D_ACELP_decode_4t_28:
   \   0000032C   0D00A0E1           MOV      R0,SP
   \   00000330   012190E7           LDR      R2,[R0, +R1, LSL #+2]
   \   00000334   0F0002E2           AND      R0,R2,#0xF
   \   00000338   000186E0           ADD      R0,R6,R0, LSL #+2
   \   0000033C   100012E3           TST      R2,#0x10
   \   00000340   800085E0           ADD      R0,R5,R0, LSL #+1
   \   00000344   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000348   02208310           ADDNE    R2,R3,R2
   \   0000034C   802F8202           ADDEQ    R2,R2,#+512
   \   00000350   E3FFFFEA           B        ??D_ACELP_decode_4t_27
    538                }
    539             }
    540             else if(nbbits == 72)
   \                     ??D_ACELP_decode_4t_25:
   \   00000354   480056E3           CMP      R6,#+72
   \   00000358   3900001A           BNE      ??D_ACELP_decode_4t_29
    541             {
    542                for(k = 0; k < 4 - 2; k++)
   \   0000035C   0060A0E3           MOV      R6,#+0
    543                {
    544                   L_index = ((index[k] << 10) + index[k + 4]);
    545                   D_ACELP_decode_5p_5N(L_index, 4, 0, pos);
   \                     ??D_ACELP_decode_4t_30:
   \   00000360   860084E0           ADD      R0,R4,R6, LSL #+1
   \   00000364   F0C0D0E1           LDRSH    R12,[R0, #+0]
   \   00000368   F800D0E1           LDRSH    R0,[R0, #+8]
   \   0000036C   0D30A0E1           MOV      R3,SP
   \   00000370   0020A0E3           MOV      R2,#+0
   \   00000374   0410A0E3           MOV      R1,#+4
   \   00000378   0C0580E0           ADD      R0,R0,R12, LSL #+10
   \   0000037C   ........           BL       D_ACELP_decode_5p_5N
    546                   D_ACELP_add_pulse(pos, 5, k, code);
   \   00000380   0000A0E3           MOV      R0,#+0
   \   00000384   FF30E0E3           MVN      R3,#+255
   \   00000388   403FC3E3           BIC      R3,R3,#0x100
   \                     ??D_ACELP_decode_4t_31:
   \   0000038C   0D10A0E1           MOV      R1,SP
   \   00000390   001191E7           LDR      R1,[R1, +R0, LSL #+2]
   \   00000394   0F2001E2           AND      R2,R1,#0xF
   \   00000398   022186E0           ADD      R2,R6,R2, LSL #+2
   \   0000039C   100011E3           TST      R1,#0x10
   \   000003A0   821085E0           ADD      R1,R5,R2, LSL #+1
   \   000003A4   F020D1E1           LDRSH    R2,[R1, #+0]
   \   000003A8   010080E2           ADD      R0,R0,#+1
   \   000003AC   802F8202           ADDEQ    R2,R2,#+512
   \   000003B0   02208310           ADDNE    R2,R3,R2
   \   000003B4   B020C1E1           STRH     R2,[R1, #+0]
   \   000003B8   050050E3           CMP      R0,#+5
   \   000003BC   F2FFFFBA           BLT      ??D_ACELP_decode_4t_31
    547                }
   \   000003C0   016086E2           ADD      R6,R6,#+1
   \   000003C4   020056E3           CMP      R6,#+2
   \   000003C8   E4FFFFBA           BLT      ??D_ACELP_decode_4t_30
    548          
    549                for(k = 2; k < 4; k++)
   \   000003CC   0260A0E3           MOV      R6,#+2
   \   000003D0   060000EA           B        ??D_ACELP_decode_4t_32
    550                {
   \                     ??D_ACELP_decode_4t_33:
   \   000003D4   B020C0E1           STRH     R2,[R0, #+0]
   \   000003D8   011081E2           ADD      R1,R1,#+1
   \   000003DC   040051E3           CMP      R1,#+4
   \   000003E0   0D0000BA           BLT      ??D_ACELP_decode_4t_34
    551                   L_index = ((index[k] << 14) + index[k + 4]);
    552                   D_ACELP_decode_4p_4N(L_index, 4, 0, pos);
    553                   D_ACELP_add_pulse(pos, 4, k, code);
   \   000003E4   016086E2           ADD      R6,R6,#+1
   \   000003E8   040056E3           CMP      R6,#+4
   \   000003EC   320000AA           BGE      ??D_ACELP_decode_4t_4
   \                     ??D_ACELP_decode_4t_32:
   \   000003F0   860084E0           ADD      R0,R4,R6, LSL #+1
   \   000003F4   F0C0D0E1           LDRSH    R12,[R0, #+0]
   \   000003F8   F800D0E1           LDRSH    R0,[R0, #+8]
   \   000003FC   0D30A0E1           MOV      R3,SP
   \   00000400   0020A0E3           MOV      R2,#+0
   \   00000404   0410A0E3           MOV      R1,#+4
   \   00000408   0C0780E0           ADD      R0,R0,R12, LSL #+14
   \   0000040C   ........           BL       D_ACELP_decode_4p_4N
   \   00000410   0010A0E3           MOV      R1,#+0
   \   00000414   FF30E0E3           MVN      R3,#+255
   \   00000418   403FC3E3           BIC      R3,R3,#0x100
   \                     ??D_ACELP_decode_4t_34:
   \   0000041C   0D00A0E1           MOV      R0,SP
   \   00000420   012190E7           LDR      R2,[R0, +R1, LSL #+2]
   \   00000424   0F0002E2           AND      R0,R2,#0xF
   \   00000428   000186E0           ADD      R0,R6,R0, LSL #+2
   \   0000042C   100012E3           TST      R2,#0x10
   \   00000430   800085E0           ADD      R0,R5,R0, LSL #+1
   \   00000434   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000438   02208310           ADDNE    R2,R3,R2
   \   0000043C   802F8202           ADDEQ    R2,R2,#+512
   \   00000440   E3FFFFEA           B        ??D_ACELP_decode_4t_33
    554                }
    555             }
    556             else if(nbbits == 88)
   \                     ??D_ACELP_decode_4t_29:
   \   00000444   580056E3           CMP      R6,#+88
   \   00000448   1B00001A           BNE      ??D_ACELP_decode_4t_4
    557             {
    558                for(k = 0; k < 4; k++)
   \   0000044C   0060A0E3           MOV      R6,#+0
    559                {
    560                   L_index = ((index[k] << 11) + index[k + 4]);
    561                   D_ACELP_decode_6p_6N_2(L_index, 4, 0, pos);
   \                     ??D_ACELP_decode_4t_35:
   \   00000450   860084E0           ADD      R0,R4,R6, LSL #+1
   \   00000454   F0C0D0E1           LDRSH    R12,[R0, #+0]
   \   00000458   F800D0E1           LDRSH    R0,[R0, #+8]
   \   0000045C   0D30A0E1           MOV      R3,SP
   \   00000460   0020A0E3           MOV      R2,#+0
   \   00000464   0410A0E3           MOV      R1,#+4
   \   00000468   8C0580E0           ADD      R0,R0,R12, LSL #+11
   \   0000046C   ........           BL       D_ACELP_decode_6p_6N_2
    562                   D_ACELP_add_pulse(pos, 6, k, code);
   \   00000470   0000A0E3           MOV      R0,#+0
   \   00000474   FF30E0E3           MVN      R3,#+255
   \   00000478   403FC3E3           BIC      R3,R3,#0x100
   \                     ??D_ACELP_decode_4t_36:
   \   0000047C   0D10A0E1           MOV      R1,SP
   \   00000480   001191E7           LDR      R1,[R1, +R0, LSL #+2]
   \   00000484   0F2001E2           AND      R2,R1,#0xF
   \   00000488   022186E0           ADD      R2,R6,R2, LSL #+2
   \   0000048C   100011E3           TST      R1,#0x10
   \   00000490   821085E0           ADD      R1,R5,R2, LSL #+1
   \   00000494   F020D1E1           LDRSH    R2,[R1, #+0]
   \   00000498   010080E2           ADD      R0,R0,#+1
   \   0000049C   802F8202           ADDEQ    R2,R2,#+512
   \   000004A0   02208310           ADDNE    R2,R3,R2
   \   000004A4   B020C1E1           STRH     R2,[R1, #+0]
   \   000004A8   060050E3           CMP      R0,#+6
   \   000004AC   F2FFFFBA           BLT      ??D_ACELP_decode_4t_36
    563                }
   \   000004B0   016086E2           ADD      R6,R6,#+1
   \   000004B4   040056E3           CMP      R6,#+4
   \   000004B8   E4FFFFBA           BLT      ??D_ACELP_decode_4t_35
    564             }
    565             return;
   \                     ??D_ACELP_decode_4t_4:
   \   000004BC   18D08DE2           ADD      SP,SP,#+24       ;; stack cleaning
   \   000004C0   7080BDE8           POP      {R4-R6,PC}       ;; return
    566          }
    567          
    568          
    569          /*
    570           * D_ACELP_phase_dispersion
    571           *
    572           * Parameters:
    573           *    gain_code         I: (Q0) gain of code
    574           *    gain_pit          I: (Q14) gain of pitch
    575           *    code            I/O: code vector
    576           *    mode              I: level, 0=hi, 1=lo, 2=off
    577           *    disp_mem        I/O: static memory (size = 8)
    578           *
    579           * Function:
    580           *    An adaptive anti-sparseness post-processing procedure is
    581           *    applied to the fixed codebook vector in order to
    582           *    reduce perceptual artifacts arising from the sparseness
    583           *    of the algebraic fixed codebook vectors with only
    584           *    a few non-zero samples per subframe.
    585           *
    586           * Returns:
    587           *    void
    588           */

   \                                 In segment CODE, align 4, keep-with-next
    589          void D_ACELP_phase_dispersion(Word16 gain_code, Word16 gain_pit, Word16 code[],
    590                                        Word16 mode, Word16 disp_mem[])
    591          {
   \                     D_ACELP_phase_dispersion:
   \   00000000   F0072DE9           PUSH     {R4-R10}
   \   00000004   80DF4DE2           SUB      SP,SP,#+512
   \   00000008   1C429DE5           LDR      R4,[SP, #+540]
    592             Word32 code2[2 * L_SUBFR] = {0};
   \   0000000C   0D50A0E1           MOV      R5,SP
   \   00000010   0060A0E3           MOV      R6,#+0
   \   00000014   807FA0E3           MOV      R7,#+512
   \                     ??D_ACELP_phase_dispersion_0:
   \   00000018   047057E2           SUBS     R7,R7,#+4
   \   0000001C   076085E7           STR      R6,[R5, R7]
   \   00000020   FCFFFF1A           BNE      ??D_ACELP_phase_dispersion_0
    593             Word32 i, j, state;
    594             Word16 *prev_gain_pit, *prev_gain_code, *prev_state;
    595          
    596             prev_state = disp_mem;
    597             prev_gain_code = disp_mem + 1;
   \   00000024   025084E2           ADD      R5,R4,#+2
    598             prev_gain_pit = disp_mem + 2;
   \   00000028   046084E2           ADD      R6,R4,#+4
    599          
    600             if(gain_pit < 9830)   /* 0.6 in Q14 */
   \   0000002C   6670A0E3           MOV      R7,#+102
   \   00000030   987D87E3           ORR      R7,R7,#0x2600
   \   00000034   070051E1           CMP      R1,R7
    601             {
    602                state = 0;
   \   00000038   0080A0B3           MOVLT    R8,#+0
   \   0000003C   040000BA           BLT      ??D_ACELP_phase_dispersion_1
    603             }
    604             else if(gain_pit < 14746)   /* 0.9 in Q14 */
   \   00000040   9A80A0E3           MOV      R8,#+154
   \   00000044   E48D88E3           ORR      R8,R8,#0x3900
   \   00000048   080051E1           CMP      R1,R8
    605             {
    606                state = 1;
   \   0000004C   0180A0B3           MOVLT    R8,#+1
    607             }
    608             else
    609             {
    610                state = 2;
   \   00000050   0280A0A3           MOVGE    R8,#+2
    611             }
    612          
    613             for(i = 5; i > 0; i--)
   \                     ??D_ACELP_phase_dispersion_1:
   \   00000054   05C0A0E3           MOV      R12,#+5
    614             {
    615                prev_gain_pit[i] = prev_gain_pit[i - 1];
   \                     ??D_ACELP_phase_dispersion_2:
   \   00000058   8C9086E0           ADD      R9,R6,R12, LSL #+1
   \   0000005C   F2A059E1           LDRSH    R10,[R9, #-2]
    616             }
   \   00000060   01C04CE2           SUB      R12,R12,#+1
   \   00000064   01005CE3           CMP      R12,#+1
   \   00000068   B0A0C9E1           STRH     R10,[R9, #+0]
   \   0000006C   F9FFFFAA           BGE      ??D_ACELP_phase_dispersion_2
    617             prev_gain_pit[0] = gain_pit;
   \   00000070   B010C6E1           STRH     R1,[R6, #+0]
    618          
    619             if((gain_code - *prev_gain_code) > (*prev_gain_code << 1))
   \   00000074   F010D5E1           LDRSH    R1,[R5, #+0]
   \   00000078   019040E0           SUB      R9,R0,R1
   \   0000007C   810059E1           CMP      R9,R1, LSL #+1
   \   00000080   030000DA           BLE      ??D_ACELP_phase_dispersion_3
    620             {
    621                /* onset */
    622                if(state < 2)
   \   00000084   020058E3           CMP      R8,#+2
   \   00000088   100000AA           BGE      ??D_ACELP_phase_dispersion_4
    623                {
    624                   state = state + 1;
   \   0000008C   018088E2           ADD      R8,R8,#+1
   \   00000090   0E0000EA           B        ??D_ACELP_phase_dispersion_4
    625                }
    626             }
    627             else
    628             {
    629                j = 0;
   \                     ??D_ACELP_phase_dispersion_3:
   \   00000094   0010A0E3           MOV      R1,#+0
    630          
    631                for(i = 0; i < 6; i++)
   \   00000098   00C0A0E3           MOV      R12,#+0
    632                {
    633                   if(prev_gain_pit[i] < 9830)   /* 0.6 in Q14 */
   \                     ??D_ACELP_phase_dispersion_5:
   \   0000009C   8C9086E0           ADD      R9,R6,R12, LSL #+1
   \   000000A0   F090D9E1           LDRSH    R9,[R9, #+0]
    634                      j = (j + 1);
    635                }
   \   000000A4   01C08CE2           ADD      R12,R12,#+1
   \   000000A8   070059E1           CMP      R9,R7
   \   000000AC   011081B2           ADDLT    R1,R1,#+1
   \   000000B0   06005CE3           CMP      R12,#+6
   \   000000B4   F8FFFFBA           BLT      ??D_ACELP_phase_dispersion_5
    636          
    637                if(j > 2)
   \   000000B8   030051E3           CMP      R1,#+3
    638                {
    639                   state = 0;
    640                }
    641          
    642                if((state - *prev_state) > 1)
   \   000000BC   F010D4E1           LDRSH    R1,[R4, #+0]
   \   000000C0   0080A0A3           MOVGE    R8,#+0
   \   000000C4   011048E0           SUB      R1,R8,R1
   \   000000C8   020051E3           CMP      R1,#+2
    643                {
    644                   state = state - 1;
   \   000000CC   018048A2           SUBGE    R8,R8,#+1
    645                }
    646             }
    647             *prev_gain_code = gain_code;
   \                     ??D_ACELP_phase_dispersion_4:
   \   000000D0   B000C5E1           STRH     R0,[R5, #+0]
    648             *prev_state = (Word16)state;
   \   000000D4   B080C4E1           STRH     R8,[R4, #+0]
    649          
    650             /* circular convolution */
    651             state = state + mode;   /* level of dispersion */
   \   000000D8   080093E0           ADDS     R0,R3,R8
    652          
    653             if(state == 0)
   \   000000DC   1800001A           BNE      ??D_ACELP_phase_dispersion_6
    654             {
    655                for(i = 0; i < L_SUBFR; i++)
   \   000000E0   00C0A0E3           MOV      R12,#+0
    656                {
    657                   if(code[i] != 0)
   \                     ??D_ACELP_phase_dispersion_7:
   \   000000E4   8C0082E0           ADD      R0,R2,R12, LSL #+1
   \   000000E8   F010D0E1           LDRSH    R1,[R0, #+0]
   \   000000EC   000051E3           CMP      R1,#+0
   \   000000F0   0F00000A           BEQ      ??D_ACELP_phase_dispersion_8
    658                   {
    659                      for(j = 0; j < L_SUBFR; j++)
   \   000000F4   0010A0E3           MOV      R1,#+0
   \                     ??D_ACELP_phase_dispersion_9:
   \   000000F8   F0609FE5           LDR      R6,??D_ACELP_phase_dispersion_10  ;; D_ROM_ph_imp_low
   \   000000FC   F050D0E1           LDRSH    R5,[R0, #+0]
   \   00000100   816086E0           ADD      R6,R6,R1, LSL #+1
   \   00000104   F060D6E1           LDRSH    R6,[R6, #+0]
   \   00000108   0C3081E0           ADD      R3,R1,R12
   \   0000010C   0D40A0E1           MOV      R4,SP
   \   00000110   033184E0           ADD      R3,R4,R3, LSL #+2
   \   00000114   004093E5           LDR      R4,[R3, #+0]
   \   00000118   960505E0           MUL      R5,R6,R5
    660                      {
    661                         code2[i + j] = code2[i + j] +
    662                            (((code[i] * D_ROM_ph_imp_low[j]) + 0x4000) >> 15);
   \   0000011C   011081E2           ADD      R1,R1,#+1
   \   00000120   405C85E2           ADD      R5,R5,#+16384
   \   00000124   C54784E0           ADD      R4,R4,R5, ASR #+15
   \   00000128   004083E5           STR      R4,[R3, #+0]
   \   0000012C   400051E3           CMP      R1,#+64
   \   00000130   F0FFFFBA           BLT      ??D_ACELP_phase_dispersion_9
    663                      }
    664                   }
    665                }
   \                     ??D_ACELP_phase_dispersion_8:
   \   00000134   01C08CE2           ADD      R12,R12,#+1
   \   00000138   40005CE3           CMP      R12,#+64
   \   0000013C   1D0000AA           BGE      ??D_ACELP_phase_dispersion_11
   \   00000140   E7FFFFEA           B        ??D_ACELP_phase_dispersion_7
    666             }
    667             else if(state == 1)
   \                     ??D_ACELP_phase_dispersion_6:
   \   00000144   010050E3           CMP      R0,#+1
   \   00000148   1800001A           BNE      ??D_ACELP_phase_dispersion_12
    668             {
    669                for(i = 0; i < L_SUBFR; i++)
   \   0000014C   00C0A0E3           MOV      R12,#+0
    670                {
    671                   if(code[i] != 0)
   \                     ??D_ACELP_phase_dispersion_13:
   \   00000150   8C0082E0           ADD      R0,R2,R12, LSL #+1
   \   00000154   F010D0E1           LDRSH    R1,[R0, #+0]
   \   00000158   000051E3           CMP      R1,#+0
   \   0000015C   0F00000A           BEQ      ??D_ACELP_phase_dispersion_14
    672                   {
    673                      for(j = 0; j < L_SUBFR; j++)
   \   00000160   0010A0E3           MOV      R1,#+0
   \                     ??D_ACELP_phase_dispersion_15:
   \   00000164   88609FE5           LDR      R6,??D_ACELP_phase_dispersion_10+0x4  ;; D_ROM_ph_imp_mid
   \   00000168   F050D0E1           LDRSH    R5,[R0, #+0]
   \   0000016C   816086E0           ADD      R6,R6,R1, LSL #+1
   \   00000170   F060D6E1           LDRSH    R6,[R6, #+0]
   \   00000174   0C3081E0           ADD      R3,R1,R12
   \   00000178   0D40A0E1           MOV      R4,SP
   \   0000017C   033184E0           ADD      R3,R4,R3, LSL #+2
   \   00000180   004093E5           LDR      R4,[R3, #+0]
   \   00000184   960505E0           MUL      R5,R6,R5
    674                      {
    675                         code2[i + j] = code2[i + j] +
    676                            (((code[i] * D_ROM_ph_imp_mid[j]) + 0x4000) >> 15);
   \   00000188   011081E2           ADD      R1,R1,#+1
   \   0000018C   405C85E2           ADD      R5,R5,#+16384
   \   00000190   C54784E0           ADD      R4,R4,R5, ASR #+15
   \   00000194   004083E5           STR      R4,[R3, #+0]
   \   00000198   400051E3           CMP      R1,#+64
   \   0000019C   F0FFFFBA           BLT      ??D_ACELP_phase_dispersion_15
    677                      }
    678                   }
    679                }
   \                     ??D_ACELP_phase_dispersion_14:
   \   000001A0   01C08CE2           ADD      R12,R12,#+1
   \   000001A4   40005CE3           CMP      R12,#+64
   \   000001A8   020000AA           BGE      ??D_ACELP_phase_dispersion_11
   \   000001AC   E7FFFFEA           B        ??D_ACELP_phase_dispersion_13
    680             }
    681          
    682             if(state < 2)
   \                     ??D_ACELP_phase_dispersion_12:
   \   000001B0   020050E3           CMP      R0,#+2
   \   000001B4   0A0000AA           BGE      ??D_ACELP_phase_dispersion_16
    683             {
    684                for(i = 0; i < L_SUBFR; i++)
   \                     ??D_ACELP_phase_dispersion_11:
   \   000001B8   00C0A0E3           MOV      R12,#+0
    685                {
    686                   code[i] = (Word16)(code2[i] + code2[i + L_SUBFR]);
   \                     ??D_ACELP_phase_dispersion_17:
   \   000001BC   0D00A0E1           MOV      R0,SP
   \   000001C0   0C0180E0           ADD      R0,R0,R12, LSL #+2
   \   000001C4   003090E5           LDR      R3,[R0, #+0]
   \   000001C8   000190E5           LDR      R0,[R0, #+256]
   \   000001CC   8C1082E0           ADD      R1,R2,R12, LSL #+1
   \   000001D0   030080E0           ADD      R0,R0,R3
   \   000001D4   B000C1E1           STRH     R0,[R1, #+0]
    687                }
   \   000001D8   01C08CE2           ADD      R12,R12,#+1
   \   000001DC   40005CE3           CMP      R12,#+64
   \   000001E0   F5FFFFBA           BLT      ??D_ACELP_phase_dispersion_17
    688             }
    689          
    690             return;
   \                     ??D_ACELP_phase_dispersion_16:
   \   000001E4   80DF8DE2           ADD      SP,SP,#+512
   \   000001E8   F007BDE8           POP      {R4-R10}
   \   000001EC   1EFF2FE1           BX       LR               ;; return
   \                     ??D_ACELP_phase_dispersion_10:
   \   000001F0   ........           DC32     D_ROM_ph_imp_low
   \   000001F4   ........           DC32     D_ROM_ph_imp_mid
    691          }

   \                                 In segment DATA_C, align 4, align-sorted
   \   00000000   00000000           DC32 0
   \   00000004   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000014   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000024   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000034   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000044   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000054   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000064   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000074   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000084   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000094   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000A4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000B4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000C4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000D4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000E4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000F4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000104   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000114   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000124   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000134   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000144   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000154   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000164   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000174   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000184   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000194   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001A4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001B4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001C4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001D4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001E4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001F4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000

   Maximum stack usage in bytes:

     Function                 CSTACK
     --------                 ------
     D_ACELP_decode_2t           12
     D_ACELP_decode_3p_3N1       24
     D_ACELP_decode_4p_4N        24
     D_ACELP_decode_4p_4N1       28
     D_ACELP_decode_4t           40
     D_ACELP_decode_5p_5N        28
     D_ACELP_decode_6p_6N_2      44
     D_ACELP_phase_dispersion   540


   Segment part sizes:

     Function/Label           Bytes
     --------------           -----
     D_ACELP_decode_3p_3N1     196
     D_ACELP_decode_4p_4N1     248
     D_ACELP_decode_4p_4N      408
     D_ACELP_decode_5p_5N      232
     D_ACELP_decode_6p_6N_2    376
     D_ACELP_decode_2t         104
     D_ACELP_decode_4t        1220
     D_ACELP_phase_dispersion  504
     ?<Constant {0L}>          512
      Others                    32

 
 3 320 bytes in segment CODE
   512 bytes in segment DATA_C
 
 3 288 bytes of CODE  memory (+ 32 bytes shared)
   512 bytes of CONST memory

Errors: none
Warnings: 4
