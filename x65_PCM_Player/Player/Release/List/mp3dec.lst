##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    14/Feb/2012  15:39:49 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\MP3\mp3de #
#                       c\mp3dec.c                                           #
#    Command line    =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\MP3\mp3de #
#                       c\mp3dec.c -D NDEBUG -lC D:\SVN\SieELF\SieELF\x65_PC #
#                       M_Player\Player\Release\List\ -lA                    #
#                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\R #
#                       elease\Obj\ -s9 --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "D:\Program                 #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude       #
#                       swilib.h -I "D:\Program Files\IAR\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=16                                #
#    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\mp3dec.lst                                       #
#    Object file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\O #
#                       bj\mp3dec.r79                                        #
#                                                                            #
#                                                                            #
##############################################################################

D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\MP3\mp3dec\mp3dec.c
      1          /* ***** BEGIN LICENSE BLOCK ***** 
      2           * Version: RCSL 1.0/RPSL 1.0 
      3           *  
      4           * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
      5           *      
      6           * The contents of this file, and the files included with this file, are 
      7           * subject to the current version of the RealNetworks Public Source License 
      8           * Version 1.0 (the "RPSL") available at 
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed 
     10           * the file under the RealNetworks Community Source License Version 1.0 
     11           * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
     12           * in which case the RCSL will apply. You may also obtain the license terms 
     13           * directly from RealNetworks.  You may not use this file except in 
     14           * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
     15           * applicable to this file, the RCSL.  Please see the applicable RPSL or 
     16           * RCSL for the rights, obligations and limitations governing use of the 
     17           * contents of the file.  
     18           *  
     19           * This file is part of the Helix DNA Technology. RealNetworks is the 
     20           * developer of the Original Code and owns the copyrights in the portions 
     21           * it created. 
     22           *  
     23           * This file, and the files included with this file, is distributed and made 
     24           * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
     25           * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
     26           * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
     27           * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
     28           * 
     29           * Technology Compatibility Kit Test Suite(s) Location: 
     30           *    http://www.helixcommunity.org/content/tck 
     31           * 
     32           * Contributor(s): 
     33           *  
     34           * ***** END LICENSE BLOCK ***** */ 
     35          
     36          /**************************************************************************************
     37           * Fixed-point MP3 decoder
     38           * Jon Recker (jrecker@real.com), Ken Cooke (kenc@real.com)
     39           * June 2003
     40           *
     41           * mp3dec.c - platform-independent top level MP3 decoder API
     42           **************************************************************************************/
     43          
     44          //#include "..\..\..\swilib.h"		/* for memmove, memcpy (can replace with different implementations if desired) */
     45          
     46          #include "mp3common.h"	/* includes mp3dec.h (public API) and internal, platform-independent API */
     47          
     48          /**************************************************************************************
     49           * Function:    MP3InitDecoder
     50           *
     51           * Description: allocate memory for platform-specific data
     52           *              clear all the user-accessible fields
     53           *
     54           * Inputs:      none
     55           *
     56           * Outputs:     none
     57           *
     58           * Return:      handle to mp3 decoder instance, 0 if malloc fails
     59           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     60          HMP3Decoder MP3InitDecoder(void)
     61          {
     62          	MP3DecInfo *mp3DecInfo;
     63          
     64          	mp3DecInfo = AllocateBuffers();
     65          
     66          	return (HMP3Decoder)mp3DecInfo;
   \                     MP3InitDecoder:
   \   00000000   ........           _BF      xmp3_AllocateBuffers,??xmp3_AllocateBuffers??rA  ;; tailcall
     67          }
     68          
     69          /**************************************************************************************
     70           * Function:    MP3FreeDecoder
     71           *
     72           * Description: free platform-specific data allocated by InitMP3Decoder
     73           *              zero out the contents of MP3DecInfo struct
     74           *
     75           * Inputs:      valid MP3 decoder instance pointer (HMP3Decoder)
     76           *
     77           * Outputs:     none
     78           *
     79           * Return:      none
     80           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     81          void MP3FreeDecoder(HMP3Decoder hMP3Decoder)
     82          {
   \                     MP3FreeDecoder:
   \   00000000   00402DE9           PUSH     {LR}
     83          	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
     84          
     85          	if (!mp3DecInfo)
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0080BD08           POPEQ    {PC}
     86          		return;
     87          
     88          	FreeBuffers(mp3DecInfo);
   \   0000000C   ........           _BLF     xmp3_FreeBuffers,??xmp3_FreeBuffers??rA
     89          }
   \   00000010   0080BDE8           POP      {PC}             ;; return
     90          
     91          /**************************************************************************************
     92           * Function:    MP3FindSyncWord
     93           *
     94           * Description: locate the next byte-alinged sync word in the raw mp3 stream
     95           *
     96           * Inputs:      buffer to search for sync word
     97           *              max number of bytes to search in buffer
     98           *
     99           * Outputs:     none
    100           *
    101           * Return:      offset to first sync word (bytes from start of buf)
    102           *              -1 if sync not found after searching nBytes
    103           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    104          int MP3FindSyncWord(unsigned char *buf, int nBytes)
    105          {
    106          	int i;
    107          
    108          	/* find byte-aligned syncword - need 12 (MPEG 1,2) or 11 (MPEG 2.5) matching bits */
    109          	for (i = 0; i < nBytes - 1; i++) {
   \                     MP3FindSyncWord:
   \   00000000   0020A0E3           MOV      R2,#+0
   \   00000004   011041E2           SUB      R1,R1,#+1
   \   00000008   000000EA           B        ??MP3FindSyncWord_0
   \                     ??MP3FindSyncWord_1:
   \   0000000C   012082E2           ADD      R2,R2,#+1
   \                     ??MP3FindSyncWord_0:
   \   00000010   010052E1           CMP      R2,R1
   \   00000014   090000AA           BGE      ??MP3FindSyncWord_2
    110          		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
   \   00000018   0030D2E7           LDRB     R3,[R2, +R0]
   \   0000001C   FF0053E3           CMP      R3,#+255
   \   00000020   F9FFFF1A           BNE      ??MP3FindSyncWord_1
   \   00000024   003082E0           ADD      R3,R2,R0
   \   00000028   0130D3E5           LDRB     R3,[R3, #+1]
   \   0000002C   E03003E2           AND      R3,R3,#0xE0
   \   00000030   E00053E3           CMP      R3,#+224
   \   00000034   F4FFFF1A           BNE      ??MP3FindSyncWord_1
    111          			return i;
   \   00000038   0200A0E1           MOV      R0,R2
   \   0000003C   1EFF2FE1           BX       LR
    112          	}
    113          	
    114          	return -1;
   \                     ??MP3FindSyncWord_2:
   \   00000040   0000E0E3           MVN      R0,#+0
   \   00000044   1EFF2FE1           BX       LR               ;; return
    115          }
    116          
    117          /**************************************************************************************
    118           * Function:    MP3FindFreeSync
    119           *
    120           * Description: figure out number of bytes between adjacent sync words in "free" mode
    121           *
    122           * Inputs:      buffer to search for next sync word
    123           *              the 4-byte frame header starting at the current sync word
    124           *              max number of bytes to search in buffer
    125           *
    126           * Outputs:     none
    127           *
    128           * Return:      offset to next sync word, minus any pad byte (i.e. nSlots)
    129           *              -1 if sync not found after searching nBytes
    130           *
    131           * Notes:       this checks that the first 22 bits of the next frame header are the
    132           *                same as the current frame header, but it's still not foolproof
    133           *                (could accidentally find a sequence in the bitstream which 
    134           *                 appears to match but is not actually the next frame header)
    135           *              this could be made more error-resilient by checking several frames
    136           *                in a row and verifying that nSlots is the same in each case
    137           *              since free mode requires CBR (see spec) we generally only call
    138           *                this function once (first frame) then store the result (nSlots)
    139           *                and just use it from then on
    140           **************************************************************************************/
    141          static int MP3FindFreeSync(unsigned char *buf, unsigned char firstFH[4], int nBytes)
    142          {
    143          	int offset = 0;
    144          	unsigned char *bufPtr = buf;
    145          
    146          	/* loop until we either: 
    147          	 *  - run out of nBytes (FindMP3SyncWord() returns -1)
    148          	 *  - find the next valid frame header (sync word, version, layer, CRC flag, bitrate, and sample rate
    149          	 *      in next header must match current header)
    150          	 */
    151          	while (1) {
    152          		offset = MP3FindSyncWord(bufPtr, nBytes);
    153          		bufPtr += offset;
    154          		if (offset < 0) {
    155          			return -1;
    156          		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
    157          			/* want to return number of bytes per frame, NOT counting the padding byte, so subtract one if padFlag == 1 */
    158          			if ((firstFH[2] >> 1) & 0x01)
    159          				bufPtr--;
    160          			return bufPtr - buf;
    161          		}
    162          		bufPtr += 3;
    163          		nBytes -= (offset + 3);
    164          	};
    165          
    166          	return -1;
                 	^
Warning[Pe111]: statement is unreachable
    167          }
    168          
    169          /**************************************************************************************
    170           * Function:    MP3GetLastFrameInfo
    171           *
    172           * Description: get info about last MP3 frame decoded (number of sampled decoded, 
    173           *                sample rate, bitrate, etc.)
    174           *
    175           * Inputs:      valid MP3 decoder instance pointer (HMP3Decoder)
    176           *              pointer to MP3FrameInfo struct
    177           *
    178           * Outputs:     filled-in MP3FrameInfo struct
    179           *
    180           * Return:      none
    181           *
    182           * Notes:       call this right after calling MP3Decode
    183           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    184          void MP3GetLastFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo)
    185          {
   \                     MP3GetLastFrameInfo:
   \   00000000   30002DE9           PUSH     {R4,R5}
    186          	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
    187          
    188          	if (!mp3DecInfo || mp3DecInfo->layer != 3) {
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0300000A           BEQ      ??MP3GetLastFrameInfo_0
   \   0000000C   D02790E5           LDR      R2,[R0, #+2000]
   \   00000010   030052E3           CMP      R2,#+3
   \   00000014   0800000A           BEQ      ??MP3GetLastFrameInfo_1
    189          		mp3FrameInfo->bitrate = 0;
   \   00000018   0000A0E3           MOV      R0,#+0
   \                     ??MP3GetLastFrameInfo_0:
   \   0000001C   000081E5           STR      R0,[R1, #+0]
    190          		mp3FrameInfo->nChans = 0;
   \   00000020   040081E5           STR      R0,[R1, #+4]
    191          		mp3FrameInfo->samprate = 0;
   \   00000024   080081E5           STR      R0,[R1, #+8]
    192          		mp3FrameInfo->bitsPerSample = 0;
   \   00000028   0C0081E5           STR      R0,[R1, #+12]
    193          		mp3FrameInfo->outputSamps = 0;
   \   0000002C   100081E5           STR      R0,[R1, #+16]
    194          		mp3FrameInfo->layer = 0;
   \   00000030   140081E5           STR      R0,[R1, #+20]
    195          		mp3FrameInfo->version = 0;
   \   00000034   0000A0E3           MOV      R0,#+0
   \   00000038   140000EA           B        ??MP3GetLastFrameInfo_2
    196          	} else {
    197          		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
   \                     ??MP3GetLastFrameInfo_1:
   \   0000003C   B82790E5           LDR      R2,[R0, #+1976]
    198          		mp3FrameInfo->nChans = mp3DecInfo->nChans;
    199          		mp3FrameInfo->samprate = mp3DecInfo->samprate;
    200          		mp3FrameInfo->bitsPerSample = 16;
    201          		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
   \   00000040   ........           LDR      R5,??DataTable1  ;; xmp3_samplesPerFrameTab
   \   00000044   002081E5           STR      R2,[R1, #+0]
   \   00000048   BC2790E5           LDR      R2,[R0, #+1980]
   \   0000004C   0640A0E3           MOV      R4,#+6
   \   00000050   042081E5           STR      R2,[R1, #+4]
   \   00000054   C02790E5           LDR      R2,[R0, #+1984]
   \   00000058   082081E5           STR      R2,[R1, #+8]
   \   0000005C   1020A0E3           MOV      R2,#+16
   \   00000060   0C2081E5           STR      R2,[R1, #+12]
   \   00000064   D4C7D0E5           LDRB     R12,[R0, #+2004]
   \   00000068   D03790E5           LDR      R3,[R0, #+2000]
   \   0000006C   BC2790E5           LDR      R2,[R0, #+1980]
   \   00000070   945C25E0           MLA      R5,R4,R12,R5
   \   00000074   833085E0           ADD      R3,R5,R3, LSL #+1
   \   00000078   F23053E1           LDRSH    R3,[R3, #-2]
   \   0000007C   930202E0           MUL      R2,R3,R2
   \   00000080   102081E5           STR      R2,[R1, #+16]
    202          		mp3FrameInfo->layer = mp3DecInfo->layer;
   \   00000084   D02790E5           LDR      R2,[R0, #+2000]
   \   00000088   142081E5           STR      R2,[R1, #+20]
    203          		mp3FrameInfo->version = mp3DecInfo->version;
   \   0000008C   D407D0E5           LDRB     R0,[R0, #+2004]
   \                     ??MP3GetLastFrameInfo_2:
   \   00000090   180081E5           STR      R0,[R1, #+24]
    204          	}
    205          }
   \   00000094   3000BDE8           POP      {R4,R5}
   \   00000098   1EFF2FE1           BX       LR               ;; return
    206          
    207          /**************************************************************************************
    208           * Function:    MP3GetNextFrameInfo
    209           *
    210           * Description: parse MP3 frame header
    211           *
    212           * Inputs:      valid MP3 decoder instance pointer (HMP3Decoder)
    213           *              pointer to MP3FrameInfo struct
    214           *              pointer to buffer containing valid MP3 frame header (located using 
    215           *                MP3FindSyncWord(), above)
    216           *
    217           * Outputs:     filled-in MP3FrameInfo struct
    218           *
    219           * Return:      error code, defined in mp3dec.h (0 means no error, < 0 means error)
    220           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    221          int MP3GetNextFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo, unsigned char *buf)
    222          {
   \                     MP3GetNextFrameInfo:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0050A0E1           MOV      R5,R0
   \   00000008   0140A0E1           MOV      R4,R1
   \   0000000C   0210A0E1           MOV      R1,R2
    223          	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
    224          
    225          	if (!mp3DecInfo)
   \   00000010   000055E3           CMP      R5,#+0
    226          		return ERR_MP3_NULL_POINTER;
   \   00000014   0400E003           MVNEQ    R0,#+4
   \   00000018   3080BD08           POPEQ    {R4,R5,PC}
    227          
    228          	if (UnpackFrameHeader(mp3DecInfo, buf) == -1 || mp3DecInfo->layer != 3)
   \   0000001C   ........           _BLF     xmp3_UnpackFrameHeader,??xmp3_UnpackFrameHeader??rA
   \   00000020   010070E3           CMN      R0,#+1
   \   00000024   0200000A           BEQ      ??MP3GetNextFrameInfo_0
   \   00000028   D00795E5           LDR      R0,[R5, #+2000]
   \   0000002C   030050E3           CMP      R0,#+3
   \   00000030   0100000A           BEQ      ??MP3GetNextFrameInfo_1
    229          		return ERR_MP3_INVALID_FRAMEHEADER;
   \                     ??MP3GetNextFrameInfo_0:
   \   00000034   0500E0E3           MVN      R0,#+5
   \   00000038   3080BDE8           POP      {R4,R5,PC}
    230          
    231          	MP3GetLastFrameInfo(mp3DecInfo, mp3FrameInfo);
   \                     ??MP3GetNextFrameInfo_1:
   \   0000003C   000055E3           CMP      R5,#+0
   \   00000040   0100000A           BEQ      ??MP3GetNextFrameInfo_2
   \   00000044   030050E3           CMP      R0,#+3
   \   00000048   0900000A           BEQ      ??MP3GetNextFrameInfo_3
   \                     ??MP3GetNextFrameInfo_2:
   \   0000004C   0000A0E3           MOV      R0,#+0
   \   00000050   000084E5           STR      R0,[R4, #+0]
   \   00000054   040084E5           STR      R0,[R4, #+4]
   \   00000058   080084E5           STR      R0,[R4, #+8]
   \   0000005C   0C0084E5           STR      R0,[R4, #+12]
   \   00000060   100084E5           STR      R0,[R4, #+16]
   \   00000064   140084E5           STR      R0,[R4, #+20]
   \   00000068   180084E5           STR      R0,[R4, #+24]
   \   0000006C   0000A0E3           MOV      R0,#+0
   \   00000070   3080BDE8           POP      {R4,R5,PC}
   \                     ??MP3GetNextFrameInfo_3:
   \   00000074   B80795E5           LDR      R0,[R5, #+1976]
   \   00000078   ........           LDR      R12,??DataTable1  ;; xmp3_samplesPerFrameTab
   \   0000007C   000084E5           STR      R0,[R4, #+0]
   \   00000080   BC0795E5           LDR      R0,[R5, #+1980]
   \   00000084   0630A0E3           MOV      R3,#+6
   \   00000088   040084E5           STR      R0,[R4, #+4]
   \   0000008C   C00795E5           LDR      R0,[R5, #+1984]
   \   00000090   080084E5           STR      R0,[R4, #+8]
   \   00000094   1000A0E3           MOV      R0,#+16
   \   00000098   0C0084E5           STR      R0,[R4, #+12]
   \   0000009C   D427D5E5           LDRB     R2,[R5, #+2004]
   \   000000A0   D01795E5           LDR      R1,[R5, #+2000]
   \   000000A4   BC0795E5           LDR      R0,[R5, #+1980]
   \   000000A8   93C222E0           MLA      R2,R3,R2,R12
   \   000000AC   811082E0           ADD      R1,R2,R1, LSL #+1
   \   000000B0   F21051E1           LDRSH    R1,[R1, #-2]
   \   000000B4   910000E0           MUL      R0,R1,R0
   \   000000B8   100084E5           STR      R0,[R4, #+16]
   \   000000BC   D00795E5           LDR      R0,[R5, #+2000]
   \   000000C0   140084E5           STR      R0,[R4, #+20]
   \   000000C4   D407D5E5           LDRB     R0,[R5, #+2004]
   \   000000C8   180084E5           STR      R0,[R4, #+24]
    232          
    233          	return ERR_MP3_NONE;
   \   000000CC   0000A0E3           MOV      R0,#+0
   \   000000D0   3080BDE8           POP      {R4,R5,PC}       ;; return
    234          }
    235          
    236          /**************************************************************************************
    237           * Function:    MP3ClearBadFrame
    238           *
    239           * Description: zero out pcm buffer if error decoding MP3 frame
    240           *
    241           * Inputs:      mp3DecInfo struct with correct frame size parameters filled in
    242           *              pointer pcm output buffer
    243           *
    244           * Outputs:     zeroed out pcm buffer
    245           *
    246           * Return:      none
    247           **************************************************************************************/
    248          static void MP3ClearBadFrame(MP3DecInfo *mp3DecInfo, short *outbuf)
    249          {
    250          	int i;
    251          
    252          	if (!mp3DecInfo)
    253          		return;
    254          
    255          	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
    256          		outbuf[i] = 0;
    257          }
    258          
    259          /**************************************************************************************
    260           * Function:    MP3Decode
    261           *
    262           * Description: decode one frame of MP3 data
    263           *
    264           * Inputs:      valid MP3 decoder instance pointer (HMP3Decoder)
    265           *              double pointer to buffer of MP3 data (containing headers + mainData)
    266           *              number of valid bytes remaining in inbuf
    267           *              pointer to outbuf, big enough to hold one frame of decoded PCM samples
    268           *              flag indicating whether MP3 data is normal MPEG format (useSize = 0)
    269           *                or reformatted as "self-contained" frames (useSize = 1)
    270           *
    271           * Outputs:     PCM data in outbuf, interleaved LRLRLR... if stereo
    272           *                number of output samples = nGrans * nGranSamps * nChans
    273           *              updated inbuf pointer, updated bytesLeft
    274           *
    275           * Return:      error code, defined in mp3dec.h (0 means no error, < 0 means error)
    276           *
    277           * Notes:       switching useSize on and off between frames in the same stream 
    278           *                is not supported (bit reservoir is not maintained if useSize on)
    279           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    280          int MP3Decode(HMP3Decoder hMP3Decoder, unsigned char **inbuf, int *bytesLeft, short *outbuf, int useSize)
    281          {
   \                     MP3Decode:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0170A0E1           MOV      R7,R1
   \   00000010   0280A0E1           MOV      R8,R2
   \   00000014   0350A0E1           MOV      R5,R3
    282          	int offset, bitOffset, mainBits, gr, ch, fhBytes, siBytes, freeFrameBytes;
    283          	int prevBitOffset, sfBlockBits, huffBlockBits;
    284          	unsigned char *mainPtr;
    285          	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
    286          
    287          	if (!mp3DecInfo)
   \   00000018   000054E3           CMP      R4,#+0
    288          		return ERR_MP3_NULL_POINTER;
   \   0000001C   0400E003           MVNEQ    R0,#+4
   \   00000020   F28FBD08           POPEQ    {R1,R4-R11,PC}
    289          
    290          	/* unpack frame header */
    291          	fhBytes = UnpackFrameHeader(mp3DecInfo, *inbuf);
   \   00000024   001097E5           LDR      R1,[R7, #+0]
   \   00000028   ........           _BLF     xmp3_UnpackFrameHeader,??xmp3_UnpackFrameHeader??rA
   \   0000002C   0090B0E1           MOVS     R9,R0
    292          	if (fhBytes < 0)	
   \   00000030   0100005A           BPL      ??MP3Decode_0
    293          		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
   \                     ??MP3Decode_1:
   \   00000034   0500E0E3           MVN      R0,#+5
   \   00000038   F28FBDE8           POP      {R1,R4-R11,PC}
    294          	*inbuf += fhBytes;
   \                     ??MP3Decode_0:
   \   0000003C   000097E5           LDR      R0,[R7, #+0]
    295          	
    296          	/* unpack side info */
    297          	siBytes = UnpackSideInfo(mp3DecInfo, *inbuf);
    298          	if (siBytes < 0) {
   \   00000040   0060A0E3           MOV      R6,#+0
   \   00000044   001089E0           ADD      R1,R9,R0
   \   00000048   001087E5           STR      R1,[R7, #+0]
   \   0000004C   0400A0E1           MOV      R0,R4
   \   00000050   ........           _BLF     xmp3_UnpackSideInfo,??xmp3_UnpackSideInfo??rA
   \   00000054   0010B0E1           MOVS     R1,R0
   \   00000058   0D00005A           BPL      ??MP3Decode_2
   \   0000005C   0000A0E3           MOV      R0,#+0
   \   00000060   020000EA           B        ??MP3Decode_3
   \                     ??MP3Decode_4:
   \   00000064   801085E0           ADD      R1,R5,R0, LSL #+1
   \   00000068   B060C1E1           STRH     R6,[R1, #+0]
   \   0000006C   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_3:
   \   00000070   C41794E5           LDR      R1,[R4, #+1988]
   \   00000074   C82794E5           LDR      R2,[R4, #+1992]
   \   00000078   920101E0           MUL      R1,R2,R1
   \   0000007C   BC2794E5           LDR      R2,[R4, #+1980]
   \   00000080   920101E0           MUL      R1,R2,R1
   \   00000084   010050E1           CMP      R0,R1
   \   00000088   F5FFFFBA           BLT      ??MP3Decode_4
    299          		MP3ClearBadFrame(mp3DecInfo, outbuf);
    300          		return ERR_MP3_INVALID_SIDEINFO;
   \   0000008C   0600E0E3           MVN      R0,#+6
   \   00000090   F28FBDE8           POP      {R1,R4-R11,PC}
    301          	}
    302          	*inbuf += siBytes;
   \                     ??MP3Decode_2:
   \   00000094   000097E5           LDR      R0,[R7, #+0]
   \   00000098   002081E0           ADD      R2,R1,R0
   \   0000009C   002087E5           STR      R2,[R7, #+0]
    303          	*bytesLeft -= (fhBytes + siBytes);
   \   000000A0   000098E5           LDR      R0,[R8, #+0]
   \   000000A4   090040E0           SUB      R0,R0,R9
   \   000000A8   010040E0           SUB      R0,R0,R1
   \   000000AC   000088E5           STR      R0,[R8, #+0]
    304          	
    305          	/* if free mode, need to calculate bitrate and nSlots manually, based on frame size */
    306          	if (mp3DecInfo->bitrate == 0 || mp3DecInfo->freeBitrateFlag) {
   \   000000B0   B80794E5           LDR      R0,[R4, #+1976]
   \   000000B4   000050E3           CMP      R0,#+0
   \   000000B8   0200000A           BEQ      ??MP3Decode_5
   \   000000BC   B00794E5           LDR      R0,[R4, #+1968]
   \   000000C0   000050E3           CMP      R0,#+0
   \   000000C4   5600000A           BEQ      ??MP3Decode_6
    307          		if (!mp3DecInfo->freeBitrateFlag) {
   \                     ??MP3Decode_5:
   \   000000C8   B00794E5           LDR      R0,[R4, #+1968]
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   4E00001A           BNE      ??MP3Decode_7
    308          			/* first time through, need to scan for next sync word and figure out frame size */
    309          			mp3DecInfo->freeBitrateFlag = 1;
   \   000000D4   0100A0E3           MOV      R0,#+1
   \   000000D8   B00784E5           STR      R0,[R4, #+1968]
    310          			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
   \   000000DC   00C098E5           LDR      R12,[R8, #+0]
   \   000000E0   0100A0E1           MOV      R0,R1
   \   000000E4   000060E2           RSB      R0,R0,#+0
   \   000000E8   0930A0E1           MOV      R3,R9
   \   000000EC   003063E2           RSB      R3,R3,#+0
   \   000000F0   023083E0           ADD      R3,R3,R2
   \   000000F4   033080E0           ADD      R3,R0,R3
   \   000000F8   02A0A0E1           MOV      R10,R2
   \   000000FC   020000EA           B        ??MP3Decode_8
   \                     ??MP3Decode_9:
   \   00000100   03A08AE2           ADD      R10,R10,#+3
   \   00000104   00004CE0           SUB      R0,R12,R0
   \   00000108   03C040E2           SUB      R12,R0,#+3
   \                     ??MP3Decode_8:
   \   0000010C   0000A0E3           MOV      R0,#+0
   \   00000110   01E04CE2           SUB      LR,R12,#+1
   \   00000114   000000EA           B        ??MP3Decode_10
   \                     ??MP3Decode_11:
   \   00000118   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_10:
   \   0000011C   0E0050E1           CMP      R0,LR
   \   00000120   080000AA           BGE      ??MP3Decode_12
   \   00000124   0AB0D0E7           LDRB     R11,[R0, +R10]
   \   00000128   FF005BE3           CMP      R11,#+255
   \   0000012C   F9FFFF1A           BNE      ??MP3Decode_11
   \   00000130   0AB080E0           ADD      R11,R0,R10
   \   00000134   01B0DBE5           LDRB     R11,[R11, #+1]
   \   00000138   E0B00BE2           AND      R11,R11,#0xE0
   \   0000013C   E0005BE3           CMP      R11,#+224
   \   00000140   F4FFFF1A           BNE      ??MP3Decode_11
   \   00000144   000000EA           B        ??MP3Decode_13
   \                     ??MP3Decode_12:
   \   00000148   0600E0E1           MVN      R0,R6
   \                     ??MP3Decode_13:
   \   0000014C   0AA080E0           ADD      R10,R0,R10
   \   00000150   000050E3           CMP      R0,#+0
   \   00000154   0600E041           MVNMI    R0,R6
   \   00000158   1100004A           BMI      ??MP3Decode_14
   \   0000015C   00B0DAE5           LDRB     R11,[R10, #+0]
   \   00000160   00E0D3E5           LDRB     LR,[R3, #+0]
   \   00000164   0E005BE1           CMP      R11,LR
   \   00000168   E4FFFF1A           BNE      ??MP3Decode_9
   \   0000016C   01B0DAE5           LDRB     R11,[R10, #+1]
   \   00000170   01E0D3E5           LDRB     LR,[R3, #+1]
   \   00000174   0E005BE1           CMP      R11,LR
   \   00000178   E0FFFF1A           BNE      ??MP3Decode_9
   \   0000017C   02B0DAE5           LDRB     R11,[R10, #+2]
   \   00000180   FCE00BE2           AND      LR,R11,#0xFC
   \   00000184   02B0D3E5           LDRB     R11,[R3, #+2]
   \   00000188   FCB00BE2           AND      R11,R11,#0xFC
   \   0000018C   0B005EE1           CMP      LR,R11
   \   00000190   DAFFFF1A           BNE      ??MP3Decode_9
   \   00000194   0200D3E5           LDRB     R0,[R3, #+2]
   \   00000198   020010E3           TST      R0,#0x2
   \   0000019C   01A04A12           SUBNE    R10,R10,#+1
   \   000001A0   02004AE0           SUB      R0,R10,R2
   \                     ??MP3Decode_14:
   \   000001A4   B40784E5           STR      R0,[R4, #+1972]
    311          			if (mp3DecInfo->freeBitrateSlots < 0) {
   \   000001A8   000050E3           CMP      R0,#+0
   \   000001AC   0D00005A           BPL      ??MP3Decode_15
   \   000001B0   0000A0E3           MOV      R0,#+0
   \   000001B4   020000EA           B        ??MP3Decode_16
   \                     ??MP3Decode_17:
   \   000001B8   801085E0           ADD      R1,R5,R0, LSL #+1
   \   000001BC   B060C1E1           STRH     R6,[R1, #+0]
   \   000001C0   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_16:
   \   000001C4   C41794E5           LDR      R1,[R4, #+1988]
   \   000001C8   C82794E5           LDR      R2,[R4, #+1992]
   \   000001CC   920101E0           MUL      R1,R2,R1
   \   000001D0   BC2794E5           LDR      R2,[R4, #+1980]
   \   000001D4   920101E0           MUL      R1,R2,R1
   \   000001D8   010050E1           CMP      R0,R1
   \   000001DC   F5FFFFBA           BLT      ??MP3Decode_17
    312          				MP3ClearBadFrame(mp3DecInfo, outbuf);
    313          				return ERR_MP3_FREE_BITRATE_SYNC;
   \   000001E0   0200E0E3           MVN      R0,#+2
   \   000001E4   F28FBDE8           POP      {R1,R4-R11,PC}
    314          			}
    315          			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
    316          			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
   \                     ??MP3Decode_15:
   \   000001E8   C82794E5           LDR      R2,[R4, #+1992]
   \   000001EC   000089E0           ADD      R0,R9,R0
   \   000001F0   000081E0           ADD      R0,R1,R0
   \   000001F4   C01794E5           LDR      R1,[R4, #+1984]
   \   000001F8   910000E0           MUL      R0,R1,R0
   \   000001FC   C41794E5           LDR      R1,[R4, #+1988]
   \   00000200   8001A0E1           LSL      R0,R0,#+3
   \   00000204   920101E0           MUL      R1,R2,R1
   \   00000208   ........           _BLF     ??div32_a,??rA??div32_a
   \   0000020C   B81784E5           STR      R1,[R4, #+1976]
    317          		}
    318          		mp3DecInfo->nSlots = mp3DecInfo->freeBitrateSlots + CheckPadBit(mp3DecInfo);	/* add pad byte, if required */
   \                     ??MP3Decode_7:
   \   00000210   B49794E5           LDR      R9,[R4, #+1972]
   \   00000214   0400A0E1           MOV      R0,R4
   \   00000218   ........           _BLF     xmp3_CheckPadBit,??xmp3_CheckPadBit??rA
   \   0000021C   090080E0           ADD      R0,R0,R9
   \   00000220   CC0784E5           STR      R0,[R4, #+1996]
    319          	}
    320          
    321          	/* useSize != 0 means we're getting reformatted (RTP) packets (see RFC 3119)
    322          	 *  - calling function assembles "self-contained" MP3 frames by shifting any main_data 
    323          	 *      from the bit reservoir (in previous frames) to AFTER the sync word and side info
    324          	 *  - calling function should set mainDataBegin to 0, and tell us exactly how large this
    325          	 *      frame is (in bytesLeft)
    326          	 */
    327          	if (useSize) {
   \                     ??MP3Decode_6:
   \   00000224   28209DE5           LDR      R2,[SP, #+40]
   \   00000228   001097E5           LDR      R1,[R7, #+0]
   \   0000022C   000098E5           LDR      R0,[R8, #+0]
   \   00000230   000052E3           CMP      R2,#+0
   \   00000234   2000000A           BEQ      ??MP3Decode_18
    328          		mp3DecInfo->nSlots = *bytesLeft;
   \   00000238   CC0784E5           STR      R0,[R4, #+1996]
    329          		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
   \   0000023C   D80794E5           LDR      R0,[R4, #+2008]
   \   00000240   000050E3           CMP      R0,#+0
   \   00000244   0200001A           BNE      ??MP3Decode_19
   \   00000248   CC0794E5           LDR      R0,[R4, #+1996]
   \   0000024C   010050E3           CMP      R0,#+1
   \   00000250   0B0000AA           BGE      ??MP3Decode_20
   \                     ??MP3Decode_19:
   \   00000254   0000A0E3           MOV      R0,#+0
   \                     ??MP3Decode_21:
   \   00000258   C41794E5           LDR      R1,[R4, #+1988]
   \   0000025C   C82794E5           LDR      R2,[R4, #+1992]
   \   00000260   920101E0           MUL      R1,R2,R1
   \   00000264   BC2794E5           LDR      R2,[R4, #+1980]
   \   00000268   920101E0           MUL      R1,R2,R1
   \   0000026C   010050E1           CMP      R0,R1
   \   00000270   6FFFFFAA           BGE      ??MP3Decode_1
   \   00000274   801085E0           ADD      R1,R5,R0, LSL #+1
   \   00000278   B060C1E1           STRH     R6,[R1, #+0]
   \   0000027C   010080E2           ADD      R0,R0,#+1
   \   00000280   F4FFFFEA           B        ??MP3Decode_21
    330          			/* error - non self-contained frame, or missing frame (size <= 0), could do loss concealment here */
    331          			MP3ClearBadFrame(mp3DecInfo, outbuf);
    332          			return ERR_MP3_INVALID_FRAMEHEADER;
    333          		}
    334          
    335          		/* can operate in-place on reformatted frames */
    336          		mp3DecInfo->mainDataBytes = mp3DecInfo->nSlots;
   \                     ??MP3Decode_20:
   \   00000284   DC0784E5           STR      R0,[R4, #+2012]
    337          		mainPtr = *inbuf;
   \   00000288   0190A0E1           MOV      R9,R1
    338          		*inbuf += mp3DecInfo->nSlots;
   \                     ??MP3Decode_22:
   \   0000028C   010080E0           ADD      R0,R0,R1
   \   00000290   000087E5           STR      R0,[R7, #+0]
    339          		*bytesLeft -= (mp3DecInfo->nSlots);
   \   00000294   000098E5           LDR      R0,[R8, #+0]
   \   00000298   CC1794E5           LDR      R1,[R4, #+1996]
   \   0000029C   010040E0           SUB      R0,R0,R1
   \   000002A0   000088E5           STR      R0,[R8, #+0]
    340          	} else {
    341          		/* out of data - assume last or truncated frame */
    342          		if (mp3DecInfo->nSlots > *bytesLeft) {
    343          			MP3ClearBadFrame(mp3DecInfo, outbuf);
    344          			return ERR_MP3_INDATA_UNDERFLOW;	
    345          		}
    346          		/* fill main data buffer with enough new data for this frame */
    347          		if (mp3DecInfo->mainDataBytes >= mp3DecInfo->mainDataBegin) {
    348          			/* adequate "old" main data available (i.e. bit reservoir) */
    349          			memcpy(mp3DecInfo->mainBuf, mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes - mp3DecInfo->mainDataBegin, mp3DecInfo->mainDataBegin);
    350          			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBegin, *inbuf, mp3DecInfo->nSlots);
    351          
    352          			mp3DecInfo->mainDataBytes = mp3DecInfo->mainDataBegin + mp3DecInfo->nSlots;
    353          			*inbuf += mp3DecInfo->nSlots;
    354          			*bytesLeft -= (mp3DecInfo->nSlots);
    355          			mainPtr = mp3DecInfo->mainBuf;
    356          		} else {
    357          			/* not enough data in bit reservoir from previous frames (perhaps starting in middle of file) */
    358          			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes, *inbuf, mp3DecInfo->nSlots);
    359          			mp3DecInfo->mainDataBytes += mp3DecInfo->nSlots;
    360          			*inbuf += mp3DecInfo->nSlots;
    361          			*bytesLeft -= (mp3DecInfo->nSlots);
    362          			MP3ClearBadFrame(mp3DecInfo, outbuf);
    363          			return ERR_MP3_MAINDATA_UNDERFLOW;
    364          		}
    365          	}
    366          	bitOffset = 0;
   \   000002A4   0010A0E3           MOV      R1,#+0
   \   000002A8   00108DE5           STR      R1,[SP, #+0]
    367          	mainBits = mp3DecInfo->mainDataBytes * 8;
   \   000002AC   DC0794E5           LDR      R0,[R4, #+2012]
    368          
    369          	/* decode one complete frame */
    370          	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
   \   000002B0   0170A0E1           MOV      R7,R1
   \   000002B4   8081A0E1           LSL      R8,R0,#+3
   \   000002B8   490000EA           B        ??MP3Decode_23
   \                     ??MP3Decode_18:
   \   000002BC   CC2794E5           LDR      R2,[R4, #+1996]
   \   000002C0   020050E1           CMP      R0,R2
   \   000002C4   0D0000AA           BGE      ??MP3Decode_24
   \   000002C8   0000A0E3           MOV      R0,#+0
   \   000002CC   020000EA           B        ??MP3Decode_25
   \                     ??MP3Decode_26:
   \   000002D0   801085E0           ADD      R1,R5,R0, LSL #+1
   \   000002D4   B060C1E1           STRH     R6,[R1, #+0]
   \   000002D8   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_25:
   \   000002DC   C41794E5           LDR      R1,[R4, #+1988]
   \   000002E0   C82794E5           LDR      R2,[R4, #+1992]
   \   000002E4   920101E0           MUL      R1,R2,R1
   \   000002E8   BC2794E5           LDR      R2,[R4, #+1980]
   \   000002EC   920101E0           MUL      R1,R2,R1
   \   000002F0   010050E1           CMP      R0,R1
   \   000002F4   F5FFFFBA           BLT      ??MP3Decode_26
   \   000002F8   0600E0E1           MVN      R0,R6
   \   000002FC   F28FBDE8           POP      {R1,R4-R11,PC}
   \                     ??MP3Decode_24:
   \   00000300   DC0794E5           LDR      R0,[R4, #+2012]
   \   00000304   D82794E5           LDR      R2,[R4, #+2008]
   \   00000308   020050E1           CMP      R0,R2
   \   0000030C   150000BA           BLT      ??MP3Decode_27
   \   00000310   DC1794E5           LDR      R1,[R4, #+2012]
   \   00000314   0200A0E1           MOV      R0,R2
   \   00000318   000060E2           RSB      R0,R0,#+0
   \   0000031C   041081E0           ADD      R1,R1,R4
   \   00000320   010080E0           ADD      R0,R0,R1
   \   00000324   1C1080E2           ADD      R1,R0,#+28
   \   00000328   1C0084E2           ADD      R0,R4,#+28
   \   0000032C   1E0100EF           SWI      +286
   \   00000330   D80794E5           LDR      R0,[R4, #+2008]
   \   00000334   CC2794E5           LDR      R2,[R4, #+1996]
   \   00000338   001097E5           LDR      R1,[R7, #+0]
   \   0000033C   040080E0           ADD      R0,R0,R4
   \   00000340   1C0080E2           ADD      R0,R0,#+28
   \   00000344   1E0100EF           SWI      +286
   \   00000348   D80794E5           LDR      R0,[R4, #+2008]
   \   0000034C   CC1794E5           LDR      R1,[R4, #+1996]
   \   00000350   1C9084E2           ADD      R9,R4,#+28
   \   00000354   000081E0           ADD      R0,R1,R0
   \   00000358   DC0784E5           STR      R0,[R4, #+2012]
   \   0000035C   0100A0E1           MOV      R0,R1
   \   00000360   001097E5           LDR      R1,[R7, #+0]
   \   00000364   C8FFFFEA           B        ??MP3Decode_22
   \                     ??MP3Decode_27:
   \   00000368   CC2794E5           LDR      R2,[R4, #+1996]
   \   0000036C   040080E0           ADD      R0,R0,R4
   \   00000370   1C0080E2           ADD      R0,R0,#+28
   \   00000374   1E0100EF           SWI      +286
   \   00000378   DC0794E5           LDR      R0,[R4, #+2012]
   \   0000037C   CC1794E5           LDR      R1,[R4, #+1996]
   \   00000380   000081E0           ADD      R0,R1,R0
   \   00000384   DC0784E5           STR      R0,[R4, #+2012]
   \   00000388   0100A0E1           MOV      R0,R1
   \   0000038C   001097E5           LDR      R1,[R7, #+0]
   \   00000390   010080E0           ADD      R0,R0,R1
   \   00000394   000087E5           STR      R0,[R7, #+0]
   \   00000398   000098E5           LDR      R0,[R8, #+0]
   \   0000039C   CC1794E5           LDR      R1,[R4, #+1996]
   \   000003A0   010040E0           SUB      R0,R0,R1
   \   000003A4   000088E5           STR      R0,[R8, #+0]
   \   000003A8   0000A0E3           MOV      R0,#+0
   \   000003AC   020000EA           B        ??MP3Decode_28
   \                     ??MP3Decode_29:
   \   000003B0   801085E0           ADD      R1,R5,R0, LSL #+1
   \   000003B4   B060C1E1           STRH     R6,[R1, #+0]
   \   000003B8   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_28:
   \   000003BC   C41794E5           LDR      R1,[R4, #+1988]
   \   000003C0   C82794E5           LDR      R2,[R4, #+1992]
   \   000003C4   920101E0           MUL      R1,R2,R1
   \   000003C8   BC2794E5           LDR      R2,[R4, #+1980]
   \   000003CC   920101E0           MUL      R1,R2,R1
   \   000003D0   010050E1           CMP      R0,R1
   \   000003D4   F5FFFFBA           BLT      ??MP3Decode_29
   \   000003D8   0100E0E3           MVN      R0,#+1
   \   000003DC   F28FBDE8           POP      {R1,R4-R11,PC}
   \                     ??MP3Decode_30:
   \   000003E0   017087E2           ADD      R7,R7,#+1
   \                     ??MP3Decode_23:
   \   000003E4   C40794E5           LDR      R0,[R4, #+1988]
   \   000003E8   000057E1           CMP      R7,R0
   \   000003EC   8E0000AA           BGE      ??MP3Decode_31
    371          		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
   \   000003F0   00A0A0E3           MOV      R10,#+0
   \   000003F4   050000EA           B        ??MP3Decode_32
    372          			/* unpack scale factors and compute size of scale factor block */
    373          			prevBitOffset = bitOffset;
    374          			offset = UnpackScaleFactors(mp3DecInfo, mainPtr, &bitOffset, mainBits, gr, ch);
    375          
    376          			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
    377          			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
    378          			mainPtr += offset;
    379          			mainBits -= sfBlockBits;
    380          
    381          			if (offset < 0 || mainBits < huffBlockBits) {
    382          				MP3ClearBadFrame(mp3DecInfo, outbuf);
    383          				return ERR_MP3_INVALID_SCALEFACT;
    384          			}
    385          
    386          			/* decode Huffman code words */
    387          			prevBitOffset = bitOffset;
    388          			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
    389          			if (offset < 0) {
    390          				MP3ClearBadFrame(mp3DecInfo, outbuf);
    391          				return ERR_MP3_INVALID_HUFFCODES;
    392          			}
    393          
    394          			mainPtr += offset;
    395          			mainBits -= (8*offset - prevBitOffset + bitOffset);
   \                     ??MP3Decode_33:
   \   000003F8   00109DE5           LDR      R1,[SP, #+0]
   \   000003FC   099080E0           ADD      R9,R0,R9
   \   00000400   800148E0           SUB      R0,R8,R0, LSL #+3
   \   00000404   00008BE0           ADD      R0,R11,R0
   \   00000408   018040E0           SUB      R8,R0,R1
   \   0000040C   01A08AE2           ADD      R10,R10,#+1
   \                     ??MP3Decode_32:
   \   00000410   BC0794E5           LDR      R0,[R4, #+1980]
   \   00000414   00005AE1           CMP      R10,R0
   \   00000418   3F0000AA           BGE      ??MP3Decode_34
   \   0000041C   00B09DE5           LDR      R11,[SP, #+0]
   \   00000420   0A00A0E1           MOV      R0,R10
   \   00000424   01002DE9           PUSH     {R0}
   \   00000428   0830A0E1           MOV      R3,R8
   \   0000042C   0910A0E1           MOV      R1,R9
   \   00000430   0700A0E1           MOV      R0,R7
   \   00000434   01002DE9           PUSH     {R0}
   \   00000438   08208DE2           ADD      R2,SP,#+8
   \   0000043C   0400A0E1           MOV      R0,R4
   \   00000440   ........           _BLF     xmp3_UnpackScaleFactors,??xmp3_UnpackScaleFactors??rA
   \   00000444   08209DE5           LDR      R2,[SP, #+8]
   \   00000448   80116BE0           RSB      R1,R11,R0, LSL #+3
   \   0000044C   011082E0           ADD      R1,R2,R1
   \   00000450   872184E0           ADD      R2,R4,R7, LSL #+3
   \   00000454   0A2182E0           ADD      R2,R2,R10, LSL #+2
   \   00000458   E02792E5           LDR      R2,[R2, #+2016]
   \   0000045C   099080E0           ADD      R9,R0,R9
   \   00000460   013042E0           SUB      R3,R2,R1
   \   00000464   018048E0           SUB      R8,R8,R1
   \   00000468   000050E3           CMP      R0,#+0
   \   0000046C   08D08DE2           ADD      SP,SP,#+8
   \   00000470   0100004A           BMI      ??MP3Decode_35
   \   00000474   030058E1           CMP      R8,R3
   \   00000478   0D0000AA           BGE      ??MP3Decode_36
   \                     ??MP3Decode_35:
   \   0000047C   0000A0E3           MOV      R0,#+0
   \   00000480   020000EA           B        ??MP3Decode_37
   \                     ??MP3Decode_38:
   \   00000484   801085E0           ADD      R1,R5,R0, LSL #+1
   \   00000488   B060C1E1           STRH     R6,[R1, #+0]
   \   0000048C   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_37:
   \   00000490   C41794E5           LDR      R1,[R4, #+1988]
   \   00000494   C82794E5           LDR      R2,[R4, #+1992]
   \   00000498   920101E0           MUL      R1,R2,R1
   \   0000049C   BC2794E5           LDR      R2,[R4, #+1980]
   \   000004A0   920101E0           MUL      R1,R2,R1
   \   000004A4   010050E1           CMP      R0,R1
   \   000004A8   F5FFFFBA           BLT      ??MP3Decode_38
   \   000004AC   0700E0E3           MVN      R0,#+7
   \   000004B0   F28FBDE8           POP      {R1,R4-R11,PC}
   \                     ??MP3Decode_36:
   \   000004B4   00B09DE5           LDR      R11,[SP, #+0]
   \   000004B8   0A00A0E1           MOV      R0,R10
   \   000004BC   01002DE9           PUSH     {R0}
   \   000004C0   0910A0E1           MOV      R1,R9
   \   000004C4   0700A0E1           MOV      R0,R7
   \   000004C8   01002DE9           PUSH     {R0}
   \   000004CC   08208DE2           ADD      R2,SP,#+8
   \   000004D0   0400A0E1           MOV      R0,R4
   \   000004D4   ........           _BLF     xmp3_DecodeHuffman,??xmp3_DecodeHuffman??rA
   \   000004D8   000050E3           CMP      R0,#+0
   \   000004DC   08D08DE2           ADD      SP,SP,#+8
   \   000004E0   C4FFFF5A           BPL      ??MP3Decode_33
   \   000004E4   0000A0E3           MOV      R0,#+0
   \   000004E8   020000EA           B        ??MP3Decode_39
   \                     ??MP3Decode_40:
   \   000004EC   801085E0           ADD      R1,R5,R0, LSL #+1
   \   000004F0   B060C1E1           STRH     R6,[R1, #+0]
   \   000004F4   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_39:
   \   000004F8   C41794E5           LDR      R1,[R4, #+1988]
   \   000004FC   C82794E5           LDR      R2,[R4, #+1992]
   \   00000500   920101E0           MUL      R1,R2,R1
   \   00000504   BC2794E5           LDR      R2,[R4, #+1980]
   \   00000508   920101E0           MUL      R1,R2,R1
   \   0000050C   010050E1           CMP      R0,R1
   \   00000510   F5FFFFBA           BLT      ??MP3Decode_40
   \   00000514   0800E0E3           MVN      R0,#+8
   \   00000518   F28FBDE8           POP      {R1,R4-R11,PC}
    396          		}
    397          		/* dequantize coefficients, decode stereo, reorder short blocks */
    398          		if (Dequantize(mp3DecInfo, gr) < 0) {
   \                     ??MP3Decode_34:
   \   0000051C   0710A0E1           MOV      R1,R7
   \   00000520   0400A0E1           MOV      R0,R4
   \   00000524   ........           _BLF     xmp3_Dequantize,??xmp3_Dequantize??rA
   \   00000528   000050E3           CMP      R0,#+0
   \   0000052C   0D00005A           BPL      ??MP3Decode_41
   \   00000530   0000A0E3           MOV      R0,#+0
   \   00000534   020000EA           B        ??MP3Decode_42
   \                     ??MP3Decode_43:
   \   00000538   801085E0           ADD      R1,R5,R0, LSL #+1
   \   0000053C   B060C1E1           STRH     R6,[R1, #+0]
   \   00000540   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_42:
   \   00000544   C41794E5           LDR      R1,[R4, #+1988]
   \   00000548   C82794E5           LDR      R2,[R4, #+1992]
   \   0000054C   920101E0           MUL      R1,R2,R1
   \   00000550   BC2794E5           LDR      R2,[R4, #+1980]
   \   00000554   920101E0           MUL      R1,R2,R1
   \   00000558   010050E1           CMP      R0,R1
   \   0000055C   F5FFFFBA           BLT      ??MP3Decode_43
    399          			MP3ClearBadFrame(mp3DecInfo, outbuf);
    400          			return ERR_MP3_INVALID_DEQUANTIZE;			
   \   00000560   0900E0E3           MVN      R0,#+9
   \   00000564   F28FBDE8           POP      {R1,R4-R11,PC}
    401          		}
    402          
    403          		/* alias reduction, inverse MDCT, overlap-add, frequency inversion */
    404          		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
   \                     ??MP3Decode_41:
   \   00000568   00A0A0E3           MOV      R10,#+0
   \   0000056C   000000EA           B        ??MP3Decode_44
   \                     ??MP3Decode_45:
   \   00000570   01A08AE2           ADD      R10,R10,#+1
   \                     ??MP3Decode_44:
   \   00000574   BC0794E5           LDR      R0,[R4, #+1980]
   \   00000578   00005AE1           CMP      R10,R0
   \   0000057C   130000AA           BGE      ??MP3Decode_46
    405          			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
   \   00000580   0A20A0E1           MOV      R2,R10
   \   00000584   0710A0E1           MOV      R1,R7
   \   00000588   0400A0E1           MOV      R0,R4
   \   0000058C   ........           _BLF     xmp3_IMDCT,??xmp3_IMDCT??rA
   \   00000590   000050E3           CMP      R0,#+0
   \   00000594   F5FFFF5A           BPL      ??MP3Decode_45
   \   00000598   0000A0E3           MOV      R0,#+0
   \   0000059C   020000EA           B        ??MP3Decode_47
   \                     ??MP3Decode_48:
   \   000005A0   801085E0           ADD      R1,R5,R0, LSL #+1
   \   000005A4   B060C1E1           STRH     R6,[R1, #+0]
   \   000005A8   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_47:
   \   000005AC   C41794E5           LDR      R1,[R4, #+1988]
   \   000005B0   C82794E5           LDR      R2,[R4, #+1992]
   \   000005B4   920101E0           MUL      R1,R2,R1
   \   000005B8   BC2794E5           LDR      R2,[R4, #+1980]
   \   000005BC   920101E0           MUL      R1,R2,R1
   \   000005C0   010050E1           CMP      R0,R1
   \   000005C4   F5FFFFBA           BLT      ??MP3Decode_48
    406          				MP3ClearBadFrame(mp3DecInfo, outbuf);
    407          				return ERR_MP3_INVALID_IMDCT;			
   \   000005C8   0A00E0E3           MVN      R0,#+10
   \   000005CC   F28FBDE8           POP      {R1,R4-R11,PC}
    408          			}
    409          
    410          		/* subband transform - if stereo, interleaves pcm LRLRLR */
    411          		if (Subband(mp3DecInfo, outbuf + gr*mp3DecInfo->nGranSamps*mp3DecInfo->nChans) < 0) {
   \                     ??MP3Decode_46:
   \   000005D0   C80794E5           LDR      R0,[R4, #+1992]
   \   000005D4   900701E0           MUL      R1,R0,R7
   \   000005D8   BC0794E5           LDR      R0,[R4, #+1980]
   \   000005DC   900101E0           MUL      R1,R0,R1
   \   000005E0   0400A0E1           MOV      R0,R4
   \   000005E4   811085E0           ADD      R1,R5,R1, LSL #+1
   \   000005E8   ........           _BLF     xmp3_Subband,??xmp3_Subband??rA
   \   000005EC   000050E3           CMP      R0,#+0
   \   000005F0   7AFFFF5A           BPL      ??MP3Decode_30
   \   000005F4   0000A0E3           MOV      R0,#+0
   \   000005F8   020000EA           B        ??MP3Decode_49
   \                     ??MP3Decode_50:
   \   000005FC   801085E0           ADD      R1,R5,R0, LSL #+1
   \   00000600   B060C1E1           STRH     R6,[R1, #+0]
   \   00000604   010080E2           ADD      R0,R0,#+1
   \                     ??MP3Decode_49:
   \   00000608   C41794E5           LDR      R1,[R4, #+1988]
   \   0000060C   C82794E5           LDR      R2,[R4, #+1992]
   \   00000610   920101E0           MUL      R1,R2,R1
   \   00000614   BC2794E5           LDR      R2,[R4, #+1980]
   \   00000618   920101E0           MUL      R1,R2,R1
   \   0000061C   010050E1           CMP      R0,R1
   \   00000620   F5FFFFBA           BLT      ??MP3Decode_50
    412          			MP3ClearBadFrame(mp3DecInfo, outbuf);
    413          			return ERR_MP3_INVALID_SUBBAND;			
   \   00000624   0B00E0E3           MVN      R0,#+11
   \   00000628   F28FBDE8           POP      {R1,R4-R11,PC}
    414          		}
    415          	}
    416          	return ERR_MP3_NONE;
   \                     ??MP3Decode_31:
   \   0000062C   0000A0E3           MOV      R0,#+0
   \   00000630   F28FBDE8           POP      {R1,R4-R11,PC}   ;; return
    417          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     xmp3_samplesPerFrameTab

   Maximum stack usage in bytes:

     Function            CSTACK
     --------            ------
     MP3Decode              48
     MP3FindSyncWord         0
     MP3FreeDecoder          4
     MP3GetLastFrameInfo     8
     MP3GetNextFrameInfo    12
     MP3InitDecoder          4


   Segment part sizes:

     Function/Label      Bytes
     --------------      -----
     MP3InitDecoder         4
     MP3FreeDecoder        20
     MP3FindSyncWord       72
     MP3GetLastFrameInfo  156
     MP3GetNextFrameInfo  212
     MP3Decode           1588
     ??DataTable1           4
      Others              156

 
 2 212 bytes in segment CODE
 
 2 056 bytes of CODE memory (+ 156 bytes shared)

Errors: none
Warnings: 1
