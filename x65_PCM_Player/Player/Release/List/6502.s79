//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   14/Feb/2012  15:39:13 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\NSF\6502 /
//                       .C                                                  /
//    Command line    =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\NSF\6502 /
//                       .C -D NDEBUG -lC D:\SVN\SieELF\SieELF\x65_PCM_Playe /
//                       r\Player\Release\List\ -lA                          /
//                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player\Player /
//                       \Release\Obj\ -s9 --cpu_mode arm --endian little    /
//                       --cpu ARM926EJ-S --stack_align 4 --interwork -e     /
//                       --fpu None --dlib_config "D:\Program                /
//                       Files\IAR\Embedded Workbench 4.0                    /
//                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude      /
//                       swilib.h -I "D:\Program Files\IAR\Embedded          /
//                       Workbench 4.0 Evaluation\ARM\INC\"                  /
//                       --inline_threshold=16                               /
//    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\6502.s79                                       /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME `6502`

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        MULTWEAK ??APUWrite??rA
??DataTable0 EQU 0
??DataTable1 EQU 0
??DataTable10 EQU 0
??DataTable100 EQU 0
??DataTable101 EQU 0
??DataTable102 EQU 0
??DataTable103 EQU 0
??DataTable104 EQU 0
??DataTable105 EQU 0
??DataTable106 EQU 0
??DataTable107 EQU 0
??DataTable108 EQU 0
??DataTable109 EQU 0
??DataTable11 EQU 0
??DataTable110 EQU 0
??DataTable111 EQU 0
??DataTable112 EQU 0
??DataTable113 EQU 0
??DataTable114 EQU 0
??DataTable115 EQU 0
??DataTable116 EQU 0
??DataTable117 EQU 0
??DataTable118 EQU 0
??DataTable119 EQU 0
??DataTable12 EQU 0
??DataTable120 EQU 0
??DataTable121 EQU 0
??DataTable122 EQU 0
??DataTable123 EQU 0
??DataTable125 EQU 0
??DataTable126 EQU 0
??DataTable127 EQU 0
??DataTable128 EQU 0
??DataTable129 EQU 0
??DataTable13 EQU 0
??DataTable130 EQU 0
??DataTable131 EQU 0
??DataTable132 EQU 0
??DataTable133 EQU 0
??DataTable134 EQU 0
??DataTable135 EQU 0
??DataTable136 EQU 0
??DataTable137 EQU 0
??DataTable138 EQU 0
??DataTable14 EQU 0
??DataTable141 EQU 0
??DataTable142 EQU 0
??DataTable143 EQU 0
??DataTable144 EQU 0
??DataTable145 EQU 0
??DataTable146 EQU 0
??DataTable147 EQU 0
??DataTable148 EQU 0
??DataTable15 EQU 0
??DataTable16 EQU 0
??DataTable17 EQU 0
??DataTable18 EQU 0
??DataTable19 EQU 0
??DataTable2 EQU 0
??DataTable20 EQU 0
??DataTable21 EQU 0
??DataTable22 EQU 0
??DataTable23 EQU 0
??DataTable24 EQU 0
??DataTable25 EQU 0
??DataTable26 EQU 0
??DataTable27 EQU 0
??DataTable28 EQU 0
??DataTable29 EQU 0
??DataTable3 EQU 0
??DataTable30 EQU 0
??DataTable31 EQU 0
??DataTable32 EQU 0
??DataTable33 EQU 0
??DataTable34 EQU 0
??DataTable35 EQU 0
??DataTable36 EQU 0
??DataTable37 EQU 0
??DataTable38 EQU 0
??DataTable39 EQU 0
??DataTable4 EQU 0
??DataTable40 EQU 0
??DataTable41 EQU 0
??DataTable42 EQU 0
??DataTable43 EQU 0
??DataTable44 EQU 0
??DataTable45 EQU 0
??DataTable46 EQU 0
??DataTable47 EQU 0
??DataTable48 EQU 0
??DataTable49 EQU 0
??DataTable5 EQU 0
??DataTable51 EQU 0
??DataTable52 EQU 0
??DataTable54 EQU 0
??DataTable55 EQU 0
??DataTable56 EQU 0
??DataTable57 EQU 0
??DataTable58 EQU 0
??DataTable59 EQU 0
??DataTable6 EQU 0
??DataTable60 EQU 0
??DataTable61 EQU 0
??DataTable62 EQU 0
??DataTable63 EQU 0
??DataTable64 EQU 0
??DataTable65 EQU 0
??DataTable66 EQU 0
??DataTable67 EQU 0
??DataTable68 EQU 0
??DataTable69 EQU 0
??DataTable7 EQU 0
??DataTable70 EQU 0
??DataTable71 EQU 0
??DataTable73 EQU 0
??DataTable74 EQU 0
??DataTable75 EQU 0
??DataTable76 EQU 0
??DataTable77 EQU 0
??DataTable78 EQU 0
??DataTable79 EQU 0
??DataTable8 EQU 0
??DataTable80 EQU 0
??DataTable81 EQU 0
??DataTable82 EQU 0
??DataTable83 EQU 0
??DataTable84 EQU 0
??DataTable85 EQU 0
??DataTable86 EQU 0
??DataTable87 EQU 0
??DataTable88 EQU 0
??DataTable89 EQU 0
??DataTable9 EQU 0
??DataTable90 EQU 0
??DataTable92 EQU 0
??DataTable93 EQU 0
??DataTable94 EQU 0
??DataTable95 EQU 0
??DataTable96 EQU 0
??DataTable97 EQU 0
??DataTable98 EQU 0
??DataTable99 EQU 0
        MULTWEAK ??abs6502??rT
        MULTWEAK ??absx6502??rT
        MULTWEAK ??absy6502??rT
        MULTWEAK ??adc6502??rT
        MULTWEAK ??and6502??rT
        MULTWEAK ??asl6502??rT
        MULTWEAK ??asla6502??rT
        MULTWEAK ??bcc6502??rT
        MULTWEAK ??bcs6502??rT
        MULTWEAK ??beq6502??rT
        MULTWEAK ??bit6502??rT
        MULTWEAK ??bmi6502??rT
        MULTWEAK ??bne6502??rT
        MULTWEAK ??bpl6502??rT
        MULTWEAK ??bra6502??rT
        MULTWEAK ??brk6502??rT
        MULTWEAK ??bvc6502??rT
        MULTWEAK ??bvs6502??rT
        MULTWEAK ??clc6502??rT
        MULTWEAK ??cld6502??rT
        MULTWEAK ??cli6502??rT
        MULTWEAK ??clv6502??rT
        MULTWEAK ??cmp6502??rT
        MULTWEAK ??cpx6502??rT
        MULTWEAK ??cpy6502??rT
        MULTWEAK ??dea6502??rT
        MULTWEAK ??dec6502??rT
        MULTWEAK ??dex6502??rT
        MULTWEAK ??dey6502??rT
        MULTWEAK ??eor6502??rT
        MULTWEAK ??exec6502??rT
        MULTWEAK ??get6502memory??rT
        MULTWEAK ??immediate6502??rT
        MULTWEAK ??implied6502??rT
        MULTWEAK ??ina6502??rT
        MULTWEAK ??inc6502??rT
        MULTWEAK ??indabsx6502??rT
        MULTWEAK ??indirect6502??rT
        MULTWEAK ??indx6502??rT
        MULTWEAK ??indy6502??rT
        MULTWEAK ??indzp6502??rT
        MULTWEAK ??init6502??rT
        MULTWEAK ??inx6502??rT
        MULTWEAK ??iny6502??rT
        MULTWEAK ??irq6502??rT
        MULTWEAK ??jmp6502??rT
        MULTWEAK ??jsr6502??rT
        MULTWEAK ??lda6502??rT
        MULTWEAK ??ldx6502??rT
        MULTWEAK ??ldy6502??rT
        MULTWEAK ??lsr6502??rT
        MULTWEAK ??lsra6502??rT
        MULTWEAK ??nmi6502??rT
        MULTWEAK ??nop6502??rT
        MULTWEAK ??ora6502??rT
        MULTWEAK ??pha6502??rT
        MULTWEAK ??php6502??rT
        MULTWEAK ??phx6502??rT
        MULTWEAK ??phy6502??rT
        MULTWEAK ??pla6502??rT
        MULTWEAK ??plp6502??rT
        MULTWEAK ??plx6502??rT
        MULTWEAK ??ply6502??rT
        MULTWEAK ??put6502memory??rT
        MULTWEAK ??relative6502??rT
        MULTWEAK ??reset6502??rT
        MULTWEAK ??rol6502??rT
        MULTWEAK ??rola6502??rT
        MULTWEAK ??ror6502??rT
        MULTWEAK ??rora6502??rT
        MULTWEAK ??rti6502??rT
        MULTWEAK ??rts6502??rT
        MULTWEAK ??sbc6502??rT
        MULTWEAK ??sec6502??rT
        MULTWEAK ??sed6502??rT
        MULTWEAK ??sei6502??rT
        MULTWEAK ??sta6502??rT
        MULTWEAK ??stx6502??rT
        MULTWEAK ??sty6502??rT
        MULTWEAK ??stz6502??rT
        MULTWEAK ??tax6502??rT
        MULTWEAK ??tay6502??rT
        MULTWEAK ??trb6502??rT
        MULTWEAK ??tsb6502??rT
        MULTWEAK ??tsx6502??rT
        MULTWEAK ??txa6502??rT
        MULTWEAK ??txs6502??rT
        MULTWEAK ??tya6502??rT
        MULTWEAK ??zp6502??rT
        MULTWEAK ??zpx6502??rT
        MULTWEAK ??zpy6502??rT
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC a_reg
        PUBLIC abs6502
        FUNCTION abs6502,0601H
        PUBLIC absx6502
        FUNCTION absx6502,0601H
        PUBLIC absy6502
        FUNCTION absy6502,0601H
        PUBLIC adc6502
        FUNCTION adc6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC adrmode
        PUBLIC and6502
        FUNCTION and6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC asl6502
        FUNCTION asl6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC asla6502
        FUNCTION asla6502,0601H
        PUBLIC bcc6502
        FUNCTION bcc6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC bcs6502
        FUNCTION bcs6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC beq6502
        FUNCTION beq6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC bit6502
        FUNCTION bit6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC bmi6502
        FUNCTION bmi6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC bne6502
        FUNCTION bne6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC bpl6502
        FUNCTION bpl6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC bra6502
        FUNCTION bra6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC brk6502
        FUNCTION brk6502,0601H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC bvc6502
        FUNCTION bvc6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC bvs6502
        FUNCTION bvs6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC clc6502
        FUNCTION clc6502,0601H
        PUBLIC cld6502
        FUNCTION cld6502,0601H
        PUBLIC cli6502
        FUNCTION cli6502,0601H
        PUBLIC clockticks6502
        PUBLIC clv6502
        FUNCTION clv6502,0601H
        PUBLIC cmp6502
        FUNCTION cmp6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC cpx6502
        FUNCTION cpx6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC cpy6502
        FUNCTION cpy6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC dea6502
        FUNCTION dea6502,0601H
        PUBLIC dec6502
        FUNCTION dec6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC dex6502
        FUNCTION dex6502,0601H
        PUBLIC dey6502
        FUNCTION dey6502,0601H
        PUBLIC eor6502
        FUNCTION eor6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC exec6502
        FUNCTION exec6502,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC flag_reg
        PUBLIC get6502memory
        FUNCTION get6502memory,0203H
        PUBLIC help
        PUBLIC immediate6502
        FUNCTION immediate6502,0601H
        PUBLIC implied6502
        FUNCTION implied6502,0601H
        PUBLIC ina6502
        FUNCTION ina6502,0601H
        PUBLIC inc6502
        FUNCTION inc6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC indabsx6502
        FUNCTION indabsx6502,0601H
        PUBLIC indirect6502
        FUNCTION indirect6502,0601H
        PUBLIC indx6502
        FUNCTION indx6502,0601H
        PUBLIC indy6502
        FUNCTION indy6502,0601H
        PUBLIC indzp6502
        FUNCTION indzp6502,0601H
        PUBLIC init6502
        FUNCTION init6502,0203H
        LOCFRAME CSTACK, 36, STACK
        PUBLIC instruction
        PUBLIC inx6502
        FUNCTION inx6502,0601H
        PUBLIC iny6502
        FUNCTION iny6502,0601H
        PUBLIC irq6502
        FUNCTION irq6502,0201H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC jmp6502
        FUNCTION jmp6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC jsr6502
        FUNCTION jsr6502,0601H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC lda6502
        FUNCTION lda6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC ldx6502
        FUNCTION ldx6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC ldy6502
        FUNCTION ldy6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC lsr6502
        FUNCTION lsr6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC lsra6502
        FUNCTION lsra6502,0601H
        PUBLIC nmi6502
        FUNCTION nmi6502,0201H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC nop6502
        FUNCTION nop6502,0601H
        PUBLIC opcode
        PUBLIC ora6502
        FUNCTION ora6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC pc_reg
        PUBLIC pha6502
        FUNCTION pha6502,0601H
        PUBLIC php6502
        FUNCTION php6502,0601H
        PUBLIC phx6502
        FUNCTION phx6502,0601H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC phy6502
        FUNCTION phy6502,0601H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC pla6502
        FUNCTION pla6502,0601H
        PUBLIC plp6502
        FUNCTION plp6502,0601H
        PUBLIC plx6502
        FUNCTION plx6502,0601H
        PUBLIC ply6502
        FUNCTION ply6502,0601H
        PUBLIC put6502memory
        FUNCTION put6502memory,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC relative6502
        FUNCTION relative6502,0601H
        PUBLIC reset6502
        FUNCTION reset6502,0203H
        PUBLIC rol6502
        FUNCTION rol6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC rola6502
        FUNCTION rola6502,0601H
        PUBLIC ror6502
        FUNCTION ror6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC rora6502
        FUNCTION rora6502,0601H
        PUBLIC rti6502
        FUNCTION rti6502,0601H
        PUBLIC rts6502
        FUNCTION rts6502,0601H
        PUBLIC s_reg
        PUBLIC saveflags
        PUBLIC savepc
        PUBLIC sbc6502
        FUNCTION sbc6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC sec6502
        FUNCTION sec6502,0601H
        PUBLIC sed6502
        FUNCTION sed6502,0601H
        PUBLIC sei6502
        FUNCTION sei6502,0601H
        PUBLIC sta6502
        FUNCTION sta6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC stx6502
        FUNCTION stx6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC sty6502
        FUNCTION sty6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC stz6502
        FUNCTION stz6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC sum
        PUBLIC tax6502
        FUNCTION tax6502,0601H
        PUBLIC tay6502
        FUNCTION tay6502,0601H
        PUBLIC ticks
        PUBLIC trb6502
        FUNCTION trb6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC tsb6502
        FUNCTION tsb6502,0601H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC tsx6502
        FUNCTION tsx6502,0601H
        PUBLIC txa6502
        FUNCTION txa6502,0601H
        PUBLIC txs6502
        FUNCTION txs6502,0601H
        PUBLIC tya6502
        FUNCTION tya6502,0601H
        PUBLIC value
        PUBLIC x_reg
        PUBLIC y_reg
        PUBLIC zp6502
        FUNCTION zp6502,0601H
        PUBLIC zpx6502
        FUNCTION zpx6502,0601H
        PUBLIC zpy6502
        FUNCTION zpy6502,0601H
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
APUWrite            SYMBOL "APUWrite"
??APUWrite??rA      SYMBOL "??rA", APUWrite
abs6502             SYMBOL "abs6502"
??abs6502??rT       SYMBOL "??rT", abs6502
absx6502            SYMBOL "absx6502"
??absx6502??rT      SYMBOL "??rT", absx6502
absy6502            SYMBOL "absy6502"
??absy6502??rT      SYMBOL "??rT", absy6502
adc6502             SYMBOL "adc6502"
??adc6502??rT       SYMBOL "??rT", adc6502
and6502             SYMBOL "and6502"
??and6502??rT       SYMBOL "??rT", and6502
asl6502             SYMBOL "asl6502"
??asl6502??rT       SYMBOL "??rT", asl6502
asla6502            SYMBOL "asla6502"
??asla6502??rT      SYMBOL "??rT", asla6502
bcc6502             SYMBOL "bcc6502"
??bcc6502??rT       SYMBOL "??rT", bcc6502
bcs6502             SYMBOL "bcs6502"
??bcs6502??rT       SYMBOL "??rT", bcs6502
beq6502             SYMBOL "beq6502"
??beq6502??rT       SYMBOL "??rT", beq6502
bit6502             SYMBOL "bit6502"
??bit6502??rT       SYMBOL "??rT", bit6502
bmi6502             SYMBOL "bmi6502"
??bmi6502??rT       SYMBOL "??rT", bmi6502
bne6502             SYMBOL "bne6502"
??bne6502??rT       SYMBOL "??rT", bne6502
bpl6502             SYMBOL "bpl6502"
??bpl6502??rT       SYMBOL "??rT", bpl6502
bra6502             SYMBOL "bra6502"
??bra6502??rT       SYMBOL "??rT", bra6502
brk6502             SYMBOL "brk6502"
??brk6502??rT       SYMBOL "??rT", brk6502
bvc6502             SYMBOL "bvc6502"
??bvc6502??rT       SYMBOL "??rT", bvc6502
bvs6502             SYMBOL "bvs6502"
??bvs6502??rT       SYMBOL "??rT", bvs6502
clc6502             SYMBOL "clc6502"
??clc6502??rT       SYMBOL "??rT", clc6502
cld6502             SYMBOL "cld6502"
??cld6502??rT       SYMBOL "??rT", cld6502
cli6502             SYMBOL "cli6502"
??cli6502??rT       SYMBOL "??rT", cli6502
clv6502             SYMBOL "clv6502"
??clv6502??rT       SYMBOL "??rT", clv6502
cmp6502             SYMBOL "cmp6502"
??cmp6502??rT       SYMBOL "??rT", cmp6502
cpx6502             SYMBOL "cpx6502"
??cpx6502??rT       SYMBOL "??rT", cpx6502
cpy6502             SYMBOL "cpy6502"
??cpy6502??rT       SYMBOL "??rT", cpy6502
dea6502             SYMBOL "dea6502"
??dea6502??rT       SYMBOL "??rT", dea6502
dec6502             SYMBOL "dec6502"
??dec6502??rT       SYMBOL "??rT", dec6502
dex6502             SYMBOL "dex6502"
??dex6502??rT       SYMBOL "??rT", dex6502
dey6502             SYMBOL "dey6502"
??dey6502??rT       SYMBOL "??rT", dey6502
eor6502             SYMBOL "eor6502"
??eor6502??rT       SYMBOL "??rT", eor6502
exec6502            SYMBOL "exec6502"
??exec6502??rT      SYMBOL "??rT", exec6502
get6502memory       SYMBOL "get6502memory"
??get6502memory??rT SYMBOL "??rT", get6502memory
immediate6502       SYMBOL "immediate6502"
??immediate6502??rT SYMBOL "??rT", immediate6502
implied6502         SYMBOL "implied6502"
??implied6502??rT   SYMBOL "??rT", implied6502
ina6502             SYMBOL "ina6502"
??ina6502??rT       SYMBOL "??rT", ina6502
inc6502             SYMBOL "inc6502"
??inc6502??rT       SYMBOL "??rT", inc6502
indabsx6502         SYMBOL "indabsx6502"
??indabsx6502??rT   SYMBOL "??rT", indabsx6502
indirect6502        SYMBOL "indirect6502"
??indirect6502??rT  SYMBOL "??rT", indirect6502
indx6502            SYMBOL "indx6502"
??indx6502??rT      SYMBOL "??rT", indx6502
indy6502            SYMBOL "indy6502"
??indy6502??rT      SYMBOL "??rT", indy6502
indzp6502           SYMBOL "indzp6502"
??indzp6502??rT     SYMBOL "??rT", indzp6502
init6502            SYMBOL "init6502"
??init6502??rT      SYMBOL "??rT", init6502
inx6502             SYMBOL "inx6502"
??inx6502??rT       SYMBOL "??rT", inx6502
iny6502             SYMBOL "iny6502"
??iny6502??rT       SYMBOL "??rT", iny6502
irq6502             SYMBOL "irq6502"
??irq6502??rT       SYMBOL "??rT", irq6502
jmp6502             SYMBOL "jmp6502"
??jmp6502??rT       SYMBOL "??rT", jmp6502
jsr6502             SYMBOL "jsr6502"
??jsr6502??rT       SYMBOL "??rT", jsr6502
lda6502             SYMBOL "lda6502"
??lda6502??rT       SYMBOL "??rT", lda6502
ldx6502             SYMBOL "ldx6502"
??ldx6502??rT       SYMBOL "??rT", ldx6502
ldy6502             SYMBOL "ldy6502"
??ldy6502??rT       SYMBOL "??rT", ldy6502
lsr6502             SYMBOL "lsr6502"
??lsr6502??rT       SYMBOL "??rT", lsr6502
lsra6502            SYMBOL "lsra6502"
??lsra6502??rT      SYMBOL "??rT", lsra6502
nmi6502             SYMBOL "nmi6502"
??nmi6502??rT       SYMBOL "??rT", nmi6502
nop6502             SYMBOL "nop6502"
??nop6502??rT       SYMBOL "??rT", nop6502
ora6502             SYMBOL "ora6502"
??ora6502??rT       SYMBOL "??rT", ora6502
pha6502             SYMBOL "pha6502"
??pha6502??rT       SYMBOL "??rT", pha6502
php6502             SYMBOL "php6502"
??php6502??rT       SYMBOL "??rT", php6502
phx6502             SYMBOL "phx6502"
??phx6502??rT       SYMBOL "??rT", phx6502
phy6502             SYMBOL "phy6502"
??phy6502??rT       SYMBOL "??rT", phy6502
pla6502             SYMBOL "pla6502"
??pla6502??rT       SYMBOL "??rT", pla6502
plp6502             SYMBOL "plp6502"
??plp6502??rT       SYMBOL "??rT", plp6502
plx6502             SYMBOL "plx6502"
??plx6502??rT       SYMBOL "??rT", plx6502
ply6502             SYMBOL "ply6502"
??ply6502??rT       SYMBOL "??rT", ply6502
put6502memory       SYMBOL "put6502memory"
??put6502memory??rT SYMBOL "??rT", put6502memory
relative6502        SYMBOL "relative6502"
??relative6502??rT  SYMBOL "??rT", relative6502
reset6502           SYMBOL "reset6502"
??reset6502??rT     SYMBOL "??rT", reset6502
rol6502             SYMBOL "rol6502"
??rol6502??rT       SYMBOL "??rT", rol6502
rola6502            SYMBOL "rola6502"
??rola6502??rT      SYMBOL "??rT", rola6502
ror6502             SYMBOL "ror6502"
??ror6502??rT       SYMBOL "??rT", ror6502
rora6502            SYMBOL "rora6502"
??rora6502??rT      SYMBOL "??rT", rora6502
rti6502             SYMBOL "rti6502"
??rti6502??rT       SYMBOL "??rT", rti6502
rts6502             SYMBOL "rts6502"
??rts6502??rT       SYMBOL "??rT", rts6502
sbc6502             SYMBOL "sbc6502"
??sbc6502??rT       SYMBOL "??rT", sbc6502
sec6502             SYMBOL "sec6502"
??sec6502??rT       SYMBOL "??rT", sec6502
sed6502             SYMBOL "sed6502"
??sed6502??rT       SYMBOL "??rT", sed6502
sei6502             SYMBOL "sei6502"
??sei6502??rT       SYMBOL "??rT", sei6502
sta6502             SYMBOL "sta6502"
??sta6502??rT       SYMBOL "??rT", sta6502
stx6502             SYMBOL "stx6502"
??stx6502??rT       SYMBOL "??rT", stx6502
sty6502             SYMBOL "sty6502"
??sty6502??rT       SYMBOL "??rT", sty6502
stz6502             SYMBOL "stz6502"
??stz6502??rT       SYMBOL "??rT", stz6502
tax6502             SYMBOL "tax6502"
??tax6502??rT       SYMBOL "??rT", tax6502
tay6502             SYMBOL "tay6502"
??tay6502??rT       SYMBOL "??rT", tay6502
trb6502             SYMBOL "trb6502"
??trb6502??rT       SYMBOL "??rT", trb6502
tsb6502             SYMBOL "tsb6502"
??tsb6502??rT       SYMBOL "??rT", tsb6502
tsx6502             SYMBOL "tsx6502"
??tsx6502??rT       SYMBOL "??rT", tsx6502
txa6502             SYMBOL "txa6502"
??txa6502??rT       SYMBOL "??rT", txa6502
txs6502             SYMBOL "txs6502"
??txs6502??rT       SYMBOL "??rT", txs6502
tya6502             SYMBOL "tya6502"
??tya6502??rT       SYMBOL "??rT", tya6502
zp6502              SYMBOL "zp6502"
??zp6502??rT        SYMBOL "??rT", zp6502
zpx6502             SYMBOL "zpx6502"
??zpx6502??rT       SYMBOL "??rT", zpx6502
zpy6502             SYMBOL "zpy6502"
??zpy6502??rT       SYMBOL "??rT", zpy6502

        EXTERN APUWrite
        FUNCTION APUWrite,0202H
        EXTERN addrmask
        EXTERN gameImage

// D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\NSF\6502.C
//    1 
//    2 #include "6502.h"
//    3 extern void APUWrite( WORD address, BYTE data );
//    4 /* flags = NVRBDIZC */

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//    5 BYTE a_reg, x_reg, y_reg, flag_reg, s_reg;
//    6 WORD pc_reg = 0;
pc_reg:
        DS8 2
//    7 
//    8 /* Macros for convenience */
//    9 #define A a_reg
//   10 #define X x_reg
//   11 #define Y y_reg
//   12 #define P flag_reg
//   13 #define S s_reg
//   14 #define PC pc_reg
//   15 
//   16 /* internal registers */
//   17 BYTE opcode;
//   18 int clockticks6502 = 0;
//   19 
//   20 /* help variables */
//   21 WORD savepc;
savepc:
        DS8 2
//   22 BYTE value;
//   23 int sum, saveflags;
//   24 
//   25 /* arrays */
//   26 void( * adrmode[256] ) ();
//   27 void( * instruction[256] ) ();
//   28 int ticks[256];
//   29 WORD help;
help:
        DS8 2
        DS8 2
adrmode:
        DS8 1024
instruction:
        DS8 1024
ticks:
        DS8 1024
clockticks6502:
        DS8 4
sum:
        DS8 4
saveflags:
        DS8 4
a_reg:
        DS8 1
x_reg:
        DS8 1
y_reg:
        DS8 1
flag_reg:
        DS8 1
s_reg:
        DS8 1
opcode:
        DS8 1
value:
        DS8 1

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??get6502memory??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE get6502memory
//   30 
//   31 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function get6502memory
        ARM
//   32 int get6502memory( WORD addr )
//   33 {
//   34 
//   35   return ( gameImage[addr] );
get6502memory:
        LDR      R1,??DataTable72  ;; gameImage
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
        BX       LR               ;; return
        CFI EndBlock cfiBlock1
//   36 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??put6502memory??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE put6502memory
//   37 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function put6502memory
        ARM
//   38 void put6502memory( WORD addr, BYTE byte )
//   39 {
put6502memory:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//   40   if ( addr > 32768 ) return;
        MOV      R2,#+1
        ORR      R2,R2,#0x8000
        CMP      R0,R2
        POPCS    {PC}
//   41   gameImage[addr] = byte;
        LDR      R3,??DataTable72  ;; gameImage
//   42   if ( ( addr > 0x3FFF ) && ( addr < 0x4020 ) ) APUWrite( addr, byte );
        CMP      R0,#+16384
        LDR      R3,[R3, #+0]
        STRB     R1,[R0, +R3]
        POPCC    {PC}
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        POPCS    {PC}
        _BLF     APUWrite,??APUWrite??rA
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock3
//   43 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??implied6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE implied6502
//   44 
//   45 
//   46 
//   47 /* Adressing modes */
//   48 /* Implied */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function implied6502
        ARM
//   49 void implied6502()
//   50 {
//   51 }
implied6502:
        BX       LR               ;; return
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??immediate6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE immediate6502
//   52 
//   53 /* #Immediate */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function immediate6502
        ARM
//   54 void immediate6502()
//   55 {
//   56   savepc = PC++;
immediate6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDRH     R1,[R0, #+0]
        STRH     R1,[R0, #+2]
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+0]
//   57 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??abs6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE abs6502
//   58 
//   59 /* ABS */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function abs6502
        ARM
//   60 void abs6502()
//   61 {
//   62   savepc = gameImage[PC] + ( gameImage[PC + 1] << 8 );
abs6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R3,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R3,[R3, #+0]
        ADD      R2,R1,R3
        LDRB     R3,[R2, #+0]
        LDRB     R2,[R2, #+1]
//   63   PC++;
//   64   PC++;
        ADD      R1,R1,#+2
        STRH     R1,[R0, #+0]
        ADD      R2,R3,R2, LSL #+8
        STRH     R2,[R0, #+2]
//   65 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??relative6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE relative6502
//   66 
//   67 /* Branch */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function relative6502
        ARM
//   68 void relative6502()
//   69 {
//   70   savepc = gameImage[PC++];
relative6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R3,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R3,[R3, #+0]
        LDRB     R2,[R1, +R3]
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+0]
//   71   if ( savepc & 0x80 ) savepc -= 0x100;
        TST      R2,#0x80
        ADDNE    R2,R2,#+65280
        STRH     R2,[R0, #+2]
//   72   if ( ( savepc >> 8 ) != ( PC >> 8 ) )
        LSL      R2,R2,#+16
        LSL      R1,R1,#+16
        LSR      R2,R2,#+24
        LSR      R1,R1,#+24
        CMP      R2,R1
//   73     clockticks6502++;
        LDRNE    R1,[R0, #+3080]
        ADDNE    R1,R1,#+1
        STRNE    R1,[R0, #+3080]
//   74 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??indirect6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE indirect6502
//   75 
//   76 /* (ABS) */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function indirect6502
        ARM
//   77 void indirect6502()
//   78 {
//   79   help = gameImage[PC] + ( gameImage[PC + 1] << 8 );
indirect6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R2,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R2,[R2, #+0]
        ADD      R3,R1,R2
        LDRB     R12,[R3, #+0]
        LDRB     R3,[R3, #+1]
//   80   savepc = gameImage[help] + ( gameImage[help + 1] << 8 );
//   81   PC++;
//   82   PC++;
        ADD      R1,R1,#+2
        ADD      R3,R12,R3, LSL #+8
        STRH     R3,[R0, #+4]
        LDRH     R3,[R0, #+4]
        ADD      R2,R3,R2
        LDRB     R3,[R2, #+0]
        LDRB     R2,[R2, #+1]
        STRH     R1,[R0, #+0]
        ADD      R2,R3,R2, LSL #+8
        STRH     R2,[R0, #+2]
//   83 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??absx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock14
        REQUIRE absx6502
//   84 
//   85 /* ABS,X */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI Function absx6502
        ARM
//   86 void absx6502()
//   87 {
//   88   savepc = gameImage[PC] + ( gameImage[PC + 1] << 8 );
absx6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R3,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R3,[R3, #+0]
        ADD      R2,R1,R3
        LDRB     R3,[R2, #+0]
        LDRB     R2,[R2, #+1]
//   89   PC++;
//   90   PC++;
        ADD      R1,R1,#+2
        STRH     R1,[R0, #+0]
//   91   if ( ticks[opcode] == 4 )
        LDRB     R1,[R0, #+3093]
        ADD      R2,R3,R2, LSL #+8
        STRH     R2,[R0, #+2]
        LDRB     R2,[R0, #+3097]
        ADD      R2,R0,R2, LSL #+2
        LDR      R2,[R2, #+2056]
        CMP      R2,#+4
        BNE      ??absx6502_0
//   92     if ( ( savepc >> 8 ) != ( ( savepc + X ) >> 8 ) )
        LDRH     R2,[R0, #+2]
        LSR      R3,R2,#+8
        ADD      R2,R1,R2
        CMP      R3,R2, ASR #+8
//   93       clockticks6502++;
        LDRNE    R2,[R0, #+3080]
        ADDNE    R2,R2,#+1
        STRNE    R2,[R0, #+3080]
//   94   savepc += X;
??absx6502_0:
        LDRH     R2,[R0, #+2]
        ADD      R1,R1,R2
        STRH     R1,[R0, #+2]
//   95 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??absy6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock16
        REQUIRE absy6502
//   96 
//   97 /* ABS,Y */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI Function absy6502
        ARM
//   98 void absy6502()
//   99 {
//  100   savepc = gameImage[PC] + ( gameImage[PC + 1] << 8 );
absy6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R3,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R3,[R3, #+0]
        ADD      R2,R1,R3
        LDRB     R3,[R2, #+0]
        LDRB     R2,[R2, #+1]
//  101   PC++;
//  102   PC++;
        ADD      R1,R1,#+2
        STRH     R1,[R0, #+0]
//  103 
//  104   if ( ticks[opcode] == 4 )
        LDRB     R1,[R0, #+3094]
        ADD      R2,R3,R2, LSL #+8
        STRH     R2,[R0, #+2]
        LDRB     R2,[R0, #+3097]
        ADD      R2,R0,R2, LSL #+2
        LDR      R2,[R2, #+2056]
        CMP      R2,#+4
        BNE      ??absy6502_0
//  105     if ( ( savepc >> 8 ) != ( ( savepc + Y ) >> 8 ) )
        LDRH     R2,[R0, #+2]
        LSR      R3,R2,#+8
        ADD      R2,R1,R2
        CMP      R3,R2, ASR #+8
//  106       clockticks6502++;
        LDRNE    R2,[R0, #+3080]
        ADDNE    R2,R2,#+1
        STRNE    R2,[R0, #+3080]
//  107   savepc += Y;
??absy6502_0:
        LDRH     R2,[R0, #+2]
        ADD      R1,R1,R2
        STRH     R1,[R0, #+2]
//  108 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock17

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon0
        CFI NoFunction
        THUMB
??zp6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock18
        REQUIRE zp6502
//  109 
//  110 /* ZP */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon1
        CFI Function zp6502
        ARM
//  111 void zp6502()
//  112 {
//  113   savepc = gameImage[PC++];
zp6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R3,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R3,[R3, #+0]
        LDRB     R2,[R1, +R3]
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+0]
        STRH     R2,[R0, #+2]
//  114 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock19

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??zpx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock20
        REQUIRE zpx6502
//  115 
//  116 /* ZP,X */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI Function zpx6502
        ARM
//  117 void zpx6502()
//  118 {
//  119   savepc = gameImage[PC++] + X;
zpx6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R3,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R3,[R3, #+0]
        LDRB     R2,[R1, +R3]
        LDRB     R3,[R0, #+3093]
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+0]
        ADD      R2,R3,R2
        STRH     R2,[R0, #+2]
//  120   savepc &= 0x00ff;
        LDRH     R1,[R0, #+2]
        AND      R1,R1,#0xFF
        STRH     R1,[R0, #+2]
//  121 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock21

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon0
        CFI NoFunction
        THUMB
??zpy6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock22
        REQUIRE zpy6502
//  122 
//  123 /* ZP,Y */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon1
        CFI Function zpy6502
        ARM
//  124 void zpy6502()
//  125 {
//  126   savepc = gameImage[PC++] + Y;
zpy6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R3,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R3,[R3, #+0]
        LDRB     R2,[R1, +R3]
        LDRB     R3,[R0, #+3094]
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+0]
        ADD      R2,R3,R2
        STRH     R2,[R0, #+2]
//  127   savepc &= 0x00ff;
        LDRH     R1,[R0, #+2]
        AND      R1,R1,#0xFF
        STRH     R1,[R0, #+2]
//  128 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock23

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??indx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock24
        REQUIRE indx6502
//  129 
//  130 /* (ZP,X) */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI Function indx6502
        ARM
//  131 void indx6502()
//  132 {
//  133   value = gameImage[PC++] + X;
indx6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R2,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R2,[R2, #+0]
        LDRB     R12,[R0, #+3093]
        LDRB     R3,[R1, +R2]
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+0]
        ADD      R3,R12,R3
        STRB     R3,[R0, #+3098]
//  134   savepc = gameImage[value] + ( gameImage[value + 1] << 8 );
        AND      R3,R3,#0xFF
        ADD      R1,R3,R2
        LDRB     R2,[R1, #+0]
        LDRB     R1,[R1, #+1]
        ADD      R1,R2,R1, LSL #+8
        STRH     R1,[R0, #+2]
//  135 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock25

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock26 Using cfiCommon0
        CFI NoFunction
        THUMB
??indy6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock26
        REQUIRE indy6502
//  136 
//  137 /* (ZP),Y */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock27 Using cfiCommon1
        CFI Function indy6502
        ARM
//  138 void indy6502()
//  139 {
//  140   value = gameImage[PC++];
indy6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R2,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R2,[R2, #+0]
        LDRB     R3,[R1, +R2]
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+0]
        STRB     R3,[R0, #+3098]
//  141   savepc = gameImage[value] + ( gameImage[value + 1] << 8 );
        ADD      R1,R3,R2
        LDRB     R2,[R1, #+0]
        LDRB     R1,[R1, #+1]
        ADD      R1,R2,R1, LSL #+8
//  142   if ( ticks[opcode] == 5 )
        LDRB     R2,[R0, #+3097]
        STRH     R1,[R0, #+2]
        LDRB     R1,[R0, #+3094]
        ADD      R2,R0,R2, LSL #+2
        LDR      R2,[R2, #+2056]
        CMP      R2,#+5
        BNE      ??indy6502_0
//  143     if ( ( savepc >> 8 ) != ( ( savepc + Y ) >> 8 ) )
        LDRH     R2,[R0, #+2]
        LSR      R3,R2,#+8
        ADD      R2,R1,R2
        CMP      R3,R2, ASR #+8
//  144       clockticks6502++;
        LDRNE    R2,[R0, #+3080]
        ADDNE    R2,R2,#+1
        STRNE    R2,[R0, #+3080]
//  145   savepc += Y;
??indy6502_0:
        LDRH     R2,[R0, #+2]
        ADD      R1,R1,R2
        STRH     R1,[R0, #+2]
//  146 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock27

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock28 Using cfiCommon0
        CFI NoFunction
        THUMB
??indabsx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock28
        REQUIRE indabsx6502
//  147 
//  148 /* (ABS,X) */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock29 Using cfiCommon1
        CFI Function indabsx6502
        ARM
//  149 void indabsx6502()
//  150 {
//  151   help = gameImage[PC] + ( gameImage[PC + 1] << 8 ) + X;
indabsx6502:
        LDR      R1,??DataTable53  ;; pc_reg
        LDR      R0,??DataTable72  ;; gameImage
        LDRH     R2,[R1, #+0]
        LDR      R0,[R0, #+0]
        ADD      R2,R2,R0
        LDRB     R3,[R2, #+0]
        LDRB     R2,[R2, #+1]
        ADD      R2,R3,R2, LSL #+8
        LDRB     R3,[R1, #+3093]
        ADD      R2,R3,R2
        STRH     R2,[R1, #+4]
//  152   savepc = gameImage[help] + ( gameImage[help + 1] << 8 );
        MOV      R2,R2, LSL #+16
        MOV      R2,R2, LSR #+16
        ADD      R0,R2,R0
        LDRB     R2,[R0, #+0]
        LDRB     R0,[R0, #+1]
        ADD      R0,R2,R0, LSL #+8
        STRH     R0,[R1, #+2]
//  153 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock29

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock30 Using cfiCommon0
        CFI NoFunction
        THUMB
??indzp6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock30
        REQUIRE indzp6502
//  154 
//  155 /* (ZP) */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock31 Using cfiCommon1
        CFI Function indzp6502
        ARM
//  156 void indzp6502()
//  157 {
//  158   value = gameImage[PC++];
indzp6502:
        LDR      R0,??DataTable53  ;; pc_reg
        LDR      R2,??DataTable72  ;; gameImage
        LDRH     R1,[R0, #+0]
        LDR      R2,[R2, #+0]
        LDRB     R3,[R1, +R2]
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+0]
        STRB     R3,[R0, #+3098]
//  159   savepc = gameImage[value] + ( gameImage[value + 1] << 8 );
        ADD      R1,R3,R2
        LDRB     R2,[R1, #+0]
        LDRB     R1,[R1, #+1]
        ADD      R1,R2,R1, LSL #+8
        STRH     R1,[R0, #+2]
//  160 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock31

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock32 Using cfiCommon0
        CFI NoFunction
        THUMB
??adc6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock32
        REQUIRE adc6502
//  161 
//  162 /* Instructions */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock33 Using cfiCommon1
        CFI Function adc6502
        ARM
//  163 void adc6502()
//  164 {
adc6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  165   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  166   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable72  ;; gameImage
//  167   saveflags = ( P & 0x01 );
//  168   sum = ( ( char )A ) + ( ( char )value ) + saveflags;
        LDRB     R3,[R4, #+3092]
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
        LDRB     R1,[R4, #+3095]
        STRB     R0,[R4, #+3098]
        AND      R2,R1,#0x1
        STR      R2,[R4, #+3088]
        ADD      R0,R0,R3
        ADD      R0,R2,R0
        STR      R0,[R4, #+3084]
//  169   if ( ( sum > 0x7f ) || ( sum < -0x80 ) ) P |= 0x40;
        CMP      R0,#+128
        BGE      ??adc6502_0
        MVN      R2,#+127
        CMP      R0,R2
        BGE      ??adc6502_1
??adc6502_0:
        ORR      R1,R1,#0x40
//  170   else P &= 0xbf;
//  171   sum = A + value + saveflags;
//  172   if ( sum > 0xff ) P |= 0x01;
        CMP      R0,#+256
        BLT      ??adc6502_2
        ORR      R1,R1,#0x1
        B        ??adc6502_3
??adc6502_1:
        AND      R1,R1,#0xBF
//  173   else P &= 0xfe;
??adc6502_2:
        AND      R1,R1,#0xFE
//  174   A = sum;
//  175   if ( P & 0x08 )
??adc6502_3:
        TST      R1,#0x8
        BEQ      ??adc6502_4
//  176   {
//  177     P &= 0xfe;
        AND      R1,R1,#0xFE
//  178     if ( ( A & 0x0f ) > 0x09 )
        AND      R2,R0,#0xFF
        AND      R2,R2,#0xF
        CMP      R2,#+10
//  179       A += 0x06;
        ADDGE    R0,R0,#+6
//  180     if ( ( A & 0xf0 ) > 0x90 )
        AND      R2,R0,#0xFF
        AND      R2,R2,#0xF0
        CMP      R2,#+145
        BLT      ??adc6502_5
//  181     {
//  182       A += 0x60;
        ADD      R0,R0,#+96
//  183       P |= 0x01;
        ORR      R1,R1,#0x1
        B        ??adc6502_5
//  184     }
//  185   }
//  186   else
//  187   {
//  188     clockticks6502++;
??adc6502_4:
        LDR      R2,[R4, #+3080]
        ADD      R2,R2,#+1
        STR      R2,[R4, #+3080]
??adc6502_5:
        STRB     R0,[R4, #+3092]
//  189   }
//  190   if ( A ) P &= 0xfd;
        LSLS     R0,R0,#+24
        ANDNE    R0,R1,#0xFD
//  191   else P |= 0x02;
        ORREQ    R0,R1,#0x2
//  192   if ( A & 0x80 ) P |= 0x80;
        LDRB     R1,[R4, #+3092]
        TST      R1,#0x80
        ORRNE    R0,R0,#0x80
//  193   else P &= 0x7f;
        ANDEQ    R0,R0,#0x7F
        STRB     R0,[R4, #+3095]
//  194 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock33

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock34 Using cfiCommon0
        CFI NoFunction
        THUMB
??and6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock34
        REQUIRE and6502
//  195 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock35 Using cfiCommon1
        CFI Function and6502
        ARM
//  196 void and6502()
//  197 {
and6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  198   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  199   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable72  ;; gameImage
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
//  200   A &= value;
        LDRB     R1,[R4, #+3092]
        STRB     R0,[R4, #+3098]
        ANDS     R0,R0,R1
//  201   if ( A ) P &= 0xfd;
        LDRB     R1,[R4, #+3095]
        STRB     R0,[R4, #+3092]
        ANDNE    R1,R1,#0xFD
//  202   else P |= 0x02;
        ORREQ    R1,R1,#0x2
//  203   if ( A & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  204   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  205 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock35

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock36 Using cfiCommon0
        CFI NoFunction
        THUMB
??asl6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock36
        REQUIRE asl6502
//  206 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock37 Using cfiCommon1
        CFI Function asl6502
        ARM
//  207 void asl6502()
//  208 {
asl6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  209   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  210   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R2,??DataTable72  ;; gameImage
//  211   P = ( P & 0xfe ) | ( ( value >> 7 ) & 0x01 );
        LDRB     R3,[R4, #+3095]
        LDR      R2,[R2, #+0]
        ADD      R2,R0,R2
        LDRB     R1,[R2, #+0]
        AND      R3,R3,#0xFE
        STRB     R1,[R4, #+3098]
        ORR      R3,R3,R1, LSR #+7
        STRB     R3,[R4, #+3095]
//  212   value = value << 1;
        LSL      R1,R1,#+1
        STRB     R1,[R4, #+3098]
//  213   put6502memory( savepc, value );
        MOV      R3,#+1
        ORR      R3,R3,#0x8000
        CMP      R0,R3
        BCS      ??asl6502_0
        STRB     R1,[R2, #+0]
        CMP      R0,#+16384
        BCC      ??asl6502_0
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        BCS      ??asl6502_0
        AND      R1,R1,#0xFF
        _BLF     APUWrite,??APUWrite??rA
//  214   if ( value ) P &= 0xfd;
??asl6502_0:
        LDRB     R0,[R4, #+3095]
        LDRB     R1,[R4, #+3098]
        CMP      R1,#+0
        ANDNE    R0,R0,#0xFD
//  215   else P |= 0x02;
        ORREQ    R0,R0,#0x2
//  216   if ( value & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R0,R0,#0x80
//  217   else P &= 0x7f;
        ANDEQ    R0,R0,#0x7F
        STRB     R0,[R4, #+3095]
//  218 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock37

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock38 Using cfiCommon0
        CFI NoFunction
        THUMB
??asla6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock38
        REQUIRE asla6502
//  219 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock39 Using cfiCommon1
        CFI Function asla6502
        ARM
//  220 void asla6502()
//  221 {
//  222   P = ( P & 0xfe ) | ( ( A >> 7 ) & 0x01 );
asla6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3092]
        LDRB     R2,[R0, #+3095]
        AND      R2,R2,#0xFE
        ORR      R2,R2,R1, LSR #+7
//  223   A = A << 1;
        LSL      R1,R1,#+1
        STRB     R1,[R0, #+3092]
//  224   if ( A ) P &= 0xfd;
        ANDS     R1,R1,#0xFF
        ANDNE    R2,R2,#0xFD
//  225   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  226   if ( A & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  227   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  228 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock39

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock40 Using cfiCommon0
        CFI NoFunction
        THUMB
??bcc6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock40
        REQUIRE bcc6502
//  229 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock41 Using cfiCommon1
        CFI Function bcc6502
        ARM
//  230 void bcc6502()
//  231 {
bcc6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  232   if ( ( P & 0x01 ) == 0 )
        LDR      R4,??DataTable53  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        TST      R0,#0x1
        BNE      ??bcc6502_0
//  233   {
//  234     adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  235     PC += savepc;
        LDRH     R0,[R4, #+0]
        LDRH     R1,[R4, #+2]
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  236     clockticks6502++;
        LDR      R0,[R4, #+3080]
        ADD      R0,R0,#+1
        STR      R0,[R4, #+3080]
        POP      {R4,PC}
//  237   }
//  238   else
//  239     value = gameImage[PC++];
??bcc6502_0:
        LDRH     R0,[R4, #+0]
        LDR      R2,??DataTable72  ;; gameImage
        LDR      R2,[R2, #+0]
        LDRB     R1,[R0, +R2]
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        STRB     R1,[R4, #+3098]
//  240 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock41

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock42 Using cfiCommon0
        CFI NoFunction
        THUMB
??bcs6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock42
        REQUIRE bcs6502
//  241 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock43 Using cfiCommon1
        CFI Function bcs6502
        ARM
//  242 void bcs6502()
//  243 {
bcs6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  244   if ( P & 0x01 )
        LDR      R4,??DataTable53  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        TST      R0,#0x1
        BEQ      ??bcs6502_0
//  245   {
//  246     adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  247     PC += savepc;
        LDRH     R0,[R4, #+0]
        LDRH     R1,[R4, #+2]
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  248     clockticks6502++;
        LDR      R0,[R4, #+3080]
        ADD      R0,R0,#+1
        STR      R0,[R4, #+3080]
        POP      {R4,PC}
//  249   }
//  250   else
//  251     value = gameImage[PC++];
??bcs6502_0:
        LDRH     R0,[R4, #+0]
        LDR      R2,??DataTable72  ;; gameImage
        LDR      R2,[R2, #+0]
        LDRB     R1,[R0, +R2]
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        STRB     R1,[R4, #+3098]
//  252 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock43

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock44 Using cfiCommon0
        CFI NoFunction
        THUMB
??beq6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock44
        REQUIRE beq6502
//  253 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock45 Using cfiCommon1
        CFI Function beq6502
        ARM
//  254 void beq6502()
//  255 {
beq6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  256   if ( P & 0x02 )
        LDR      R4,??DataTable53  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        TST      R0,#0x2
        BEQ      ??beq6502_0
//  257   {
//  258     adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  259     PC += savepc;
        LDRH     R0,[R4, #+0]
        LDRH     R1,[R4, #+2]
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  260     clockticks6502++;
        LDR      R0,[R4, #+3080]
        ADD      R0,R0,#+1
        STR      R0,[R4, #+3080]
        POP      {R4,PC}
//  261   }
//  262   else
//  263     value = gameImage[PC++];
??beq6502_0:
        LDRH     R0,[R4, #+0]
        LDR      R2,??DataTable72  ;; gameImage
        LDR      R2,[R2, #+0]
        LDRB     R1,[R0, +R2]
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        STRB     R1,[R4, #+3098]
//  264 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock45

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock46 Using cfiCommon0
        CFI NoFunction
        THUMB
??bit6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock46
        REQUIRE bit6502
//  265 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock47 Using cfiCommon1
        CFI Function bit6502
        ARM
//  266 void bit6502()
//  267 {
bit6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  268   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  269   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable72  ;; gameImage
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
//  270 
//  271   /* non-destrucive logically And between value and the accumulator * and set zero flag */
//  272   if ( value & A ) P &= 0xfd;
        LDRB     R1,[R4, #+3092]
        STRB     R0,[R4, #+3098]
        TST      R1,R0
        LDRB     R1,[R4, #+3095]
        ANDNE    R1,R1,#0xFD
//  273   else P |= 0x02;
        ORREQ    R1,R1,#0x2
        STRB     R1,[R4, #+3095]
//  274 
//  275   /* set negative and overflow flags from value */
//  276   P = ( P & 0x3f ) | ( value & 0xc0 );
        LDRB     R1,[R4, #+3095]
        AND      R0,R0,#0xC0
        AND      R1,R1,#0x3F
        ORR      R0,R0,R1
        STRB     R0,[R4, #+3095]
//  277 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock47

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock48 Using cfiCommon0
        CFI NoFunction
        THUMB
??bmi6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock48
        REQUIRE bmi6502
//  278 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock49 Using cfiCommon1
        CFI Function bmi6502
        ARM
//  279 void bmi6502()
//  280 {
bmi6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  281   if ( P & 0x80 )
        LDR      R4,??DataTable53  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        TST      R0,#0x80
        BEQ      ??bmi6502_0
//  282   {
//  283     adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  284     PC += savepc;
        LDRH     R0,[R4, #+0]
        LDRH     R1,[R4, #+2]
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  285     clockticks6502++;
        LDR      R0,[R4, #+3080]
        ADD      R0,R0,#+1
        STR      R0,[R4, #+3080]
        POP      {R4,PC}
//  286   }
//  287   else
//  288     value = gameImage[PC++];
??bmi6502_0:
        LDRH     R0,[R4, #+0]
        LDR      R2,??DataTable72  ;; gameImage
        LDR      R2,[R2, #+0]
        LDRB     R1,[R0, +R2]
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        STRB     R1,[R4, #+3098]
//  289 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock49

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock50 Using cfiCommon0
        CFI NoFunction
        THUMB
??bne6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock50
        REQUIRE bne6502
//  290 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock51 Using cfiCommon1
        CFI Function bne6502
        ARM
//  291 void bne6502()
//  292 {
bne6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  293   if ( ( P & 0x02 ) == 0 )
        LDR      R4,??DataTable53  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        TST      R0,#0x2
        BNE      ??bne6502_0
//  294   {
//  295     adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  296     PC += savepc;
        LDRH     R0,[R4, #+0]
        LDRH     R1,[R4, #+2]
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  297     clockticks6502++;
        LDR      R0,[R4, #+3080]
        ADD      R0,R0,#+1
        STR      R0,[R4, #+3080]
        POP      {R4,PC}
//  298   }
//  299   else
//  300     value = gameImage[PC++];
??bne6502_0:
        LDRH     R0,[R4, #+0]
        LDR      R2,??DataTable72  ;; gameImage
        LDR      R2,[R2, #+0]
        LDRB     R1,[R0, +R2]
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        STRB     R1,[R4, #+3098]
//  301 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock51

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock52 Using cfiCommon0
        CFI NoFunction
        THUMB
??bpl6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock52
        REQUIRE bpl6502
//  302 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock53 Using cfiCommon1
        CFI Function bpl6502
        ARM
//  303 void bpl6502()
//  304 {
bpl6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  305   if ( ( P & 0x80 ) == 0 )
        LDR      R4,??DataTable53  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        TST      R0,#0x80
        BNE      ??bpl6502_0
//  306   {
//  307     adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  308     PC += savepc;
        LDRH     R0,[R4, #+0]
        LDRH     R1,[R4, #+2]
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  309     clockticks6502++;
        LDR      R0,[R4, #+3080]
        ADD      R0,R0,#+1
        STR      R0,[R4, #+3080]
        POP      {R4,PC}
//  310   }
//  311   else
//  312     value = gameImage[PC++];
??bpl6502_0:
        LDRH     R0,[R4, #+0]
        LDR      R2,??DataTable72  ;; gameImage
        LDR      R2,[R2, #+0]
        LDRB     R1,[R0, +R2]
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        STRB     R1,[R4, #+3098]
//  313 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock53

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock54 Using cfiCommon0
        CFI NoFunction
        THUMB
??brk6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock54
        REQUIRE brk6502
//  314 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock55 Using cfiCommon1
        CFI Function brk6502
        ARM
//  315 void brk6502()
//  316 {
brk6502:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  317   PC++;
        LDR      R4,??DataTable53  ;; pc_reg
        LDRH     R0,[R4, #+0]
//  318   put6502memory( 0x0100 + S--, ( BYTE )( PC >> 8 ) );
        LDRB     R2,[R4, #+3096]
        LDR      R6,??DataTable72  ;; gameImage
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        SUB      R1,R2,#+1
        STRB     R1,[R4, #+3096]
        LSR      R1,R0,#+8
        ADD      R0,R2,#+256
        MOV      R5,#+32
        ORR      R5,R5,#0x4000
        MOV      R7,#+1
        ORR      R7,R7,#0x8000
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??brk6502_0
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??brk6502_0
        CMP      R0,R5
        BCS      ??brk6502_0
        AND      R1,R1,#0xFF
        _BLF     APUWrite,??APUWrite??rA
//  319   put6502memory( 0x0100 + S--, ( BYTE )( PC & 0xff ) );
??brk6502_0:
        LDRB     R0,[R4, #+3096]
        SUB      R1,R0,#+1
        STRB     R1,[R4, #+3096]
        LDRH     R1,[R4, #+0]
        ADD      R0,R0,#+256
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??brk6502_1
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??brk6502_1
        CMP      R0,R5
        BCS      ??brk6502_1
        AND      R1,R1,#0xFF
        _BLF     APUWrite,??APUWrite??rA
//  320   put6502memory( 0x0100 + S--, P );
??brk6502_1:
        LDRB     R0,[R4, #+3096]
        SUB      R1,R0,#+1
        STRB     R1,[R4, #+3096]
        LDRB     R1,[R4, #+3095]
        ADD      R0,R0,#+256
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??brk6502_2
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??brk6502_2
        CMP      R0,R5
        BCS      ??brk6502_2
        _BLF     APUWrite,??APUWrite??rA
//  321   P |= 0x14;
??brk6502_2:
        LDRB     R0,[R4, #+3095]
//  322   PC = gameImage[0xfffe & addrmask] + ( gameImage[0xffff & addrmask] << 8 );
        LDR      R1,[R6, #+0]
        MOV      R2,#+254
        ORR      R0,R0,#0x14
        STRB     R0,[R4, #+3095]
        LDR      R0,??DataTable50  ;; addrmask
        ORR      R2,R2,#0xFF00
        LDRH     R0,[R0, #+0]
        AND      R2,R2,R0
        LDRB     R2,[R2, +R1]
        LDRB     R0,[R0, +R1]
        ADD      R0,R2,R0, LSL #+8
        STRH     R0,[R4, #+0]
//  323 }
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock55

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable50:
        DC32     addrmask

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock56 Using cfiCommon0
        CFI NoFunction
        THUMB
??bvc6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock56
        REQUIRE bvc6502
//  324 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock57 Using cfiCommon1
        CFI Function bvc6502
        ARM
//  325 void bvc6502()
//  326 {
bvc6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  327   if ( ( P & 0x40 ) == 0 )
        LDR      R4,??DataTable53  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        TST      R0,#0x40
        BNE      ??bvc6502_0
//  328   {
//  329     adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  330     PC += savepc;
        LDRH     R0,[R4, #+0]
        LDRH     R1,[R4, #+2]
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  331     clockticks6502++;
        LDR      R0,[R4, #+3080]
        ADD      R0,R0,#+1
        STR      R0,[R4, #+3080]
        POP      {R4,PC}
//  332   }
//  333   else
//  334     value = gameImage[PC++];
??bvc6502_0:
        LDRH     R0,[R4, #+0]
        LDR      R2,??DataTable72  ;; gameImage
        LDR      R2,[R2, #+0]
        LDRB     R1,[R0, +R2]
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        STRB     R1,[R4, #+3098]
//  335 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock57

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock58 Using cfiCommon0
        CFI NoFunction
        THUMB
??bvs6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock58
        REQUIRE bvs6502
//  336 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock59 Using cfiCommon1
        CFI Function bvs6502
        ARM
//  337 void bvs6502()
//  338 {
bvs6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  339   if ( P & 0x40 )
        LDR      R4,??DataTable53  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        TST      R0,#0x40
        BEQ      ??bvs6502_0
//  340   {
//  341     adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  342     PC += savepc;
        LDRH     R0,[R4, #+0]
        LDRH     R1,[R4, #+2]
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  343     clockticks6502++;
        LDR      R0,[R4, #+3080]
        ADD      R0,R0,#+1
        STR      R0,[R4, #+3080]
        POP      {R4,PC}
//  344   }
//  345   else
//  346     value = gameImage[PC++];
??bvs6502_0:
        LDRH     R0,[R4, #+0]
        LDR      R2,??DataTable72  ;; gameImage
        LDR      R2,[R2, #+0]
        LDRB     R1,[R0, +R2]
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        STRB     R1,[R4, #+3098]
//  347 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock59

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable53:
        DC32     pc_reg

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock60 Using cfiCommon0
        CFI NoFunction
        THUMB
??clc6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock60
        REQUIRE clc6502
//  348 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock61 Using cfiCommon1
        CFI Function clc6502
        ARM
//  349 void clc6502()
//  350 {
//  351   P &= 0xfe;
clc6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3095]
        AND      R1,R1,#0xFE
        STRB     R1,[R0, #+3095]
//  352 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock61

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock62 Using cfiCommon0
        CFI NoFunction
        THUMB
??cld6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock62
        REQUIRE cld6502
//  353 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock63 Using cfiCommon1
        CFI Function cld6502
        ARM
//  354 void cld6502()
//  355 {
//  356   P &= 0xf7;
cld6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3095]
        AND      R1,R1,#0xF7
        STRB     R1,[R0, #+3095]
//  357 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock63

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock64 Using cfiCommon0
        CFI NoFunction
        THUMB
??cli6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock64
        REQUIRE cli6502
//  358 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock65 Using cfiCommon1
        CFI Function cli6502
        ARM
//  359 void cli6502()
//  360 {
//  361   P &= 0xfb;
cli6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3095]
        AND      R1,R1,#0xFB
        STRB     R1,[R0, #+3095]
//  362 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock65

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock66 Using cfiCommon0
        CFI NoFunction
        THUMB
??clv6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock66
        REQUIRE clv6502
//  363 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock67 Using cfiCommon1
        CFI Function clv6502
        ARM
//  364 void clv6502()
//  365 {
//  366   P &= 0xbf;
clv6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3095]
        AND      R1,R1,#0xBF
        STRB     R1,[R0, #+3095]
//  367 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock67

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock68 Using cfiCommon0
        CFI NoFunction
        THUMB
??cmp6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock68
        REQUIRE cmp6502
//  368 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock69 Using cfiCommon1
        CFI Function cmp6502
        ARM
//  369 void cmp6502()
//  370 {
cmp6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  371   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  372   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable72  ;; gameImage
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
//  373   if ( A + 0x100 - value > 0xff ) P |= 0x01;
        LDRB     R1,[R4, #+3092]
        STRB     R0,[R4, #+3098]
        ADD      R2,R1,#+256
        SUB      R2,R2,R0
        CMP      R2,#+256
        LDRB     R2,[R4, #+3095]
//  374   else P &= 0xfe;
//  375   value = A + 0x100 - value;
        SUB      R0,R1,R0
        STRB     R0,[R4, #+3098]
        ORRGE    R2,R2,#0x1
        ANDLT    R2,R2,#0xFE
//  376   if ( value ) P &= 0xfd;
        ANDS     R0,R0,#0xFF
        ANDNE    R1,R2,#0xFD
//  377   else P |= 0x02;
        ORREQ    R1,R2,#0x2
//  378   if ( value & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  379   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  380 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock69

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock70 Using cfiCommon0
        CFI NoFunction
        THUMB
??cpx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock70
        REQUIRE cpx6502
//  381 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock71 Using cfiCommon1
        CFI Function cpx6502
        ARM
//  382 void cpx6502()
//  383 {
cpx6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  384   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  385   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable72  ;; gameImage
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
//  386   if ( X + 0x100 - value > 0xff ) P |= 0x01;
        LDRB     R1,[R4, #+3093]
        STRB     R0,[R4, #+3098]
        ADD      R2,R1,#+256
        SUB      R2,R2,R0
        CMP      R2,#+256
        LDRB     R2,[R4, #+3095]
//  387   else P &= 0xfe;
//  388   value = X + 0x100 - value;
        SUB      R0,R1,R0
        STRB     R0,[R4, #+3098]
        ORRGE    R2,R2,#0x1
        ANDLT    R2,R2,#0xFE
//  389   if ( value ) P &= 0xfd;
        ANDS     R0,R0,#0xFF
        ANDNE    R1,R2,#0xFD
//  390   else P |= 0x02;
        ORREQ    R1,R2,#0x2
//  391   if ( value & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  392   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  393 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock71

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock72 Using cfiCommon0
        CFI NoFunction
        THUMB
??cpy6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock72
        REQUIRE cpy6502
//  394 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock73 Using cfiCommon1
        CFI Function cpy6502
        ARM
//  395 void cpy6502()
//  396 {
cpy6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  397   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  398   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable72  ;; gameImage
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
//  399   if ( Y + 0x100 - value > 0xff ) P |= 0x01;
        LDRB     R1,[R4, #+3094]
        STRB     R0,[R4, #+3098]
        ADD      R2,R1,#+256
        SUB      R2,R2,R0
        CMP      R2,#+256
        LDRB     R2,[R4, #+3095]
//  400   else P &= 0xfe;
//  401   value = Y + 0x100 - value;
        SUB      R0,R1,R0
        STRB     R0,[R4, #+3098]
        ORRGE    R2,R2,#0x1
        ANDLT    R2,R2,#0xFE
//  402   if ( value ) P &= 0xfd;
        ANDS     R0,R0,#0xFF
        ANDNE    R1,R2,#0xFD
//  403   else P |= 0x02;
        ORREQ    R1,R2,#0x2
//  404   if ( value & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  405   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  406 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock73

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock74 Using cfiCommon0
        CFI NoFunction
        THUMB
??dec6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock74
        REQUIRE dec6502
//  407 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock75 Using cfiCommon1
        CFI Function dec6502
        ARM
//  408 void dec6502()
//  409 {
dec6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  410   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  411   gameImage[savepc] --;
        LDR      R0,??DataTable72  ;; gameImage
        LDRH     R1,[R4, #+2]
        LDR      R2,[R0, #+0]
        ADD      R1,R1,R2
        LDRB     R2,[R1, #+0]
        SUB      R2,R2,#+1
        STRB     R2,[R1, #+0]
//  412   value = gameImage[savepc];
        LDRH     R1,[R4, #+2]
        LDR      R0,[R0, #+0]
        LDRB     R0,[R1, +R0]
//  413   if ( value ) P &= 0xfd;
        LDRB     R1,[R4, #+3095]
        STRB     R0,[R4, #+3098]
        CMP      R0,#+0
        ANDNE    R1,R1,#0xFD
//  414   else P |= 0x02;
        ORREQ    R1,R1,#0x2
//  415   if ( value & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  416   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  417 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock75

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock76 Using cfiCommon0
        CFI NoFunction
        THUMB
??dex6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock76
        REQUIRE dex6502
//  418 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock77 Using cfiCommon1
        CFI Function dex6502
        ARM
//  419 void dex6502()
//  420 {
//  421   X--;
dex6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3093]
//  422   if ( X ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        SUB      R1,R1,#+1
        STRB     R1,[R0, #+3093]
        ANDS     R1,R1,#0xFF
        ANDNE    R2,R2,#0xFD
//  423   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  424   if ( X & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  425   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  426 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock77

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock78 Using cfiCommon0
        CFI NoFunction
        THUMB
??dey6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock78
        REQUIRE dey6502
//  427 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock79 Using cfiCommon1
        CFI Function dey6502
        ARM
//  428 void dey6502()
//  429 {
//  430   Y--;
dey6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3094]
//  431   if ( Y ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        SUB      R1,R1,#+1
        STRB     R1,[R0, #+3094]
        ANDS     R1,R1,#0xFF
        ANDNE    R2,R2,#0xFD
//  432   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  433   if ( Y & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  434   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  435 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock79

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock80 Using cfiCommon0
        CFI NoFunction
        THUMB
??eor6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock80
        REQUIRE eor6502
//  436 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock81 Using cfiCommon1
        CFI Function eor6502
        ARM
//  437 void eor6502()
//  438 {
eor6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  439   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  440   A ^= gameImage[savepc];
        LDRH     R1,[R4, #+2]
        LDR      R2,??DataTable72  ;; gameImage
        LDRB     R0,[R4, #+3092]
        LDR      R2,[R2, #+0]
        LDRB     R1,[R1, +R2]
        EOR      R0,R1,R0
//  441   if ( A ) P &= 0xfd;
        LDRB     R1,[R4, #+3095]
        STRB     R0,[R4, #+3092]
        ANDS     R0,R0,#0xFF
        ANDNE    R1,R1,#0xFD
//  442   else P |= 0x02;
        ORREQ    R1,R1,#0x2
//  443   if ( A & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  444   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  445 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock81

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock82 Using cfiCommon0
        CFI NoFunction
        THUMB
??inc6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock82
        REQUIRE inc6502
//  446 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock83 Using cfiCommon1
        CFI Function inc6502
        ARM
//  447 void inc6502()
//  448 {
inc6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  449   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  450   gameImage[savepc] ++;
        LDR      R0,??DataTable72  ;; gameImage
        LDRH     R1,[R4, #+2]
        LDR      R2,[R0, #+0]
        ADD      R1,R1,R2
        LDRB     R2,[R1, #+0]
        ADD      R2,R2,#+1
        STRB     R2,[R1, #+0]
//  451   value = gameImage[savepc];
        LDRH     R1,[R4, #+2]
        LDR      R0,[R0, #+0]
        LDRB     R0,[R1, +R0]
//  452   if ( value ) P &= 0xfd;
        LDRB     R1,[R4, #+3095]
        STRB     R0,[R4, #+3098]
        CMP      R0,#+0
        ANDNE    R1,R1,#0xFD
//  453   else P |= 0x02;
        ORREQ    R1,R1,#0x2
//  454   if ( value & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  455   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  456 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock83

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable72:
        DC32     gameImage

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock84 Using cfiCommon0
        CFI NoFunction
        THUMB
??inx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock84
        REQUIRE inx6502
//  457 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock85 Using cfiCommon1
        CFI Function inx6502
        ARM
//  458 void inx6502()
//  459 {
//  460   X++;
inx6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3093]
//  461   if ( X ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3093]
        ANDS     R1,R1,#0xFF
        ANDNE    R2,R2,#0xFD
//  462   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  463   if ( X & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  464   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  465 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock85

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock86 Using cfiCommon0
        CFI NoFunction
        THUMB
??iny6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock86
        REQUIRE iny6502
//  466 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock87 Using cfiCommon1
        CFI Function iny6502
        ARM
//  467 void iny6502()
//  468 {
//  469   Y++;
iny6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3094]
//  470   if ( Y ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3094]
        ANDS     R1,R1,#0xFF
        ANDNE    R2,R2,#0xFD
//  471   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  472   if ( Y & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  473   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  474 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock87

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock88 Using cfiCommon0
        CFI NoFunction
        THUMB
??jmp6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock88
        REQUIRE jmp6502
//  475 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock89 Using cfiCommon1
        CFI Function jmp6502
        ARM
//  476 void jmp6502()
//  477 {
jmp6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  478   adrmode[opcode] ();
        LDR      R4,??DataTable124  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  479   PC = savepc;
        LDRH     R0,[R4, #+2]
        STRH     R0,[R4, #+0]
//  480 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock89

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock90 Using cfiCommon0
        CFI NoFunction
        THUMB
??jsr6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock90
        REQUIRE jsr6502
//  481 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock91 Using cfiCommon1
        CFI Function jsr6502
        ARM
//  482 void jsr6502()
//  483 {
jsr6502:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  484   PC++;
        LDR      R4,??DataTable124  ;; pc_reg
        LDRH     R0,[R4, #+0]
//  485   put6502memory( 0x0100 + S--, ( BYTE )( PC >> 8 ) );
        LDRB     R2,[R4, #+3096]
        LDR      R6,??DataTable140  ;; gameImage
        ADD      R0,R0,#+1
        STRH     R0,[R4, #+0]
        SUB      R1,R2,#+1
        STRB     R1,[R4, #+3096]
        LSR      R1,R0,#+8
        ADD      R0,R2,#+256
        MOV      R5,#+32
        ORR      R5,R5,#0x4000
        MOV      R7,#+1
        ORR      R7,R7,#0x8000
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??jsr6502_0
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??jsr6502_0
        CMP      R0,R5
        BCS      ??jsr6502_0
        AND      R1,R1,#0xFF
        _BLF     APUWrite,??APUWrite??rA
//  486   put6502memory( 0x0100 + S--, ( BYTE )( PC & 0xff ) );
??jsr6502_0:
        LDRB     R0,[R4, #+3096]
        SUB      R1,R0,#+1
        STRB     R1,[R4, #+3096]
        LDRH     R1,[R4, #+0]
        ADD      R0,R0,#+256
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??jsr6502_1
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??jsr6502_1
        CMP      R0,R5
        BCS      ??jsr6502_1
        AND      R1,R1,#0xFF
        _BLF     APUWrite,??APUWrite??rA
//  487   PC--;
??jsr6502_1:
        LDRH     R0,[R4, #+0]
        MOV      R1,#+255
        ORR      R1,R1,#0xFF00
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  488   adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  489   PC = savepc;
        LDRH     R0,[R4, #+2]
        STRH     R0,[R4, #+0]
//  490 }
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock91

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock92 Using cfiCommon0
        CFI NoFunction
        THUMB
??lda6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock92
        REQUIRE lda6502
//  491 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock93 Using cfiCommon1
        CFI Function lda6502
        ARM
//  492 void lda6502()
//  493 {
lda6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  494   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  495   A = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable140  ;; gameImage
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
//  496   // set the zero flag
//  497   if ( A ) P &= 0xfd;
        LDRB     R1,[R4, #+3095]
        STRB     R0,[R4, #+3092]
        CMP      R0,#+0
        ANDNE    R1,R1,#0xFD
//  498   else P |= 0x02;
        ORREQ    R1,R1,#0x2
//  499   // set the negative flag
//  500   if ( A & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  501   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  502 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock93

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock94 Using cfiCommon0
        CFI NoFunction
        THUMB
??ldx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock94
        REQUIRE ldx6502
//  503 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock95 Using cfiCommon1
        CFI Function ldx6502
        ARM
//  504 void ldx6502()
//  505 {
ldx6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  506   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  507   X = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable140  ;; gameImage
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
//  508   if ( X ) P &= 0xfd;
        LDRB     R1,[R4, #+3095]
        STRB     R0,[R4, #+3093]
        CMP      R0,#+0
        ANDNE    R1,R1,#0xFD
//  509   else P |= 0x02;
        ORREQ    R1,R1,#0x2
//  510   if ( X & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  511   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  512 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock95

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock96 Using cfiCommon0
        CFI NoFunction
        THUMB
??ldy6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock96
        REQUIRE ldy6502
//  513 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock97 Using cfiCommon1
        CFI Function ldy6502
        ARM
//  514 void ldy6502()
//  515 {
ldy6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  516   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  517   Y = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable140  ;; gameImage
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
//  518   if ( Y ) P &= 0xfd;
        LDRB     R1,[R4, #+3095]
        STRB     R0,[R4, #+3094]
        CMP      R0,#+0
        ANDNE    R1,R1,#0xFD
//  519   else P |= 0x02;
        ORREQ    R1,R1,#0x2
//  520   if ( Y & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  521   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  522 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock97

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock98 Using cfiCommon0
        CFI NoFunction
        THUMB
??lsr6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock98
        REQUIRE lsr6502
//  523 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock99 Using cfiCommon1
        CFI Function lsr6502
        ARM
//  524 void lsr6502()
//  525 {
lsr6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  526   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  527   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R2,??DataTable140  ;; gameImage
//  528 
//  529   /* set carry flag if shifting right causes a bit to be lost */
//  530   P = ( P & 0xfe ) | ( value & 0x01 );
        LDRB     R3,[R4, #+3095]
        LDR      R2,[R2, #+0]
        ADD      R2,R0,R2
        LDRB     R1,[R2, #+0]
        AND      R3,R3,#0xFE
        STRB     R1,[R4, #+3098]
        AND      R12,R1,#0x1
        ORR      R3,R12,R3
        STRB     R3,[R4, #+3095]
//  531 
//  532   value = value >> 1;
        LSR      R1,R1,#+1
        STRB     R1,[R4, #+3098]
//  533   put6502memory( savepc, value );
        MOV      R3,#+1
        ORR      R3,R3,#0x8000
        CMP      R0,R3
        BCS      ??lsr6502_0
        STRB     R1,[R2, #+0]
        CMP      R0,#+16384
        BCC      ??lsr6502_0
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        BCS      ??lsr6502_0
        _BLF     APUWrite,??APUWrite??rA
//  534 
//  535   /* set zero flag if value is zero */
//  536   if ( value != 0 ) P &= 0xfd;
??lsr6502_0:
        LDRB     R0,[R4, #+3095]
        LDRB     R1,[R4, #+3098]
        CMP      R1,#+0
        ANDNE    R0,R0,#0xFD
//  537   else P |= 0x02;
        ORREQ    R0,R0,#0x2
//  538 
//  539   /* set negative flag if bit 8 set??? can this happen on an LSR? */
//  540   if ( ( value & 0x80 ) == 0x80 )
        TST      R1,#0x80
//  541     P |= 0x80;
        ORRNE    R0,R0,#0x80
//  542   else
//  543     P &= 0x7f;
        ANDEQ    R0,R0,#0x7F
        STRB     R0,[R4, #+3095]
//  544 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock99

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock100 Using cfiCommon0
        CFI NoFunction
        THUMB
??lsra6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock100
        REQUIRE lsra6502
//  545 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock101 Using cfiCommon1
        CFI Function lsra6502
        ARM
//  546 void lsra6502()
//  547 {
//  548   P = ( P & 0xfe ) | ( A & 0x01 );
lsra6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDRB     R1,[R0, #+3092]
        LDRB     R2,[R0, #+3095]
        AND      R3,R1,#0x1
        AND      R2,R2,#0xFE
        ORR      R2,R3,R2
//  549   A = A >> 1;
        LSRS     R1,R1,#+1
        STRB     R1,[R0, #+3092]
//  550   if ( A ) P &= 0xfd;
        ANDNE    R2,R2,#0xFD
//  551   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  552   if ( A & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  553   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  554 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock101

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock102 Using cfiCommon0
        CFI NoFunction
        THUMB
??nop6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock102
        REQUIRE nop6502
//  555 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock103 Using cfiCommon1
        CFI Function nop6502
        ARM
//  556 void nop6502()
//  557 {
//  558 
//  559 }
nop6502:
        BX       LR               ;; return
        CFI EndBlock cfiBlock103

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock104 Using cfiCommon0
        CFI NoFunction
        THUMB
??ora6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock104
        REQUIRE ora6502
//  560 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock105 Using cfiCommon1
        CFI Function ora6502
        ARM
//  561 void ora6502()
//  562 {
ora6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  563   adrmode[opcode] ();
        LDR      R4,??DataTable91  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  564   A |= gameImage[savepc];
        LDRH     R1,[R4, #+2]
        LDR      R2,??DataTable140  ;; gameImage
        LDRB     R0,[R4, #+3092]
        LDR      R2,[R2, #+0]
        LDRB     R1,[R1, +R2]
        ORRS     R0,R1,R0
//  565   if ( A ) P &= 0xfd;
        LDRB     R1,[R4, #+3095]
        STRB     R0,[R4, #+3092]
        ANDNE    R1,R1,#0xFD
//  566   else P |= 0x02;
        ORREQ    R1,R1,#0x2
//  567   if ( A & 0x80 ) P |= 0x80;
        TST      R0,#0x80
        ORRNE    R0,R1,#0x80
//  568   else P &= 0x7f;
        ANDEQ    R0,R1,#0x7F
        STRB     R0,[R4, #+3095]
//  569 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock105

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock106 Using cfiCommon0
        CFI NoFunction
        THUMB
??pha6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock106
        REQUIRE pha6502
//  570 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock107 Using cfiCommon1
        CFI Function pha6502
        ARM
//  571 void pha6502()
//  572 {
//  573   gameImage[0x100 + S--] = A;
pha6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDR      R2,??DataTable140  ;; gameImage
        LDRB     R1,[R0, #+3096]
        LDR      R2,[R2, #+0]
        ADD      R1,R1,R2
        LDRB     R2,[R0, #+3092]
        STRB     R2,[R1, #+256]
        LDRB     R1,[R0, #+3096]
        SUB      R1,R1,#+1
        STRB     R1,[R0, #+3096]
//  574 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock107

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock108 Using cfiCommon0
        CFI NoFunction
        THUMB
??php6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock108
        REQUIRE php6502
//  575 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock109 Using cfiCommon1
        CFI Function php6502
        ARM
//  576 void php6502()
//  577 {
//  578   gameImage[0x100 + S--] = P;
php6502:
        LDR      R0,??DataTable91  ;; pc_reg
        LDR      R2,??DataTable140  ;; gameImage
        LDRB     R1,[R0, #+3096]
        LDR      R2,[R2, #+0]
        ADD      R1,R1,R2
        LDRB     R2,[R0, #+3095]
        STRB     R2,[R1, #+256]
        LDRB     R1,[R0, #+3096]
        SUB      R1,R1,#+1
        STRB     R1,[R0, #+3096]
//  579 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock109

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable91:
        DC32     pc_reg

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock110 Using cfiCommon0
        CFI NoFunction
        THUMB
??pla6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock110
        REQUIRE pla6502
//  580 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock111 Using cfiCommon1
        CFI Function pla6502
        ARM
//  581 void pla6502()
//  582 {
//  583   A = gameImage[++S + 0x100];
pla6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDR      R2,??DataTable140  ;; gameImage
        LDRB     R1,[R0, #+3096]
        LDR      R2,[R2, #+0]
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3096]
        AND      R1,R1,#0xFF
        ADD      R1,R1,R2
        LDRB     R1,[R1, #+256]
//  584   if ( A ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        STRB     R1,[R0, #+3092]
        CMP      R1,#+0
        ANDNE    R2,R2,#0xFD
//  585   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  586   if ( A & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  587   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  588 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock111

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock112 Using cfiCommon0
        CFI NoFunction
        THUMB
??plp6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock112
        REQUIRE plp6502
//  589 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock113 Using cfiCommon1
        CFI Function plp6502
        ARM
//  590 void plp6502()
//  591 {
//  592   P = gameImage[++S + 0x100] | 0x20;
plp6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDR      R2,??DataTable140  ;; gameImage
        LDRB     R1,[R0, #+3096]
        LDR      R2,[R2, #+0]
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3096]
        AND      R1,R1,#0xFF
        ADD      R1,R1,R2
        LDRB     R1,[R1, #+256]
        ORR      R1,R1,#0x20
        STRB     R1,[R0, #+3095]
//  593 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock113

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock114 Using cfiCommon0
        CFI NoFunction
        THUMB
??rol6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock114
        REQUIRE rol6502
//  594 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock115 Using cfiCommon1
        CFI Function rol6502
        ARM
//  595 void rol6502()
//  596 {
rol6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  597   saveflags = ( P & 0x01 );
        LDR      R4,??DataTable139  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        AND      R0,R0,#0x1
        STR      R0,[R4, #+3088]
//  598   adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  599   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R2,??DataTable140  ;; gameImage
//  600   P = ( P & 0xfe ) | ( ( value >> 7 ) & 0x01 );
        LDRB     R3,[R4, #+3095]
        LDR      R2,[R2, #+0]
        ADD      R2,R0,R2
        LDRB     R1,[R2, #+0]
        AND      R3,R3,#0xFE
        STRB     R1,[R4, #+3098]
        ORR      R3,R3,R1, LSR #+7
        STRB     R3,[R4, #+3095]
//  601   value = value << 1;
//  602   value |= saveflags;
        LDR      R3,[R4, #+3088]
        ORR      R1,R3,R1, LSL #+1
        STRB     R1,[R4, #+3098]
//  603   put6502memory( savepc, value );
        MOV      R3,#+1
        ORR      R3,R3,#0x8000
        CMP      R0,R3
        BCS      ??rol6502_0
        STRB     R1,[R2, #+0]
        CMP      R0,#+16384
        BCC      ??rol6502_0
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        BCS      ??rol6502_0
        AND      R1,R1,#0xFF
        _BLF     APUWrite,??APUWrite??rA
//  604   if ( value ) P &= 0xfd;
??rol6502_0:
        LDRB     R0,[R4, #+3095]
        LDRB     R1,[R4, #+3098]
        CMP      R1,#+0
        ANDNE    R0,R0,#0xFD
//  605   else P |= 0x02;
        ORREQ    R0,R0,#0x2
//  606   if ( value & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R0,R0,#0x80
//  607   else P &= 0x7f;
        ANDEQ    R0,R0,#0x7F
        STRB     R0,[R4, #+3095]
//  608 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock115

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock116 Using cfiCommon0
        CFI NoFunction
        THUMB
??rola6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock116
        REQUIRE rola6502
//  609 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock117 Using cfiCommon1
        CFI Function rola6502
        ARM
//  610 void rola6502()
//  611 {
//  612   saveflags = ( P & 0x01 );
rola6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3095]
//  613   P = ( P & 0xfe ) | ( ( A >> 7 ) & 0x01 );
        LDRB     R3,[R0, #+3092]
        AND      R2,R1,#0x1
        STR      R2,[R0, #+3088]
        AND      R1,R1,#0xFE
        ORR      R1,R1,R3, LSR #+7
//  614   A = A << 1;
//  615   A |= saveflags;
        ORR      R2,R2,R3, LSL #+1
        STRB     R2,[R0, #+3092]
//  616   if ( A ) P &= 0xfd;
        ANDS     R2,R2,#0xFF
        ANDNE    R1,R1,#0xFD
//  617   else P |= 0x02;
        ORREQ    R1,R1,#0x2
//  618   if ( A & 0x80 ) P |= 0x80;
        TST      R2,#0x80
        ORRNE    R1,R1,#0x80
//  619   else P &= 0x7f;
        ANDEQ    R1,R1,#0x7F
        STRB     R1,[R0, #+3095]
//  620 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock117

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock118 Using cfiCommon0
        CFI NoFunction
        THUMB
??ror6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock118
        REQUIRE ror6502
//  621 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock119 Using cfiCommon1
        CFI Function ror6502
        ARM
//  622 void ror6502()
//  623 {
ror6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  624   saveflags = ( P & 0x01 );
        LDR      R4,??DataTable139  ;; pc_reg
        LDRB     R0,[R4, #+3095]
        AND      R0,R0,#0x1
        STR      R0,[R4, #+3088]
//  625   adrmode[opcode] ();
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  626   value = gameImage[savepc];
        LDRH     R0,[R4, #+2]
        LDR      R2,??DataTable140  ;; gameImage
//  627   P = ( P & 0xfe ) | ( value & 0x01 );
        LDRB     R3,[R4, #+3095]
        LDR      R2,[R2, #+0]
        ADD      R2,R0,R2
        LDRB     R1,[R2, #+0]
        AND      R3,R3,#0xFE
        AND      R12,R1,#0x1
        ORR      R3,R12,R3
        STRB     R3,[R4, #+3095]
//  628   value = value >> 1;
//  629   if ( saveflags ) value |= 0x80;
        LDR      R3,[R4, #+3088]
        LSR      R1,R1,#+1
        CMP      R3,#+0
        ORRNE    R1,R1,#0x80
        STRB     R1,[R4, #+3098]
//  630   put6502memory( savepc, value );
        MOV      R3,#+1
        ORR      R3,R3,#0x8000
        CMP      R0,R3
        BCS      ??ror6502_0
        STRB     R1,[R2, #+0]
        CMP      R0,#+16384
        BCC      ??ror6502_0
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        BCS      ??ror6502_0
        _BLF     APUWrite,??APUWrite??rA
//  631   if ( value ) P &= 0xfd;
??ror6502_0:
        LDRB     R0,[R4, #+3095]
        LDRB     R1,[R4, #+3098]
        CMP      R1,#+0
        ANDNE    R0,R0,#0xFD
//  632   else P |= 0x02;
        ORREQ    R0,R0,#0x2
//  633   if ( value & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R0,R0,#0x80
//  634   else P &= 0x7f;
        ANDEQ    R0,R0,#0x7F
        STRB     R0,[R4, #+3095]
//  635 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock119

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock120 Using cfiCommon0
        CFI NoFunction
        THUMB
??rora6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock120
        REQUIRE rora6502
//  636 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock121 Using cfiCommon1
        CFI Function rora6502
        ARM
//  637 void rora6502()
//  638 {
//  639   saveflags = ( P & 0x01 );
rora6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3095]
//  640   P = ( P & 0xfe ) | ( A & 0x01 );
        LDRB     R3,[R0, #+3092]
        AND      R2,R1,#0x1
        STR      R2,[R0, #+3088]
        AND      R12,R3,#0x1
//  641   A = A >> 1;
        LSR      R3,R3,#+1
//  642   if ( saveflags ) A |= 0x80;
        CMP      R2,#+0
        ORRNE    R3,R3,#0x80
        STRB     R3,[R0, #+3092]
//  643   if ( A ) P &= 0xfd;
//  644   else P |= 0x02;
//  645   if ( A & 0x80 ) P |= 0x80;
        LDRB     R2,[R0, #+3092]
        AND      R1,R1,#0xFE
        ORR      R1,R12,R1
        CMP      R3,#+0
        ANDNE    R1,R1,#0xFD
        ORREQ    R1,R1,#0x2
        TST      R2,#0x80
        ORRNE    R1,R1,#0x80
//  646   else P &= 0x7f;
        ANDEQ    R1,R1,#0x7F
        STRB     R1,[R0, #+3095]
//  647 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock121

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock122 Using cfiCommon0
        CFI NoFunction
        THUMB
??rti6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock122
        REQUIRE rti6502
//  648 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock123 Using cfiCommon1
        CFI Function rti6502
        ARM
//  649 void rti6502()
//  650 {
//  651   P = gameImage[++S + 0x100] | 0x20;
rti6502:
        LDR      R0,??DataTable124  ;; pc_reg
        LDR      R2,??DataTable140  ;; gameImage
        LDRB     R1,[R0, #+3096]
        LDR      R2,[R2, #+0]
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3096]
        AND      R3,R1,#0xFF
        ADD      R3,R3,R2
        LDRB     R3,[R3, #+256]
//  652   PC = gameImage[++S + 0x100];
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3096]
        ORR      R3,R3,#0x20
        STRB     R3,[R0, #+3095]
        AND      R3,R1,#0xFF
        ADD      R3,R3,R2
        LDRB     R3,[R3, #+256]
//  653   PC |= ( gameImage[++S + 0x100] << 8 );
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3096]
        STRH     R3,[R0, #+0]
        AND      R1,R1,#0xFF
        ADD      R1,R1,R2
        LDRB     R1,[R1, #+256]
        ORR      R1,R3,R1, LSL #+8
        STRH     R1,[R0, #+0]
//  654 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock123

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock124 Using cfiCommon0
        CFI NoFunction
        THUMB
??rts6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock124
        REQUIRE rts6502
//  655 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock125 Using cfiCommon1
        CFI Function rts6502
        ARM
//  656 void rts6502()
//  657 {
//  658   PC = gameImage[++S + 0x100];
rts6502:
        LDR      R0,??DataTable124  ;; pc_reg
        LDR      R2,??DataTable140  ;; gameImage
        LDRB     R1,[R0, #+3096]
        LDR      R2,[R2, #+0]
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3096]
        AND      R3,R1,#0xFF
        ADD      R3,R3,R2
        LDRB     R3,[R3, #+256]
//  659   PC |= ( gameImage[++S + 0x100] << 8 );
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3096]
        STRH     R3,[R0, #+0]
//  660   PC++;
        AND      R1,R1,#0xFF
        ADD      R1,R1,R2
        LDRB     R1,[R1, #+256]
        ORR      R1,R3,R1, LSL #+8
        ADD      R1,R1,#+1
        STRH     R1,[R0, #+0]
//  661 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock125

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock126 Using cfiCommon0
        CFI NoFunction
        THUMB
??sbc6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock126
        REQUIRE sbc6502
//  662 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock127 Using cfiCommon1
        CFI Function sbc6502
        ARM
//  663 void sbc6502()
//  664 {
sbc6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  665   adrmode[opcode] ();
        LDR      R4,??DataTable139  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  666   value = gameImage[savepc] ^ 0xff;
        LDRH     R0,[R4, #+2]
        LDR      R1,??DataTable140  ;; gameImage
//  667   saveflags = ( P & 0x01 );
//  668   sum = ( ( char )A ) + ( ( char )value ) + ( saveflags << 4 );
        LDRB     R3,[R4, #+3092]
        LDR      R1,[R1, #+0]
        LDRB     R0,[R0, +R1]
        LDRB     R1,[R4, #+3095]
        EOR      R0,R0,#0xFF
        STRB     R0,[R4, #+3098]
        AND      R2,R1,#0x1
        STR      R2,[R4, #+3088]
        ADD      R0,R0,R3
        ADD      R3,R0,R2, LSL #+4
        STR      R3,[R4, #+3084]
//  669   if ( ( sum > 0x7f ) || ( sum < -0x80 ) ) P |= 0x40;
        CMP      R3,#+128
        BGE      ??sbc6502_0
        MVN      R12,#+127
        CMP      R3,R12
        BGE      ??sbc6502_1
??sbc6502_0:
        ORR      R1,R1,#0x40
        B        ??sbc6502_2
//  670   else P &= 0xbf;
??sbc6502_1:
        AND      R1,R1,#0xBF
//  671   sum = A + value + saveflags;
??sbc6502_2:
        ADD      R0,R2,R0
        STR      R0,[R4, #+3084]
//  672   if ( sum > 0xff ) P |= 0x01;
        CMP      R0,#+256
        ORRGE    R1,R1,#0x1
//  673   else P &= 0xfe;
        ANDLT    R1,R1,#0xFE
//  674   A = sum;
//  675   if ( P & 0x08 )
        TST      R1,#0x8
        BEQ      ??sbc6502_3
//  676   {
//  677     A -= 0x66;
        ADD      R0,R0,#+154
//  678     P &= 0xfe;
        AND      R1,R1,#0xFE
//  679     if ( ( A & 0x0f ) > 0x09 )
        AND      R2,R0,#0xFF
        AND      R2,R2,#0xF
        CMP      R2,#+10
//  680       A += 0x06;
        ADDGE    R0,R0,#+6
//  681     if ( ( A & 0xf0 ) > 0x90 )
        AND      R2,R0,#0xFF
        AND      R2,R2,#0xF0
        CMP      R2,#+145
        BLT      ??sbc6502_4
//  682     {
//  683       A += 0x60;
        ADD      R0,R0,#+96
//  684       P |= 0x01;
        ORR      R1,R1,#0x1
        B        ??sbc6502_4
//  685     }
//  686   }
//  687   else
//  688   {
//  689     clockticks6502++;
??sbc6502_3:
        LDR      R2,[R4, #+3080]
        ADD      R2,R2,#+1
        STR      R2,[R4, #+3080]
??sbc6502_4:
        STRB     R0,[R4, #+3092]
//  690   }
//  691   if ( A ) P &= 0xfd;
        LSLS     R0,R0,#+24
        ANDNE    R0,R1,#0xFD
//  692   else P |= 0x02;
        ORREQ    R0,R1,#0x2
//  693   if ( A & 0x80 ) P |= 0x80;
        LDRB     R1,[R4, #+3092]
        TST      R1,#0x80
        ORRNE    R0,R0,#0x80
//  694   else P &= 0x7f;
        ANDEQ    R0,R0,#0x7F
        STRB     R0,[R4, #+3095]
//  695 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock127

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock128 Using cfiCommon0
        CFI NoFunction
        THUMB
??sec6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock128
        REQUIRE sec6502
//  696 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock129 Using cfiCommon1
        CFI Function sec6502
        ARM
//  697 void sec6502()
//  698 {
//  699   P |= 0x01;
sec6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3095]
        ORR      R1,R1,#0x1
        STRB     R1,[R0, #+3095]
//  700 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock129

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock130 Using cfiCommon0
        CFI NoFunction
        THUMB
??sed6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock130
        REQUIRE sed6502
//  701 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock131 Using cfiCommon1
        CFI Function sed6502
        ARM
//  702 void sed6502()
//  703 {
//  704   P |= 0x08;
sed6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3095]
        ORR      R1,R1,#0x8
        STRB     R1,[R0, #+3095]
//  705 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock131

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock132 Using cfiCommon0
        CFI NoFunction
        THUMB
??sei6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock132
        REQUIRE sei6502
//  706 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock133 Using cfiCommon1
        CFI Function sei6502
        ARM
//  707 void sei6502()
//  708 {
//  709   P |= 0x04;
sei6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3095]
        ORR      R1,R1,#0x4
        STRB     R1,[R0, #+3095]
//  710 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock133

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock134 Using cfiCommon0
        CFI NoFunction
        THUMB
??sta6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock134
        REQUIRE sta6502
//  711 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock135 Using cfiCommon1
        CFI Function sta6502
        ARM
//  712 void sta6502()
//  713 {
sta6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  714   adrmode[opcode] ();
        LDR      R4,??DataTable139  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  715   put6502memory( savepc, A );
        LDRH     R0,[R4, #+2]
        LDRB     R1,[R4, #+3092]
        MOV      R2,#+1
        ORR      R2,R2,#0x8000
        CMP      R0,R2
        POPCS    {R4,PC}
        LDR      R3,??DataTable140  ;; gameImage
        CMP      R0,#+16384
        LDR      R3,[R3, #+0]
        STRB     R1,[R0, +R3]
        POPCC    {R4,PC}
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        POPCS    {R4,PC}
        _BLF     APUWrite,??APUWrite??rA
//  716 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock135

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock136 Using cfiCommon0
        CFI NoFunction
        THUMB
??stx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock136
        REQUIRE stx6502
//  717 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock137 Using cfiCommon1
        CFI Function stx6502
        ARM
//  718 void stx6502()
//  719 {
stx6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  720   adrmode[opcode] ();
        LDR      R4,??DataTable139  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  721   put6502memory( savepc, X );
        LDRH     R0,[R4, #+2]
        LDRB     R1,[R4, #+3093]
        MOV      R2,#+1
        ORR      R2,R2,#0x8000
        CMP      R0,R2
        POPCS    {R4,PC}
        LDR      R3,??DataTable140  ;; gameImage
        CMP      R0,#+16384
        LDR      R3,[R3, #+0]
        STRB     R1,[R0, +R3]
        POPCC    {R4,PC}
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        POPCS    {R4,PC}
        _BLF     APUWrite,??APUWrite??rA
//  722 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock137

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock138 Using cfiCommon0
        CFI NoFunction
        THUMB
??sty6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock138
        REQUIRE sty6502
//  723 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock139 Using cfiCommon1
        CFI Function sty6502
        ARM
//  724 void sty6502()
//  725 {
sty6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  726   adrmode[opcode] ();
        LDR      R4,??DataTable139  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  727   put6502memory( savepc, Y );
        LDRH     R0,[R4, #+2]
        LDRB     R1,[R4, #+3094]
        MOV      R2,#+1
        ORR      R2,R2,#0x8000
        CMP      R0,R2
        POPCS    {R4,PC}
        LDR      R3,??DataTable140  ;; gameImage
        CMP      R0,#+16384
        LDR      R3,[R3, #+0]
        STRB     R1,[R0, +R3]
        POPCC    {R4,PC}
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        POPCS    {R4,PC}
        _BLF     APUWrite,??APUWrite??rA
//  728 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock139

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock140 Using cfiCommon0
        CFI NoFunction
        THUMB
??tax6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock140
        REQUIRE tax6502
//  729 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock141 Using cfiCommon1
        CFI Function tax6502
        ARM
//  730 void tax6502()
//  731 {
//  732   X = A;
tax6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3092]
//  733   if ( X ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        STRB     R1,[R0, #+3093]
        CMP      R1,#+0
        ANDNE    R2,R2,#0xFD
//  734   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  735   if ( X & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  736   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  737 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock141

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock142 Using cfiCommon0
        CFI NoFunction
        THUMB
??tay6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock142
        REQUIRE tay6502
//  738 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock143 Using cfiCommon1
        CFI Function tay6502
        ARM
//  739 void tay6502()
//  740 {
//  741   Y = A;
tay6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3092]
//  742   if ( Y ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        STRB     R1,[R0, #+3094]
        CMP      R1,#+0
        ANDNE    R2,R2,#0xFD
//  743   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  744   if ( Y & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  745   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  746 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock143

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock144 Using cfiCommon0
        CFI NoFunction
        THUMB
??tsx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock144
        REQUIRE tsx6502
//  747 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock145 Using cfiCommon1
        CFI Function tsx6502
        ARM
//  748 void tsx6502()
//  749 {
//  750   X = S;
tsx6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3096]
//  751   if ( X ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        STRB     R1,[R0, #+3093]
        CMP      R1,#+0
        ANDNE    R2,R2,#0xFD
//  752   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  753   if ( X & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  754   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  755 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock145

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock146 Using cfiCommon0
        CFI NoFunction
        THUMB
??txa6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock146
        REQUIRE txa6502
//  756 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock147 Using cfiCommon1
        CFI Function txa6502
        ARM
//  757 void txa6502()
//  758 {
//  759   A = X;
txa6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3093]
//  760   if ( A ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        STRB     R1,[R0, #+3092]
        CMP      R1,#+0
        ANDNE    R2,R2,#0xFD
//  761   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  762   if ( A & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  763   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  764 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock147

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock148 Using cfiCommon0
        CFI NoFunction
        THUMB
??txs6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock148
        REQUIRE txs6502
//  765 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock149 Using cfiCommon1
        CFI Function txs6502
        ARM
//  766 void txs6502()
//  767 {
//  768   S = X;
txs6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3093]
        STRB     R1,[R0, #+3096]
//  769 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock149

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock150 Using cfiCommon0
        CFI NoFunction
        THUMB
??tya6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock150
        REQUIRE tya6502
//  770 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock151 Using cfiCommon1
        CFI Function tya6502
        ARM
//  771 void tya6502()
//  772 {
//  773   A = Y;
tya6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3094]
//  774   if ( A ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        STRB     R1,[R0, #+3092]
        CMP      R1,#+0
        ANDNE    R2,R2,#0xFD
//  775   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  776   if ( A & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  777   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  778 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock151

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock152 Using cfiCommon0
        CFI NoFunction
        THUMB
??bra6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock152
        REQUIRE bra6502
//  779 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock153 Using cfiCommon1
        CFI Function bra6502
        ARM
//  780 void bra6502()
//  781 {
bra6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  782   adrmode[opcode] ();
        LDR      R4,??DataTable124  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  783   PC += savepc;
        LDRH     R0,[R4, #+0]
        LDRH     R1,[R4, #+2]
        ADD      R0,R1,R0
        STRH     R0,[R4, #+0]
//  784   clockticks6502++;
        LDR      R0,[R4, #+3080]
        ADD      R0,R0,#+1
        STR      R0,[R4, #+3080]
//  785 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock153

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable124:
        DC32     pc_reg

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock154 Using cfiCommon0
        CFI NoFunction
        THUMB
??dea6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock154
        REQUIRE dea6502
//  786 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock155 Using cfiCommon1
        CFI Function dea6502
        ARM
//  787 void dea6502()
//  788 {
//  789   A--;
dea6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3092]
//  790   if ( A ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        SUB      R1,R1,#+1
        STRB     R1,[R0, #+3092]
        ANDS     R1,R1,#0xFF
        ANDNE    R2,R2,#0xFD
//  791   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  792   if ( A & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  793   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  794 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock155

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock156 Using cfiCommon0
        CFI NoFunction
        THUMB
??ina6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock156
        REQUIRE ina6502
//  795 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock157 Using cfiCommon1
        CFI Function ina6502
        ARM
//  796 void ina6502()
//  797 {
//  798   A++;
ina6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDRB     R1,[R0, #+3092]
//  799   if ( A ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3092]
        ANDS     R1,R1,#0xFF
        ANDNE    R2,R2,#0xFD
//  800   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  801   if ( A & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  802   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  803 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock157

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock158 Using cfiCommon0
        CFI NoFunction
        THUMB
??phx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock158
        REQUIRE phx6502
//  804 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock159 Using cfiCommon1
        CFI Function phx6502
        ARM
//  805 void phx6502()
//  806 {
//  807   put6502memory( 0x100 + S--, X );
phx6502:
        LDR      R0,??DataTable139  ;; pc_reg
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        LDRB     R2,[R0, #+3096]
        SUB      R1,R2,#+1
        STRB     R1,[R0, #+3096]
        LDRB     R1,[R0, #+3093]
        ADD      R0,R2,#+256
        MOV      R2,#+1
        ORR      R2,R2,#0x8000
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R2
        POPCS    {PC}
        LDR      R3,??DataTable140  ;; gameImage
        CMP      R0,#+16384
        LDR      R3,[R3, #+0]
        STRB     R1,[R0, +R3]
        POPCC    {PC}
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        POPCS    {PC}
        _BLF     APUWrite,??APUWrite??rA
//  808 }
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock159

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock160 Using cfiCommon0
        CFI NoFunction
        THUMB
??plx6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock160
        REQUIRE plx6502
//  809 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock161 Using cfiCommon1
        CFI Function plx6502
        ARM
//  810 void plx6502()
//  811 {
//  812   X = gameImage[++S + 0x100];
plx6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDR      R2,??DataTable140  ;; gameImage
        LDRB     R1,[R0, #+3096]
        LDR      R2,[R2, #+0]
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3096]
        AND      R1,R1,#0xFF
        ADD      R1,R1,R2
        LDRB     R1,[R1, #+256]
//  813   if ( X ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        STRB     R1,[R0, #+3093]
        CMP      R1,#+0
        ANDNE    R2,R2,#0xFD
//  814   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  815   if ( X & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  816   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  817 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock161

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock162 Using cfiCommon0
        CFI NoFunction
        THUMB
??phy6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock162
        REQUIRE phy6502
//  818 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock163 Using cfiCommon1
        CFI Function phy6502
        ARM
//  819 void phy6502()
//  820 {
//  821   put6502memory( 0x100 + S--, Y );
phy6502:
        LDR      R0,??DataTable139  ;; pc_reg
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        LDRB     R2,[R0, #+3096]
        SUB      R1,R2,#+1
        STRB     R1,[R0, #+3096]
        LDRB     R1,[R0, #+3094]
        ADD      R0,R2,#+256
        MOV      R2,#+1
        ORR      R2,R2,#0x8000
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R2
        POPCS    {PC}
        LDR      R3,??DataTable140  ;; gameImage
        CMP      R0,#+16384
        LDR      R3,[R3, #+0]
        STRB     R1,[R0, +R3]
        POPCC    {PC}
        MOV      R2,#+32
        ORR      R2,R2,#0x4000
        CMP      R0,R2
        POPCS    {PC}
        _BLF     APUWrite,??APUWrite??rA
//  822 }
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock163

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock164 Using cfiCommon0
        CFI NoFunction
        THUMB
??ply6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock164
        REQUIRE ply6502
//  823 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock165 Using cfiCommon1
        CFI Function ply6502
        ARM
//  824 void ply6502()
//  825 {
//  826   Y = gameImage[++S + 0x100];
ply6502:
        LDR      R0,??DataTable139  ;; pc_reg
        LDR      R2,??DataTable140  ;; gameImage
        LDRB     R1,[R0, #+3096]
        LDR      R2,[R2, #+0]
        ADD      R1,R1,#+1
        STRB     R1,[R0, #+3096]
        AND      R1,R1,#0xFF
        ADD      R1,R1,R2
        LDRB     R1,[R1, #+256]
//  827   if ( Y ) P &= 0xfd;
        LDRB     R2,[R0, #+3095]
        STRB     R1,[R0, #+3094]
        CMP      R1,#+0
        ANDNE    R2,R2,#0xFD
//  828   else P |= 0x02;
        ORREQ    R2,R2,#0x2
//  829   if ( Y & 0x80 ) P |= 0x80;
        TST      R1,#0x80
        ORRNE    R1,R2,#0x80
//  830   else P &= 0x7f;
        ANDEQ    R1,R2,#0x7F
        STRB     R1,[R0, #+3095]
//  831 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock165

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock166 Using cfiCommon0
        CFI NoFunction
        THUMB
??stz6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock166
        REQUIRE stz6502
//  832 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock167 Using cfiCommon1
        CFI Function stz6502
        ARM
//  833 void stz6502()
//  834 {
stz6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  835   adrmode[opcode] ();
        LDR      R4,??DataTable139  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  836   put6502memory( savepc, 0 );
        LDRH     R0,[R4, #+2]
        MOV      R1,#+1
        ORR      R1,R1,#0x8000
        CMP      R0,R1
        POPCS    {R4,PC}
        LDR      R2,??DataTable140  ;; gameImage
        MOV      R3,#+0
        LDR      R2,[R2, #+0]
        CMP      R0,#+16384
        STRB     R3,[R0, +R2]
        POPCC    {R4,PC}
        MOV      R1,#+32
        ORR      R1,R1,#0x4000
        CMP      R0,R1
        POPCS    {R4,PC}
        MOV      R1,#+0
        _BLF     APUWrite,??APUWrite??rA
//  837 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock167

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock168 Using cfiCommon0
        CFI NoFunction
        THUMB
??tsb6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock168
        REQUIRE tsb6502
//  838 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock169 Using cfiCommon1
        CFI Function tsb6502
        ARM
//  839 void tsb6502()
//  840 {
tsb6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  841   adrmode[opcode] ();
        LDR      R4,??DataTable139  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  842   gameImage[savepc] |= A;
        LDR      R0,??DataTable140  ;; gameImage
        LDRH     R1,[R4, #+2]
        LDR      R2,[R0, #+0]
        LDRB     R3,[R4, #+3092]
        ADD      R1,R1,R2
        LDRB     R2,[R1, #+0]
        ORR      R2,R3,R2
        STRB     R2,[R1, #+0]
//  843   if ( gameImage[savepc] ) P &= 0xfd;
        LDRH     R1,[R4, #+2]
        LDR      R0,[R0, #+0]
        LDRB     R0,[R1, +R0]
        CMP      R0,#+0
        LDRB     R0,[R4, #+3095]
        ANDNE    R0,R0,#0xFD
//  844   else P |= 0x02;
        ORREQ    R0,R0,#0x2
        STRB     R0,[R4, #+3095]
//  845 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock169

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock170 Using cfiCommon0
        CFI NoFunction
        THUMB
??trb6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock170
        REQUIRE trb6502
//  846 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock171 Using cfiCommon1
        CFI Function trb6502
        ARM
//  847 void trb6502()
//  848 {
trb6502:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  849   adrmode[opcode] ();
        LDR      R4,??DataTable139  ;; pc_reg
        LDRB     R0,[R4, #+3097]
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+8]
        BLX      R0
//  850   gameImage[savepc] = gameImage[savepc] & ( A ^ 0xff );
        LDR      R0,??DataTable140  ;; gameImage
        LDRH     R1,[R4, #+2]
        LDR      R2,[R0, #+0]
        LDRB     R3,[R4, #+3092]
        ADD      R1,R1,R2
        LDRB     R2,[R1, #+0]
        EOR      R3,R3,#0xFF
        AND      R2,R3,R2
        STRB     R2,[R1, #+0]
//  851   if ( gameImage[savepc] ) P &= 0xfd;
        LDRH     R1,[R4, #+2]
        LDR      R0,[R0, #+0]
        LDRB     R0,[R1, +R0]
        CMP      R0,#+0
        LDRB     R0,[R4, #+3095]
        ANDNE    R0,R0,#0xFD
//  852   else P |= 0x02;
        ORREQ    R0,R0,#0x2
        STRB     R0,[R4, #+3095]
//  853 }
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock171

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable139:
        DC32     pc_reg

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable140:
        DC32     gameImage

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock172 Using cfiCommon0
        CFI NoFunction
        THUMB
??init6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock172
        REQUIRE init6502
//  854 
//  855 /* Init CPU */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock173 Using cfiCommon1
        CFI Function init6502
        ARM
//  856 void init6502()
//  857 {
//  858   ticks[0x00] = 7; instruction[0x00] = brk6502; adrmode[0x00] = implied6502;
init6502:
        LDR      R0,??init6502_0+0x4  ;; pc_reg
//  859   ticks[0x01] = 6; instruction[0x01] = ora6502; adrmode[0x01] = indx6502;
        LDR      R3,??init6502_0  ;; indx6502
//  860   ticks[0x02] = 2; instruction[0x02] = nop6502; adrmode[0x02] = implied6502;
        LDR      R12,??init6502_0+0x8  ;; nop6502
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
//  861   ticks[0x03] = 2; instruction[0x03] = nop6502; adrmode[0x03] = implied6502;
//  862   ticks[0x04] = 3; instruction[0x04] = tsb6502; adrmode[0x04] = zp6502;
//  863   ticks[0x05] = 3; instruction[0x05] = ora6502; adrmode[0x05] = zp6502;
//  864   ticks[0x06] = 5; instruction[0x06] = asl6502; adrmode[0x06] = zp6502;
//  865   ticks[0x07] = 2; instruction[0x07] = nop6502; adrmode[0x07] = implied6502;
//  866   ticks[0x08] = 3; instruction[0x08] = php6502; adrmode[0x08] = implied6502;
        LDR      R8,??init6502_0+0xC  ;; php6502
//  867   ticks[0x09] = 3; instruction[0x09] = ora6502; adrmode[0x09] = immediate6502;
//  868   ticks[0x0a] = 2; instruction[0x0a] = asla6502; adrmode[0x0a] = implied6502;
//  869   ticks[0x0b] = 2; instruction[0x0b] = nop6502; adrmode[0x0b] = implied6502;
//  870   ticks[0x0c] = 4; instruction[0x0c] = tsb6502; adrmode[0x0c] = abs6502;
//  871   ticks[0x0d] = 4; instruction[0x0d] = ora6502; adrmode[0x0d] = abs6502;
//  872   ticks[0x0e] = 6; instruction[0x0e] = asl6502; adrmode[0x0e] = abs6502;
//  873   ticks[0x0f] = 2; instruction[0x0f] = nop6502; adrmode[0x0f] = implied6502;
//  874   ticks[0x10] = 2; instruction[0x10] = bpl6502; adrmode[0x10] = relative6502;
        LDR      R10,??init6502_0+0x10  ;; bpl6502
        LDR      R11,??init6502_0+0x14  ;; ora6502
        LDR      R9,??init6502_0+0x18  ;; tsb6502
        LDR      R5,??init6502_0+0x1C  ;; zp6502
        LDR      R7,??init6502_0+0x20  ;; asl6502
//  875   ticks[0x11] = 5; instruction[0x11] = ora6502; adrmode[0x11] = indy6502;
//  876   ticks[0x12] = 3; instruction[0x12] = ora6502; adrmode[0x12] = indzp6502;
//  877   ticks[0x13] = 2; instruction[0x13] = nop6502; adrmode[0x13] = implied6502;
//  878   ticks[0x14] = 3; instruction[0x14] = trb6502; adrmode[0x14] = zp6502;
//  879   ticks[0x15] = 4; instruction[0x15] = ora6502; adrmode[0x15] = zpx6502;
//  880   ticks[0x16] = 6; instruction[0x16] = asl6502; adrmode[0x16] = zpx6502;
//  881   ticks[0x17] = 2; instruction[0x17] = nop6502; adrmode[0x17] = implied6502;
//  882   ticks[0x18] = 2; instruction[0x18] = clc6502; adrmode[0x18] = implied6502;
        LDR      LR,??init6502_0+0x24  ;; clc6502
        STR      R10,[R0, #+1096]
        LDR      R10,??init6502_0+0x28  ;; relative6502
        STR      LR,[R0, #+1128]
//  883   ticks[0x19] = 4; instruction[0x19] = ora6502; adrmode[0x19] = absy6502;
        LDR      LR,??init6502_0+0x2C  ;; absy6502
        STR      R10,[R0, #+72]
        LDR      R10,??init6502_0+0x30  ;; indy6502
        MOV      R1,#+7
        STR      R10,[R0, #+76]
        LDR      R10,??init6502_0+0x34  ;; indzp6502
        STR      R1,[R0, #+2056]
        LDR      R1,??init6502_0+0x38  ;; brk6502
        STR      R8,[R0, #+1064]
        LDR      R8,??init6502_0+0x3C  ;; immediate6502
        STR      R10,[R0, #+80]
        LDR      R10,??init6502_0+0x40  ;; trb6502
        STR      LR,[R0, #+108]
//  884   ticks[0x1a] = 2; instruction[0x1a] = ina6502; adrmode[0x1a] = implied6502;
        LDR      LR,??init6502_0+0x44  ;; ina6502
        STR      R1,[R0, #+1032]
        LDR      R1,??init6502_0+0x48  ;; implied6502
        STR      R11,[R0, #+1036]
        STR      R9,[R0, #+1048]
        STR      R11,[R0, #+1052]
        STR      R11,[R0, #+1068]
        STR      R8,[R0, #+44]
        LDR      R8,??init6502_0+0x4C  ;; asla6502
        STR      R9,[R0, #+1080]
        LDR      R9,??init6502_0+0x50  ;; abs6502
        STR      R11,[R0, #+1084]
        STR      R11,[R0, #+1100]
        STR      R11,[R0, #+1104]
        STR      R10,[R0, #+1112]
        LDR      R10,??init6502_0+0x54  ;; zpx6502
        STR      R11,[R0, #+1116]
        STR      R11,[R0, #+1132]
        STR      LR,[R0, #+1136]
//  885   ticks[0x1b] = 2; instruction[0x1b] = nop6502; adrmode[0x1b] = implied6502;
//  886   ticks[0x1c] = 4; instruction[0x1c] = trb6502; adrmode[0x1c] = abs6502;
        LDR      LR,??init6502_0+0x40  ;; trb6502
//  887   ticks[0x1d] = 4; instruction[0x1d] = ora6502; adrmode[0x1d] = absx6502;
        STR      R11,[R0, #+1148]
        LDR      R11,??init6502_0+0x58  ;; absx6502
        STR      R1,[R0, #+8]
        MOV      R2,#+6
        STR      R2,[R0, #+2060]
        STR      R3,[R0, #+12]
        MOV      R3,#+2
        STR      R3,[R0, #+2064]
        STR      R12,[R0, #+1040]
        STR      R1,[R0, #+16]
        STR      R3,[R0, #+2068]
        STR      R12,[R0, #+1044]
        STR      R1,[R0, #+20]
        MOV      R4,#+3
        STR      R4,[R0, #+2072]
        STR      R5,[R0, #+24]
        STR      R4,[R0, #+2076]
        STR      R5,[R0, #+28]
        MOV      R6,#+5
        STR      R6,[R0, #+2080]
        STR      R7,[R0, #+1056]
        STR      R5,[R0, #+32]
        STR      R3,[R0, #+2084]
        STR      R12,[R0, #+1060]
        STR      R1,[R0, #+36]
        STR      R4,[R0, #+2088]
        STR      R1,[R0, #+40]
        STR      R4,[R0, #+2092]
        STR      R3,[R0, #+2096]
        STR      R8,[R0, #+1072]
        STR      R1,[R0, #+48]
        STR      R3,[R0, #+2100]
        STR      R12,[R0, #+1076]
        STR      R1,[R0, #+52]
        MOV      R8,#+4
        STR      R8,[R0, #+2104]
        STR      R9,[R0, #+56]
        STR      R8,[R0, #+2108]
        STR      R9,[R0, #+60]
        STR      R2,[R0, #+2112]
        STR      R7,[R0, #+1088]
        STR      R9,[R0, #+64]
        STR      R3,[R0, #+2116]
        STR      R12,[R0, #+1092]
        STR      R1,[R0, #+68]
        STR      R3,[R0, #+2120]
        STR      R6,[R0, #+2124]
        STR      R4,[R0, #+2128]
        STR      R3,[R0, #+2132]
        STR      R12,[R0, #+1108]
        STR      R1,[R0, #+84]
        STR      R4,[R0, #+2136]
        STR      R5,[R0, #+88]
        STR      R8,[R0, #+2140]
        STR      R10,[R0, #+92]
        STR      R2,[R0, #+2144]
        STR      R7,[R0, #+1120]
        STR      R10,[R0, #+96]
        STR      R3,[R0, #+2148]
        STR      R12,[R0, #+1124]
        STR      R1,[R0, #+100]
        STR      R3,[R0, #+2152]
        STR      R1,[R0, #+104]
        STR      R8,[R0, #+2156]
        STR      R3,[R0, #+2160]
        STR      R1,[R0, #+112]
        STR      R3,[R0, #+2164]
        STR      R12,[R0, #+1140]
        STR      R1,[R0, #+116]
        STR      R8,[R0, #+2168]
        STR      LR,[R0, #+1144]
        STR      R9,[R0, #+120]
        STR      R8,[R0, #+2172]
        STR      R11,[R0, #+124]
//  888   ticks[0x1e] = 7; instruction[0x1e] = asl6502; adrmode[0x1e] = absx6502;
        MOV      LR,#+7
        STR      LR,[R0, #+2176]
        STR      R7,[R0, #+1152]
        STR      R11,[R0, #+128]
//  889   ticks[0x1f] = 2; instruction[0x1f] = nop6502; adrmode[0x1f] = implied6502;
        STR      R3,[R0, #+2180]
        STR      R12,[R0, #+1156]
        STR      R1,[R0, #+132]
//  890   ticks[0x20] = 6; instruction[0x20] = jsr6502; adrmode[0x20] = abs6502;
//  891   ticks[0x21] = 6; instruction[0x21] = and6502; adrmode[0x21] = indx6502;
        LDR      LR,??init6502_0  ;; indx6502
        LDR      R7,??init6502_0+0x5C  ;; jsr6502
        STR      LR,[R0, #+140]
//  892   ticks[0x22] = 2; instruction[0x22] = nop6502; adrmode[0x22] = implied6502;
//  893   ticks[0x23] = 2; instruction[0x23] = nop6502; adrmode[0x23] = implied6502;
//  894   ticks[0x24] = 3; instruction[0x24] = bit6502; adrmode[0x24] = zp6502;
        LDR      LR,??init6502_0+0x60  ;; bit6502
        STR      R7,[R0, #+1160]
        LDR      R7,??init6502_0+0x64  ;; and6502
        STR      LR,[R0, #+1176]
//  895   ticks[0x25] = 3; instruction[0x25] = and6502; adrmode[0x25] = zp6502;
//  896   ticks[0x26] = 5; instruction[0x26] = rol6502; adrmode[0x26] = zp6502;
        LDR      LR,??init6502_0+0x68  ;; rol6502
        STR      R7,[R0, #+1164]
        STR      LR,[R0, #+1184]
//  897   ticks[0x27] = 2; instruction[0x27] = nop6502; adrmode[0x27] = implied6502;
//  898   ticks[0x28] = 4; instruction[0x28] = plp6502; adrmode[0x28] = implied6502;
        LDR      LR,??init6502_0+0x6C  ;; plp6502
        STR      R7,[R0, #+1180]
        STR      LR,[R0, #+1192]
//  899   ticks[0x29] = 3; instruction[0x29] = and6502; adrmode[0x29] = immediate6502;
        LDR      LR,??init6502_0+0x3C  ;; immediate6502
        STR      R7,[R0, #+1196]
        STR      LR,[R0, #+172]
//  900   ticks[0x2a] = 2; instruction[0x2a] = rola6502; adrmode[0x2a] = implied6502;
        LDR      LR,??init6502_0+0x70  ;; rola6502
//  901   ticks[0x2b] = 2; instruction[0x2b] = nop6502; adrmode[0x2b] = implied6502;
//  902   ticks[0x2c] = 4; instruction[0x2c] = bit6502; adrmode[0x2c] = abs6502;
//  903   ticks[0x2d] = 4; instruction[0x2d] = and6502; adrmode[0x2d] = abs6502;
        STR      R7,[R0, #+1212]
        STR      LR,[R0, #+1200]
        LDR      LR,??init6502_0+0x60  ;; bit6502
//  904   ticks[0x2e] = 6; instruction[0x2e] = rol6502; adrmode[0x2e] = abs6502;
//  905   ticks[0x2f] = 2; instruction[0x2f] = nop6502; adrmode[0x2f] = implied6502;
//  906   ticks[0x30] = 2; instruction[0x30] = bmi6502; adrmode[0x30] = relative6502;
//  907   ticks[0x31] = 5; instruction[0x31] = and6502; adrmode[0x31] = indy6502;
        STR      R7,[R0, #+1228]
        STR      LR,[R0, #+1208]
        LDR      LR,??init6502_0+0x68  ;; rol6502
//  908   ticks[0x32] = 3; instruction[0x32] = and6502; adrmode[0x32] = indzp6502;
        STR      R7,[R0, #+1232]
        STR      LR,[R0, #+1216]
        LDR      LR,??init6502_0+0x74  ;; bmi6502
//  909   ticks[0x33] = 2; instruction[0x33] = nop6502; adrmode[0x33] = implied6502;
//  910   ticks[0x34] = 4; instruction[0x34] = bit6502; adrmode[0x34] = zpx6502;
//  911   ticks[0x35] = 4; instruction[0x35] = and6502; adrmode[0x35] = zpx6502;
        STR      R7,[R0, #+1244]
        STR      LR,[R0, #+1224]
        LDR      LR,??init6502_0+0x28  ;; relative6502
//  912   ticks[0x36] = 6; instruction[0x36] = rol6502; adrmode[0x36] = zpx6502;
//  913   ticks[0x37] = 2; instruction[0x37] = nop6502; adrmode[0x37] = implied6502;
//  914   ticks[0x38] = 2; instruction[0x38] = sec6502; adrmode[0x38] = implied6502;
//  915   ticks[0x39] = 4; instruction[0x39] = and6502; adrmode[0x39] = absy6502;
        STR      R7,[R0, #+1260]
        STR      LR,[R0, #+200]
        LDR      LR,??init6502_0+0x30  ;; indy6502
//  916   ticks[0x3a] = 2; instruction[0x3a] = dea6502; adrmode[0x3a] = implied6502;
//  917   ticks[0x3b] = 2; instruction[0x3b] = nop6502; adrmode[0x3b] = implied6502;
//  918   ticks[0x3c] = 4; instruction[0x3c] = bit6502; adrmode[0x3c] = absx6502;
//  919   ticks[0x3d] = 4; instruction[0x3d] = and6502; adrmode[0x3d] = absx6502;
        STR      R7,[R0, #+1276]
        STR      LR,[R0, #+204]
        LDR      LR,??init6502_0+0x34  ;; indzp6502
//  920   ticks[0x3e] = 7; instruction[0x3e] = rol6502; adrmode[0x3e] = absx6502;
        MOV      R7,#+7
        STR      LR,[R0, #+208]
        LDR      LR,??init6502_0+0x60  ;; bit6502
        STR      R7,[R0, #+2304]
        LDR      R7,??init6502_0+0x68  ;; rol6502
        STR      LR,[R0, #+1240]
        LDR      LR,??init6502_0+0x68  ;; rol6502
        STR      R7,[R0, #+1280]
//  921   ticks[0x3f] = 2; instruction[0x3f] = nop6502; adrmode[0x3f] = implied6502;
//  922   ticks[0x40] = 6; instruction[0x40] = rti6502; adrmode[0x40] = implied6502;
        LDR      R7,??init6502_0+0x78  ;; rti6502
        STR      LR,[R0, #+1248]
        LDR      LR,??init6502_0+0x7C  ;; sec6502
        STR      R7,[R0, #+1288]
//  923   ticks[0x41] = 6; instruction[0x41] = eor6502; adrmode[0x41] = indx6502;
        LDR      R7,??init6502_0+0x80  ;; eor6502
        STR      LR,[R0, #+1256]
        LDR      LR,??init6502_0+0x2C  ;; absy6502
        STR      R2,[R0, #+2184]
        STR      LR,[R0, #+236]
        LDR      LR,??init6502_0+0x84  ;; dea6502
        STR      R9,[R0, #+136]
        STR      LR,[R0, #+1264]
        LDR      LR,??init6502_0+0x60  ;; bit6502
        STR      R2,[R0, #+2188]
        STR      LR,[R0, #+1272]
        LDR      LR,??init6502_0  ;; indx6502
        STR      R3,[R0, #+2192]
        STR      R12,[R0, #+1168]
        STR      R1,[R0, #+144]
        STR      R3,[R0, #+2196]
        STR      R12,[R0, #+1172]
        STR      R1,[R0, #+148]
        STR      R4,[R0, #+2200]
        STR      R5,[R0, #+152]
        STR      R4,[R0, #+2204]
        STR      R5,[R0, #+156]
        STR      R6,[R0, #+2208]
        STR      R5,[R0, #+160]
        STR      R3,[R0, #+2212]
        STR      R12,[R0, #+1188]
        STR      R1,[R0, #+164]
        STR      R8,[R0, #+2216]
        STR      R1,[R0, #+168]
        STR      R4,[R0, #+2220]
        STR      R3,[R0, #+2224]
        STR      R1,[R0, #+176]
        STR      R3,[R0, #+2228]
        STR      R12,[R0, #+1204]
        STR      R1,[R0, #+180]
        STR      R8,[R0, #+2232]
        STR      R9,[R0, #+184]
        STR      R8,[R0, #+2236]
        STR      R9,[R0, #+188]
        STR      R2,[R0, #+2240]
        STR      R9,[R0, #+192]
        STR      R3,[R0, #+2244]
        STR      R12,[R0, #+1220]
        STR      R1,[R0, #+196]
        STR      R3,[R0, #+2248]
        STR      R6,[R0, #+2252]
        STR      R4,[R0, #+2256]
        STR      R3,[R0, #+2260]
        STR      R12,[R0, #+1236]
        STR      R1,[R0, #+212]
        STR      R8,[R0, #+2264]
        STR      R10,[R0, #+216]
        STR      R8,[R0, #+2268]
        STR      R10,[R0, #+220]
        STR      R2,[R0, #+2272]
        STR      R10,[R0, #+224]
        STR      R3,[R0, #+2276]
        STR      R12,[R0, #+1252]
        STR      R1,[R0, #+228]
        STR      R3,[R0, #+2280]
        STR      R1,[R0, #+232]
        STR      R8,[R0, #+2284]
        STR      R3,[R0, #+2288]
        STR      R1,[R0, #+240]
        STR      R3,[R0, #+2292]
        STR      R12,[R0, #+1268]
        STR      R1,[R0, #+244]
        STR      R8,[R0, #+2296]
        STR      R11,[R0, #+248]
        STR      R8,[R0, #+2300]
        STR      R11,[R0, #+252]
        STR      R11,[R0, #+256]
        STR      R3,[R0, #+2308]
        STR      R12,[R0, #+1284]
        STR      R1,[R0, #+260]
        STR      R2,[R0, #+2312]
        STR      R1,[R0, #+264]
        STR      R2,[R0, #+2316]
        STR      R7,[R0, #+1292]
        STR      LR,[R0, #+268]
//  924   ticks[0x42] = 2; instruction[0x42] = nop6502; adrmode[0x42] = implied6502;
        STR      R3,[R0, #+2320]
//  925   ticks[0x43] = 2; instruction[0x43] = nop6502; adrmode[0x43] = implied6502;
//  926   ticks[0x44] = 2; instruction[0x44] = nop6502; adrmode[0x44] = implied6502;
//  927   ticks[0x45] = 3; instruction[0x45] = eor6502; adrmode[0x45] = zp6502;
//  928   ticks[0x46] = 5; instruction[0x46] = lsr6502; adrmode[0x46] = zp6502;
        LDR      LR,??init6502_0+0x88  ;; lsr6502
        STR      R7,[R0, #+1308]
        STR      LR,[R0, #+1312]
//  929   ticks[0x47] = 2; instruction[0x47] = nop6502; adrmode[0x47] = implied6502;
//  930   ticks[0x48] = 3; instruction[0x48] = pha6502; adrmode[0x48] = implied6502;
        LDR      LR,??init6502_0+0x8C  ;; pha6502
//  931   ticks[0x49] = 3; instruction[0x49] = eor6502; adrmode[0x49] = immediate6502;
        STR      R7,[R0, #+1324]
        STR      LR,[R0, #+1320]
        LDR      LR,??init6502_0+0x3C  ;; immediate6502
//  932   ticks[0x4a] = 2; instruction[0x4a] = lsra6502; adrmode[0x4a] = implied6502;
//  933   ticks[0x4b] = 2; instruction[0x4b] = nop6502; adrmode[0x4b] = implied6502;
//  934   ticks[0x4c] = 3; instruction[0x4c] = jmp6502; adrmode[0x4c] = abs6502;
//  935   ticks[0x4d] = 4; instruction[0x4d] = eor6502; adrmode[0x4d] = abs6502;
        STR      R7,[R0, #+1340]
        STR      LR,[R0, #+300]
        LDR      LR,??init6502_0+0x90  ;; lsra6502
//  936   ticks[0x4e] = 6; instruction[0x4e] = lsr6502; adrmode[0x4e] = abs6502;
//  937   ticks[0x4f] = 2; instruction[0x4f] = nop6502; adrmode[0x4f] = implied6502;
//  938   ticks[0x50] = 2; instruction[0x50] = bvc6502; adrmode[0x50] = relative6502;
//  939   ticks[0x51] = 5; instruction[0x51] = eor6502; adrmode[0x51] = indy6502;
        STR      R7,[R0, #+1356]
        STR      LR,[R0, #+1328]
        LDR      LR,??init6502_0+0x94  ;; jmp6502
//  940   ticks[0x52] = 3; instruction[0x52] = eor6502; adrmode[0x52] = indzp6502;
        STR      R7,[R0, #+1360]
        STR      LR,[R0, #+1336]
        LDR      LR,??init6502_0+0x88  ;; lsr6502
//  941   ticks[0x53] = 2; instruction[0x53] = nop6502; adrmode[0x53] = implied6502;
//  942   ticks[0x54] = 2; instruction[0x54] = nop6502; adrmode[0x54] = implied6502;
//  943   ticks[0x55] = 4; instruction[0x55] = eor6502; adrmode[0x55] = zpx6502;
        STR      R7,[R0, #+1372]
        STR      LR,[R0, #+1344]
        LDR      LR,??init6502_0+0x98  ;; bvc6502
//  944   ticks[0x56] = 6; instruction[0x56] = lsr6502; adrmode[0x56] = zpx6502;
//  945   ticks[0x57] = 2; instruction[0x57] = nop6502; adrmode[0x57] = implied6502;
//  946   ticks[0x58] = 2; instruction[0x58] = cli6502; adrmode[0x58] = implied6502;
//  947   ticks[0x59] = 4; instruction[0x59] = eor6502; adrmode[0x59] = absy6502;
        STR      R7,[R0, #+1388]
        STR      LR,[R0, #+1352]
        LDR      LR,??init6502_0+0x28  ;; relative6502
//  948   ticks[0x5a] = 3; instruction[0x5a] = phy6502; adrmode[0x5a] = implied6502;
//  949   ticks[0x5b] = 2; instruction[0x5b] = nop6502; adrmode[0x5b] = implied6502;
//  950   ticks[0x5c] = 2; instruction[0x5c] = nop6502; adrmode[0x5c] = implied6502;
//  951   ticks[0x5d] = 4; instruction[0x5d] = eor6502; adrmode[0x5d] = absx6502;
        STR      R7,[R0, #+1404]
        STR      LR,[R0, #+328]
        LDR      LR,??init6502_0+0x30  ;; indy6502
//  952   ticks[0x5e] = 7; instruction[0x5e] = lsr6502; adrmode[0x5e] = absx6502;
        MOV      R7,#+7
        STR      LR,[R0, #+332]
        LDR      LR,??init6502_0+0x34  ;; indzp6502
        STR      R7,[R0, #+2432]
        LDR      R7,??init6502_0+0x88  ;; lsr6502
        STR      LR,[R0, #+336]
        LDR      LR,??init6502_0+0x88  ;; lsr6502
        STR      R7,[R0, #+1408]
//  953   ticks[0x5f] = 2; instruction[0x5f] = nop6502; adrmode[0x5f] = implied6502;
//  954   ticks[0x60] = 6; instruction[0x60] = rts6502; adrmode[0x60] = implied6502;
        LDR      R7,??init6502_0+0x9C  ;; rts6502
        STR      LR,[R0, #+1376]
        LDR      LR,??init6502_0+0xA0  ;; cli6502
        STR      R7,[R0, #+1416]
//  955   ticks[0x61] = 6; instruction[0x61] = adc6502; adrmode[0x61] = indx6502;
        LDR      R7,??init6502_0+0xA4  ;; adc6502
        STR      LR,[R0, #+1384]
        LDR      LR,??init6502_0+0x2C  ;; absy6502
        STR      R12,[R0, #+1296]
        STR      LR,[R0, #+364]
        LDR      LR,??init6502_0+0xA8  ;; phy6502
        STR      R1,[R0, #+272]
        STR      LR,[R0, #+1392]
        LDR      LR,??init6502_0  ;; indx6502
        STR      R3,[R0, #+2324]
        STR      LR,[R0, #+396]
//  956   ticks[0x62] = 2; instruction[0x62] = nop6502; adrmode[0x62] = implied6502;
//  957   ticks[0x63] = 2; instruction[0x63] = nop6502; adrmode[0x63] = implied6502;
//  958   ticks[0x64] = 3; instruction[0x64] = stz6502; adrmode[0x64] = zp6502;
        LDR      LR,??init6502_0+0xAC  ;; stz6502
        STR      R12,[R0, #+1300]
        STR      R1,[R0, #+276]
        STR      R3,[R0, #+2328]
        STR      R12,[R0, #+1304]
        STR      R1,[R0, #+280]
        STR      R4,[R0, #+2332]
        STR      R5,[R0, #+284]
        STR      R6,[R0, #+2336]
        STR      R5,[R0, #+288]
        STR      R3,[R0, #+2340]
        STR      R12,[R0, #+1316]
        STR      R1,[R0, #+292]
        STR      R4,[R0, #+2344]
        STR      R1,[R0, #+296]
        STR      R4,[R0, #+2348]
        STR      R3,[R0, #+2352]
        STR      R1,[R0, #+304]
        STR      R3,[R0, #+2356]
        STR      R12,[R0, #+1332]
        STR      R1,[R0, #+308]
        STR      R4,[R0, #+2360]
        STR      R9,[R0, #+312]
        STR      R8,[R0, #+2364]
        STR      R9,[R0, #+316]
        STR      R2,[R0, #+2368]
        STR      R9,[R0, #+320]
        STR      R3,[R0, #+2372]
        STR      R12,[R0, #+1348]
        STR      R1,[R0, #+324]
        STR      R3,[R0, #+2376]
        STR      R6,[R0, #+2380]
        STR      R4,[R0, #+2384]
        STR      R3,[R0, #+2388]
        STR      R12,[R0, #+1364]
        STR      R1,[R0, #+340]
        STR      R3,[R0, #+2392]
        STR      R12,[R0, #+1368]
        STR      R1,[R0, #+344]
        STR      R8,[R0, #+2396]
        STR      R10,[R0, #+348]
        STR      R2,[R0, #+2400]
        STR      R10,[R0, #+352]
        STR      R3,[R0, #+2404]
        STR      R12,[R0, #+1380]
        STR      R1,[R0, #+356]
        STR      R3,[R0, #+2408]
        STR      R1,[R0, #+360]
        STR      R8,[R0, #+2412]
        STR      R4,[R0, #+2416]
        STR      R1,[R0, #+368]
        STR      R3,[R0, #+2420]
        STR      R12,[R0, #+1396]
        STR      R1,[R0, #+372]
        STR      R3,[R0, #+2424]
        STR      R12,[R0, #+1400]
        STR      R1,[R0, #+376]
        STR      R8,[R0, #+2428]
        STR      R11,[R0, #+380]
        STR      R11,[R0, #+384]
        STR      R3,[R0, #+2436]
        STR      R12,[R0, #+1412]
        STR      R1,[R0, #+388]
        STR      R2,[R0, #+2440]
        STR      R1,[R0, #+392]
        STR      R2,[R0, #+2444]
        STR      R7,[R0, #+1420]
        STR      R3,[R0, #+2448]
        STR      R12,[R0, #+1424]
        STR      R1,[R0, #+400]
        STR      R3,[R0, #+2452]
        STR      R12,[R0, #+1428]
        STR      R1,[R0, #+404]
        STR      R4,[R0, #+2456]
        STR      LR,[R0, #+1432]
        STR      R5,[R0, #+408]
//  959   ticks[0x65] = 3; instruction[0x65] = adc6502; adrmode[0x65] = zp6502;
        STR      R4,[R0, #+2460]
        STR      R7,[R0, #+1436]
        STR      R5,[R0, #+412]
//  960   ticks[0x66] = 5; instruction[0x66] = ror6502; adrmode[0x66] = zp6502;
        STR      R6,[R0, #+2464]
        LDR      LR,??init6502_0+0xB0  ;; ror6502
//  961   ticks[0x67] = 2; instruction[0x67] = nop6502; adrmode[0x67] = implied6502;
//  962   ticks[0x68] = 4; instruction[0x68] = pla6502; adrmode[0x68] = implied6502;
//  963   ticks[0x69] = 3; instruction[0x69] = adc6502; adrmode[0x69] = immediate6502;
        STR      R7,[R0, #+1452]
        STR      LR,[R0, #+1440]
        LDR      LR,??init6502_0+0xB4  ;; pla6502
//  964   ticks[0x6a] = 2; instruction[0x6a] = rora6502; adrmode[0x6a] = implied6502;
//  965   ticks[0x6b] = 2; instruction[0x6b] = nop6502; adrmode[0x6b] = implied6502;
//  966   ticks[0x6c] = 5; instruction[0x6c] = jmp6502; adrmode[0x6c] = indirect6502;
//  967   ticks[0x6d] = 4; instruction[0x6d] = adc6502; adrmode[0x6d] = abs6502;
        STR      R7,[R0, #+1468]
        STR      LR,[R0, #+1448]
        LDR      LR,??init6502_0+0x3C  ;; immediate6502
//  968   ticks[0x6e] = 6; instruction[0x6e] = ror6502; adrmode[0x6e] = abs6502;
//  969   ticks[0x6f] = 2; instruction[0x6f] = nop6502; adrmode[0x6f] = implied6502;
//  970   ticks[0x70] = 2; instruction[0x70] = bvs6502; adrmode[0x70] = relative6502;
//  971   ticks[0x71] = 5; instruction[0x71] = adc6502; adrmode[0x71] = indy6502;
        STR      R7,[R0, #+1484]
        STR      LR,[R0, #+428]
        LDR      LR,??init6502_0+0xB8  ;; rora6502
//  972   ticks[0x72] = 3; instruction[0x72] = adc6502; adrmode[0x72] = indzp6502;
        STR      R7,[R0, #+1488]
        STR      LR,[R0, #+1456]
        LDR      LR,??init6502_0+0x94  ;; jmp6502
//  973   ticks[0x73] = 2; instruction[0x73] = nop6502; adrmode[0x73] = implied6502;
//  974   ticks[0x74] = 4; instruction[0x74] = stz6502; adrmode[0x74] = zpx6502;
//  975   ticks[0x75] = 4; instruction[0x75] = adc6502; adrmode[0x75] = zpx6502;
        STR      R7,[R0, #+1500]
        STR      LR,[R0, #+1464]
        LDR      LR,??init6502_0+0xBC  ;; indirect6502
//  976   ticks[0x76] = 6; instruction[0x76] = ror6502; adrmode[0x76] = zpx6502;
//  977   ticks[0x77] = 2; instruction[0x77] = nop6502; adrmode[0x77] = implied6502;
//  978   ticks[0x78] = 2; instruction[0x78] = sei6502; adrmode[0x78] = implied6502;
//  979   ticks[0x79] = 4; instruction[0x79] = adc6502; adrmode[0x79] = absy6502;
        STR      R7,[R0, #+1516]
        STR      LR,[R0, #+440]
        LDR      LR,??init6502_0+0xB0  ;; ror6502
//  980   ticks[0x7a] = 4; instruction[0x7a] = ply6502; adrmode[0x7a] = implied6502;
//  981   ticks[0x7b] = 2; instruction[0x7b] = nop6502; adrmode[0x7b] = implied6502;
//  982   ticks[0x7c] = 6; instruction[0x7c] = jmp6502; adrmode[0x7c] = indabsx6502;
//  983   ticks[0x7d] = 4; instruction[0x7d] = adc6502; adrmode[0x7d] = absx6502;
        STR      R7,[R0, #+1532]
        STR      LR,[R0, #+1472]
        LDR      LR,??init6502_0+0xC0  ;; bvs6502
//  984   ticks[0x7e] = 7; instruction[0x7e] = ror6502; adrmode[0x7e] = absx6502;
        MOV      R7,#+7
        STR      LR,[R0, #+1480]
        LDR      LR,??init6502_0+0x28  ;; relative6502
        STR      R7,[R0, #+2560]
        LDR      R7,??init6502_0+0xB0  ;; ror6502
        STR      LR,[R0, #+456]
        LDR      LR,??init6502_0+0x30  ;; indy6502
        STR      R7,[R0, #+1536]
//  985   ticks[0x7f] = 2; instruction[0x7f] = nop6502; adrmode[0x7f] = implied6502;
//  986   ticks[0x80] = 2; instruction[0x80] = bra6502; adrmode[0x80] = relative6502;
        LDR      R7,??init6502_0+0xC4  ;; bra6502
        STR      LR,[R0, #+460]
        LDR      LR,??init6502_0+0x34  ;; indzp6502
        STR      R7,[R0, #+1544]
        LDR      R7,??init6502_0+0x28  ;; relative6502
        STR      LR,[R0, #+464]
        LDR      LR,??init6502_0+0xAC  ;; stz6502
        STR      R7,[R0, #+520]
//  987   ticks[0x81] = 6; instruction[0x81] = sta6502; adrmode[0x81] = indx6502;
        LDR      R7,??init6502_0+0xC8  ;; sta6502
        STR      LR,[R0, #+1496]
        LDR      LR,??init6502_0+0xB0  ;; ror6502
        STR      R5,[R0, #+416]
        STR      LR,[R0, #+1504]
        LDR      LR,??init6502_0+0xCC  ;; sei6502
        STR      R3,[R0, #+2468]
        STR      LR,[R0, #+1512]
        LDR      LR,??init6502_0+0x2C  ;; absy6502
        STR      R12,[R0, #+1444]
        STR      LR,[R0, #+492]
        LDR      LR,??init6502_0+0xD0  ;; ply6502
        STR      R1,[R0, #+420]
        STR      LR,[R0, #+1520]
        LDR      LR,??init6502_0+0x94  ;; jmp6502
        STR      R8,[R0, #+2472]
        STR      LR,[R0, #+1528]
        LDR      LR,??init6502_0+0xD4  ;; indabsx6502
        STR      R1,[R0, #+424]
        STR      LR,[R0, #+504]
        LDR      LR,??init6502_0  ;; indx6502
        STR      R4,[R0, #+2476]
        STR      LR,[R0, #+524]
//  988   ticks[0x82] = 2; instruction[0x82] = nop6502; adrmode[0x82] = implied6502;
//  989   ticks[0x83] = 2; instruction[0x83] = nop6502; adrmode[0x83] = implied6502;
//  990   ticks[0x84] = 2; instruction[0x84] = sty6502; adrmode[0x84] = zp6502;
        LDR      LR,??init6502_0+0xD8  ;; sty6502
        STR      R3,[R0, #+2480]
        STR      LR,[R0, #+1560]
//  991   ticks[0x85] = 2; instruction[0x85] = sta6502; adrmode[0x85] = zp6502;
//  992   ticks[0x86] = 2; instruction[0x86] = stx6502; adrmode[0x86] = zp6502;
        LDR      LR,??init6502_0+0xDC  ;; stx6502
        STR      R1,[R0, #+432]
        STR      R3,[R0, #+2484]
        STR      R12,[R0, #+1460]
        STR      R1,[R0, #+436]
        STR      R6,[R0, #+2488]
        STR      R8,[R0, #+2492]
        STR      R9,[R0, #+444]
        STR      R2,[R0, #+2496]
        STR      R9,[R0, #+448]
        STR      R3,[R0, #+2500]
        STR      R12,[R0, #+1476]
        STR      R1,[R0, #+452]
        STR      R3,[R0, #+2504]
        STR      R6,[R0, #+2508]
        STR      R4,[R0, #+2512]
        STR      R3,[R0, #+2516]
        STR      R12,[R0, #+1492]
        STR      R1,[R0, #+468]
        STR      R8,[R0, #+2520]
        STR      R10,[R0, #+472]
        STR      R8,[R0, #+2524]
        STR      R10,[R0, #+476]
        STR      R2,[R0, #+2528]
        STR      R10,[R0, #+480]
        STR      R3,[R0, #+2532]
        STR      R12,[R0, #+1508]
        STR      R1,[R0, #+484]
        STR      R3,[R0, #+2536]
        STR      R1,[R0, #+488]
        STR      R8,[R0, #+2540]
        STR      R8,[R0, #+2544]
        STR      R1,[R0, #+496]
        STR      R3,[R0, #+2548]
        STR      R12,[R0, #+1524]
        STR      R1,[R0, #+500]
        STR      R2,[R0, #+2552]
        STR      R8,[R0, #+2556]
        STR      R11,[R0, #+508]
        STR      R11,[R0, #+512]
        STR      R3,[R0, #+2564]
        STR      R12,[R0, #+1540]
        STR      R1,[R0, #+516]
        STR      R3,[R0, #+2568]
        STR      R2,[R0, #+2572]
        STR      R7,[R0, #+1548]
        STR      R3,[R0, #+2576]
        STR      R12,[R0, #+1552]
        STR      R1,[R0, #+528]
        STR      R3,[R0, #+2580]
        STR      R12,[R0, #+1556]
        STR      R1,[R0, #+532]
        STR      R3,[R0, #+2584]
        STR      R5,[R0, #+536]
        STR      R3,[R0, #+2588]
        STR      R7,[R0, #+1564]
        STR      R5,[R0, #+540]
        STR      R3,[R0, #+2592]
        STR      LR,[R0, #+1568]
        STR      R5,[R0, #+544]
//  993   ticks[0x87] = 2; instruction[0x87] = nop6502; adrmode[0x87] = implied6502;
        STR      R3,[R0, #+2596]
        STR      R12,[R0, #+1572]
        STR      R1,[R0, #+548]
//  994   ticks[0x88] = 2; instruction[0x88] = dey6502; adrmode[0x88] = implied6502;
        STR      R3,[R0, #+2600]
        LDR      LR,??init6502_0+0xE0  ;; dey6502
//  995   ticks[0x89] = 2; instruction[0x89] = bit6502; adrmode[0x89] = immediate6502;
//  996   ticks[0x8a] = 2; instruction[0x8a] = txa6502; adrmode[0x8a] = implied6502;
//  997   ticks[0x8b] = 2; instruction[0x8b] = nop6502; adrmode[0x8b] = implied6502;
//  998   ticks[0x8c] = 4; instruction[0x8c] = sty6502; adrmode[0x8c] = abs6502;
//  999   ticks[0x8d] = 4; instruction[0x8d] = sta6502; adrmode[0x8d] = abs6502;
        STR      R7,[R0, #+1596]
        STR      LR,[R0, #+1576]
        LDR      LR,??init6502_0+0x60  ;; bit6502
// 1000   ticks[0x8e] = 4; instruction[0x8e] = stx6502; adrmode[0x8e] = abs6502;
// 1001   ticks[0x8f] = 2; instruction[0x8f] = nop6502; adrmode[0x8f] = implied6502;
// 1002   ticks[0x90] = 2; instruction[0x90] = bcc6502; adrmode[0x90] = relative6502;
// 1003   ticks[0x91] = 6; instruction[0x91] = sta6502; adrmode[0x91] = indy6502;
        STR      R7,[R0, #+1612]
        STR      LR,[R0, #+1580]
        LDR      LR,??init6502_0+0x3C  ;; immediate6502
// 1004   ticks[0x92] = 3; instruction[0x92] = sta6502; adrmode[0x92] = indzp6502;
        STR      R7,[R0, #+1616]
        STR      LR,[R0, #+556]
        LDR      LR,??init6502_0+0xE4  ;; txa6502
// 1005   ticks[0x93] = 2; instruction[0x93] = nop6502; adrmode[0x93] = implied6502;
// 1006   ticks[0x94] = 4; instruction[0x94] = sty6502; adrmode[0x94] = zpx6502;
// 1007   ticks[0x95] = 4; instruction[0x95] = sta6502; adrmode[0x95] = zpx6502;
        STR      R7,[R0, #+1628]
        STR      LR,[R0, #+1584]
        LDR      LR,??init6502_0+0xD8  ;; sty6502
// 1008   ticks[0x96] = 4; instruction[0x96] = stx6502; adrmode[0x96] = zpy6502;
// 1009   ticks[0x97] = 2; instruction[0x97] = nop6502; adrmode[0x97] = implied6502;
// 1010   ticks[0x98] = 2; instruction[0x98] = tya6502; adrmode[0x98] = implied6502;
// 1011   ticks[0x99] = 5; instruction[0x99] = sta6502; adrmode[0x99] = absy6502;
        STR      R7,[R0, #+1644]
        STR      LR,[R0, #+1592]
        LDR      LR,??init6502_0+0xDC  ;; stx6502
// 1012   ticks[0x9a] = 2; instruction[0x9a] = txs6502; adrmode[0x9a] = implied6502;
// 1013   ticks[0x9b] = 2; instruction[0x9b] = nop6502; adrmode[0x9b] = implied6502;
// 1014   ticks[0x9c] = 4; instruction[0x9c] = stz6502; adrmode[0x9c] = abs6502;
// 1015   ticks[0x9d] = 5; instruction[0x9d] = sta6502; adrmode[0x9d] = absx6502;
        STR      R7,[R0, #+1660]
// 1016   ticks[0x9e] = 5; instruction[0x9e] = stz6502; adrmode[0x9e] = absx6502;
        LDR      R7,??init6502_0+0xAC  ;; stz6502
        STR      LR,[R0, #+1600]
        LDR      LR,??init6502_0+0xE8  ;; bcc6502
        STR      R7,[R0, #+1664]
// 1017   ticks[0x9f] = 2; instruction[0x9f] = nop6502; adrmode[0x9f] = implied6502;
// 1018   ticks[0xa0] = 3; instruction[0xa0] = ldy6502; adrmode[0xa0] = immediate6502;
        LDR      R7,??init6502_0+0xEC  ;; ldy6502
        STR      LR,[R0, #+1608]
        LDR      LR,??init6502_0+0x28  ;; relative6502
        STR      R7,[R0, #+1672]
        LDR      R7,??init6502_0+0x3C  ;; immediate6502
        STR      LR,[R0, #+584]
        LDR      LR,??init6502_0+0x30  ;; indy6502
        STR      R7,[R0, #+648]
// 1019   ticks[0xa1] = 6; instruction[0xa1] = lda6502; adrmode[0xa1] = indx6502;
        LDR      R7,??init6502_0+0xF0  ;; lda6502
        STR      LR,[R0, #+588]
        LDR      LR,??init6502_0+0x34  ;; indzp6502
        STR      R1,[R0, #+552]
        STR      LR,[R0, #+592]
        LDR      LR,??init6502_0+0xD8  ;; sty6502
        STR      R3,[R0, #+2604]
        STR      LR,[R0, #+1624]
        LDR      LR,??init6502_0+0xDC  ;; stx6502
        STR      R3,[R0, #+2608]
        STR      LR,[R0, #+1632]
        LDR      LR,??init6502_0+0xF4  ;; zpy6502
        STR      R1,[R0, #+560]
        STR      LR,[R0, #+608]
        LDR      LR,??init6502_0+0xF8  ;; tya6502
        STR      R3,[R0, #+2612]
        STR      LR,[R0, #+1640]
        LDR      LR,??init6502_0+0x2C  ;; absy6502
        STR      R12,[R0, #+1588]
        STR      LR,[R0, #+620]
        LDR      LR,??init6502_0+0xFC  ;; txs6502
        STR      R1,[R0, #+564]
        STR      LR,[R0, #+1648]
        LDR      LR,??init6502_0+0xAC  ;; stz6502
        STR      R8,[R0, #+2616]
        STR      LR,[R0, #+1656]
        LDR      LR,??init6502_0  ;; indx6502
        STR      R9,[R0, #+568]
        STR      LR,[R0, #+652]
// 1020   ticks[0xa2] = 3; instruction[0xa2] = ldx6502; adrmode[0xa2] = immediate6502;
        LDR      LR,??init6502_0+0x100  ;; ldx6502
        STR      R8,[R0, #+2620]
        STR      LR,[R0, #+1680]
        LDR      LR,??init6502_0+0x3C  ;; immediate6502
        STR      R9,[R0, #+572]
        STR      LR,[R0, #+656]
// 1021   ticks[0xa3] = 2; instruction[0xa3] = nop6502; adrmode[0xa3] = implied6502;
// 1022   ticks[0xa4] = 3; instruction[0xa4] = ldy6502; adrmode[0xa4] = zp6502;
        LDR      LR,??init6502_0+0xEC  ;; ldy6502
        STR      R8,[R0, #+2624]
        STR      LR,[R0, #+1688]
// 1023   ticks[0xa5] = 3; instruction[0xa5] = lda6502; adrmode[0xa5] = zp6502;
// 1024   ticks[0xa6] = 3; instruction[0xa6] = ldx6502; adrmode[0xa6] = zp6502;
        LDR      LR,??init6502_0+0x100  ;; ldx6502
        STR      R9,[R0, #+576]
        STR      LR,[R0, #+1696]
// 1025   ticks[0xa7] = 2; instruction[0xa7] = nop6502; adrmode[0xa7] = implied6502;
// 1026   ticks[0xa8] = 2; instruction[0xa8] = tay6502; adrmode[0xa8] = implied6502;
        LDR      LR,??init6502_0+0x104  ;; tay6502
        STR      R3,[R0, #+2628]
        STR      R12,[R0, #+1604]
        STR      R1,[R0, #+580]
        STR      R3,[R0, #+2632]
        STR      R2,[R0, #+2636]
        STR      R4,[R0, #+2640]
        STR      R3,[R0, #+2644]
        STR      R12,[R0, #+1620]
        STR      R1,[R0, #+596]
        STR      R8,[R0, #+2648]
        STR      R10,[R0, #+600]
        STR      R8,[R0, #+2652]
        STR      R10,[R0, #+604]
        STR      R8,[R0, #+2656]
        STR      R3,[R0, #+2660]
        STR      R12,[R0, #+1636]
        STR      R1,[R0, #+612]
        STR      R3,[R0, #+2664]
        STR      R1,[R0, #+616]
        STR      R6,[R0, #+2668]
        STR      R3,[R0, #+2672]
        STR      R1,[R0, #+624]
        STR      R3,[R0, #+2676]
        STR      R12,[R0, #+1652]
        STR      R1,[R0, #+628]
        STR      R8,[R0, #+2680]
        STR      R9,[R0, #+632]
        STR      R6,[R0, #+2684]
        STR      R11,[R0, #+636]
        STR      R6,[R0, #+2688]
        STR      R11,[R0, #+640]
        STR      R3,[R0, #+2692]
        STR      R12,[R0, #+1668]
        STR      R1,[R0, #+644]
        STR      R4,[R0, #+2696]
        STR      R2,[R0, #+2700]
        STR      R7,[R0, #+1676]
        STR      R4,[R0, #+2704]
        STR      R3,[R0, #+2708]
        STR      R12,[R0, #+1684]
        STR      R1,[R0, #+660]
        STR      R4,[R0, #+2712]
        STR      R5,[R0, #+664]
        STR      R4,[R0, #+2716]
        STR      R7,[R0, #+1692]
        STR      R5,[R0, #+668]
        STR      R4,[R0, #+2720]
        STR      R5,[R0, #+672]
        STR      R3,[R0, #+2724]
        STR      R12,[R0, #+1700]
        STR      R1,[R0, #+676]
        STR      R3,[R0, #+2728]
        STR      LR,[R0, #+1704]
// 1027   ticks[0xa9] = 3; instruction[0xa9] = lda6502; adrmode[0xa9] = immediate6502;
        LDR      LR,??init6502_0+0x3C  ;; immediate6502
        STR      R1,[R0, #+680]
        STR      R4,[R0, #+2732]
        STR      R7,[R0, #+1708]
        STR      LR,[R0, #+684]
// 1028   ticks[0xaa] = 2; instruction[0xaa] = tax6502; adrmode[0xaa] = implied6502;
        LDR      LR,??init6502_0+0x108  ;; tax6502
// 1029   ticks[0xab] = 2; instruction[0xab] = nop6502; adrmode[0xab] = implied6502;
// 1030   ticks[0xac] = 4; instruction[0xac] = ldy6502; adrmode[0xac] = abs6502;
// 1031   ticks[0xad] = 4; instruction[0xad] = lda6502; adrmode[0xad] = abs6502;
        STR      R7,[R0, #+1724]
        STR      LR,[R0, #+1712]
        LDR      LR,??init6502_0+0xEC  ;; ldy6502
// 1032   ticks[0xae] = 4; instruction[0xae] = ldx6502; adrmode[0xae] = abs6502;
// 1033   ticks[0xaf] = 2; instruction[0xaf] = nop6502; adrmode[0xaf] = implied6502;
// 1034   ticks[0xb0] = 2; instruction[0xb0] = bcs6502; adrmode[0xb0] = relative6502;
// 1035   ticks[0xb1] = 5; instruction[0xb1] = lda6502; adrmode[0xb1] = indy6502;
        STR      R7,[R0, #+1740]
        STR      LR,[R0, #+1720]
        LDR      LR,??init6502_0+0x100  ;; ldx6502
// 1036   ticks[0xb2] = 3; instruction[0xb2] = lda6502; adrmode[0xb2] = indzp6502;
        STR      R7,[R0, #+1744]
        STR      LR,[R0, #+1728]
        LDR      LR,??init6502_0+0x10C  ;; bcs6502
// 1037   ticks[0xb3] = 2; instruction[0xb3] = nop6502; adrmode[0xb3] = implied6502;
// 1038   ticks[0xb4] = 4; instruction[0xb4] = ldy6502; adrmode[0xb4] = zpx6502;
// 1039   ticks[0xb5] = 4; instruction[0xb5] = lda6502; adrmode[0xb5] = zpx6502;
        STR      R7,[R0, #+1756]
        STR      LR,[R0, #+1736]
        LDR      LR,??init6502_0+0x28  ;; relative6502
// 1040   ticks[0xb6] = 4; instruction[0xb6] = ldx6502; adrmode[0xb6] = zpy6502;
// 1041   ticks[0xb7] = 2; instruction[0xb7] = nop6502; adrmode[0xb7] = implied6502;
// 1042   ticks[0xb8] = 2; instruction[0xb8] = clv6502; adrmode[0xb8] = implied6502;
// 1043   ticks[0xb9] = 4; instruction[0xb9] = lda6502; adrmode[0xb9] = absy6502;
        STR      R7,[R0, #+1772]
        STR      LR,[R0, #+712]
        LDR      LR,??init6502_0+0x30  ;; indy6502
// 1044   ticks[0xba] = 2; instruction[0xba] = tsx6502; adrmode[0xba] = implied6502;
// 1045   ticks[0xbb] = 2; instruction[0xbb] = nop6502; adrmode[0xbb] = implied6502;
// 1046   ticks[0xbc] = 4; instruction[0xbc] = ldy6502; adrmode[0xbc] = absx6502;
// 1047   ticks[0xbd] = 4; instruction[0xbd] = lda6502; adrmode[0xbd] = absx6502;
        STR      R7,[R0, #+1788]
// 1048   ticks[0xbe] = 4; instruction[0xbe] = ldx6502; adrmode[0xbe] = absy6502;
        LDR      R7,??init6502_0+0x100  ;; ldx6502
        STR      LR,[R0, #+716]
        LDR      LR,??init6502_0+0x34  ;; indzp6502
        STR      R7,[R0, #+1792]
        LDR      R7,??init6502_0+0x2C  ;; absy6502
        STR      LR,[R0, #+720]
        LDR      LR,??init6502_0+0xEC  ;; ldy6502
        STR      R7,[R0, #+768]
// 1049   ticks[0xbf] = 2; instruction[0xbf] = nop6502; adrmode[0xbf] = implied6502;
// 1050   ticks[0xc0] = 3; instruction[0xc0] = cpy6502; adrmode[0xc0] = immediate6502;
        LDR      R7,??init6502_0+0x110  ;; cpy6502
        STR      LR,[R0, #+1752]
        LDR      LR,??init6502_0+0x100  ;; ldx6502
        STR      R7,[R0, #+1800]
        LDR      R7,??init6502_0+0x3C  ;; immediate6502
        STR      LR,[R0, #+1760]
        LDR      LR,??init6502_0+0xF4  ;; zpy6502
        STR      R7,[R0, #+776]
// 1051   ticks[0xc1] = 6; instruction[0xc1] = cmp6502; adrmode[0xc1] = indx6502;
        LDR      R7,??init6502_0+0x114  ;; cmp6502
        STR      LR,[R0, #+736]
        LDR      LR,??init6502_0+0x118  ;; clv6502
        STR      R3,[R0, #+2736]
        STR      LR,[R0, #+1768]
        LDR      LR,??init6502_0+0x2C  ;; absy6502
        STR      R1,[R0, #+688]
        STR      LR,[R0, #+748]
        LDR      LR,??init6502_0+0x11C  ;; tsx6502
        STR      R3,[R0, #+2740]
        STR      LR,[R0, #+1776]
        LDR      LR,??init6502_0+0xEC  ;; ldy6502
        STR      R12,[R0, #+1716]
        STR      LR,[R0, #+1784]
        LDR      LR,??init6502_0  ;; indx6502
        STR      R1,[R0, #+692]
        STR      LR,[R0, #+780]
// 1052   ticks[0xc2] = 2; instruction[0xc2] = nop6502; adrmode[0xc2] = implied6502;
// 1053   ticks[0xc3] = 2; instruction[0xc3] = nop6502; adrmode[0xc3] = implied6502;
// 1054   ticks[0xc4] = 3; instruction[0xc4] = cpy6502; adrmode[0xc4] = zp6502;
        LDR      LR,??init6502_0+0x110  ;; cpy6502
        STR      R8,[R0, #+2744]
        STR      LR,[R0, #+1816]
// 1055   ticks[0xc5] = 3; instruction[0xc5] = cmp6502; adrmode[0xc5] = zp6502;
// 1056   ticks[0xc6] = 5; instruction[0xc6] = dec6502; adrmode[0xc6] = zp6502;
        LDR      LR,??init6502_0+0x120  ;; dec6502
        STR      R9,[R0, #+696]
        STR      LR,[R0, #+1824]
// 1057   ticks[0xc7] = 2; instruction[0xc7] = nop6502; adrmode[0xc7] = implied6502;
// 1058   ticks[0xc8] = 2; instruction[0xc8] = iny6502; adrmode[0xc8] = implied6502;
        LDR      LR,??init6502_0+0x124  ;; iny6502
        STR      R8,[R0, #+2748]
        STR      LR,[R0, #+1832]
// 1059   ticks[0xc9] = 3; instruction[0xc9] = cmp6502; adrmode[0xc9] = immediate6502;
        LDR      LR,??init6502_0+0x3C  ;; immediate6502
        STR      R9,[R0, #+700]
        STR      LR,[R0, #+812]
// 1060   ticks[0xca] = 2; instruction[0xca] = dex6502; adrmode[0xca] = implied6502;
        LDR      LR,??init6502_0+0x128  ;; dex6502
        STR      R8,[R0, #+2752]
        STR      R9,[R0, #+704]
        STR      R3,[R0, #+2756]
        STR      R12,[R0, #+1732]
        STR      R1,[R0, #+708]
        STR      R3,[R0, #+2760]
        STR      R6,[R0, #+2764]
        STR      R4,[R0, #+2768]
        STR      R3,[R0, #+2772]
        STR      R12,[R0, #+1748]
        STR      R1,[R0, #+724]
        STR      R8,[R0, #+2776]
        STR      R10,[R0, #+728]
        STR      R8,[R0, #+2780]
        STR      R10,[R0, #+732]
        STR      R8,[R0, #+2784]
        STR      R3,[R0, #+2788]
        STR      R12,[R0, #+1764]
        STR      R1,[R0, #+740]
        STR      R3,[R0, #+2792]
        STR      R1,[R0, #+744]
        STR      R8,[R0, #+2796]
        STR      R3,[R0, #+2800]
        STR      R1,[R0, #+752]
        STR      R3,[R0, #+2804]
        STR      R12,[R0, #+1780]
        STR      R1,[R0, #+756]
        STR      R8,[R0, #+2808]
        STR      R11,[R0, #+760]
        STR      R8,[R0, #+2812]
        STR      R11,[R0, #+764]
        STR      R8,[R0, #+2816]
        STR      R3,[R0, #+2820]
        STR      R12,[R0, #+1796]
        STR      R1,[R0, #+772]
        STR      R4,[R0, #+2824]
        STR      R2,[R0, #+2828]
        STR      R7,[R0, #+1804]
        STR      R3,[R0, #+2832]
        STR      R12,[R0, #+1808]
        STR      R1,[R0, #+784]
        STR      R3,[R0, #+2836]
        STR      R12,[R0, #+1812]
        STR      R1,[R0, #+788]
        STR      R4,[R0, #+2840]
        STR      R5,[R0, #+792]
        STR      R4,[R0, #+2844]
        STR      R7,[R0, #+1820]
        STR      R5,[R0, #+796]
        STR      R6,[R0, #+2848]
        STR      R5,[R0, #+800]
        STR      R3,[R0, #+2852]
        STR      R12,[R0, #+1828]
        STR      R1,[R0, #+804]
        STR      R3,[R0, #+2856]
        STR      R1,[R0, #+808]
        STR      R4,[R0, #+2860]
        STR      R7,[R0, #+1836]
        STR      R3,[R0, #+2864]
        STR      LR,[R0, #+1840]
        STR      R1,[R0, #+816]
// 1061   ticks[0xcb] = 2; instruction[0xcb] = nop6502; adrmode[0xcb] = implied6502;
        STR      R3,[R0, #+2868]
        STR      R12,[R0, #+1844]
        STR      R1,[R0, #+820]
// 1062   ticks[0xcc] = 4; instruction[0xcc] = cpy6502; adrmode[0xcc] = abs6502;
        LDR      LR,??init6502_0+0x110  ;; cpy6502
// 1063   ticks[0xcd] = 4; instruction[0xcd] = cmp6502; adrmode[0xcd] = abs6502;
        STR      R7,[R0, #+1852]
        STR      LR,[R0, #+1848]
// 1064   ticks[0xce] = 6; instruction[0xce] = dec6502; adrmode[0xce] = abs6502;
        LDR      LR,??init6502_0+0x120  ;; dec6502
// 1065   ticks[0xcf] = 2; instruction[0xcf] = nop6502; adrmode[0xcf] = implied6502;
// 1066   ticks[0xd0] = 2; instruction[0xd0] = bne6502; adrmode[0xd0] = relative6502;
// 1067   ticks[0xd1] = 5; instruction[0xd1] = cmp6502; adrmode[0xd1] = indy6502;
        STR      R7,[R0, #+1868]
        STR      LR,[R0, #+1856]
        LDR      LR,??init6502_0+0x12C  ;; bne6502
// 1068   ticks[0xd2] = 3; instruction[0xd2] = cmp6502; adrmode[0xd2] = indzp6502;
        STR      R7,[R0, #+1872]
        STR      LR,[R0, #+1864]
        LDR      LR,??init6502_0+0x28  ;; relative6502
// 1069   ticks[0xd3] = 2; instruction[0xd3] = nop6502; adrmode[0xd3] = implied6502;
// 1070   ticks[0xd4] = 2; instruction[0xd4] = nop6502; adrmode[0xd4] = implied6502;
// 1071   ticks[0xd5] = 4; instruction[0xd5] = cmp6502; adrmode[0xd5] = zpx6502;
        STR      R7,[R0, #+1884]
        STR      LR,[R0, #+840]
        LDR      LR,??init6502_0+0x30  ;; indy6502
// 1072   ticks[0xd6] = 6; instruction[0xd6] = dec6502; adrmode[0xd6] = zpx6502;
// 1073   ticks[0xd7] = 2; instruction[0xd7] = nop6502; adrmode[0xd7] = implied6502;
// 1074   ticks[0xd8] = 2; instruction[0xd8] = cld6502; adrmode[0xd8] = implied6502;
// 1075   ticks[0xd9] = 4; instruction[0xd9] = cmp6502; adrmode[0xd9] = absy6502;
        STR      R7,[R0, #+1900]
        STR      LR,[R0, #+844]
        LDR      LR,??init6502_0+0x34  ;; indzp6502
// 1076   ticks[0xda] = 3; instruction[0xda] = phx6502; adrmode[0xda] = implied6502;
// 1077   ticks[0xdb] = 2; instruction[0xdb] = nop6502; adrmode[0xdb] = implied6502;
// 1078   ticks[0xdc] = 2; instruction[0xdc] = nop6502; adrmode[0xdc] = implied6502;
// 1079   ticks[0xdd] = 4; instruction[0xdd] = cmp6502; adrmode[0xdd] = absx6502;
        STR      R7,[R0, #+1916]
        STR      LR,[R0, #+848]
        LDR      LR,??init6502_0+0x120  ;; dec6502
// 1080   ticks[0xde] = 7; instruction[0xde] = dec6502; adrmode[0xde] = absx6502;
        MOV      R7,#+7
        STR      LR,[R0, #+1888]
        LDR      LR,??init6502_0+0x130  ;; cld6502
        STR      R7,[R0, #+2944]
        LDR      R7,??init6502_0+0x120  ;; dec6502
        STR      LR,[R0, #+1896]
        LDR      LR,??init6502_0+0x2C  ;; absy6502
        STR      R7,[R0, #+1920]
// 1081   ticks[0xdf] = 2; instruction[0xdf] = nop6502; adrmode[0xdf] = implied6502;
// 1082   ticks[0xe0] = 3; instruction[0xe0] = cpx6502; adrmode[0xe0] = immediate6502;
        LDR      R7,??init6502_0+0x134  ;; cpx6502
        STR      LR,[R0, #+876]
        LDR      LR,??init6502_0+0x138  ;; phx6502
// 1083   ticks[0xe1] = 6; instruction[0xe1] = sbc6502; adrmode[0xe1] = indx6502;
// 1084   ticks[0xe2] = 2; instruction[0xe2] = nop6502; adrmode[0xe2] = implied6502;
// 1085   ticks[0xe3] = 2; instruction[0xe3] = nop6502; adrmode[0xe3] = implied6502;
// 1086   ticks[0xe4] = 3; instruction[0xe4] = cpx6502; adrmode[0xe4] = zp6502;
        STR      R5,[R0, #+920]
        STR      LR,[R0, #+1904]
        LDR      LR,??init6502_0  ;; indx6502
// 1087   ticks[0xe5] = 3; instruction[0xe5] = sbc6502; adrmode[0xe5] = zp6502;
        STR      R5,[R0, #+924]
// 1088   ticks[0xe6] = 5; instruction[0xe6] = inc6502; adrmode[0xe6] = zp6502;
        STR      R5,[R0, #+928]
// 1089   ticks[0xe7] = 2; instruction[0xe7] = nop6502; adrmode[0xe7] = implied6502;
// 1090   ticks[0xe8] = 2; instruction[0xe8] = inx6502; adrmode[0xe8] = implied6502;
        LDR      R5,??init6502_0+0x13C  ;; inx6502
        STR      R7,[R0, #+1928]
        LDR      R7,??init6502_0+0x3C  ;; immediate6502
        STR      LR,[R0, #+908]
        LDR      LR,??init6502_0+0x134  ;; cpx6502
        STR      R5,[R0, #+1960]
// 1091   ticks[0xe9] = 3; instruction[0xe9] = sbc6502; adrmode[0xe9] = immediate6502;
        LDR      R5,??init6502_0+0x3C  ;; immediate6502
        STR      R7,[R0, #+904]
        LDR      R7,??init6502_0+0x140  ;; sbc6502
        STR      LR,[R0, #+1944]
        LDR      LR,??init6502_0+0x144  ;; inc6502
        STR      R5,[R0, #+940]
// 1092   ticks[0xea] = 2; instruction[0xea] = nop6502; adrmode[0xea] = implied6502;
// 1093   ticks[0xeb] = 2; instruction[0xeb] = nop6502; adrmode[0xeb] = implied6502;
// 1094   ticks[0xec] = 4; instruction[0xec] = cpx6502; adrmode[0xec] = abs6502;
        LDR      R5,??init6502_0+0x134  ;; cpx6502
        STR      R8,[R0, #+2872]
        STR      R9,[R0, #+824]
        STR      R8,[R0, #+2876]
        STR      R9,[R0, #+828]
        STR      R2,[R0, #+2880]
        STR      R9,[R0, #+832]
        STR      R3,[R0, #+2884]
        STR      R12,[R0, #+1860]
        STR      R1,[R0, #+836]
        STR      R3,[R0, #+2888]
        STR      R6,[R0, #+2892]
        STR      R4,[R0, #+2896]
        STR      R3,[R0, #+2900]
        STR      R12,[R0, #+1876]
        STR      R1,[R0, #+852]
        STR      R3,[R0, #+2904]
        STR      R12,[R0, #+1880]
        STR      R1,[R0, #+856]
        STR      R8,[R0, #+2908]
        STR      R10,[R0, #+860]
        STR      R2,[R0, #+2912]
        STR      R10,[R0, #+864]
        STR      R3,[R0, #+2916]
        STR      R12,[R0, #+1892]
        STR      R1,[R0, #+868]
        STR      R3,[R0, #+2920]
        STR      R1,[R0, #+872]
        STR      R8,[R0, #+2924]
        STR      R4,[R0, #+2928]
        STR      R1,[R0, #+880]
        STR      R3,[R0, #+2932]
        STR      R12,[R0, #+1908]
        STR      R1,[R0, #+884]
        STR      R3,[R0, #+2936]
        STR      R12,[R0, #+1912]
        STR      R1,[R0, #+888]
        STR      R8,[R0, #+2940]
        STR      R11,[R0, #+892]
        STR      R11,[R0, #+896]
        STR      R3,[R0, #+2948]
        STR      R12,[R0, #+1924]
        STR      R1,[R0, #+900]
        STR      R4,[R0, #+2952]
        STR      R2,[R0, #+2956]
        STR      R7,[R0, #+1932]
        STR      R3,[R0, #+2960]
        STR      R12,[R0, #+1936]
        STR      R1,[R0, #+912]
        STR      R3,[R0, #+2964]
        STR      R12,[R0, #+1940]
        STR      R1,[R0, #+916]
        STR      R4,[R0, #+2968]
        STR      R4,[R0, #+2972]
        STR      R7,[R0, #+1948]
        STR      R6,[R0, #+2976]
        STR      LR,[R0, #+1952]
        STR      R3,[R0, #+2980]
        STR      R12,[R0, #+1956]
        STR      R1,[R0, #+932]
        STR      R3,[R0, #+2984]
        STR      R1,[R0, #+936]
        STR      R4,[R0, #+2988]
        STR      R7,[R0, #+1964]
        STR      R3,[R0, #+2992]
        STR      R12,[R0, #+1968]
        STR      R1,[R0, #+944]
        STR      R3,[R0, #+2996]
        STR      R12,[R0, #+1972]
        STR      R1,[R0, #+948]
        STR      R8,[R0, #+3000]
        STR      R5,[R0, #+1976]
        STR      R9,[R0, #+952]
// 1095   ticks[0xed] = 4; instruction[0xed] = sbc6502; adrmode[0xed] = abs6502;
        STR      R8,[R0, #+3004]
        STR      R7,[R0, #+1980]
        STR      R9,[R0, #+956]
// 1096   ticks[0xee] = 6; instruction[0xee] = inc6502; adrmode[0xee] = abs6502;
        STR      R2,[R0, #+3008]
        STR      LR,[R0, #+1984]
        STR      R9,[R0, #+960]
// 1097   ticks[0xef] = 2; instruction[0xef] = nop6502; adrmode[0xef] = implied6502;
        STR      R3,[R0, #+3012]
        STR      R12,[R0, #+1988]
// 1098   ticks[0xf0] = 2; instruction[0xf0] = beq6502; adrmode[0xf0] = relative6502;
        LDR      R5,??init6502_0+0x148  ;; beq6502
// 1099   ticks[0xf1] = 5; instruction[0xf1] = sbc6502; adrmode[0xf1] = indy6502;
// 1100   ticks[0xf2] = 3; instruction[0xf2] = sbc6502; adrmode[0xf2] = indzp6502;
// 1101   ticks[0xf3] = 2; instruction[0xf3] = nop6502; adrmode[0xf3] = implied6502;
// 1102   ticks[0xf4] = 2; instruction[0xf4] = nop6502; adrmode[0xf4] = implied6502;
// 1103   ticks[0xf5] = 4; instruction[0xf5] = sbc6502; adrmode[0xf5] = zpx6502;
// 1104   ticks[0xf6] = 6; instruction[0xf6] = inc6502; adrmode[0xf6] = zpx6502;
        STR      R2,[R0, #+3040]
// 1105   ticks[0xf7] = 2; instruction[0xf7] = nop6502; adrmode[0xf7] = implied6502;
// 1106   ticks[0xf8] = 2; instruction[0xf8] = sed6502; adrmode[0xf8] = implied6502;
        LDR      R2,??init6502_0+0x14C  ;; sed6502
        STR      R5,[R0, #+1992]
        LDR      R5,??init6502_0+0x28  ;; relative6502
        STR      R2,[R0, #+2024]
// 1107   ticks[0xf9] = 4; instruction[0xf9] = sbc6502; adrmode[0xf9] = absy6502;
        LDR      R2,??init6502_0+0x2C  ;; absy6502
        STR      R5,[R0, #+968]
        LDR      R5,??init6502_0+0x30  ;; indy6502
        STR      R4,[R0, #+3024]
        LDR      R4,??init6502_0+0x34  ;; indzp6502
        STR      R2,[R0, #+1004]
// 1108   ticks[0xfa] = 4; instruction[0xfa] = plx6502; adrmode[0xfa] = implied6502;
        LDR      R2,??init6502_0+0x150  ;; plx6502
        STR      R1,[R0, #+964]
        STR      R3,[R0, #+3016]
        STR      R6,[R0, #+3020]
        STR      R7,[R0, #+1996]
        STR      R5,[R0, #+972]
        STR      R7,[R0, #+2000]
        STR      R4,[R0, #+976]
        STR      R3,[R0, #+3028]
        STR      R12,[R0, #+2004]
        STR      R1,[R0, #+980]
        STR      R3,[R0, #+3032]
        STR      R12,[R0, #+2008]
        STR      R1,[R0, #+984]
        STR      R8,[R0, #+3036]
        STR      R7,[R0, #+2012]
        STR      R10,[R0, #+988]
        STR      LR,[R0, #+2016]
        STR      R10,[R0, #+992]
        STR      R3,[R0, #+3044]
        STR      R12,[R0, #+2020]
        STR      R1,[R0, #+996]
        STR      R3,[R0, #+3048]
        STR      R1,[R0, #+1000]
        STR      R8,[R0, #+3052]
        STR      R7,[R0, #+2028]
        STR      R8,[R0, #+3056]
        STR      R2,[R0, #+2032]
        STR      R1,[R0, #+1008]
// 1109   ticks[0xfb] = 2; instruction[0xfb] = nop6502; adrmode[0xfb] = implied6502;
        STR      R3,[R0, #+3060]
        STR      R12,[R0, #+2036]
        STR      R1,[R0, #+1012]
// 1110   ticks[0xfc] = 2; instruction[0xfc] = nop6502; adrmode[0xfc] = implied6502;
        STR      R3,[R0, #+3064]
        STR      R12,[R0, #+2040]
        STR      R1,[R0, #+1016]
// 1111   ticks[0xfd] = 4; instruction[0xfd] = sbc6502; adrmode[0xfd] = absx6502;
        STR      R8,[R0, #+3068]
        STR      R7,[R0, #+2044]
        STR      R11,[R0, #+1020]
// 1112   ticks[0xfe] = 7; instruction[0xfe] = inc6502; adrmode[0xfe] = absx6502;
        MOV      R2,#+7
        STR      R2,[R0, #+3072]
        STR      LR,[R0, #+2048]
        STR      R11,[R0, #+1024]
// 1113   ticks[0xff] = 2; instruction[0xff] = nop6502; adrmode[0xff] = implied6502;
        STR      R3,[R0, #+3076]
        STR      R12,[R0, #+2052]
        STR      R1,[R0, #+1028]
// 1114 }
        POP      {R4-R11,PC}      ;; return
        DATA
??init6502_0:
        DC32     indx6502
        DC32     pc_reg
        DC32     nop6502
        DC32     php6502
        DC32     bpl6502
        DC32     ora6502
        DC32     tsb6502
        DC32     zp6502
        DC32     asl6502
        DC32     clc6502
        DC32     relative6502
        DC32     absy6502
        DC32     indy6502
        DC32     indzp6502
        DC32     brk6502
        DC32     immediate6502
        DC32     trb6502
        DC32     ina6502
        DC32     implied6502
        DC32     asla6502
        DC32     abs6502
        DC32     zpx6502
        DC32     absx6502
        DC32     jsr6502
        DC32     bit6502
        DC32     and6502
        DC32     rol6502
        DC32     plp6502
        DC32     rola6502
        DC32     bmi6502
        DC32     rti6502
        DC32     sec6502
        DC32     eor6502
        DC32     dea6502
        DC32     lsr6502
        DC32     pha6502
        DC32     lsra6502
        DC32     jmp6502
        DC32     bvc6502
        DC32     rts6502
        DC32     cli6502
        DC32     adc6502
        DC32     phy6502
        DC32     stz6502
        DC32     ror6502
        DC32     pla6502
        DC32     rora6502
        DC32     indirect6502
        DC32     bvs6502
        DC32     bra6502
        DC32     sta6502
        DC32     sei6502
        DC32     ply6502
        DC32     indabsx6502
        DC32     sty6502
        DC32     stx6502
        DC32     dey6502
        DC32     txa6502
        DC32     bcc6502
        DC32     ldy6502
        DC32     lda6502
        DC32     zpy6502
        DC32     tya6502
        DC32     txs6502
        DC32     ldx6502
        DC32     tay6502
        DC32     tax6502
        DC32     bcs6502
        DC32     cpy6502
        DC32     cmp6502
        DC32     clv6502
        DC32     tsx6502
        DC32     dec6502
        DC32     iny6502
        DC32     dex6502
        DC32     bne6502
        DC32     cld6502
        DC32     cpx6502
        DC32     phx6502
        DC32     inx6502
        DC32     sbc6502
        DC32     inc6502
        DC32     beq6502
        DC32     sed6502
        DC32     plx6502
        CFI EndBlock cfiBlock173

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock174 Using cfiCommon0
        CFI NoFunction
        THUMB
??reset6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock174
        REQUIRE reset6502
// 1115 
// 1116 /* Reset CPU */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock175 Using cfiCommon1
        CFI Function reset6502
        ARM
// 1117 void reset6502()
// 1118 {
// 1119   A = X = Y = P = 0;
reset6502:
        LDR      R0,??DataTable150  ;; pc_reg
// 1120   P |= 0x20;
// 1121   S = 0xff;
// 1122   PC = get6502memory( 0xfffc & addrmask );
        LDR      R2,??DataTable151  ;; gameImage
        MOV      R1,#+0
        STRB     R1,[R0, #+3094]
        STRB     R1,[R0, #+3093]
        LDR      R2,[R2, #+0]
        STRB     R1,[R0, #+3092]
        MOV      R1,#+32
        STRB     R1,[R0, #+3095]
        MOV      R1,#+255
        STRB     R1,[R0, #+3096]
        LDR      R1,??DataTable149  ;; addrmask
        MOV      R3,#+252
        LDRH     R1,[R1, #+0]
        ORR      R3,R3,#0xFF00
// 1123   PC |= get6502memory( 0xfffd & addrmask ) << 8;
        MOV      R12,#+253
        AND      R3,R3,R1
        LDRB     R3,[R3, +R2]
        ORR      R12,R12,#0xFF00
        AND      R1,R12,R1
        STRH     R3,[R0, #+0]
        LDRB     R1,[R1, +R2]
        ORR      R1,R3,R1, LSL #+8
        STRH     R1,[R0, #+0]
// 1124 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock175

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock176 Using cfiCommon0
        CFI NoFunction
        THUMB
??nmi6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock176
        REQUIRE nmi6502
// 1125 
// 1126 /* Non maskerable interrupt */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock177 Using cfiCommon1
        CFI Function nmi6502
        ARM
// 1127 void nmi6502()
// 1128 {
nmi6502:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
// 1129   put6502memory( 0x0100 + S--, ( BYTE )( PC >> 8 ) );
        LDR      R4,??DataTable150  ;; pc_reg
        LDR      R6,??DataTable151  ;; gameImage
        LDRB     R0,[R4, #+3096]
        MOV      R5,#+32
        ORR      R5,R5,#0x4000
        SUB      R1,R0,#+1
        STRB     R1,[R4, #+3096]
        LDRH     R1,[R4, #+0]
        ADD      R0,R0,#+256
        MOV      R7,#+1
        LSR      R1,R1,#+8
        ORR      R7,R7,#0x8000
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??nmi6502_0
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??nmi6502_0
        CMP      R0,R5
        BCS      ??nmi6502_0
        _BLF     APUWrite,??APUWrite??rA
// 1130   put6502memory( 0x0100 + S--, ( BYTE )( PC & 0xff ) );
??nmi6502_0:
        LDRB     R0,[R4, #+3096]
        SUB      R1,R0,#+1
        STRB     R1,[R4, #+3096]
        LDRH     R1,[R4, #+0]
        ADD      R0,R0,#+256
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??nmi6502_1
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??nmi6502_1
        CMP      R0,R5
        BCS      ??nmi6502_1
        AND      R1,R1,#0xFF
        _BLF     APUWrite,??APUWrite??rA
// 1131   put6502memory( 0x0100 + S--, P );
??nmi6502_1:
        LDRB     R0,[R4, #+3096]
        SUB      R1,R0,#+1
        STRB     R1,[R4, #+3096]
        LDRB     R1,[R4, #+3095]
        ADD      R0,R0,#+256
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??nmi6502_2
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??nmi6502_2
        CMP      R0,R5
        BCS      ??nmi6502_2
        _BLF     APUWrite,??APUWrite??rA
// 1132   P |= 0x04;
??nmi6502_2:
        LDRB     R0,[R4, #+3095]
// 1133   PC = get6502memory( 0xfffa & addrmask );
        LDR      R1,[R6, #+0]
        MOV      R2,#+250
        ORR      R0,R0,#0x4
        STRB     R0,[R4, #+3095]
        LDR      R0,??DataTable149  ;; addrmask
        ORR      R2,R2,#0xFF00
        LDRH     R0,[R0, #+0]
// 1134   PC |= get6502memory( 0xfffb & addrmask ) << 8;
        MOV      R3,#+251
        ORR      R3,R3,#0xFF00
        AND      R2,R2,R0
        LDRB     R2,[R2, +R1]
        AND      R0,R3,R0
        STRH     R2,[R4, #+0]
        LDRB     R0,[R0, +R1]
        ORR      R0,R2,R0, LSL #+8
        STRH     R0,[R4, #+0]
// 1135 }
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock177

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock178 Using cfiCommon0
        CFI NoFunction
        THUMB
??irq6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock178
        REQUIRE irq6502
// 1136 
// 1137 /* Maskerable Interrupt */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock179 Using cfiCommon1
        CFI Function irq6502
        ARM
// 1138 void irq6502()
// 1139 {
irq6502:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
// 1140   put6502memory( 0x0100 + S--, ( BYTE )( PC >> 8 ) );
        LDR      R4,??DataTable150  ;; pc_reg
        LDR      R6,??DataTable151  ;; gameImage
        LDRB     R0,[R4, #+3096]
        MOV      R5,#+32
        ORR      R5,R5,#0x4000
        SUB      R1,R0,#+1
        STRB     R1,[R4, #+3096]
        LDRH     R1,[R4, #+0]
        ADD      R0,R0,#+256
        MOV      R7,#+1
        LSR      R1,R1,#+8
        ORR      R7,R7,#0x8000
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??irq6502_0
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??irq6502_0
        CMP      R0,R5
        BCS      ??irq6502_0
        _BLF     APUWrite,??APUWrite??rA
// 1141   put6502memory( 0x0100 + S--, ( BYTE )( PC & 0xff ) );
??irq6502_0:
        LDRB     R0,[R4, #+3096]
        SUB      R1,R0,#+1
        STRB     R1,[R4, #+3096]
        LDRH     R1,[R4, #+0]
        ADD      R0,R0,#+256
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??irq6502_1
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??irq6502_1
        CMP      R0,R5
        BCS      ??irq6502_1
        AND      R1,R1,#0xFF
        _BLF     APUWrite,??APUWrite??rA
// 1142   put6502memory( 0x0100 + S--, P );
??irq6502_1:
        LDRB     R0,[R4, #+3096]
        SUB      R1,R0,#+1
        STRB     R1,[R4, #+3096]
        LDRB     R1,[R4, #+3095]
        ADD      R0,R0,#+256
        MOV      R0,R0, LSL #+16
        MOV      R0,R0, LSR #+16
        CMP      R0,R7
        BCS      ??irq6502_2
        LDR      R3,[R6, #+0]
        CMP      R0,#+16384
        STRB     R1,[R0, +R3]
        BCC      ??irq6502_2
        CMP      R0,R5
        BCS      ??irq6502_2
        _BLF     APUWrite,??APUWrite??rA
// 1143   P |= 0x04;
??irq6502_2:
        LDRB     R0,[R4, #+3095]
// 1144   PC = get6502memory( 0xfffe & addrmask );
        LDR      R1,[R6, #+0]
        MOV      R2,#+254
        ORR      R0,R0,#0x4
        STRB     R0,[R4, #+3095]
        LDR      R0,??DataTable149  ;; addrmask
        ORR      R2,R2,#0xFF00
        LDRH     R0,[R0, #+0]
        AND      R2,R2,R0
        LDRB     R2,[R2, +R1]
        STRH     R2,[R4, #+0]
// 1145   PC |= get6502memory( 0xffff & addrmask ) << 8;
        LDRB     R0,[R0, +R1]
        ORR      R0,R2,R0, LSL #+8
        STRH     R0,[R4, #+0]
// 1146 }
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock179

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable149:
        DC32     addrmask

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock180 Using cfiCommon0
        CFI NoFunction
        THUMB
??exec6502??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock180
        REQUIRE exec6502
// 1147 
// 1148 
// 1149 /* Execute Instruction */
// 1150 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock181 Using cfiCommon1
        CFI Function exec6502
        ARM
// 1151 void exec6502( int timerTicks )
// 1152 {
exec6502:
        PUSH     {R4-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
        MOV      R4,R0
        CMP      R4,#+1
        POPLT    {R4-R7,PC}
        LDR      R6,??DataTable150  ;; pc_reg
        LDR      R7,??DataTable151  ;; gameImage
        MOV      R5,#+0
// 1153   while ( timerTicks > 0 )
// 1154   {
// 1155     // fetch instruction
// 1156     opcode = gameImage[PC++];
??exec6502_0:
        LDRH     R0,[R6, #+0]
        LDR      R2,[R7, #+0]
        LDRB     R1,[R0, +R2]
        ADD      R0,R0,#+1
        STRH     R0,[R6, #+0]
        STRB     R1,[R6, #+3097]
// 1157 
// 1158     // execute instruction
// 1159     instruction[opcode] ();
        ADD      R0,R6,R1, LSL #+2
        LDR      R0,[R0, #+1032]
        BLX      R0
// 1160 
// 1161     // calculate clock cycles
// 1162     clockticks6502 += ticks[opcode];
// 1163     timerTicks -= clockticks6502;
        LDRB     R1,[R6, #+3097]
        LDR      R0,[R6, #+3080]
        SUB      R0,R4,R0
        ADD      R1,R6,R1, LSL #+2
        LDR      R1,[R1, #+2056]
// 1164     clockticks6502 = 0;
        STR      R5,[R6, #+3080]
        SUB      R4,R0,R1
// 1165   }
        CMP      R4,#+1
        BGE      ??exec6502_0
// 1166 }
        POP      {R4-R7,PC}       ;; return
        CFI EndBlock cfiBlock181

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable150:
        DC32     pc_reg

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable151:
        DC32     gameImage

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock182 Using cfiCommon1
        CFI NoFunction
        ARM
??APUWrite??rA:
        LDR      R12,??Subroutine91_0  ;; APUWrite
        BX       R12
        DATA
??Subroutine91_0:
        DC32     APUWrite
        CFI EndBlock cfiBlock182

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        END
// 1167 
// 1168 
// 
// 12 344 bytes in segment CODE
//  3 099 bytes in segment DATA_Z
//     12 bytes in segment INITTAB
// 
// 11 968 bytes of CODE memory (+ 388 bytes shared)
//  3 099 bytes of DATA memory
//
//Errors: none
//Warnings: none
