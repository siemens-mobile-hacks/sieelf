##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    14/Feb/2012  15:39:18 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDE #
#                       C\AAC_FILE (18).c                                    #
#    Command line    =  "D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACD #
#                       EC\AAC_FILE (18).c" -D NDEBUG -lC                    #
#                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\ -lA D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\ #
#                       Release\List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player #
#                       \Player\Release\Obj\ -s9 --cpu_mode arm --endian     #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None --dlib_config "D:\Program              #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude       #
#                       swilib.h -I "D:\Program Files\IAR\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=16                                #
#    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\AAC_FILE (18).lst                                #
#    Object file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\O #
#                       bj\AAC_FILE (18).r79                                 #
#                                                                            #
#                                                                            #
##############################################################################

D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDEC\AAC_FILE (18).c
      1          /* ***** BEGIN LICENSE BLOCK *****  
      2           * Source last modified: $Id: fft.c,v 1.1 2005/02/26 01:47:34 jrecker Exp $ 
      3           *   
      4           * Portions Copyright (c) 1995-2005 RealNetworks, Inc. All Rights Reserved.  
      5           *       
      6           * The contents of this file, and the files included with this file, 
      7           * are subject to the current version of the RealNetworks Public 
      8           * Source License (the "RPSL") available at 
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed 
     10           * the file under the current version of the RealNetworks Community 
     11           * Source License (the "RCSL") available at 
     12           * http://www.helixcommunity.org/content/rcsl, in which case the RCSL 
     13           * will apply. You may also obtain the license terms directly from 
     14           * RealNetworks.  You may not use this file except in compliance with 
     15           * the RPSL or, if you have a valid RCSL with RealNetworks applicable 
     16           * to this file, the RCSL.  Please see the applicable RPSL or RCSL for 
     17           * the rights, obligations and limitations governing use of the 
     18           * contents of the file. 
     19           *   
     20           * This file is part of the Helix DNA Technology. RealNetworks is the 
     21           * developer of the Original Code and owns the copyrights in the 
     22           * portions it created. 
     23           *   
     24           * This file, and the files included with this file, is distributed 
     25           * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY 
     26           * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS 
     27           * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES 
     28           * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET 
     29           * ENJOYMENT OR NON-INFRINGEMENT. 
     30           *  
     31           * Technology Compatibility Kit Test Suite(s) Location:  
     32           *    http://www.helixcommunity.org/content/tck  
     33           *  
     34           * Contributor(s):  
     35           *   
     36           * ***** END LICENSE BLOCK ***** */  
     37          
     38          /**************************************************************************************
     39           * Fixed-point HE-AAC decoder
     40           * Jon Recker (jrecker@real.com), Ken Cooke (kenc@real.com)
     41           * February 2005
     42           *
     43           * fft.c - Ken's optimized radix-4 DIT FFT, optional radix-8 first pass for odd log2(N)
     44           **************************************************************************************/
     45          
     46          #include "coder_aac.h"
     47          #include "assembly_aac.h"
     48          
     49          #define NUM_FFT_SIZES	2

   \                                 In segment DATA_C, align 4, align-sorted
     50          static const int nfftTab[NUM_FFT_SIZES] =		{64, 512};
   \                     nfftTab:
   \   00000000   400000000002       DC32 64, 512
   \              0000        
   \   00000008   060000000900       DC32 6, 9
   \              0000        
     51          static const int nfftlog2Tab[NUM_FFT_SIZES] =	{6, 9};
     52          
     53          #define SQRT1_2 0x5a82799a	/* sqrt(1/2) in Q31 */
     54          
     55          #define swapcplx(p0,p1) \
     56          	t = p0; t1 = *(&(p0)+1); p0 = p1; *(&(p0)+1) = *(&(p1)+1); p1 = t; *(&(p1)+1) = t1
     57          
     58          /**************************************************************************************
     59           * Function:    BitReverse
     60           *
     61           * Description: Ken's fast in-place bit reverse, using super-small table
     62           *
     63           * Inputs:      buffer of samples
     64           *              table index (for transform size)
     65           *
     66           * Outputs:     bit-reversed samples in same buffer
     67           *
     68           * Return:      none
     69           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     70          static void BitReverse(int *inout, int tabidx)
     71          {
     72              int *part0, *part1;
     73          	int a,b, t,t1;
     74          	const unsigned char* tab = bitrevtab + bitrevtabOffset[tabidx];
   \                     BitReverse:
   \   00000000   04219FE5           LDR      R2,??BitReverse_0  ;; raac_bitrevtabOffset
   \   00000004   04319FE5           LDR      R3,??BitReverse_0+0x4  ;; raac_bitrevtab
   \   00000008   F0012DE9           PUSH     {R4-R8}
     75          	int nbits = nfftlog2Tab[tabidx];
     76          
     77          	part0 = inout;
     78              part1 = inout + (1 << nbits);
   \   0000000C   00419FE5           LDR      R4,??BitReverse_0+0x8  ;; nfftTab
   \   00000010   012192E7           LDR      R2,[R2, +R1, LSL #+2]
   \   00000014   011184E0           ADD      R1,R4,R1, LSL #+2
   \   00000018   081091E5           LDR      R1,[R1, #+8]
   \   0000001C   032082E0           ADD      R2,R2,R3
   \   00000020   0130A0E3           MOV      R3,#+1
   \   00000024   1311A0E1           LSL      R1,R3,R1
   \   00000028   011180E0           ADD      R1,R0,R1, LSL #+2
   \   0000002C   240000EA           B        ??BitReverse_1
     79          	
     80          	while ((a = *tab++) != 0) {
     81                  b = *tab++;
   \                     ??BitReverse_2:
   \   00000030   ........           LDRB     R5,[R2], #+1
     82          
     83                  swapcplx(part0[4*a+0], part0[4*b+0]);	/* 0xxx0 <-> 0yyy0 */
   \   00000034   0C4280E0           ADD      R4,R0,R12, LSL #+4
   \   00000038   006094E5           LDR      R6,[R4, #+0]
   \   0000003C   047094E5           LDR      R7,[R4, #+4]
   \   00000040   053280E0           ADD      R3,R0,R5, LSL #+4
   \   00000044   008093E5           LDR      R8,[R3, #+0]
     84                  swapcplx(part0[4*a+2], part1[4*b+0]);	/* 0xxx1 <-> 1yyy0 */
   \   00000048   055281E0           ADD      R5,R1,R5, LSL #+4
   \   0000004C   008084E5           STR      R8,[R4, #+0]
   \   00000050   048093E5           LDR      R8,[R3, #+4]
   \   00000054   048084E5           STR      R8,[R4, #+4]
   \   00000058   006083E5           STR      R6,[R3, #+0]
   \   0000005C   047083E5           STR      R7,[R3, #+4]
   \   00000060   008095E5           LDR      R8,[R5, #+0]
   \   00000064   086094E5           LDR      R6,[R4, #+8]
   \   00000068   0C7094E5           LDR      R7,[R4, #+12]
   \   0000006C   088084E5           STR      R8,[R4, #+8]
   \   00000070   048095E5           LDR      R8,[R5, #+4]
   \   00000074   0C8084E5           STR      R8,[R4, #+12]
   \   00000078   006085E5           STR      R6,[R5, #+0]
   \   0000007C   047085E5           STR      R7,[R5, #+4]
     85                  swapcplx(part1[4*a+0], part0[4*b+2]);	/* 1xxx0 <-> 0yyy1 */
   \   00000080   088093E5           LDR      R8,[R3, #+8]
   \   00000084   0C4281E0           ADD      R4,R1,R12, LSL #+4
   \   00000088   006094E5           LDR      R6,[R4, #+0]
   \   0000008C   047094E5           LDR      R7,[R4, #+4]
   \   00000090   008084E5           STR      R8,[R4, #+0]
   \   00000094   0C8093E5           LDR      R8,[R3, #+12]
   \   00000098   048084E5           STR      R8,[R4, #+4]
   \   0000009C   086083E5           STR      R6,[R3, #+8]
   \   000000A0   0C7083E5           STR      R7,[R3, #+12]
     86                  swapcplx(part1[4*a+2], part1[4*b+2]);	/* 1xxx1 <-> 1yyy1 */
   \   000000A4   087095E5           LDR      R7,[R5, #+8]
   \   000000A8   083094E5           LDR      R3,[R4, #+8]
   \   000000AC   0C6094E5           LDR      R6,[R4, #+12]
   \   000000B0   087084E5           STR      R7,[R4, #+8]
   \   000000B4   0C7095E5           LDR      R7,[R5, #+12]
   \   000000B8   0C7084E5           STR      R7,[R4, #+12]
   \   000000BC   083085E5           STR      R3,[R5, #+8]
   \   000000C0   0C6085E5           STR      R6,[R5, #+12]
     87              }
   \                     ??BitReverse_1:
   \   000000C4   ........           LDRB     R12,[R2], #+1
   \   000000C8   00005CE3           CMP      R12,#+0
   \   000000CC   D7FFFF1A           BNE      ??BitReverse_2
     88          
     89              do {
     90                  swapcplx(part0[4*a+2], part1[4*a+0]);	/* 0xxx1 <-> 1xxx0 */
   \                     ??BitReverse_3:
   \   000000D0   0C5281E0           ADD      R5,R1,R12, LSL #+4
   \   000000D4   007095E5           LDR      R7,[R5, #+0]
   \   000000D8   0C4280E0           ADD      R4,R0,R12, LSL #+4
   \   000000DC   083094E5           LDR      R3,[R4, #+8]
   \   000000E0   0C6094E5           LDR      R6,[R4, #+12]
   \   000000E4   087084E5           STR      R7,[R4, #+8]
   \   000000E8   047095E5           LDR      R7,[R5, #+4]
   \   000000EC   0C7084E5           STR      R7,[R4, #+12]
   \   000000F0   003085E5           STR      R3,[R5, #+0]
   \   000000F4   046085E5           STR      R6,[R5, #+4]
     91              } while ((a = *tab++) != 0);
   \   000000F8   ........           LDRB     R12,[R2], #+1
   \   000000FC   00005CE3           CMP      R12,#+0
   \   00000100   F2FFFF1A           BNE      ??BitReverse_3
     92          }
   \   00000104   F001BDE8           POP      {R4-R8}
   \   00000108   1EFF2FE1           BX       LR               ;; return
   \                     ??BitReverse_0:
   \   0000010C   ........           DC32     raac_bitrevtabOffset
   \   00000110   ........           DC32     raac_bitrevtab
   \   00000114   ........           DC32     nfftTab
     93          
     94          /**************************************************************************************
     95           * Function:    R4FirstPass
     96           *
     97           * Description: radix-4 trivial pass for decimation-in-time FFT
     98           *
     99           * Inputs:      buffer of (bit-reversed) samples
    100           *              number of R4 butterflies per group (i.e. nfft / 4)
    101           *
    102           * Outputs:     processed samples in same buffer
    103           *
    104           * Return:      none
    105           *
    106           * Notes:       assumes 2 guard bits, gains no integer bits, 
    107           *                guard bits out = guard bits in - 2
    108           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    109          static void R4FirstPass(int *x, int bg)
    110          {
   \                     R4FirstPass:
   \   00000000   F0032DE9           PUSH     {R4-R9}
   \   00000004   000051E3           CMP      R1,#+0
   \   00000008   2700000A           BEQ      ??R4FirstPass_0
    111              int ar, ai, br, bi, cr, ci, dr, di;
    112          	
    113          	for (; bg != 0; bg--) {
    114          
    115          		ar = x[0] + x[2];
   \                     ??R4FirstPass_1:
   \   0000000C   002090E5           LDR      R2,[R0, #+0]
   \   00000010   083090E5           LDR      R3,[R0, #+8]
    116          		br = x[0] - x[2];
   \   00000014   084090E5           LDR      R4,[R0, #+8]
    117          		ai = x[1] + x[3];
   \   00000018   0C5090E5           LDR      R5,[R0, #+12]
    118          		bi = x[1] - x[3];
    119          		cr = x[4] + x[6];
   \   0000001C   186090E5           LDR      R6,[R0, #+24]
    120          		dr = x[4] - x[6];
   \   00000020   187090E5           LDR      R7,[R0, #+24]
    121          		ci = x[5] + x[7];
   \   00000024   1C8090E5           LDR      R8,[R0, #+28]
    122          		di = x[5] - x[7];
   \   00000028   1C9090E5           LDR      R9,[R0, #+28]
   \   0000002C   022083E0           ADD      R2,R3,R2
   \   00000030   003090E5           LDR      R3,[R0, #+0]
    123          
    124          		/* max per-sample gain = 4.0 (adding 4 inputs together) */
    125          		x[0] = ar + cr;
    126          		x[4] = ar - cr;
    127          		x[1] = ai + ci;
    128          		x[5] = ai - ci;
    129          		x[2] = br + di;
    130          		x[6] = br - di;
    131          		x[3] = bi - dr;
    132          		x[7] = bi + dr;
    133          
    134          		x += 8;
    135          	}
   \   00000034   011051E2           SUBS     R1,R1,#+1
   \   00000038   043043E0           SUB      R3,R3,R4
   \   0000003C   044090E5           LDR      R4,[R0, #+4]
   \   00000040   04C085E0           ADD      R12,R5,R4
   \   00000044   054044E0           SUB      R4,R4,R5
   \   00000048   105090E5           LDR      R5,[R0, #+16]
   \   0000004C   055086E0           ADD      R5,R6,R5
   \   00000050   106090E5           LDR      R6,[R0, #+16]
   \   00000054   076046E0           SUB      R6,R6,R7
   \   00000058   147090E5           LDR      R7,[R0, #+20]
   \   0000005C   077088E0           ADD      R7,R8,R7
   \   00000060   148090E5           LDR      R8,[R0, #+20]
   \   00000064   098048E0           SUB      R8,R8,R9
   \   00000068   029085E0           ADD      R9,R5,R2
   \   0000006C   ........           STR      R9,[R0], #+16
   \   00000070   052042E0           SUB      R2,R2,R5
   \   00000074   ........           STR      R2,[R0], #-12
   \   00000078   0C2087E0           ADD      R2,R7,R12
   \   0000007C   ........           STR      R2,[R0], #+16
   \   00000080   07204CE0           SUB      R2,R12,R7
   \   00000084   ........           STR      R2,[R0], #-12
   \   00000088   032088E0           ADD      R2,R8,R3
   \   0000008C   ........           STR      R2,[R0], #+16
   \   00000090   082043E0           SUB      R2,R3,R8
   \   00000094   ........           STR      R2,[R0], #-12
   \   00000098   062044E0           SUB      R2,R4,R6
   \   0000009C   ........           STR      R2,[R0], #+16
   \   000000A0   042086E0           ADD      R2,R6,R4
   \   000000A4   ........           STR      R2,[R0], #+4
   \   000000A8   D7FFFF1A           BNE      ??R4FirstPass_1
    136          }
   \                     ??R4FirstPass_0:
   \   000000AC   F003BDE8           POP      {R4-R9}
   \   000000B0   1EFF2FE1           BX       LR               ;; return
    137          
    138          /**************************************************************************************
    139           * Function:    R8FirstPass
    140           *
    141           * Description: radix-8 trivial pass for decimation-in-time FFT
    142           *
    143           * Inputs:      buffer of (bit-reversed) samples
    144           *              number of R8 butterflies per group (i.e. nfft / 8)
    145           *
    146           * Outputs:     processed samples in same buffer
    147           *
    148           * Return:      none
    149           *
    150           * Notes:       assumes 3 guard bits, gains 1 integer bit
    151           *              guard bits out = guard bits in - 3 (if inputs are full scale)
    152           *                or guard bits in - 2 (if inputs bounded to +/- sqrt(2)/2)
    153           *              see scaling comments in code
    154           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    155          static void R8FirstPass(int *x, int bg)
    156          {
   \                     R8FirstPass:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   000051E3           CMP      R1,#+0
   \   0000000C   8000000A           BEQ      ??R8FirstPass_0
    157              int ar, ai, br, bi, cr, ci, dr, di;
    158          	int sr, si, tr, ti, ur, ui, vr, vi;
    159          	int wr, wi, xr, xi, yr, yi, zr, zi;
    160          
    161          	for (; bg != 0; bg--) {
    162          
    163          		ar = x[0] + x[2];
   \                     ??R8FirstPass_1:
   \   00000010   001090E5           LDR      R1,[R0, #+0]
   \   00000014   082090E5           LDR      R2,[R0, #+8]
    164          		br = x[0] - x[2];
   \   00000018   083090E5           LDR      R3,[R0, #+8]
    165          		ai = x[1] + x[3];
   \   0000001C   0C4090E5           LDR      R4,[R0, #+12]
    166          		bi = x[1] - x[3];
   \   00000020   0C5090E5           LDR      R5,[R0, #+12]
    167          		cr = x[4] + x[6];
   \   00000024   186090E5           LDR      R6,[R0, #+24]
    168          		dr = x[4] - x[6];
    169          		ci = x[5] + x[7];
   \   00000028   1C8090E5           LDR      R8,[R0, #+28]
   \   0000002C   012082E0           ADD      R2,R2,R1
   \   00000030   031041E0           SUB      R1,R1,R3
   \   00000034   043090E5           LDR      R3,[R0, #+4]
   \   00000038   033084E0           ADD      R3,R4,R3
   \   0000003C   044090E5           LDR      R4,[R0, #+4]
   \   00000040   054044E0           SUB      R4,R4,R5
   \   00000044   105090E5           LDR      R5,[R0, #+16]
   \   00000048   057086E0           ADD      R7,R6,R5
   \   0000004C   065045E0           SUB      R5,R5,R6
   \   00000050   146090E5           LDR      R6,[R0, #+20]
   \   00000054   06A088E0           ADD      R10,R8,R6
    170          		di = x[5] - x[7];
   \   00000058   08B046E0           SUB      R11,R6,R8
    171          
    172          		sr = ar + cr;
   \   0000005C   026087E0           ADD      R6,R7,R2
    173          		ur = ar - cr;
   \   00000060   078042E0           SUB      R8,R2,R7
    174          		si = ai + ci;
   \   00000064   03908AE0           ADD      R9,R10,R3
    175          		ui = ai - ci;
   \   00000068   0AA043E0           SUB      R10,R3,R10
    176          		tr = br - di;
   \   0000006C   0B3041E0           SUB      R3,R1,R11
   \   00000070   00308DE5           STR      R3,[SP, #+0]
    177          		vr = br + di;
   \   00000074   01108BE0           ADD      R1,R11,R1
   \   00000078   08108DE5           STR      R1,[SP, #+8]
    178          		ti = bi + dr;
   \   0000007C   042085E0           ADD      R2,R5,R4
   \   00000080   04208DE5           STR      R2,[SP, #+4]
    179          		vi = bi - dr;
   \   00000084   052044E0           SUB      R2,R4,R5
   \   00000088   0C208DE5           STR      R2,[SP, #+12]
    180          
    181          		ar = x[ 8] + x[10];
   \   0000008C   201090E5           LDR      R1,[R0, #+32]
   \   00000090   282090E5           LDR      R2,[R0, #+40]
   \   00000094   015082E0           ADD      R5,R2,R1
    182          		br = x[ 8] - x[10];
    183          		ai = x[ 9] + x[11];
    184          		bi = x[ 9] - x[11];
    185          		cr = x[12] + x[14];
   \   00000098   384090E5           LDR      R4,[R0, #+56]
    186          		dr = x[12] - x[14];
    187          		ci = x[13] + x[15];
   \   0000009C   3CC090E5           LDR      R12,[R0, #+60]
   \   000000A0   023041E0           SUB      R3,R1,R2
   \   000000A4   241090E5           LDR      R1,[R0, #+36]
   \   000000A8   2C2090E5           LDR      R2,[R0, #+44]
    188          		di = x[13] - x[15];
    189          
    190          		/* max gain of wr/wi/yr/yi vs input = 2
    191          		 *  (sum of 4 samples >> 1) 
    192          		 */
    193          		wr = (ar + cr) >> 1;
    194          		yr = (ar - cr) >> 1;
    195          		wi = (ai + ci) >> 1;
    196          		yi = (ai - ci) >> 1;
    197          
    198          		/* max gain of output vs input = 4
    199          		 *  (sum of 4 samples >> 1 + sum of 4 samples >> 1) 
    200          		 */
    201          		x[ 0] = (sr >> 1) + wr;
   \   000000AC   C660A0E1           ASR      R6,R6,#+1
   \   000000B0   01B082E0           ADD      R11,R2,R1
   \   000000B4   021041E0           SUB      R1,R1,R2
   \   000000B8   302090E5           LDR      R2,[R0, #+48]
   \   000000BC   027084E0           ADD      R7,R4,R2
   \   000000C0   042042E0           SUB      R2,R2,R4
   \   000000C4   344090E5           LDR      R4,[R0, #+52]
   \   000000C8   04E08CE0           ADD      LR,R12,R4
   \   000000CC   0C4044E0           SUB      R4,R4,R12
   \   000000D0   05C087E0           ADD      R12,R7,R5
   \   000000D4   CCC0A0E1           ASR      R12,R12,#+1
   \   000000D8   075045E0           SUB      R5,R5,R7
   \   000000DC   0B708EE0           ADD      R7,LR,R11
   \   000000E0   C770A0E1           ASR      R7,R7,#+1
   \   000000E4   0EB04BE0           SUB      R11,R11,LR
   \   000000E8   06E08CE0           ADD      LR,R12,R6
   \   000000EC   ........           STR      LR,[R0], #+32
    202          		x[ 8] = (sr >> 1) - wr;
   \   000000F0   0C6046E0           SUB      R6,R6,R12
   \   000000F4   ........           STR      R6,[R0], #-28
    203          		x[ 1] = (si >> 1) + wi;
   \   000000F8   C960A0E1           ASR      R6,R9,#+1
   \   000000FC   069087E0           ADD      R9,R7,R6
   \   00000100   ........           STR      R9,[R0], #+32
    204          		x[ 9] = (si >> 1) - wi;
   \   00000104   076046E0           SUB      R6,R6,R7
   \   00000108   ........           STR      R6,[R0], #-20
    205          		x[ 4] = (ur >> 1) + yi;
   \   0000010C   C860A0E1           ASR      R6,R8,#+1
    206          		x[12] = (ur >> 1) - yi;
    207          		x[ 5] = (ui >> 1) - yr;
    208          		x[13] = (ui >> 1) + yr;
    209          
    210          		ar = br - di;
   \   00000110   048043E0           SUB      R8,R3,R4
    211          		cr = br + di;
   \   00000114   03C084E0           ADD      R12,R4,R3
    212          		ai = bi + dr;
   \   00000118   019082E0           ADD      R9,R2,R1
    213          		ci = bi - dr;
   \   0000011C   021041E0           SUB      R1,R1,R2
    214          
    215          		/* max gain of xr/xi/zr/zi vs input = 4*sqrt(2)/2 = 2*sqrt(2)
    216          		 *  (sum of 8 samples, multiply by sqrt(2)/2, implicit >> 1 from Q31) 
    217          		 */
    218          		xr = MULSHIFT32(SQRT1_2, ar - ai);
   \   00000120   092048E0           SUB      R2,R8,R9
   \   00000124   C23FA0E1           ASR      R3,R2,#+31
   \   00000128   0240A0E1           MOV      R4,R2
   \   0000012C   E8209FE5           LDR      R2,??R8FirstPass_2  ;; 0x5a82799a
   \   00000130   C550A0E1           ASR      R5,R5,#+1
   \   00000134   CBB0A0E1           ASR      R11,R11,#+1
   \   00000138   06708BE0           ADD      R7,R11,R6
   \   0000013C   ........           STR      R7,[R0], #+32
   \   00000140   0B6046E0           SUB      R6,R6,R11
   \   00000144   ........           STR      R6,[R0], #-28
   \   00000148   CA60A0E1           ASR      R6,R10,#+1
   \   0000014C   057046E0           SUB      R7,R6,R5
   \   00000150   ........           STR      R7,[R0], #+32
   \   00000154   065085E0           ADD      R5,R5,R6
   \   00000158   946287E0           UMULL    R6,R7,R4,R2
   \   0000015C   ........           STR      R5,[R0], #-28
   \   00000160   937227E0           MLA      R7,R3,R2,R7
    219          		xi = MULSHIFT32(SQRT1_2, ar + ai);
   \   00000164   084089E0           ADD      R4,R9,R8
   \   00000168   07A0A0E1           MOV      R10,R7
   \   0000016C   C45FA0E1           ASR      R5,R4,#+31
   \   00000170   946287E0           UMULL    R6,R7,R4,R2
    220          		zr = MULSHIFT32(SQRT1_2, cr - ci);
   \   00000174   01404CE0           SUB      R4,R12,R1
   \   00000178   957227E0           MLA      R7,R5,R2,R7
   \   0000017C   C45FA0E1           ASR      R5,R4,#+31
   \   00000180   0780A0E1           MOV      R8,R7
   \   00000184   946287E0           UMULL    R6,R7,R4,R2
    221          		zi = MULSHIFT32(SQRT1_2, cr + ci);
   \   00000188   0C4081E0           ADD      R4,R1,R12
    222          
    223          		/* max gain of output vs input = (2 + 2*sqrt(2) ~= 4.83)
    224          		 *  (sum of 4 samples >> 1, plus xr/xi/zr/zi with gain of 2*sqrt(2))
    225          		 * in absolute terms, we have max gain of appx 9.656 (4 + 0.707*8)
    226          		 *  but we also gain 1 int bit (from MULSHIFT32 or from explicit >> 1)
    227          		 */
    228          		x[ 6] = (tr >> 1) - xr;
   \   0000018C   00109DE5           LDR      R1,[SP, #+0]
   \   00000190   957227E0           MLA      R7,R5,R2,R7
   \   00000194   C45FA0E1           ASR      R5,R4,#+31
   \   00000198   0790A0E1           MOV      R9,R7
   \   0000019C   946287E0           UMULL    R6,R7,R4,R2
   \   000001A0   C110A0E1           ASR      R1,R1,#+1
   \   000001A4   957227E0           MLA      R7,R5,R2,R7
   \   000001A8   0A2041E0           SUB      R2,R1,R10
   \   000001AC   ........           STR      R2,[R0], #+32
    229          		x[14] = (tr >> 1) + xr;
   \   000001B0   01108AE0           ADD      R1,R10,R1
   \   000001B4   ........           STR      R1,[R0], #-28
    230          		x[ 7] = (ti >> 1) - xi;
   \   000001B8   04109DE5           LDR      R1,[SP, #+4]
   \   000001BC   C110A0E1           ASR      R1,R1,#+1
   \   000001C0   082041E0           SUB      R2,R1,R8
   \   000001C4   ........           STR      R2,[R0], #+32
    231          		x[15] = (ti >> 1) + xi;
   \   000001C8   011088E0           ADD      R1,R8,R1
   \   000001CC   ........           STR      R1,[R0], #-52
    232          		x[ 2] = (vr >> 1) + zi;
   \   000001D0   08109DE5           LDR      R1,[SP, #+8]
   \   000001D4   C110A0E1           ASR      R1,R1,#+1
   \   000001D8   012087E0           ADD      R2,R7,R1
   \   000001DC   ........           STR      R2,[R0], #+32
    233          		x[10] = (vr >> 1) - zi;
   \   000001E0   071041E0           SUB      R1,R1,R7
   \   000001E4   ........           STR      R1,[R0], #-28
    234          		x[ 3] = (vi >> 1) - zr;
   \   000001E8   0C109DE5           LDR      R1,[SP, #+12]
   \   000001EC   C110A0E1           ASR      R1,R1,#+1
   \   000001F0   092041E0           SUB      R2,R1,R9
   \   000001F4   ........           STR      R2,[R0], #+32
    235          		x[11] = (vi >> 1) + zr;
   \   000001F8   011089E0           ADD      R1,R9,R1
   \   000001FC   ........           STR      R1,[R0], #+20
    236          
    237          		x += 16;
    238          	}
   \   00000200   10209DE5           LDR      R2,[SP, #+16]
   \   00000204   012042E2           SUB      R2,R2,#+1
   \   00000208   10208DE5           STR      R2,[SP, #+16]
   \   0000020C   000052E3           CMP      R2,#+0
   \   00000210   7EFFFF1A           BNE      ??R8FirstPass_1
    239          }
   \                     ??R8FirstPass_0:
   \   00000214   14D08DE2           ADD      SP,SP,#+20       ;; stack cleaning
   \   00000218   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??R8FirstPass_2:
   \   0000021C   9A79825A           DC32     0x5a82799a
    240          
    241          /**************************************************************************************
    242           * Function:    R4Core
    243           *
    244           * Description: radix-4 pass for decimation-in-time FFT
    245           *
    246           * Inputs:      buffer of samples
    247           *              number of R4 butterflies per group
    248           *              number of R4 groups per pass
    249           *              pointer to twiddle factors tables
    250           *
    251           * Outputs:     processed samples in same buffer
    252           *
    253           * Return:      none
    254           *
    255           * Notes:       gain 2 integer bits per pass (see scaling comments in code)
    256           *              min 1 GB in
    257           *              gbOut = gbIn - 1 (short block) or gbIn - 2 (long block)
    258           *              uses 3-mul, 3-add butterflies instead of 4-mul, 2-add
    259           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    260          static void R4Core(int *x, int bg, int gp, int *wtab)
    261          {
   \                     R4Core:
   \   00000000   FF4F2DE9           PUSH     {R0-R11,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   000051E3           CMP      R1,#+0
   \   0000000C   7900000A           BEQ      ??R4Core_0
    262          	int ar, ai, br, bi, cr, ci, dr, di, tr, ti;
    263          	int wd, ws, wi;
    264          	int i, j, step;
    265          	int *xptr, *wptr;
    266          
    267          	for (; bg != 0; gp <<= 2, bg >>= 2) {
    268          
    269          		step = 2*gp;
   \                     ??R4Core_1:
   \   00000010   20109DE5           LDR      R1,[SP, #+32]
    270          		xptr = x;
    271          
    272          		/* max per-sample gain, per group < 1 + 3*sqrt(2) ~= 5.25 if inputs x are full-scale
    273          		 * do 3 groups for long block, 2 groups for short block (gain 2 int bits per group)
    274          		 *
    275          		 * very conservative scaling:
    276          		 *   group 1: max gain = 5.25,           int bits gained = 2, gb used = 1 (2^3 = 8)
    277          		 *   group 2: max gain = 5.25^2 = 27.6,  int bits gained = 4, gb used = 1 (2^5 = 32)
    278          		 *   group 3: max gain = 5.25^3 = 144.7, int bits gained = 6, gb used = 2 (2^8 = 256)
    279          		 */
    280          		for (i = bg; i != 0; i--) {
   \   00000014   1C209DE5           LDR      R2,[SP, #+28]
   \   00000018   8110A0E1           LSL      R1,R1,#+1
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   \   00000020   18109DE5           LDR      R1,[SP, #+24]
   \   00000024   04208DE5           STR      R2,[SP, #+4]
   \   00000028   000052E3           CMP      R2,#+0
   \   0000002C   6400000A           BEQ      ??R4Core_2
   \   00000030   00209DE5           LDR      R2,[SP, #+0]
   \   00000034   0C30A0E3           MOV      R3,#+12
   \   00000038   930202E0           MUL      R2,R3,R2
   \   0000003C   14208DE5           STR      R2,[SP, #+20]
    281          
    282          			wptr = wtab;
    283          
    284          			for (j = gp; j != 0; j--) {
   \                     ??R4Core_3:
   \   00000040   20A09DE5           LDR      R10,[SP, #+32]
   \   00000044   24009DE5           LDR      R0,[SP, #+36]
   \   00000048   00005AE3           CMP      R10,#+0
   \   0000004C   5500000A           BEQ      ??R4Core_4
   \   00000050   00209DE5           LDR      R2,[SP, #+0]
   \   00000054   0221A0E1           LSL      R2,R2,#+2
   \   00000058   002062E2           RSB      R2,R2,#+0
   \   0000005C   08208DE5           STR      R2,[SP, #+8]
    285          
    286          				ar = xptr[0];
   \                     ??R4Core_5:
   \   00000060   003091E5           LDR      R3,[R1, #+0]
    287          				ai = xptr[1];
    288          				xptr += step;
   \   00000064   00209DE5           LDR      R2,[SP, #+0]
   \   00000068   0C308DE5           STR      R3,[SP, #+12]
   \   0000006C   043091E5           LDR      R3,[R1, #+4]
   \   00000070   021181E0           ADD      R1,R1,R2, LSL #+2
   \   00000074   10308DE5           STR      R3,[SP, #+16]
    289          				
    290          				/* gain 2 int bits for br/bi, cr/ci, dr/di (MULSHIFT32 by Q30)
    291          				 * gain 1 net GB
    292          				 */
    293          				ws = wptr[0];
   \   00000078   ........           LDR      R2,[R0], #+4
    294          				wi = wptr[1];
   \   0000007C   ........           LDR      R8,[R0], #+4
    295          				br = xptr[0];
   \   00000080   006091E5           LDR      R6,[R1, #+0]
    296          				bi = xptr[1];
   \   00000084   043091E5           LDR      R3,[R1, #+4]
    297          				wd = ws + 2*wi;
    298          				tr = MULSHIFT32(wi, br + bi);
    299          				br = MULSHIFT32(wd, br) - tr;	/* cos*br + sin*bi */
    300          				bi = MULSHIFT32(ws, bi) + tr;	/* cos*bi - sin*br */
    301          				xptr += step;
    302          				
    303          				ws = wptr[2];
    304          				wi = wptr[3];
    305          				cr = xptr[0];
    306          				ci = xptr[1];
    307          				wd = ws + 2*wi;
    308          				tr = MULSHIFT32(wi, cr + ci);
    309          				cr = MULSHIFT32(wd, cr) - tr;
    310          				ci = MULSHIFT32(ws, ci) + tr;
    311          				xptr += step;
    312          				
    313          				ws = wptr[4];
    314          				wi = wptr[5];
    315          				dr = xptr[0];
    316          				di = xptr[1];
    317          				wd = ws + 2*wi;
    318          				tr = MULSHIFT32(wi, dr + di);
    319          				dr = MULSHIFT32(wd, dr) - tr;
    320          				di = MULSHIFT32(ws, di) + tr;
    321          				wptr += 6;
    322          
    323          				tr = ar;
    324          				ti = ai;
    325          				ar = (tr >> 2) - br;
    326          				ai = (ti >> 2) - bi;
    327          				br = (tr >> 2) + br;
    328          				bi = (ti >> 2) + bi;
    329          
    330          				tr = cr;
    331          				ti = ci;
    332          				cr = tr + dr;
    333          				ci = di - ti;
    334          				dr = tr - dr;
    335          				di = di + ti;
    336          
    337          				xptr[0] = ar + ci;
    338          				xptr[1] = ai + dr;
    339          				xptr -= step;
    340          				xptr[0] = br - cr;
    341          				xptr[1] = bi - di;
    342          				xptr -= step;
    343          				xptr[0] = ar - ci;
    344          				xptr[1] = ai - dr;
    345          				xptr -= step;
    346          				xptr[0] = br + cr;
    347          				xptr[1] = bi + di;
    348          				xptr += 2;
    349          			}
   \   00000088   01A05AE2           SUBS     R10,R10,#+1
   \   0000008C   067083E0           ADD      R7,R3,R6
   \   00000090   9847C5E0           SMULL    R4,R5,R8,R7
   \   00000094   888082E0           ADD      R8,R2,R8, LSL #+1
   \   00000098   0570A0E1           MOV      R7,R5
   \   0000009C   9846C5E0           SMULL    R4,R5,R8,R6
   \   000000A0   07E045E0           SUB      LR,R5,R7
   \   000000A4   9243C5E0           SMULL    R4,R5,R2,R3
   \   000000A8   00209DE5           LDR      R2,[SP, #+0]
   \   000000AC   ........           LDR      R3,[R0], #+4
   \   000000B0   ........           LDR      R8,[R0], #+4
   \   000000B4   05B087E0           ADD      R11,R7,R5
   \   000000B8   022181E0           ADD      R2,R1,R2, LSL #+2
   \   000000BC   006092E5           LDR      R6,[R2, #+0]
   \   000000C0   047092E5           LDR      R7,[R2, #+4]
   \   000000C4   061087E0           ADD      R1,R7,R6
   \   000000C8   9841C5E0           SMULL    R4,R5,R8,R1
   \   000000CC   888083E0           ADD      R8,R3,R8, LSL #+1
   \   000000D0   0510A0E1           MOV      R1,R5
   \   000000D4   9846C5E0           SMULL    R4,R5,R8,R6
   \   000000D8   016045E0           SUB      R6,R5,R1
   \   000000DC   9347C5E0           SMULL    R4,R5,R3,R7
   \   000000E0   00309DE5           LDR      R3,[SP, #+0]
   \   000000E4   051081E0           ADD      R1,R1,R5
   \   000000E8   032182E0           ADD      R2,R2,R3, LSL #+2
   \   000000EC   ........           LDR      R3,[R0], #+4
   \   000000F0   ........           LDR      R9,[R0], #+4
   \   000000F4   008092E5           LDR      R8,[R2, #+0]
   \   000000F8   04C092E5           LDR      R12,[R2, #+4]
   \   000000FC   08708CE0           ADD      R7,R12,R8
   \   00000100   9947C5E0           SMULL    R4,R5,R9,R7
   \   00000104   899083E0           ADD      R9,R3,R9, LSL #+1
   \   00000108   0570A0E1           MOV      R7,R5
   \   0000010C   9948C5E0           SMULL    R4,R5,R9,R8
   \   00000110   078045E0           SUB      R8,R5,R7
   \   00000114   934CC5E0           SMULL    R4,R5,R3,R12
   \   00000118   0C409DE5           LDR      R4,[SP, #+12]
   \   0000011C   053087E0           ADD      R3,R7,R5
   \   00000120   10709DE5           LDR      R7,[SP, #+16]
   \   00000124   4491A0E1           ASR      R9,R4,#+2
   \   00000128   0E4049E0           SUB      R4,R9,LR
   \   0000012C   47C1A0E1           ASR      R12,R7,#+2
   \   00000130   0B704CE0           SUB      R7,R12,R11
   \   00000134   0E9089E0           ADD      R9,R9,LR
   \   00000138   0BB08CE0           ADD      R11,R12,R11
   \   0000013C   06C088E0           ADD      R12,R8,R6
   \   00000140   01E043E0           SUB      LR,R3,R1
   \   00000144   086046E0           SUB      R6,R6,R8
   \   00000148   033081E0           ADD      R3,R1,R3
   \   0000014C   04108EE0           ADD      R1,LR,R4
   \   00000150   001082E5           STR      R1,[R2, #+0]
   \   00000154   071086E0           ADD      R1,R6,R7
   \   00000158   041082E5           STR      R1,[R2, #+4]
   \   0000015C   08109DE5           LDR      R1,[SP, #+8]
   \   00000160   021081E0           ADD      R1,R1,R2
   \   00000164   0C2049E0           SUB      R2,R9,R12
   \   00000168   002081E5           STR      R2,[R1, #+0]
   \   0000016C   03204BE0           SUB      R2,R11,R3
   \   00000170   042081E5           STR      R2,[R1, #+4]
   \   00000174   08209DE5           LDR      R2,[SP, #+8]
   \   00000178   011082E0           ADD      R1,R2,R1
   \   0000017C   0E2044E0           SUB      R2,R4,LR
   \   00000180   002081E5           STR      R2,[R1, #+0]
   \   00000184   062047E0           SUB      R2,R7,R6
   \   00000188   042081E5           STR      R2,[R1, #+4]
   \   0000018C   08209DE5           LDR      R2,[SP, #+8]
   \   00000190   011082E0           ADD      R1,R2,R1
   \   00000194   09208CE0           ADD      R2,R12,R9
   \   00000198   ........           STR      R2,[R1], #+4
   \   0000019C   0B2083E0           ADD      R2,R3,R11
   \   000001A0   ........           STR      R2,[R1], #+4
   \   000001A4   ADFFFF1A           BNE      ??R4Core_5
    350          			xptr += 3*step;
   \                     ??R4Core_4:
   \   000001A8   14009DE5           LDR      R0,[SP, #+20]
    351          		}
   \   000001AC   04209DE5           LDR      R2,[SP, #+4]
   \   000001B0   011080E0           ADD      R1,R0,R1
   \   000001B4   012042E2           SUB      R2,R2,#+1
   \   000001B8   04208DE5           STR      R2,[SP, #+4]
   \   000001BC   000052E3           CMP      R2,#+0
   \   000001C0   9EFFFF1A           BNE      ??R4Core_3
    352          		wtab += 3*step;
   \                     ??R4Core_2:
   \   000001C4   00109DE5           LDR      R1,[SP, #+0]
   \   000001C8   24309DE5           LDR      R3,[SP, #+36]
   \   000001CC   0C20A0E3           MOV      R2,#+12
   \   000001D0   923121E0           MLA      R1,R2,R1,R3
   \   000001D4   24108DE5           STR      R1,[SP, #+36]
    353          	}
   \   000001D8   20109DE5           LDR      R1,[SP, #+32]
   \   000001DC   0111A0E1           LSL      R1,R1,#+2
   \   000001E0   20108DE5           STR      R1,[SP, #+32]
   \   000001E4   1C109DE5           LDR      R1,[SP, #+28]
   \   000001E8   4111A0E1           ASR      R1,R1,#+2
   \   000001EC   1C108DE5           STR      R1,[SP, #+28]
   \   000001F0   000051E3           CMP      R1,#+0
   \   000001F4   85FFFF1A           BNE      ??R4Core_1
    354          }
   \                     ??R4Core_0:
   \   000001F8   28D08DE2           ADD      SP,SP,#+40       ;; stack cleaning
   \   000001FC   F08FBDE8           POP      {R4-R11,PC}      ;; return
    355          
    356          
    357          /**************************************************************************************
    358           * Function:    R4FFT
    359           *
    360           * Description: Ken's very fast in-place radix-4 decimation-in-time FFT
    361           *
    362           * Inputs:      table index (for transform size)
    363           *              buffer of samples (non bit-reversed)
    364           *
    365           * Outputs:     processed samples in same buffer
    366           *
    367           * Return:      none
    368           *
    369           * Notes:       assumes 5 guard bits in for nfft <= 512
    370           *              gbOut = gbIn - 4 (assuming input is from PreMultiply)
    371           *              gains log2(nfft) - 2 int bits total
    372           *                so gain 7 int bits (LONG), 4 int bits (SHORT)
    373           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    374          void R4FFT(int tabidx, int *x)
    375          {
   \                     raac_R4FFT:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
    376          	int order = nfftlog2Tab[tabidx];
    377          	int nfft = nfftTab[tabidx];
   \   00000004   6C609FE5           LDR      R6,??raac_R4FFT_0  ;; nfftTab
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   047196E7           LDR      R7,[R6, +R4, LSL #+2]
   \   00000010   0150A0E1           MOV      R5,R1
    378          
    379          	/* decimation in time */
    380          	BitReverse(x, tabidx);
   \   00000014   0410A0E1           MOV      R1,R4
   \   00000018   0500A0E1           MOV      R0,R5
   \   0000001C   ........           BL       BitReverse
    381          
    382          	if (order & 0x1) {
   \   00000020   040186E0           ADD      R0,R6,R4, LSL #+2
   \   00000024   080090E5           LDR      R0,[R0, #+8]
   \   00000028   010010E3           TST      R0,#0x1
   \   0000002C   0800000A           BEQ      ??raac_R4FFT_1
    383          		/* long block: order = 9, nfft = 512 */
    384          		R8FirstPass(x, nfft >> 3);						/* gain 1 int bit,  lose 2 GB */
   \   00000030   C711A0E1           ASR      R1,R7,#+3
   \   00000034   0500A0E1           MOV      R0,R5
   \   00000038   ........           BL       R8FirstPass
    385          		R4Core(x, nfft >> 5, 8, (int *)twidTabOdd);		/* gain 6 int bits, lose 2 GB */
   \   0000003C   38309FE5           LDR      R3,??raac_R4FFT_0+0x4  ;; raac_twidTabOdd
   \   00000040   0820A0E3           MOV      R2,#+8
   \   00000044   C712A0E1           ASR      R1,R7,#+5
   \   00000048   0500A0E1           MOV      R0,R5
   \   0000004C   ........           BL       R4Core
   \   00000050   F080BDE8           POP      {R4-R7,PC}
    386          	} else {
    387          		/* short block: order = 6, nfft = 64 */
    388          		R4FirstPass(x, nfft >> 2);						/* gain 0 int bits, lose 2 GB */
   \                     ??raac_R4FFT_1:
   \   00000054   4711A0E1           ASR      R1,R7,#+2
   \   00000058   0500A0E1           MOV      R0,R5
   \   0000005C   ........           BL       R4FirstPass
    389          		R4Core(x, nfft >> 4, 4, (int *)twidTabEven);	/* gain 4 int bits, lose 1 GB */
   \   00000060   18309FE5           LDR      R3,??raac_R4FFT_0+0x8  ;; raac_twidTabEven
   \   00000064   0420A0E3           MOV      R2,#+4
   \   00000068   4712A0E1           ASR      R1,R7,#+4
   \   0000006C   0500A0E1           MOV      R0,R5
   \   00000070   ........           BL       R4Core
    390          	}
    391          }
   \   00000074   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??raac_R4FFT_0:
   \   00000078   ........           DC32     nfftTab
   \   0000007C   ........           DC32     raac_twidTabOdd
   \   00000080   ........           DC32     raac_twidTabEven

   Maximum stack usage in bytes:

     Function    CSTACK
     --------    ------
     BitReverse     20
     R4Core         76
     R4FirstPass    24
     R8FirstPass    56
     raac_R4FFT     20


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     nfftTab          16
     BitReverse      280
     R4FirstPass     180
     R8FirstPass     544
     R4Core          512
     raac_R4FFT      132
      Others          20

 
 1 668 bytes in segment CODE
    16 bytes in segment DATA_C
 
 1 648 bytes of CODE  memory (+ 20 bytes shared)
    16 bytes of CONST memory

Errors: none
Warnings: none
