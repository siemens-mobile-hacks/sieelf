##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    14/Feb/2012  15:39:19 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDE #
#                       C\AAC_FILE (19).c                                    #
#    Command line    =  "D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACD #
#                       EC\AAC_FILE (19).c" -D NDEBUG -lC                    #
#                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\ -lA D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\ #
#                       Release\List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player #
#                       \Player\Release\Obj\ -s9 --cpu_mode arm --endian     #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None --dlib_config "D:\Program              #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude       #
#                       swilib.h -I "D:\Program Files\IAR\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=16                                #
#    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\AAC_FILE (19).lst                                #
#    Object file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\O #
#                       bj\AAC_FILE (19).r79                                 #
#                                                                            #
#                                                                            #
##############################################################################

D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDEC\AAC_FILE (19).c
      1          /* ***** BEGIN LICENSE BLOCK *****  
      2           * Source last modified: $Id: filefmt.c,v 1.1 2005/02/26 01:47:34 jrecker Exp $ 
      3           *   
      4           * Portions Copyright (c) 1995-2005 RealNetworks, Inc. All Rights Reserved.  
      5           *       
      6           * The contents of this file, and the files included with this file, 
      7           * are subject to the current version of the RealNetworks Public 
      8           * Source License (the "RPSL") available at 
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed 
     10           * the file under the current version of the RealNetworks Community 
     11           * Source License (the "RCSL") available at 
     12           * http://www.helixcommunity.org/content/rcsl, in which case the RCSL 
     13           * will apply. You may also obtain the license terms directly from 
     14           * RealNetworks.  You may not use this file except in compliance with 
     15           * the RPSL or, if you have a valid RCSL with RealNetworks applicable 
     16           * to this file, the RCSL.  Please see the applicable RPSL or RCSL for 
     17           * the rights, obligations and limitations governing use of the 
     18           * contents of the file. 
     19           *   
     20           * This file is part of the Helix DNA Technology. RealNetworks is the 
     21           * developer of the Original Code and owns the copyrights in the 
     22           * portions it created. 
     23           *   
     24           * This file, and the files included with this file, is distributed 
     25           * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY 
     26           * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS 
     27           * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES 
     28           * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET 
     29           * ENJOYMENT OR NON-INFRINGEMENT. 
     30           *  
     31           * Technology Compatibility Kit Test Suite(s) Location:  
     32           *    http://www.helixcommunity.org/content/tck  
     33           *  
     34           * Contributor(s):  
     35           *   
     36           * ***** END LICENSE BLOCK ***** */  
     37          
     38          /**************************************************************************************
     39           * Fixed-point HE-AAC decoder
     40           * Jon Recker (jrecker@real.com)
     41           * February 2005
     42           *
     43           * filefmt.c - ADIF and ADTS header decoding, raw block handling
     44           **************************************************************************************/
     45          
     46          #include "coder_aac.h"
     47          
     48           /**************************************************************************************
     49           * Function:    UnpackADTSHeader
     50           *
     51           * Description: parse the ADTS frame header and initialize decoder state
     52           *
     53           * Inputs:      valid AACDecInfo struct
     54           *              double pointer to buffer with complete ADTS frame header (byte aligned)
     55           *                header size = 7 bytes, plus 2 if CRC
     56           *
     57           * Outputs:     filled in ADTS struct
     58           *              updated buffer pointer
     59           *              updated bit offset
     60           *              updated number of available bits
     61           *
     62           * Return:      0 if successful, error code (< 0) if error
     63           *
     64           * TODO:        test CRC
     65           *              verify that fixed fields don't change between frames
     66           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     67          int UnpackADTSHeader(AACDecInfo *aacDecInfo, unsigned char **buf, int *bitOffset, int *bitsAvail)
     68          {
   \                     raac_UnpackADTSHeader:
   \   00000000   F0412DE9           PUSH     {R4-R8,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040A0E1           MOV      R4,R0
     69          	int bitsUsed;
     70          	PSInfoBase *psi;
     71          	BitStreamInfo bsi;
     72          	ADTSHeader *fhADTS;
     73          
     74          	/* validate pointers */
     75          	if (!aacDecInfo || !aacDecInfo->psInfoBase)
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   00809415           LDRNE    R8,[R4, #+0]
   \   00000014   0150A0E1           MOV      R5,R1
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   0370A0E1           MOV      R7,R3
   \   00000020   00005813           CMPNE    R8,#+0
     76          		return ERR_AAC_NULL_POINTER;
   \   00000024   0100E003           MVNEQ    R0,#+1
   \   00000028   8500000A           BEQ      ??raac_UnpackADTSHeader_0
     77          	psi = (PSInfoBase *)(aacDecInfo->psInfoBase);
     78          	fhADTS = &(psi->fhADTS);
     79          
     80          	/* init bitstream reader */
     81          	SetBitstreamPointer(&bsi, (*bitsAvail + 7) >> 3, *buf);
   \   0000002C   000097E5           LDR      R0,[R7, #+0]
   \   00000030   002095E5           LDR      R2,[R5, #+0]
   \   00000034   070080E2           ADD      R0,R0,#+7
   \   00000038   C011A0E1           ASR      R1,R0,#+3
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           _BLF     raac_SetBitstreamPointer,??raac_SetBitstreamPointer??rA
     82          	GetBits(&bsi, *bitOffset);
   \   00000044   001096E5           LDR      R1,[R6, #+0]
   \   00000048   0D00A0E1           MOV      R0,SP
   \   0000004C   ........           _BLF     raac_GetBits,??raac_GetBits??rA
     83          
     84          	/* verify that first 12 bits of header are syncword */
     85          	if (GetBits(&bsi, 12) != 0x0fff)
   \   00000050   0C10A0E3           MOV      R1,#+12
   \   00000054   0D00A0E1           MOV      R0,SP
   \   00000058   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   0000005C   FF10A0E3           MOV      R1,#+255
   \   00000060   F01E81E3           ORR      R1,R1,#0xF00
   \   00000064   010050E1           CMP      R0,R1
   \   00000068   0200000A           BEQ      ??raac_UnpackADTSHeader_1
     86          		return ERR_AAC_INVALID_ADTS_HEADER;
   \                     ??raac_UnpackADTSHeader_2:
   \   0000006C   0200E0E3           MVN      R0,#+2
   \   00000070   10D08DE2           ADD      SP,SP,#+16
   \   00000074   F081BDE8           POP      {R4-R8,PC}
     87          
     88          	/* fixed fields - should not change from frame to frame */ 
     89          	fhADTS->id =               GetBits(&bsi, 1);
   \                     ??raac_UnpackADTSHeader_1:
   \   00000078   0110A0E3           MOV      R1,#+1
   \   0000007C   0D00A0E1           MOV      R0,SP
   \   00000080   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000084   0000C8E5           STRB     R0,[R8, #+0]
     90          	fhADTS->layer =            GetBits(&bsi, 2);
   \   00000088   0210A0E3           MOV      R1,#+2
   \   0000008C   0D00A0E1           MOV      R0,SP
   \   00000090   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000094   0100C8E5           STRB     R0,[R8, #+1]
     91          	fhADTS->protectBit =       GetBits(&bsi, 1);
   \   00000098   0110A0E3           MOV      R1,#+1
   \   0000009C   0D00A0E1           MOV      R0,SP
   \   000000A0   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   000000A4   0200C8E5           STRB     R0,[R8, #+2]
     92          	fhADTS->profile =          GetBits(&bsi, 2);
   \   000000A8   0210A0E3           MOV      R1,#+2
   \   000000AC   0D00A0E1           MOV      R0,SP
   \   000000B0   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   000000B4   0300C8E5           STRB     R0,[R8, #+3]
     93          	fhADTS->sampRateIdx =      GetBits(&bsi, 4);
   \   000000B8   0410A0E3           MOV      R1,#+4
   \   000000BC   0D00A0E1           MOV      R0,SP
   \   000000C0   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   000000C4   0400C8E5           STRB     R0,[R8, #+4]
     94          	fhADTS->privateBit =       GetBits(&bsi, 1);
   \   000000C8   0110A0E3           MOV      R1,#+1
   \   000000CC   0D00A0E1           MOV      R0,SP
   \   000000D0   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   000000D4   0500C8E5           STRB     R0,[R8, #+5]
     95          	fhADTS->channelConfig =    GetBits(&bsi, 3);
   \   000000D8   0310A0E3           MOV      R1,#+3
   \   000000DC   0D00A0E1           MOV      R0,SP
   \   000000E0   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   000000E4   0600C8E5           STRB     R0,[R8, #+6]
     96          	fhADTS->origCopy =         GetBits(&bsi, 1);
   \   000000E8   0110A0E3           MOV      R1,#+1
   \   000000EC   0D00A0E1           MOV      R0,SP
   \   000000F0   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   000000F4   0700C8E5           STRB     R0,[R8, #+7]
     97          	fhADTS->home =             GetBits(&bsi, 1);
   \   000000F8   0110A0E3           MOV      R1,#+1
   \   000000FC   0D00A0E1           MOV      R0,SP
   \   00000100   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000104   0800C8E5           STRB     R0,[R8, #+8]
     98          
     99          	/* variable fields - can change from frame to frame */ 
    100          	fhADTS->copyBit =          GetBits(&bsi, 1);
   \   00000108   0110A0E3           MOV      R1,#+1
   \   0000010C   0D00A0E1           MOV      R0,SP
   \   00000110   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000114   0900C8E5           STRB     R0,[R8, #+9]
    101          	fhADTS->copyStart =        GetBits(&bsi, 1);
   \   00000118   0110A0E3           MOV      R1,#+1
   \   0000011C   0D00A0E1           MOV      R0,SP
   \   00000120   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000124   0A00C8E5           STRB     R0,[R8, #+10]
    102          	fhADTS->frameLength =      GetBits(&bsi, 13);
   \   00000128   0D10A0E3           MOV      R1,#+13
   \   0000012C   0D00A0E1           MOV      R0,SP
   \   00000130   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000134   0C0088E5           STR      R0,[R8, #+12]
    103          	fhADTS->bufferFull =       GetBits(&bsi, 11);
   \   00000138   0B10A0E3           MOV      R1,#+11
   \   0000013C   0D00A0E1           MOV      R0,SP
   \   00000140   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000144   100088E5           STR      R0,[R8, #+16]
    104          	fhADTS->numRawDataBlocks = GetBits(&bsi, 2) + 1;
   \   00000148   0210A0E3           MOV      R1,#+2
   \   0000014C   0D00A0E1           MOV      R0,SP
   \   00000150   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000154   010080E2           ADD      R0,R0,#+1
   \   00000158   1400C8E5           STRB     R0,[R8, #+20]
    105          
    106          	/* note - MPEG4 spec, correction 1 changes how CRC is handled when protectBit == 0 and numRawDataBlocks > 1 */
    107          	if (fhADTS->protectBit == 0)
   \   0000015C   0200D8E5           LDRB     R0,[R8, #+2]
   \   00000160   000050E3           CMP      R0,#+0
   \   00000164   0300001A           BNE      ??raac_UnpackADTSHeader_3
    108          		fhADTS->crcCheckWord = GetBits(&bsi, 16);
   \   00000168   1010A0E3           MOV      R1,#+16
   \   0000016C   0D00A0E1           MOV      R0,SP
   \   00000170   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000174   180088E5           STR      R0,[R8, #+24]
    109          
    110          	/* byte align */
    111          	ByteAlignBitstream(&bsi);	/* should always be aligned anyway */
   \                     ??raac_UnpackADTSHeader_3:
   \   00000178   0D00A0E1           MOV      R0,SP
   \   0000017C   ........           _BLF     raac_ByteAlignBitstream,??raac_ByteAlignBitstream??rA
    112          
    113          	/* check validity of header */
    114          	if (fhADTS->layer != 0 || fhADTS->profile != AAC_PROFILE_LC ||
    115          		fhADTS->sampRateIdx >= NUM_SAMPLE_RATES || fhADTS->channelConfig >= NUM_DEF_CHAN_MAPS)
   \   00000180   0100D8E5           LDRB     R0,[R8, #+1]
   \   00000184   000050E3           CMP      R0,#+0
   \   00000188   0300D805           LDRBEQ   R0,[R8, #+3]
   \   0000018C   01005003           CMPEQ    R0,#+1
   \   00000190   B5FFFF1A           BNE      ??raac_UnpackADTSHeader_2
   \   00000194   0400D8E5           LDRB     R0,[R8, #+4]
   \   00000198   0C0050E3           CMP      R0,#+12
   \   0000019C   0610D835           LDRBCC   R1,[R8, #+6]
   \   000001A0   08005133           CMPCC    R1,#+8
   \   000001A4   B0FFFF2A           BCS      ??raac_UnpackADTSHeader_2
    116          		return ERR_AAC_INVALID_ADTS_HEADER;
    117          
    118          #ifndef AAC_ENABLE_MPEG4
    119          	if (fhADTS->id != 1)
    120          		return ERR_AAC_MPEG4_UNSUPPORTED;
    121          #endif
    122          
    123          	/* update codec info */
    124          	psi->sampRateIdx = fhADTS->sampRateIdx;
    125          	if (!psi->useImpChanMap)
    126          		psi->nChans = channelMapTab[fhADTS->channelConfig];
    127          
    128          	/* syntactic element fields will be read from bitstream for each element */
    129          	aacDecInfo->prevBlockID = AAC_ID_INVALID;
    130          	aacDecInfo->currBlockID = AAC_ID_INVALID;
    131          	aacDecInfo->currInstTag = -1;
    132          
    133          	/* fill in user-accessible data (TODO - calc bitrate, handle tricky channel config cases) */
    134          	aacDecInfo->bitRate = 0;
    135          	aacDecInfo->nChans = psi->nChans;
    136          	aacDecInfo->sampRate = sampRateTab[psi->sampRateIdx];
   \   000001A8   ........           LDR      R2,??DataTable2  ;; raac_sampRateTab
   \   000001AC   780888E5           STR      R0,[R8, #+2168]
   \   000001B0   740898E5           LDR      R0,[R8, #+2164]
   \   000001B4   000050E3           CMP      R0,#+0
   \   000001B8   8C009F05           LDREQ    R0,??raac_UnpackADTSHeader_4  ;; raac_channelMapTab
   \   000001BC   01019007           LDREQ    R0,[R0, +R1, LSL #+2]
   \   000001C0   70088805           STREQ    R0,[R8, #+2160]
   \   000001C4   0000E0E3           MVN      R0,#+0
   \   000001C8   240084E5           STR      R0,[R4, #+36]
   \   000001CC   280084E5           STR      R0,[R4, #+40]
   \   000001D0   2C0084E5           STR      R0,[R4, #+44]
   \   000001D4   0000A0E3           MOV      R0,#+0
   \   000001D8   3C0084E5           STR      R0,[R4, #+60]
   \   000001DC   701898E5           LDR      R1,[R8, #+2160]
   \   000001E0   401084E5           STR      R1,[R4, #+64]
   \   000001E4   781898E5           LDR      R1,[R8, #+2168]
   \   000001E8   011192E7           LDR      R1,[R2, +R1, LSL #+2]
   \   000001EC   441084E5           STR      R1,[R4, #+68]
    137          	aacDecInfo->profile = fhADTS->profile;
   \   000001F0   0310D8E5           LDRB     R1,[R8, #+3]
   \   000001F4   481084E5           STR      R1,[R4, #+72]
    138          	aacDecInfo->sbrEnabled = 0;
   \   000001F8   500084E5           STR      R0,[R4, #+80]
    139          	aacDecInfo->adtsBlocksLeft = fhADTS->numRawDataBlocks;
   \   000001FC   1400D8E5           LDRB     R0,[R8, #+20]
   \   00000200   380084E5           STR      R0,[R4, #+56]
    140          
    141          	/* update bitstream reader */
    142          	bitsUsed = CalcBitsUsed(&bsi, *buf, *bitOffset);
   \   00000204   002096E5           LDR      R2,[R6, #+0]
   \   00000208   001095E5           LDR      R1,[R5, #+0]
   \   0000020C   0D00A0E1           MOV      R0,SP
   \   00000210   ........           _BLF     raac_CalcBitsUsed,??raac_CalcBitsUsed??rA
    143          	*buf += (bitsUsed + *bitOffset) >> 3;
   \   00000214   001096E5           LDR      R1,[R6, #+0]
   \   00000218   002095E5           LDR      R2,[R5, #+0]
   \   0000021C   001081E0           ADD      R1,R1,R0
   \   00000220   C12182E0           ADD      R2,R2,R1, ASR #+3
   \   00000224   002085E5           STR      R2,[R5, #+0]
    144          	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
   \   00000228   071001E2           AND      R1,R1,#0x7
   \   0000022C   001086E5           STR      R1,[R6, #+0]
    145          	*bitsAvail -= bitsUsed ;
   \   00000230   001097E5           LDR      R1,[R7, #+0]
   \   00000234   000051E0           SUBS     R0,R1,R0
   \   00000238   000087E5           STR      R0,[R7, #+0]
    146          	if (*bitsAvail < 0)
    147          		return ERR_AAC_INDATA_UNDERFLOW;
   \   0000023C   0000E043           MVNMI    R0,#+0
    148          
    149          	return ERR_AAC_NONE;
   \   00000240   0000A053           MOVPL    R0,#+0
   \                     ??raac_UnpackADTSHeader_0:
   \   00000244   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000248   F081BDE8           POP      {R4-R8,PC}       ;; return
   \                     ??raac_UnpackADTSHeader_4:
   \   0000024C   ........           DC32     raac_channelMapTab
    150          }
    151          
    152          /**************************************************************************************
    153           * Function:    GetADTSChannelMapping
    154           *
    155           * Description: determine the number of channels from implicit mapping rules
    156           *
    157           * Inputs:      valid AACDecInfo struct
    158           *              pointer to start of raw_data_block
    159           *              bit offset
    160           *              bits available 
    161           *
    162           * Outputs:     updated number of channels
    163           *
    164           * Return:      0 if successful, error code (< 0) if error
    165           *
    166           * Notes:       calculates total number of channels using rules in 14496-3, 4.5.1.2.1
    167           *              does not attempt to deduce speaker geometry
    168           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    169          int GetADTSChannelMapping(AACDecInfo *aacDecInfo, unsigned char *buf, int bitOffset, int bitsAvail)
    170          {
   \                     raac_GetADTSChannelMapping:
   \   00000000   FE432DE9           PUSH     {R1-R9,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    171          	int ch, nChans, elementChans, err;
    172          	PSInfoBase *psi;
    173          
    174          	/* validate pointers */
    175          	if (!aacDecInfo || !aacDecInfo->psInfoBase)
   \   00000008   00609415           LDRNE    R6,[R4, #+0]
   \   0000000C   00005613           CMPNE    R6,#+0
    176          		return ERR_AAC_NULL_POINTER;
   \   00000010   0100E003           MVNEQ    R0,#+1
   \   00000014   FE83BD08           POPEQ    {R1-R9,PC}
    177          	psi = (PSInfoBase *)(aacDecInfo->psInfoBase);
    178          
    179          	nChans = 0;
   \   00000018   0050A0E3           MOV      R5,#+0
    180          	do {
    181          		/* parse next syntactic element */
    182          		err = DecodeNextElement(aacDecInfo, &buf, &bitOffset, &bitsAvail);
   \                     ??raac_GetADTSChannelMapping_0:
   \   0000001C   08308DE2           ADD      R3,SP,#+8
   \   00000020   04208DE2           ADD      R2,SP,#+4
   \   00000024   0D10A0E1           MOV      R1,SP
   \   00000028   0400A0E1           MOV      R0,R4
   \   0000002C   ........           _BLF     raac_DecodeNextElement,??raac_DecodeNextElement??rA
    183          		if (err)
   \   00000030   000050E3           CMP      R0,#+0
    184          			return err;
   \   00000034   FE83BD18           POPNE    {R1-R9,PC}
    185          
    186          		elementChans = elementNumChans[aacDecInfo->currBlockID];
   \   00000038   280094E5           LDR      R0,[R4, #+40]
   \   0000003C   74109FE5           LDR      R1,??raac_GetADTSChannelMapping_1  ;; raac_elementNumChans
    187          		nChans += elementChans;
    188          
    189          		for (ch = 0; ch < elementChans; ch++) {
   \   00000040   0090A0E3           MOV      R9,#+0
   \   00000044   007191E7           LDR      R7,[R1, +R0, LSL #+2]
   \   00000048   058087E0           ADD      R8,R7,R5
   \   0000004C   0850A0E1           MOV      R5,R8
   \   00000050   0A0000EA           B        ??raac_GetADTSChannelMapping_2
    190          			err = DecodeNoiselessData(aacDecInfo, &buf, &bitOffset, &bitsAvail, ch);
   \                     ??raac_GetADTSChannelMapping_3:
   \   00000054   0900A0E1           MOV      R0,R9
   \   00000058   01002DE9           PUSH     {R0}
   \   0000005C   0C308DE2           ADD      R3,SP,#+12
   \   00000060   08208DE2           ADD      R2,SP,#+8
   \   00000064   04108DE2           ADD      R1,SP,#+4
   \   00000068   0400A0E1           MOV      R0,R4
   \   0000006C   ........           _BLF     raac_DecodeNoiselessData,??raac_DecodeNoiselessData??rA
    191          			if (err)
   \   00000070   000050E3           CMP      R0,#+0
   \   00000074   04D08DE2           ADD      SP,SP,#+4
   \   00000078   FE83BD18           POPNE    {R1-R9,PC}
    192          				return err;
    193          		}
   \   0000007C   019089E2           ADD      R9,R9,#+1
   \                     ??raac_GetADTSChannelMapping_2:
   \   00000080   070059E1           CMP      R9,R7
   \   00000084   F2FFFFBA           BLT      ??raac_GetADTSChannelMapping_3
    194          	} while (aacDecInfo->currBlockID != AAC_ID_END);
   \   00000088   280094E5           LDR      R0,[R4, #+40]
   \   0000008C   070050E3           CMP      R0,#+7
   \   00000090   E1FFFF1A           BNE      ??raac_GetADTSChannelMapping_0
    195          
    196          	if (nChans <= 0)
   \   00000094   010055E3           CMP      R5,#+1
    197          		return ERR_AAC_CHANNEL_MAP;
   \   00000098   0600E0B3           MVNLT    R0,#+6
   \   0000009C   FE83BDB8           POPLT    {R1-R9,PC}
    198          
    199          	/* update number of channels in codec state and user-accessible info structs */ 
    200          	psi->nChans = nChans;
   \   000000A0   705886E5           STR      R5,[R6, #+2160]
    201          	aacDecInfo->nChans = psi->nChans;
   \   000000A4   408084E5           STR      R8,[R4, #+64]
    202          	psi->useImpChanMap = 1;
   \   000000A8   0100A0E3           MOV      R0,#+1
   \   000000AC   740886E5           STR      R0,[R6, #+2164]
    203          
    204          	return ERR_AAC_NONE;
   \   000000B0   0000A0E3           MOV      R0,#+0
   \   000000B4   FE83BDE8           POP      {R1-R9,PC}       ;; return
   \                     ??raac_GetADTSChannelMapping_1:
   \   000000B8   ........           DC32     raac_elementNumChans
    205          }
    206          
    207          /**************************************************************************************
    208           * Function:    GetNumChannelsADIF
    209           *
    210           * Description: get number of channels from program config elements in an ADIF file
    211           *
    212           * Inputs:      array of filled-in program config element structures
    213           *              number of PCE's
    214           *
    215           * Outputs:     none
    216           *
    217           * Return:      total number of channels in file
    218           *              -1 if error (invalid number of PCE's or unsupported mode)
    219           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    220          static int GetNumChannelsADIF(ProgConfigElement *fhPCE, int nPCE)
    221          {
   \                     GetNumChannelsADIF:
   \   00000000   30002DE9           PUSH     {R4,R5}
    222          	int i, j, nChans;
    223          
    224          	if (nPCE < 1 || nPCE > MAX_NUM_PCE_ADIF)
   \   00000004   010051E3           CMP      R1,#+1
   \   00000008   010000BA           BLT      ??GetNumChannelsADIF_0
   \   0000000C   110051E3           CMP      R1,#+17
   \   00000010   020000BA           BLT      ??GetNumChannelsADIF_1
    225          		return -1;
   \                     ??GetNumChannelsADIF_0:
   \   00000014   3000BDE8           POP      {R4,R5}
   \   00000018   0000E0E3           MVN      R0,#+0
   \   0000001C   1EFF2FE1           BX       LR
    226          
    227          	nChans = 0;
   \                     ??GetNumChannelsADIF_1:
   \   00000020   0020A0E3           MOV      R2,#+0
    228          	for (i = 0; i < nPCE; i++) {
   \   00000024   0030A0E3           MOV      R3,#+0
   \   00000028   090000EA           B        ??GetNumChannelsADIF_2
    229          		/* for now: only support LC, no channel coupling */
    230          		if (fhPCE[i].profile != AAC_PROFILE_LC || fhPCE[i].numCCE > 0)
    231          			return -1;
    232          
    233          		/* add up number of channels in all channel elements (assume all single-channel) */
    234                  nChans += fhPCE[i].numFCE;
    235                  nChans += fhPCE[i].numSCE;
    236                  nChans += fhPCE[i].numBCE;
    237                  nChans += fhPCE[i].numLCE;
    238          
    239          		/* add one more for every element which is a channel pair */
    240                  for (j = 0; j < fhPCE[i].numFCE; j++) {
    241                      if (CHAN_ELEM_IS_CPE(fhPCE[i].fce[j]))
    242                          nChans++;
    243                  }
    244                  for (j = 0; j < fhPCE[i].numSCE; j++) {
    245                      if (CHAN_ELEM_IS_CPE(fhPCE[i].sce[j]))
    246                          nChans++;
    247                  }
    248                  for (j = 0; j < fhPCE[i].numBCE; j++) {
    249                      if (CHAN_ELEM_IS_CPE(fhPCE[i].bce[j]))
   \                     ??GetNumChannelsADIF_3:
   \   0000002C   0C5084E0           ADD      R5,R4,R12
   \   00000030   2A50D5E5           LDRB     R5,[R5, #+42]
    250                          nChans++;
    251                  }
   \   00000034   014084E2           ADD      R4,R4,#+1
   \   00000038   105005E2           AND      R5,R5,#0x10
   \   0000003C   4552B0E1           ASRS     R5,R5,#+4
   \   00000040   01208212           ADDNE    R2,R2,#+1
   \                     ??GetNumChannelsADIF_4:
   \   00000044   0550DCE5           LDRB     R5,[R12, #+5]
   \   00000048   050054E1           CMP      R4,R5
   \   0000004C   F6FFFFBA           BLT      ??GetNumChannelsADIF_3
   \                     ??GetNumChannelsADIF_5:
   \   00000050   013083E2           ADD      R3,R3,#+1
   \                     ??GetNumChannelsADIF_2:
   \   00000054   010053E1           CMP      R3,R1
   \   00000058   2F0000AA           BGE      ??GetNumChannelsADIF_6
   \   0000005C   5240A0E3           MOV      R4,#+82
   \   00000060   94032CE0           MLA      R12,R4,R3,R0
   \   00000064   0140DCE5           LDRB     R4,[R12, #+1]
   \   00000068   010054E3           CMP      R4,#+1
   \   0000006C   0840DC05           LDRBEQ   R4,[R12, #+8]
   \   00000070   00005403           CMPEQ    R4,#+0
   \   00000074   E6FFFF1A           BNE      ??GetNumChannelsADIF_0
   \   00000078   0340DCE5           LDRB     R4,[R12, #+3]
   \   0000007C   0450DCE5           LDRB     R5,[R12, #+4]
   \   00000080   044085E0           ADD      R4,R5,R4
   \   00000084   0550DCE5           LDRB     R5,[R12, #+5]
   \   00000088   044085E0           ADD      R4,R5,R4
   \   0000008C   0650DCE5           LDRB     R5,[R12, #+6]
   \   00000090   044085E0           ADD      R4,R5,R4
   \   00000094   0350DCE5           LDRB     R5,[R12, #+3]
   \   00000098   022084E0           ADD      R2,R4,R2
   \   0000009C   0040A0E3           MOV      R4,#+0
   \   000000A0   000055E3           CMP      R5,#+0
   \   000000A4   0600001A           BNE      ??GetNumChannelsADIF_7
   \   000000A8   080000EA           B        ??GetNumChannelsADIF_8
   \                     ??GetNumChannelsADIF_9:
   \   000000AC   0C5084E0           ADD      R5,R4,R12
   \   000000B0   0C50D5E5           LDRB     R5,[R5, #+12]
   \   000000B4   014084E2           ADD      R4,R4,#+1
   \   000000B8   105005E2           AND      R5,R5,#0x10
   \   000000BC   4552B0E1           ASRS     R5,R5,#+4
   \   000000C0   01208212           ADDNE    R2,R2,#+1
   \                     ??GetNumChannelsADIF_7:
   \   000000C4   0350DCE5           LDRB     R5,[R12, #+3]
   \   000000C8   050054E1           CMP      R4,R5
   \   000000CC   F6FFFFBA           BLT      ??GetNumChannelsADIF_9
   \                     ??GetNumChannelsADIF_8:
   \   000000D0   0450DCE5           LDRB     R5,[R12, #+4]
   \   000000D4   0040A0E3           MOV      R4,#+0
   \   000000D8   000055E3           CMP      R5,#+0
   \   000000DC   0600001A           BNE      ??GetNumChannelsADIF_10
   \   000000E0   080000EA           B        ??GetNumChannelsADIF_11
   \                     ??GetNumChannelsADIF_12:
   \   000000E4   0C5084E0           ADD      R5,R4,R12
   \   000000E8   1B50D5E5           LDRB     R5,[R5, #+27]
   \   000000EC   014084E2           ADD      R4,R4,#+1
   \   000000F0   105005E2           AND      R5,R5,#0x10
   \   000000F4   4552B0E1           ASRS     R5,R5,#+4
   \   000000F8   01208212           ADDNE    R2,R2,#+1
   \                     ??GetNumChannelsADIF_10:
   \   000000FC   0450DCE5           LDRB     R5,[R12, #+4]
   \   00000100   050054E1           CMP      R4,R5
   \   00000104   F6FFFFBA           BLT      ??GetNumChannelsADIF_12
   \                     ??GetNumChannelsADIF_11:
   \   00000108   0550DCE5           LDRB     R5,[R12, #+5]
   \   0000010C   0040A0E3           MOV      R4,#+0
   \   00000110   000055E3           CMP      R5,#+0
   \   00000114   CAFFFF1A           BNE      ??GetNumChannelsADIF_4
   \   00000118   CCFFFFEA           B        ??GetNumChannelsADIF_5
    252          
    253          	}
    254          
    255          	return nChans;
   \                     ??GetNumChannelsADIF_6:
   \   0000011C   3000BDE8           POP      {R4,R5}
   \   00000120   0200A0E1           MOV      R0,R2
   \   00000124   1EFF2FE1           BX       LR               ;; return
    256          }
    257          
    258          /**************************************************************************************
    259           * Function:    GetSampleRateIdxADIF
    260           *
    261           * Description: get sampling rate index from program config elements in an ADIF file
    262           *
    263           * Inputs:      array of filled-in program config element structures
    264           *              number of PCE's
    265           *
    266           * Outputs:     none
    267           *
    268           * Return:      sample rate of file
    269           *              -1 if error (invalid number of PCE's or sample rate mismatch)
    270           **************************************************************************************/
    271          static int GetSampleRateIdxADIF(ProgConfigElement *fhPCE, int nPCE)
    272          {
    273          	int i, idx;
    274          
    275          	if (nPCE < 1 || nPCE > MAX_NUM_PCE_ADIF)
    276          		return -1;
    277          
    278          	/* make sure all PCE's have the same sample rate */
    279          	idx = fhPCE[0].sampRateIdx;
    280          	for (i = 1; i < nPCE; i++) {
    281          		if (fhPCE[i].sampRateIdx != idx)
    282          			return -1;
    283          	}
    284          
    285          	return idx;
    286          }
    287          
    288          /**************************************************************************************
    289           * Function:    UnpackADIFHeader
    290           *
    291           * Description: parse the ADIF file header and initialize decoder state
    292           *
    293           * Inputs:      valid AACDecInfo struct
    294           *              double pointer to buffer with complete ADIF header 
    295           *                (starting at 'A' in 'ADIF' tag)
    296           *              pointer to bit offset
    297           *              pointer to number of valid bits remaining in inbuf
    298           *
    299           * Outputs:     filled-in ADIF struct
    300           *              updated buffer pointer
    301           *              updated bit offset
    302           *              updated number of available bits
    303           *
    304           * Return:      0 if successful, error code (< 0) if error
    305           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    306          int UnpackADIFHeader(AACDecInfo *aacDecInfo, unsigned char **buf, int *bitOffset, int *bitsAvail)
    307          {
   \                     raac_UnpackADIFHeader:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0050A0E1           MOV      R5,R0
    308          	int i, bitsUsed;
    309          	PSInfoBase *psi;
    310          	BitStreamInfo bsi;
    311          	ADIFHeader *fhADIF;
    312          	ProgConfigElement *pce;
    313          
    314          	/* validate pointers */
    315          	if (!aacDecInfo || !aacDecInfo->psInfoBase)
   \   0000000C   000055E3           CMP      R5,#+0
   \   00000010   00409515           LDRNE    R4,[R5, #+0]
   \   00000014   0160A0E1           MOV      R6,R1
   \   00000018   0270A0E1           MOV      R7,R2
   \   0000001C   0380A0E1           MOV      R8,R3
   \   00000020   00005413           CMPNE    R4,#+0
    316          		return ERR_AAC_NULL_POINTER;
   \   00000024   0100E003           MVNEQ    R0,#+1
   \   00000028   9800000A           BEQ      ??raac_UnpackADIFHeader_0
    317          	psi = (PSInfoBase *)(aacDecInfo->psInfoBase);
    318          
    319          	/* init bitstream reader */
    320          	SetBitstreamPointer(&bsi, (*bitsAvail + 7) >> 3, *buf);
   \   0000002C   000098E5           LDR      R0,[R8, #+0]
   \   00000030   002096E5           LDR      R2,[R6, #+0]
   \   00000034   070080E2           ADD      R0,R0,#+7
   \   00000038   C011A0E1           ASR      R1,R0,#+3
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   ........           _BLF     raac_SetBitstreamPointer,??raac_SetBitstreamPointer??rA
    321          	GetBits(&bsi, *bitOffset);
   \   00000044   001097E5           LDR      R1,[R7, #+0]
   \   00000048   0D00A0E1           MOV      R0,SP
   \   0000004C   ........           _BLF     raac_GetBits,??raac_GetBits??rA
    322          
    323          	/* unpack ADIF file header */
    324          	fhADIF = &(psi->fhADIF);
   \   00000050   1C9084E2           ADD      R9,R4,#+28
    325          	pce = psi->pce;
   \   00000054   38A084E2           ADD      R10,R4,#+56
    326          
    327          	/* verify that first 32 bits of header are "ADIF" */
    328          	if (GetBits(&bsi, 8) != 'A' || GetBits(&bsi, 8) != 'D' || GetBits(&bsi, 8) != 'I' || GetBits(&bsi, 8) != 'F')
   \   00000058   0810A0E3           MOV      R1,#+8
   \   0000005C   0D00A0E1           MOV      R0,SP
   \   00000060   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000064   410050E3           CMP      R0,#+65
   \   00000068   0E00001A           BNE      ??raac_UnpackADIFHeader_1
   \   0000006C   0810A0E3           MOV      R1,#+8
   \   00000070   0D00A0E1           MOV      R0,SP
   \   00000074   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000078   440050E3           CMP      R0,#+68
   \   0000007C   0900001A           BNE      ??raac_UnpackADIFHeader_1
   \   00000080   0810A0E3           MOV      R1,#+8
   \   00000084   0D00A0E1           MOV      R0,SP
   \   00000088   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   0000008C   490050E3           CMP      R0,#+73
   \   00000090   0400001A           BNE      ??raac_UnpackADIFHeader_1
   \   00000094   0810A0E3           MOV      R1,#+8
   \   00000098   0D00A0E1           MOV      R0,SP
   \   0000009C   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   000000A0   460050E3           CMP      R0,#+70
   \   000000A4   0200000A           BEQ      ??raac_UnpackADIFHeader_2
    329          		return ERR_AAC_INVALID_ADIF_HEADER;
   \                     ??raac_UnpackADIFHeader_1:
   \   000000A8   0300E0E3           MVN      R0,#+3
   \   000000AC   10D08DE2           ADD      SP,SP,#+16
   \   000000B0   F08FBDE8           POP      {R4-R11,PC}
    330          
    331          	/* read ADIF header fields */
    332          	fhADIF->copyBit = GetBits(&bsi, 1);
   \                     ??raac_UnpackADIFHeader_2:
   \   000000B4   0110A0E3           MOV      R1,#+1
   \   000000B8   0D00A0E1           MOV      R0,SP
   \   000000BC   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   000000C0   0000C9E5           STRB     R0,[R9, #+0]
    333          	if (fhADIF->copyBit) {
   \   000000C4   0000D9E5           LDRB     R0,[R9, #+0]
   \   000000C8   000050E3           CMP      R0,#+0
   \   000000CC   0800000A           BEQ      ??raac_UnpackADIFHeader_3
    334          		for (i = 0; i < ADIF_COPYID_SIZE; i++)
   \   000000D0   00B0A0E3           MOV      R11,#+0
    335          			fhADIF->copyID[i] = GetBits(&bsi, 8);
   \                     ??raac_UnpackADIFHeader_4:
   \   000000D4   0810A0E3           MOV      R1,#+8
   \   000000D8   0D00A0E1           MOV      R0,SP
   \   000000DC   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   000000E0   09108BE0           ADD      R1,R11,R9
   \   000000E4   1000C1E5           STRB     R0,[R1, #+16]
   \   000000E8   01B08BE2           ADD      R11,R11,#+1
   \   000000EC   09005BE3           CMP      R11,#+9
   \   000000F0   F7FFFFBA           BLT      ??raac_UnpackADIFHeader_4
    336          	}
    337          	fhADIF->origCopy = GetBits(&bsi, 1);
   \                     ??raac_UnpackADIFHeader_3:
   \   000000F4   0110A0E3           MOV      R1,#+1
   \   000000F8   0D00A0E1           MOV      R0,SP
   \   000000FC   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000100   0100C9E5           STRB     R0,[R9, #+1]
    338          	fhADIF->home =     GetBits(&bsi, 1);
   \   00000104   0110A0E3           MOV      R1,#+1
   \   00000108   0D00A0E1           MOV      R0,SP
   \   0000010C   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000110   0200C9E5           STRB     R0,[R9, #+2]
    339          	fhADIF->bsType =   GetBits(&bsi, 1);
   \   00000114   0110A0E3           MOV      R1,#+1
   \   00000118   0D00A0E1           MOV      R0,SP
   \   0000011C   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000120   0300C9E5           STRB     R0,[R9, #+3]
    340          	fhADIF->bitRate =  GetBits(&bsi, 23);
   \   00000124   1710A0E3           MOV      R1,#+23
   \   00000128   0D00A0E1           MOV      R0,SP
   \   0000012C   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000130   040089E5           STR      R0,[R9, #+4]
    341          	fhADIF->numPCE =   GetBits(&bsi, 4) + 1;	/* add 1 (so range = [1, 16]) */
   \   00000134   0410A0E3           MOV      R1,#+4
   \   00000138   0D00A0E1           MOV      R0,SP
   \   0000013C   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000140   010080E2           ADD      R0,R0,#+1
   \   00000144   0800C9E5           STRB     R0,[R9, #+8]
    342          	if (fhADIF->bsType == 0)
   \   00000148   0300D9E5           LDRB     R0,[R9, #+3]
   \   0000014C   000050E3           CMP      R0,#+0
   \   00000150   0300001A           BNE      ??raac_UnpackADIFHeader_5
    343          		fhADIF->bufferFull = GetBits(&bsi, 20);
   \   00000154   1410A0E3           MOV      R1,#+20
   \   00000158   0D00A0E1           MOV      R0,SP
   \   0000015C   ........           _BLF     raac_GetBits,??raac_GetBits??rA
   \   00000160   0C0089E5           STR      R0,[R9, #+12]
    344          
    345          	/* parse all program config elements */
    346          	for (i = 0; i < fhADIF->numPCE; i++)
   \                     ??raac_UnpackADIFHeader_5:
   \   00000164   0800D9E5           LDRB     R0,[R9, #+8]
   \   00000168   00B0A0E3           MOV      R11,#+0
   \   0000016C   000050E3           CMP      R0,#+0
   \   00000170   0500001A           BNE      ??raac_UnpackADIFHeader_6
   \   00000174   070000EA           B        ??raac_UnpackADIFHeader_7
    347          		DecodeProgramConfigElement(pce + i, &bsi);
   \                     ??raac_UnpackADIFHeader_8:
   \   00000178   0D10A0E1           MOV      R1,SP
   \   0000017C   5220A0E3           MOV      R2,#+82
   \   00000180   92AB20E0           MLA      R0,R2,R11,R10
   \   00000184   01B08BE2           ADD      R11,R11,#+1
   \   00000188   ........           _BLF     raac_DecodeProgramConfigElement,??raac_DecodeProgramConfigElement??rA
   \                     ??raac_UnpackADIFHeader_6:
   \   0000018C   0800D9E5           LDRB     R0,[R9, #+8]
   \   00000190   00005BE1           CMP      R11,R0
   \   00000194   F7FFFFBA           BLT      ??raac_UnpackADIFHeader_8
    348          
    349          	/* byte align */
    350          	ByteAlignBitstream(&bsi);
   \                     ??raac_UnpackADIFHeader_7:
   \   00000198   0D00A0E1           MOV      R0,SP
   \   0000019C   ........           _BLF     raac_ByteAlignBitstream,??raac_ByteAlignBitstream??rA
    351          
    352          	/* update codec info */
    353          	psi->nChans = GetNumChannelsADIF(pce, fhADIF->numPCE);
   \   000001A0   0810D9E5           LDRB     R1,[R9, #+8]
   \   000001A4   0A00A0E1           MOV      R0,R10
   \   000001A8   ........           BL       GetNumChannelsADIF
   \   000001AC   700884E5           STR      R0,[R4, #+2160]
    354          	psi->sampRateIdx = GetSampleRateIdxADIF(pce, fhADIF->numPCE);
   \   000001B0   0800D9E5           LDRB     R0,[R9, #+8]
   \   000001B4   010050E3           CMP      R0,#+1
   \   000001B8   010000BA           BLT      ??raac_UnpackADIFHeader_9
   \   000001BC   110050E3           CMP      R0,#+17
   \   000001C0   010000BA           BLT      ??raac_UnpackADIFHeader_10
   \                     ??raac_UnpackADIFHeader_9:
   \   000001C4   0010E0E3           MVN      R1,#+0
   \   000001C8   0A0000EA           B        ??raac_UnpackADIFHeader_11
   \                     ??raac_UnpackADIFHeader_10:
   \   000001CC   0210DAE5           LDRB     R1,[R10, #+2]
   \   000001D0   0120A0E3           MOV      R2,#+1
   \   000001D4   050000EA           B        ??raac_UnpackADIFHeader_12
   \                     ??raac_UnpackADIFHeader_13:
   \   000001D8   5230A0E3           MOV      R3,#+82
   \   000001DC   93A229E0           MLA      R9,R3,R2,R10
   \   000001E0   0230D9E5           LDRB     R3,[R9, #+2]
   \   000001E4   010053E1           CMP      R3,R1
   \   000001E8   F5FFFF1A           BNE      ??raac_UnpackADIFHeader_9
   \   000001EC   012082E2           ADD      R2,R2,#+1
   \                     ??raac_UnpackADIFHeader_12:
   \   000001F0   000052E1           CMP      R2,R0
   \   000001F4   F7FFFFBA           BLT      ??raac_UnpackADIFHeader_13
   \                     ??raac_UnpackADIFHeader_11:
   \   000001F8   781884E5           STR      R1,[R4, #+2168]
    355          
    356          	/* check validity of header */
    357          	if (psi->nChans < 0 || psi->sampRateIdx < 0 || psi->sampRateIdx >= NUM_SAMPLE_RATES)
   \   000001FC   700894E5           LDR      R0,[R4, #+2160]
   \   00000200   000050E3           CMP      R0,#+0
   \   00000204   00005153           CMPPL    R1,#+0
   \   00000208   A6FFFF4A           BMI      ??raac_UnpackADIFHeader_1
   \   0000020C   0C0051E3           CMP      R1,#+12
   \   00000210   A4FFFFAA           BGE      ??raac_UnpackADIFHeader_1
    358          		return ERR_AAC_INVALID_ADIF_HEADER;
    359          								
    360          	/* syntactic element fields will be read from bitstream for each element */
    361          	aacDecInfo->prevBlockID = AAC_ID_INVALID;
    362          	aacDecInfo->currBlockID = AAC_ID_INVALID;
    363          	aacDecInfo->currInstTag = -1;
    364          
    365          	/* fill in user-accessible data */
    366          	aacDecInfo->bitRate = 0;
    367          	aacDecInfo->nChans = psi->nChans;
    368          	aacDecInfo->sampRate = sampRateTab[psi->sampRateIdx];
   \   00000214   ........           LDR      R2,??DataTable2  ;; raac_sampRateTab
   \   00000218   0000E0E3           MVN      R0,#+0
   \   0000021C   240085E5           STR      R0,[R5, #+36]
   \   00000220   280085E5           STR      R0,[R5, #+40]
   \   00000224   2C0085E5           STR      R0,[R5, #+44]
   \   00000228   0000A0E3           MOV      R0,#+0
   \   0000022C   3C0085E5           STR      R0,[R5, #+60]
   \   00000230   701894E5           LDR      R1,[R4, #+2160]
   \   00000234   401085E5           STR      R1,[R5, #+64]
   \   00000238   781894E5           LDR      R1,[R4, #+2168]
   \   0000023C   011192E7           LDR      R1,[R2, +R1, LSL #+2]
   \   00000240   441085E5           STR      R1,[R5, #+68]
    369          	aacDecInfo->profile = pce[0].profile;
   \   00000244   0110DAE5           LDRB     R1,[R10, #+1]
   \   00000248   481085E5           STR      R1,[R5, #+72]
    370          	aacDecInfo->sbrEnabled = 0;
   \   0000024C   500085E5           STR      R0,[R5, #+80]
    371          
    372          	/* update bitstream reader */
    373          	bitsUsed = CalcBitsUsed(&bsi, *buf, *bitOffset);
   \   00000250   002097E5           LDR      R2,[R7, #+0]
   \   00000254   001096E5           LDR      R1,[R6, #+0]
   \   00000258   0D00A0E1           MOV      R0,SP
   \   0000025C   ........           _BLF     raac_CalcBitsUsed,??raac_CalcBitsUsed??rA
    374          	*buf += (bitsUsed + *bitOffset) >> 3;
   \   00000260   001097E5           LDR      R1,[R7, #+0]
   \   00000264   002096E5           LDR      R2,[R6, #+0]
   \   00000268   001081E0           ADD      R1,R1,R0
   \   0000026C   C12182E0           ADD      R2,R2,R1, ASR #+3
   \   00000270   002086E5           STR      R2,[R6, #+0]
    375          	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
   \   00000274   071001E2           AND      R1,R1,#0x7
   \   00000278   001087E5           STR      R1,[R7, #+0]
    376          	*bitsAvail -= bitsUsed ;
   \   0000027C   001098E5           LDR      R1,[R8, #+0]
   \   00000280   000051E0           SUBS     R0,R1,R0
   \   00000284   000088E5           STR      R0,[R8, #+0]
    377          	if (*bitsAvail < 0)
    378          		return ERR_AAC_INDATA_UNDERFLOW;
   \   00000288   0000E043           MVNMI    R0,#+0
    379          
    380          	return ERR_AAC_NONE;
   \   0000028C   0000A053           MOVPL    R0,#+0
   \                     ??raac_UnpackADIFHeader_0:
   \   00000290   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000294   F08FBDE8           POP      {R4-R11,PC}      ;; return
    381          }
    382          
    383          /**************************************************************************************
    384           * Function:    SetRawBlockParams
    385           *
    386           * Description: set internal state variables for decoding a stream of raw data blocks
    387           *
    388           * Inputs:      valid AACDecInfo struct
    389           *              flag indicating source of parameters (from previous headers or passed 
    390           *                explicitly by caller)
    391           *              number of channels
    392           *              sample rate
    393           *              profile ID
    394           *
    395           * Outputs:     updated state variables in aacDecInfo
    396           *
    397           * Return:      0 if successful, error code (< 0) if error
    398           *
    399           * Notes:       if copyLast == 1, then psi->nChans, psi->sampRateIdx, and 
    400           *                aacDecInfo->profile are not changed (it's assumed that we already 
    401           *                set them, such as by a previous call to UnpackADTSHeader())
    402           *              if copyLast == 0, then the parameters we passed in are used instead
    403           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    404          int SetRawBlockParams(AACDecInfo *aacDecInfo, int copyLast, int nChans, int sampRate, int profile)
    405          {
   \                     raac_SetRawBlockParams:
   \   00000000   30002DE9           PUSH     {R4,R5}
   \   00000004   08C09DE5           LDR      R12,[SP, #+8]
    406          	int idx;
    407          	PSInfoBase *psi;
    408          
    409          	/* validate pointers */
    410          	if (!aacDecInfo || !aacDecInfo->psInfoBase)
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   00409015           LDRNE    R4,[R0, #+0]
   \   00000010   00005413           CMPNE    R4,#+0
    411          		return ERR_AAC_NULL_POINTER;
   \   00000014   0100E003           MVNEQ    R0,#+1
   \   00000018   2000000A           BEQ      ??raac_SetRawBlockParams_0
    412          	psi = (PSInfoBase *)(aacDecInfo->psInfoBase);
    413          
    414          	if (!copyLast) {
   \   0000001C   ........           LDR      R5,??DataTable2  ;; raac_sampRateTab
   \   00000020   000051E3           CMP      R1,#+0
   \   00000024   0500001A           BNE      ??raac_SetRawBlockParams_1
    415          		aacDecInfo->profile = profile;
   \   00000028   48C080E5           STR      R12,[R0, #+72]
    416          		psi->nChans = nChans;
   \   0000002C   702884E5           STR      R2,[R4, #+2160]
    417          		for (idx = 0; idx < NUM_SAMPLE_RATES; idx++) {
    418          			if (sampRate == sampRateTab[idx]) {
   \                     ??raac_SetRawBlockParams_2:
   \   00000030   012195E7           LDR      R2,[R5, +R1, LSL #+2]
   \   00000034   020053E1           CMP      R3,R2
   \   00000038   1000001A           BNE      ??raac_SetRawBlockParams_3
    419          				psi->sampRateIdx = idx;
   \   0000003C   781884E5           STR      R1,[R4, #+2168]
    420          				break;
    421          			}
    422          		}
    423          		if (idx == NUM_SAMPLE_RATES)
    424          			return ERR_AAC_INVALID_FRAME;
    425          	}
    426          	aacDecInfo->nChans = psi->nChans;
   \                     ??raac_SetRawBlockParams_1:
   \   00000040   701894E5           LDR      R1,[R4, #+2160]
   \   00000044   401080E5           STR      R1,[R0, #+64]
    427          	aacDecInfo->sampRate = sampRateTab[psi->sampRateIdx];
   \   00000048   781894E5           LDR      R1,[R4, #+2168]
   \   0000004C   011195E7           LDR      R1,[R5, +R1, LSL #+2]
   \   00000050   441080E5           STR      R1,[R0, #+68]
    428          
    429          	/* check validity of header */
    430          	if (psi->sampRateIdx >= NUM_SAMPLE_RATES || psi->sampRateIdx < 0 || aacDecInfo->profile != AAC_PROFILE_LC)
   \   00000054   781894E5           LDR      R1,[R4, #+2168]
   \   00000058   0C0051E3           CMP      R1,#+12
   \   0000005C   040000AA           BGE      ??raac_SetRawBlockParams_4
   \   00000060   000051E3           CMP      R1,#+0
   \   00000064   0200004A           BMI      ??raac_SetRawBlockParams_4
   \   00000068   480090E5           LDR      R0,[R0, #+72]
   \   0000006C   010050E3           CMP      R0,#+1
   \   00000070   0900000A           BEQ      ??raac_SetRawBlockParams_5
    431          		return ERR_AAC_RAWBLOCK_PARAMS;
   \                     ??raac_SetRawBlockParams_4:
   \   00000074   3000BDE8           POP      {R4,R5}
   \   00000078   1500E0E3           MVN      R0,#+21
   \   0000007C   1EFF2FE1           BX       LR
   \                     ??raac_SetRawBlockParams_3:
   \   00000080   011081E2           ADD      R1,R1,#+1
   \   00000084   0C0051E3           CMP      R1,#+12
   \   00000088   E8FFFFBA           BLT      ??raac_SetRawBlockParams_2
   \   0000008C   EBFFFF1A           BNE      ??raac_SetRawBlockParams_1
   \   00000090   3000BDE8           POP      {R4,R5}
   \   00000094   0400E0E3           MVN      R0,#+4
   \   00000098   1EFF2FE1           BX       LR
    432          
    433          	return ERR_AAC_NONE;
   \                     ??raac_SetRawBlockParams_5:
   \   0000009C   0000A0E3           MOV      R0,#+0
   \                     ??raac_SetRawBlockParams_0:
   \   000000A0   3000BDE8           POP      {R4,R5}
   \   000000A4   1EFF2FE1           BX       LR               ;; return
    434          }
    435          
    436          /**************************************************************************************
    437           * Function:    PrepareRawBlock
    438           *
    439           * Description: reset per-block state variables for raw blocks (no ADTS/ADIF headers)
    440           *
    441           * Inputs:      valid AACDecInfo struct
    442           *
    443           * Outputs:     updated state variables in aacDecInfo
    444           *
    445           * Return:      0 if successful, error code (< 0) if error
    446           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    447          int PrepareRawBlock(AACDecInfo *aacDecInfo)
    448          {
    449          	PSInfoBase *psi;
                 	            ^
Warning[Pe550]: variable "psi" was set but never used
    450          
    451          	/* validate pointers */
    452          	if (!aacDecInfo || !aacDecInfo->psInfoBase)
   \                     raac_PrepareRawBlock:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   00109015           LDRNE    R1,[R0, #+0]
   \   00000008   00005113           CMPNE    R1,#+0
    453          		return ERR_AAC_NULL_POINTER;
   \   0000000C   0100E003           MVNEQ    R0,#+1
   \   00000010   1EFF2F01           BXEQ     LR
    454          	psi = (PSInfoBase *)(aacDecInfo->psInfoBase);
    455          
    456          	/* syntactic element fields will be read from bitstream for each element */
    457          	aacDecInfo->prevBlockID = AAC_ID_INVALID;
   \   00000014   0010E0E3           MVN      R1,#+0
   \   00000018   241080E5           STR      R1,[R0, #+36]
    458          	aacDecInfo->currBlockID = AAC_ID_INVALID;
   \   0000001C   281080E5           STR      R1,[R0, #+40]
    459          	aacDecInfo->currInstTag = -1;
   \   00000020   2C1080E5           STR      R1,[R0, #+44]
    460          
    461          	/* fill in user-accessible data */
    462          	aacDecInfo->bitRate = 0;
   \   00000024   0010A0E3           MOV      R1,#+0
   \   00000028   3C1080E5           STR      R1,[R0, #+60]
    463          	aacDecInfo->sbrEnabled = 0;
   \   0000002C   501080E5           STR      R1,[R0, #+80]
    464          
    465          	return ERR_AAC_NONE;
   \   00000030   0000A0E3           MOV      R0,#+0
   \   00000034   1EFF2FE1           BX       LR               ;; return
    466          }
    467          
    468          /**************************************************************************************
    469           * Function:    FlushCodec
    470           *
    471           * Description: flush internal codec state (after seeking, for example)
    472           *
    473           * Inputs:      valid AACDecInfo struct
    474           *
    475           * Outputs:     updated state variables in aacDecInfo
    476           *
    477           * Return:      0 if successful, error code (< 0) if error
    478           *
    479           * Notes:       only need to clear data which is persistent between frames 
    480           *                (such as overlap buffer)
    481           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    482          int FlushCodec(AACDecInfo *aacDecInfo)
    483          {
   \                     raac_FlushCodec:
   \   00000000   10402DE9           PUSH     {R4,LR}
    484          	PSInfoBase *psi;
    485          
    486          	/* validate pointers */
    487          	if (!aacDecInfo || !aacDecInfo->psInfoBase)
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   00409015           LDRNE    R4,[R0, #+0]
   \   0000000C   00005413           CMPNE    R4,#+0
    488          		return ERR_AAC_NULL_POINTER;
   \   00000010   0100E003           MVNEQ    R0,#+1
   \   00000014   1080BD08           POPEQ    {R4,PC}
    489          	psi = (PSInfoBase *)(aacDecInfo->psInfoBase);
    490          	
    491          	ClearBuffer(psi->overlap, AAC_MAX_NCHANS * AAC_MAX_NSAMPS * sizeof(int));
   \   00000018   801DA0E3           MOV      R1,#+8192
   \   0000001C   4800A0E3           MOV      R0,#+72
   \   00000020   C00D80E3           ORR      R0,R0,#0x3000
   \   00000024   040080E0           ADD      R0,R0,R4
   \   00000028   ........           _BLF     raac_ClearBuffer,??raac_ClearBuffer??rA
    492          	ClearBuffer(psi->prevWinShape, AAC_MAX_NCHANS * sizeof(int));
   \   0000002C   0810A0E3           MOV      R1,#+8
   \   00000030   4800A0E3           MOV      R0,#+72
   \   00000034   500C80E3           ORR      R0,R0,#0x5000
   \   00000038   040080E0           ADD      R0,R0,R4
   \   0000003C   ........           _BLF     raac_ClearBuffer,??raac_ClearBuffer??rA
    493          
    494          	return ERR_AAC_NONE;
   \   00000040   0000A0E3           MOV      R0,#+0
   \   00000044   1080BDE8           POP      {R4,PC}          ;; return
    495          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     raac_sampRateTab

   Maximum stack usage in bytes:

     Function                   CSTACK
     --------                   ------
     GetNumChannelsADIF             8
     raac_FlushCodec                8
     raac_GetADTSChannelMapping    44
     raac_PrepareRawBlock           0
     raac_SetRawBlockParams         8
     raac_UnpackADIFHeader         52
     raac_UnpackADTSHeader         40


   Segment part sizes:

     Function/Label             Bytes
     --------------             -----
     raac_UnpackADTSHeader       592
     raac_GetADTSChannelMapping  188
     GetNumChannelsADIF          296
     raac_UnpackADIFHeader       664
     raac_SetRawBlockParams      168
     raac_PrepareRawBlock         56
     raac_FlushCodec              72
     ??DataTable2                  4
      Others                     124

 
 2 164 bytes in segment CODE
 
 2 040 bytes of CODE memory (+ 124 bytes shared)

Errors: none
Warnings: 1
