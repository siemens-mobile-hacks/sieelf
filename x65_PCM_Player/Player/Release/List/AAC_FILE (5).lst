##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    14/Feb/2012  15:39:27 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDE #
#                       C\AAC_FILE (5).c                                     #
#    Command line    =  "D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACD #
#                       EC\AAC_FILE (5).c" -D NDEBUG -lC                     #
#                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\ -lA D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\ #
#                       Release\List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player #
#                       \Player\Release\Obj\ -s9 --cpu_mode arm --endian     #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None --dlib_config "D:\Program              #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude       #
#                       swilib.h -I "D:\Program Files\IAR\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=16                                #
#    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\AAC_FILE (5).lst                                 #
#    Object file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\O #
#                       bj\AAC_FILE (5).r79                                  #
#                                                                            #
#                                                                            #
##############################################################################

D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDEC\AAC_FILE (5).c
      1          /* ***** BEGIN LICENSE BLOCK *****  
      2           * Source last modified: $Id: sbrimdct.c,v 1.1 2005/02/26 01:47:35 jrecker Exp $ 
      3           *   
      4           * Portions Copyright (c) 1995-2005 RealNetworks, Inc. All Rights Reserved.  
      5           *       
      6           * The contents of this file, and the files included with this file, 
      7           * are subject to the current version of the RealNetworks Public 
      8           * Source License (the "RPSL") available at 
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed 
     10           * the file under the current version of the RealNetworks Community 
     11           * Source License (the "RCSL") available at 
     12           * http://www.helixcommunity.org/content/rcsl, in which case the RCSL 
     13           * will apply. You may also obtain the license terms directly from 
     14           * RealNetworks.  You may not use this file except in compliance with 
     15           * the RPSL or, if you have a valid RCSL with RealNetworks applicable 
     16           * to this file, the RCSL.  Please see the applicable RPSL or RCSL for 
     17           * the rights, obligations and limitations governing use of the 
     18           * contents of the file. 
     19           *   
     20           * This file is part of the Helix DNA Technology. RealNetworks is the 
     21           * developer of the Original Code and owns the copyrights in the 
     22           * portions it created. 
     23           *   
     24           * This file, and the files included with this file, is distributed 
     25           * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY 
     26           * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS 
     27           * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES 
     28           * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET 
     29           * ENJOYMENT OR NON-INFRINGEMENT. 
     30           *  
     31           * Technology Compatibility Kit Test Suite(s) Location:  
     32           *    http://www.helixcommunity.org/content/tck  
     33           *  
     34           * Contributor(s):  
     35           *   
     36           * ***** END LICENSE BLOCK ***** */  
     37          
     38          /**************************************************************************************
     39           * Fixed-point HE-AAC decoder
     40           * Jon Recker (jrecker@real.com)
     41           * February 2005
     42           *
     43           * sbrimdct.c - inverse MDCT without clipping or interleaving, for input to SBR
     44           **************************************************************************************/
     45          
     46          #include "coder_aac.h"
     47          #include "assembly_aac.h"
     48          
     49          /**************************************************************************************
     50           * Function:    DecWindowOverlapNoClip
     51           *
     52           * Description: apply synthesis window, do overlap-add without clipping,
     53           *                for winSequence LONG-LONG
     54           *
     55           * Inputs:      input buffer (output of type-IV DCT)
     56           *              overlap buffer (saved from last time)
     57           *              window type (sin or KBD) for input buffer
     58           *              window type (sin or KBD) for overlap buffer
     59           *
     60           * Outputs:     one channel, one frame of 32-bit PCM, non-interleaved
     61           *
     62           * Return:      none
     63           *
     64           * Notes:       use this function when the decoded PCM is going to the SBR decoder
     65           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     66          void DecWindowOverlapNoClip(int *buf0, int *over0, int *out0, int winTypeCurr, int winTypePrev)
     67          {
   \                     raac_DecWindowOverlapNoClip:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
     68          	int in, w0, w1, f0, f1;
     69          	int *buf1, *over1, *out1;
     70          	const int *wndPrev, *wndCurr;
     71          
     72          	buf0 += (1024 >> 1);
     73          	buf1  = buf0  - 1;
     74          	out1  = out0 + 1024 - 1;
     75          	over1 = over0 + 1024 - 1;
     76          
     77          	wndPrev = (winTypePrev == 1 ? kbdWindow + kbdWindowOffset[1] : sinWindow + sinWindowOffset[1]);
   \   00000004   ........           LDR      R6,??DataTable14  ;; raac_sinWindowOffset
   \   00000008   ........           LDR      R8,??DataTable16  ;; raac_sinWindow
   \   0000000C   08D04DE2           SUB      SP,SP,#+8
   \   00000010   08409DE5           LDR      R4,[SP, #+8]
   \   00000014   01B0A0E1           MOV      R11,R1
   \   00000018   30109DE5           LDR      R1,[SP, #+48]
   \   0000001C   80EE80E2           ADD      LR,R0,#+2048
   \   00000020   04204EE2           SUB      R2,LR,#+4
   \   00000024   00208DE5           STR      R2,[SP, #+0]
   \   00000028   FC20A0E3           MOV      R2,#+252
   \   0000002C   F02E82E3           ORR      R2,R2,#0xF00
   \   00000030   042082E0           ADD      R2,R2,R4
   \   00000034   ........           LDR      R4,??DataTable15  ;; raac_kbdWindow
   \   00000038   04208DE5           STR      R2,[SP, #+4]
   \   0000003C   ........           LDR      R2,??DataTable17  ;; raac_kbdWindowOffset
   \   00000040   FC00A0E3           MOV      R0,#+252
   \   00000044   F00E80E3           ORR      R0,R0,#0xF00
   \   00000048   0BA080E0           ADD      R10,R0,R11
   \   0000004C   010051E3           CMP      R1,#+1
   \   00000050   04009205           LDREQ    R0,[R2, #+4]
   \   00000054   00018400           ADDEQ    R0,R4,R0, LSL #+2
   \   00000058   04009615           LDRNE    R0,[R6, #+4]
   \   0000005C   00018810           ADDNE    R0,R8,R0, LSL #+2
     78          	if (winTypeCurr == winTypePrev) {
   \   00000060   010053E1           CMP      R3,R1
   \   00000064   2700001A           BNE      ??raac_DecWindowOverlapNoClip_0
     79          		/* cut window loads in half since current and overlap sections use same symmetric window */
     80          		do {
     81          			w0 = *wndPrev++;
   \                     ??raac_DecWindowOverlapNoClip_1:
   \   00000068   ........           LDR      R4,[R0], #+4
     82          			w1 = *wndPrev++;
     83          			in = *buf0++;
   \   0000006C   ........           LDR      R2,[LR], #+4
   \   00000070   ........           LDR      R1,[R0], #+4
     84          
     85          			f0 = MULSHIFT32(w0, in);
     86          			f1 = MULSHIFT32(w1, in);
     87          
     88          			in = *over0;	
     89          			*out0++ = in - f0;
   \   00000074   00C09BE5           LDR      R12,[R11, #+0]
   \   00000078   08909DE5           LDR      R9,[SP, #+8]
   \   0000007C   C23FA0E1           ASR      R3,R2,#+31
   \   00000080   C45FA0E1           ASR      R5,R4,#+31
   \   00000084   946287E0           UMULL    R6,R7,R4,R2
   \   00000088   947327E0           MLA      R7,R4,R3,R7
   \   0000008C   957227E0           MLA      R7,R5,R2,R7
   \   00000090   07604CE0           SUB      R6,R12,R7
   \   00000094   ........           STR      R6,[R9], #+4
   \   00000098   08908DE5           STR      R9,[SP, #+8]
     90          
     91          			in = *over1;	
     92          			*out1-- = in + f1;
   \   0000009C   0160A0E1           MOV      R6,R1
   \   000000A0   C17FA0E1           ASR      R7,R1,#+31
   \   000000A4   00109AE5           LDR      R1,[R10, #+0]
   \   000000A8   968289E0           UMULL    R8,R9,R6,R2
   \   000000AC   969329E0           MLA      R9,R6,R3,R9
   \   000000B0   979229E0           MLA      R9,R7,R2,R9
   \   000000B4   04209DE5           LDR      R2,[SP, #+4]
   \   000000B8   011089E0           ADD      R1,R9,R1
   \   000000BC   ........           STR      R1,[R2], #-4
     93          
     94          			in = *buf1--;
   \   000000C0   00309DE5           LDR      R3,[SP, #+0]
   \   000000C4   04208DE5           STR      R2,[SP, #+4]
   \   000000C8   ........           LDR      R2,[R3], #-4
   \   000000CC   00308DE5           STR      R3,[SP, #+0]
     95          			*over1-- = MULSHIFT32(w0, in);
   \   000000D0   C23FA0E1           ASR      R3,R2,#+31
   \   000000D4   948289E0           UMULL    R8,R9,R4,R2
   \   000000D8   949329E0           MLA      R9,R4,R3,R9
   \   000000DC   959229E0           MLA      R9,R5,R2,R9
   \   000000E0   0940A0E1           MOV      R4,R9
   \   000000E4   ........           STR      R4,[R10], #-4
     96          			*over0++ = MULSHIFT32(w1, in);
   \   000000E8   964285E0           UMULL    R4,R5,R6,R2
   \   000000EC   965325E0           MLA      R5,R6,R3,R5
   \   000000F0   975225E0           MLA      R5,R7,R2,R5
   \   000000F4   0540A0E1           MOV      R4,R5
   \   000000F8   ........           STR      R4,[R11], #+4
     97          		} while (over0 < over1);
   \   000000FC   0A005BE1           CMP      R11,R10
   \   00000100   D8FFFF3A           BCC      ??raac_DecWindowOverlapNoClip_1
   \   00000104   F78FBDE8           POP      {R0-R2,R4-R11,PC}
     98          	} else {
     99          		/* different windows for current and overlap parts - should still fit in registers on ARM w/o stack spill */
    100          		wndCurr = (winTypeCurr == 1 ? kbdWindow + kbdWindowOffset[1] : sinWindow + sinWindowOffset[1]);
   \                     ??raac_DecWindowOverlapNoClip_0:
   \   00000108   010053E3           CMP      R3,#+1
   \   0000010C   04109205           LDREQ    R1,[R2, #+4]
   \   00000110   01C18400           ADDEQ    R12,R4,R1, LSL #+2
   \   00000114   04109615           LDRNE    R1,[R6, #+4]
   \   00000118   01C18810           ADDNE    R12,R8,R1, LSL #+2
    101          		do {
    102          			w0 = *wndPrev++;
   \                     ??raac_DecWindowOverlapNoClip_2:
   \   0000011C   ........           LDR      R4,[R0], #+4
    103          			w1 = *wndPrev++;
    104          			in = *buf0++;
   \   00000120   ........           LDR      R2,[LR], #+4
   \   00000124   ........           LDR      R1,[R0], #+4
    105          
    106          			f0 = MULSHIFT32(w0, in);
    107          			f1 = MULSHIFT32(w1, in);
    108          
    109          			in = *over0;	
    110          			*out0++ = in - f0;
   \   00000128   00809BE5           LDR      R8,[R11, #+0]
   \   0000012C   C23FA0E1           ASR      R3,R2,#+31
   \   00000130   C45FA0E1           ASR      R5,R4,#+31
   \   00000134   946287E0           UMULL    R6,R7,R4,R2
   \   00000138   08609DE5           LDR      R6,[SP, #+8]
   \   0000013C   947327E0           MLA      R7,R4,R3,R7
   \   00000140   957227E0           MLA      R7,R5,R2,R7
    111          
    112          			in = *over1;	
    113          			*out1-- = in + f1;
   \   00000144   C15FA0E1           ASR      R5,R1,#+31
   \   00000148   074048E0           SUB      R4,R8,R7
   \   0000014C   ........           STR      R4,[R6], #+4
   \   00000150   08608DE5           STR      R6,[SP, #+8]
   \   00000154   00809AE5           LDR      R8,[R10, #+0]
   \   00000158   0140A0E1           MOV      R4,R1
   \   0000015C   946287E0           UMULL    R6,R7,R4,R2
   \   00000160   947327E0           MLA      R7,R4,R3,R7
   \   00000164   957227E0           MLA      R7,R5,R2,R7
   \   00000168   04209DE5           LDR      R2,[SP, #+4]
   \   0000016C   081087E0           ADD      R1,R7,R8
   \   00000170   ........           STR      R1,[R2], #-4
    114          
    115          			w0 = *wndCurr++;
    116          			w1 = *wndCurr++;
    117          			in = *buf1--;
   \   00000174   00609DE5           LDR      R6,[SP, #+0]
   \   00000178   04208DE5           STR      R2,[SP, #+4]
   \   0000017C   ........           LDR      R4,[R12], #+4
   \   00000180   ........           LDR      R2,[R6], #-4
   \   00000184   ........           LDR      R1,[R12], #+4
   \   00000188   00608DE5           STR      R6,[SP, #+0]
    118          
    119          			*over1-- = MULSHIFT32(w0, in);
   \   0000018C   C23FA0E1           ASR      R3,R2,#+31
   \   00000190   C45FA0E1           ASR      R5,R4,#+31
   \   00000194   946287E0           UMULL    R6,R7,R4,R2
   \   00000198   947327E0           MLA      R7,R4,R3,R7
   \   0000019C   957227E0           MLA      R7,R5,R2,R7
    120          			*over0++ = MULSHIFT32(w1, in);
   \   000001A0   C15FA0E1           ASR      R5,R1,#+31
   \   000001A4   0740A0E1           MOV      R4,R7
   \   000001A8   ........           STR      R4,[R10], #-4
   \   000001AC   0140A0E1           MOV      R4,R1
   \   000001B0   946287E0           UMULL    R6,R7,R4,R2
   \   000001B4   947327E0           MLA      R7,R4,R3,R7
   \   000001B8   957227E0           MLA      R7,R5,R2,R7
   \   000001BC   0760A0E1           MOV      R6,R7
   \   000001C0   ........           STR      R6,[R11], #+4
    121          		} while (over0 < over1);
   \   000001C4   0A005BE1           CMP      R11,R10
   \   000001C8   D3FFFF3A           BCC      ??raac_DecWindowOverlapNoClip_2
    122          	}
    123          }
   \   000001CC   F78FBDE8           POP      {R0-R2,R4-R11,PC}  ;; return
    124          
    125          /**************************************************************************************
    126           * Function:    DecWindowOverlapLongStart
    127           *
    128           * Description: apply synthesis window, do overlap-add, without clipping
    129           *                for winSequence LONG-START
    130           *
    131           * Inputs:      input buffer (output of type-IV DCT)
    132           *              overlap buffer (saved from last time)
    133           *              window type (sin or KBD) for input buffer
    134           *              window type (sin or KBD) for overlap buffer
    135           *
    136           * Outputs:     one channel, one frame of 32-bit PCM, non-interleaved
    137           *
    138           * Return:      none
    139           *
    140           * Notes:       use this function when the decoded PCM is going to the SBR decoder
    141           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    142          void DecWindowOverlapLongStartNoClip(int *buf0, int *over0, int *out0, int winTypeCurr, int winTypePrev)
    143          {
   \                     raac_DecWindowOverlapLongStartNoClip:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   0190A0E1           MOV      R9,R1
   \   00000008   2C109DE5           LDR      R1,[SP, #+44]
    144          	int i,  in, w0, w1, f0, f1;
    145          	int *buf1, *over1, *out1;
    146          	const int *wndPrev, *wndCurr;
    147          
    148          	buf0 += (1024 >> 1);
    149          	buf1  = buf0  - 1;
   \   0000000C   80AE80E2           ADD      R10,R0,#+2048
   \   00000010   04E04AE2           SUB      LR,R10,#+4
    150          	out1  = out0 + 1024 - 1;
   \   00000014   FC00A0E3           MOV      R0,#+252
   \   00000018   F00E80E3           ORR      R0,R0,#0xF00
   \   0000001C   02B080E0           ADD      R11,R0,R2
    151          	over1 = over0 + 1024 - 1;
   \   00000020   090080E0           ADD      R0,R0,R9
   \   00000024   010051E3           CMP      R1,#+1
   \   00000028   0200001A           BNE      ??raac_DecWindowOverlapLongStartNoClip_0
   \   0000002C   74119FE5           LDR      R1,??raac_DecWindowOverlapLongStartNoClip_1  ;; raac_kbdWindowOffset + 4
   \   00000030   ........           LDR      R2,??DataTable15  ;; raac_kbdWindow
   \   00000034   010000EA           B        ??raac_DecWindowOverlapLongStartNoClip_2
   \                     ??raac_DecWindowOverlapLongStartNoClip_0:
   \   00000038   6C119FE5           LDR      R1,??raac_DecWindowOverlapLongStartNoClip_1+0x4  ;; raac_sinWindowOffset + 4
   \   0000003C   ........           LDR      R2,??DataTable16  ;; raac_sinWindow
   \                     ??raac_DecWindowOverlapLongStartNoClip_2:
   \   00000040   001091E5           LDR      R1,[R1, #+0]
    152          
    153          	wndPrev = (winTypePrev == 1 ? kbdWindow + kbdWindowOffset[1] : sinWindow + sinWindowOffset[1]);
    154          	i = 448;	/* 2 outputs, 2 overlaps per loop */
   \   00000044   708FA0E3           MOV      R8,#+448
   \   00000048   011182E0           ADD      R1,R2,R1, LSL #+2
    155          	do {
    156          		w0 = *wndPrev++;
   \                     ??raac_DecWindowOverlapLongStartNoClip_3:
   \   0000004C   ........           LDR      R4,[R1], #+4
    157          		w1 = *wndPrev++;
   \   00000050   ........           LDR      R12,[R1], #+4
    158          		in = *buf0++;
   \   00000054   ........           LDR      R2,[R10], #+4
    159          
    160          		f0 = MULSHIFT32(w0, in);
    161          		f1 = MULSHIFT32(w1, in);
    162          
    163          		in = *over0;	
    164          		*out0++ = in - f0;
   \   00000058   006099E5           LDR      R6,[R9, #+0]
   \   0000005C   C23FA0E1           ASR      R3,R2,#+31
   \   00000060   40002DE9           PUSH     {R6}
   \   00000064   C45FA0E1           ASR      R5,R4,#+31
    165          
    166          		in = *over1;	
    167          		*out1-- = in + f1;
    168          
    169          		in = *buf1--;
    170          
    171          		*over1-- = 0;		/* Wn = 0 for n = (2047, 2046, ... 1600) */
    172          		*over0++ = in >> 1;	/* Wn = 1 for n = (1024, 1025, ... 1471) */
    173          	} while (--i);
   \   00000068   018058E2           SUBS     R8,R8,#+1
   \   0000006C   946287E0           UMULL    R6,R7,R4,R2
   \   00000070   4000BDE8           POP      {R6}
   \   00000074   947327E0           MLA      R7,R4,R3,R7
   \   00000078   957227E0           MLA      R7,R5,R2,R7
   \   0000007C   CC5FA0E1           ASR      R5,R12,#+31
   \   00000080   074046E0           SUB      R4,R6,R7
   \   00000084   00609DE5           LDR      R6,[SP, #+0]
   \   00000088   ........           STR      R4,[R6], #+4
   \   0000008C   00608DE5           STR      R6,[SP, #+0]
   \   00000090   004090E5           LDR      R4,[R0, #+0]
   \   00000094   10002DE9           PUSH     {R4}
   \   00000098   0C40A0E1           MOV      R4,R12
   \   0000009C   946287E0           UMULL    R6,R7,R4,R2
   \   000000A0   947327E0           MLA      R7,R4,R3,R7
   \   000000A4   0030A0E3           MOV      R3,#+0
   \   000000A8   957227E0           MLA      R7,R5,R2,R7
   \   000000AC   0400BDE8           POP      {R2}
   \   000000B0   022087E0           ADD      R2,R7,R2
   \   000000B4   ........           STR      R2,[R11], #-4
   \   000000B8   ........           LDR      R2,[LR], #-4
   \   000000BC   ........           STR      R3,[R0], #-4
   \   000000C0   C220A0E1           ASR      R2,R2,#+1
   \   000000C4   ........           STR      R2,[R9], #+4
   \   000000C8   DFFFFF1A           BNE      ??raac_DecWindowOverlapLongStartNoClip_3
    174          
    175          	wndCurr = (winTypeCurr == 1 ? kbdWindow + kbdWindowOffset[0] : sinWindow + sinWindowOffset[0]);
   \   000000CC   04209DE5           LDR      R2,[SP, #+4]
   \   000000D0   010052E3           CMP      R2,#+1
   \   000000D4   0200001A           BNE      ??raac_DecWindowOverlapLongStartNoClip_4
   \   000000D8   ........           LDR      R2,??DataTable17  ;; raac_kbdWindowOffset
   \   000000DC   ........           LDR      R3,??DataTable15  ;; raac_kbdWindow
   \   000000E0   010000EA           B        ??raac_DecWindowOverlapLongStartNoClip_5
   \                     ??raac_DecWindowOverlapLongStartNoClip_4:
   \   000000E4   ........           LDR      R2,??DataTable14  ;; raac_sinWindowOffset
   \   000000E8   ........           LDR      R3,??DataTable16  ;; raac_sinWindow
   \                     ??raac_DecWindowOverlapLongStartNoClip_5:
   \   000000EC   002092E5           LDR      R2,[R2, #+0]
   \   000000F0   028183E0           ADD      R8,R3,R2, LSL #+2
    176          
    177          	/* do 64 more loops - 2 outputs, 2 overlaps per loop */
    178          	do {
    179          		w0 = *wndPrev++;
   \                     ??raac_DecWindowOverlapLongStartNoClip_6:
   \   000000F4   ........           LDR      R4,[R1], #+4
    180          		w1 = *wndPrev++;
   \   000000F8   ........           LDR      R12,[R1], #+4
    181          		in = *buf0++;
   \   000000FC   ........           LDR      R2,[R10], #+4
    182          
    183          		f0 = MULSHIFT32(w0, in);
    184          		f1 = MULSHIFT32(w1, in);
    185          
    186          		in = *over0;	
    187          		*out0++ = in - f0;
   \   00000100   006099E5           LDR      R6,[R9, #+0]
   \   00000104   C23FA0E1           ASR      R3,R2,#+31
   \   00000108   40002DE9           PUSH     {R6}
   \   0000010C   C45FA0E1           ASR      R5,R4,#+31
   \   00000110   946287E0           UMULL    R6,R7,R4,R2
   \   00000114   947327E0           MLA      R7,R4,R3,R7
   \   00000118   1000BDE8           POP      {R4}
   \   0000011C   00609DE5           LDR      R6,[SP, #+0]
   \   00000120   957227E0           MLA      R7,R5,R2,R7
    188          
    189          		in = *over1;	
    190          		*out1-- = in + f1;
   \   00000124   CC5FA0E1           ASR      R5,R12,#+31
   \   00000128   074044E0           SUB      R4,R4,R7
   \   0000012C   ........           STR      R4,[R6], #+4
   \   00000130   00608DE5           STR      R6,[SP, #+0]
   \   00000134   004090E5           LDR      R4,[R0, #+0]
   \   00000138   10002DE9           PUSH     {R4}
   \   0000013C   0C40A0E1           MOV      R4,R12
   \   00000140   946287E0           UMULL    R6,R7,R4,R2
   \   00000144   947327E0           MLA      R7,R4,R3,R7
   \   00000148   957227E0           MLA      R7,R5,R2,R7
   \   0000014C   0400BDE8           POP      {R2}
   \   00000150   022087E0           ADD      R2,R7,R2
   \   00000154   ........           STR      R2,[R11], #-4
    191          
    192          		w0 = *wndCurr++;	/* W[0], W[1], ... --> W[255], W[254], ... */
   \   00000158   ........           LDR      R4,[R8], #+4
    193          		w1 = *wndCurr++;	/* W[127], W[126], ... --> W[128], W[129], ... */
    194          		in = *buf1--;
   \   0000015C   ........           LDR      R2,[LR], #-4
   \   00000160   ........           LDR      R12,[R8], #+4
    195          
    196          		*over1-- = MULSHIFT32(w0, in);	/* Wn = short window for n = (1599, 1598, ... , 1536) */
   \   00000164   C23FA0E1           ASR      R3,R2,#+31
   \   00000168   C45FA0E1           ASR      R5,R4,#+31
   \   0000016C   946287E0           UMULL    R6,R7,R4,R2
   \   00000170   947327E0           MLA      R7,R4,R3,R7
   \   00000174   957227E0           MLA      R7,R5,R2,R7
    197          		*over0++ = MULSHIFT32(w1, in);	/* Wn = short window for n = (1472, 1473, ... , 1535) */
   \   00000178   CC5FA0E1           ASR      R5,R12,#+31
   \   0000017C   0740A0E1           MOV      R4,R7
   \   00000180   ........           STR      R4,[R0], #-4
   \   00000184   0C40A0E1           MOV      R4,R12
   \   00000188   946287E0           UMULL    R6,R7,R4,R2
   \   0000018C   947327E0           MLA      R7,R4,R3,R7
   \   00000190   957227E0           MLA      R7,R5,R2,R7
   \   00000194   0760A0E1           MOV      R6,R7
   \   00000198   ........           STR      R6,[R9], #+4
    198          	} while (over0 < over1);
   \   0000019C   000059E1           CMP      R9,R0
   \   000001A0   D3FFFF3A           BCC      ??raac_DecWindowOverlapLongStartNoClip_6
    199          }
   \   000001A4   F38FBDE8           POP      {R0,R1,R4-R11,PC}  ;; return
   \                     ??raac_DecWindowOverlapLongStartNoClip_1:
   \   000001A8   ........           DC32     raac_kbdWindowOffset + 4
   \   000001AC   ........           DC32     raac_sinWindowOffset + 4
    200          
    201          /**************************************************************************************
    202           * Function:    DecWindowOverlapLongStop
    203           *
    204           * Description: apply synthesis window, do overlap-add, without clipping
    205           *                for winSequence LONG-STOP
    206           *
    207           * Inputs:      input buffer (output of type-IV DCT)
    208           *              overlap buffer (saved from last time)
    209           *              window type (sin or KBD) for input buffer
    210           *              window type (sin or KBD) for overlap buffer
    211           *
    212           * Outputs:     one channel, one frame of 32-bit PCM, non-interleaved
    213           *
    214           * Return:      none
    215           *
    216           * Notes:       use this function when the decoded PCM is going to the SBR decoder
    217           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    218          void DecWindowOverlapLongStopNoClip(int *buf0, int *over0, int *out0, int winTypeCurr, int winTypePrev)
    219          {
   \                     raac_DecWindowOverlapLongStopNoClip:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
    220          	int i, in, w0, w1, f0, f1;
    221          	int *buf1, *over1, *out1;
    222          	const int *wndPrev, *wndCurr;
    223          
    224          	buf0 += (1024 >> 1);
    225          	buf1  = buf0  - 1;
    226          	out1  = out0 + 1024 - 1;
    227          	over1 = over0 + 1024 - 1;
    228          
    229          	wndPrev = (winTypePrev == 1 ? kbdWindow + kbdWindowOffset[0] : sinWindow + sinWindowOffset[0]);
   \   00000004   ........           LDR      R4,??DataTable14  ;; raac_sinWindowOffset
   \   00000008   ........           LDR      R6,??DataTable16  ;; raac_sinWindow
   \   0000000C   04D04DE2           SUB      SP,SP,#+4
   \   00000010   00B0A0E1           MOV      R11,R0
   \   00000014   2C009DE5           LDR      R0,[SP, #+44]
   \   00000018   80BE8BE2           ADD      R11,R11,#+2048
   \   0000001C   04204BE2           SUB      R2,R11,#+4
   \   00000020   00208DE5           STR      R2,[SP, #+0]
   \   00000024   04209DE5           LDR      R2,[SP, #+4]
   \   00000028   0190A0E1           MOV      R9,R1
   \   0000002C   FC10A0E3           MOV      R1,#+252
   \   00000030   F01E81E3           ORR      R1,R1,#0xF00
   \   00000034   02E081E0           ADD      LR,R1,R2
   \   00000038   ........           LDR      R2,??DataTable15  ;; raac_kbdWindow
   \   0000003C   09C081E0           ADD      R12,R1,R9
   \   00000040   ........           LDR      R1,??DataTable17  ;; raac_kbdWindowOffset
   \   00000044   010050E3           CMP      R0,#+1
   \   00000048   00009105           LDREQ    R0,[R1, #+0]
    230          	wndCurr = (winTypeCurr == 1 ? kbdWindow + kbdWindowOffset[1] : sinWindow + sinWindowOffset[1]);
    231          
    232          	i = 448;	/* 2 outputs, 2 overlaps per loop */
   \   0000004C   708FA0E3           MOV      R8,#+448
   \   00000050   00009415           LDRNE    R0,[R4, #+0]
   \   00000054   00A18200           ADDEQ    R10,R2,R0, LSL #+2
   \   00000058   00A18610           ADDNE    R10,R6,R0, LSL #+2
   \   0000005C   010053E3           CMP      R3,#+1
   \   00000060   04009105           LDREQ    R0,[R1, #+4]
   \   00000064   00618200           ADDEQ    R6,R2,R0, LSL #+2
   \   00000068   04009415           LDRNE    R0,[R4, #+4]
   \   0000006C   00618610           ADDNE    R6,R6,R0, LSL #+2
    233          	do {
    234          		/* Wn = 0 for n = (0, 1, ... 447) */
    235          		/* Wn = 1 for n = (576, 577, ... 1023) */
    236          		in = *buf0++;
    237          		f1 = in >> 1;	/* scale since skipping multiply by Q31 */
    238          
    239          		in = *over0;	
    240          		*out0++ = in;
   \                     ??raac_DecWindowOverlapLongStopNoClip_0:
   \   00000070   002099E5           LDR      R2,[R9, #+0]
   \   00000074   04309DE5           LDR      R3,[SP, #+4]
   \   00000078   ........           LDR      R0,[R11], #+4
   \   0000007C   ........           STR      R2,[R3], #+4
   \   00000080   04308DE5           STR      R3,[SP, #+4]
    241          
    242          		in = *over1;	
    243          		*out1-- = in + f1;
   \   00000084   00109CE5           LDR      R1,[R12, #+0]
    244          
    245          		w0 = *wndCurr++;
    246          		w1 = *wndCurr++;
    247          		in = *buf1--;
    248          
    249          		*over1-- = MULSHIFT32(w0, in);
    250          		*over0++ = MULSHIFT32(w1, in);
    251          	} while (--i);
   \   00000088   018058E2           SUBS     R8,R8,#+1
   \   0000008C   C00081E0           ADD      R0,R1,R0, ASR #+1
   \   00000090   ........           STR      R0,[LR], #-4
   \   00000094   00309DE5           LDR      R3,[SP, #+0]
   \   00000098   ........           LDR      R2,[R6], #+4
   \   0000009C   ........           LDR      R0,[R3], #-4
   \   000000A0   ........           LDR      R7,[R6], #+4
   \   000000A4   00308DE5           STR      R3,[SP, #+0]
   \   000000A8   0040A0E1           MOV      R4,R0
   \   000000AC   C05FA0E1           ASR      R5,R0,#+31
   \   000000B0   0200A0E1           MOV      R0,R2
   \   000000B4   C21FA0E1           ASR      R1,R2,#+31
   \   000000B8   902483E0           UMULL    R2,R3,R0,R4
   \   000000BC   903523E0           MLA      R3,R0,R5,R3
   \   000000C0   913423E0           MLA      R3,R1,R4,R3
   \   000000C4   C71FA0E1           ASR      R1,R7,#+31
   \   000000C8   0300A0E1           MOV      R0,R3
   \   000000CC   ........           STR      R0,[R12], #-4
   \   000000D0   0700A0E1           MOV      R0,R7
   \   000000D4   902483E0           UMULL    R2,R3,R0,R4
   \   000000D8   903523E0           MLA      R3,R0,R5,R3
   \   000000DC   913423E0           MLA      R3,R1,R4,R3
   \   000000E0   0320A0E1           MOV      R2,R3
   \   000000E4   ........           STR      R2,[R9], #+4
   \   000000E8   E0FFFF1A           BNE      ??raac_DecWindowOverlapLongStopNoClip_0
    252          
    253          	/* do 64 more loops - 2 outputs, 2 overlaps per loop */
    254          	do {
    255          		w0 = *wndPrev++;	/* W[0], W[1], ...W[63] */
   \                     ??raac_DecWindowOverlapLongStopNoClip_1:
   \   000000EC   ........           LDR      R0,[R10], #+4
    256          		w1 = *wndPrev++;	/* W[127], W[126], ... W[64] */
    257          		in = *buf0++;
   \   000000F0   ........           LDR      R2,[R11], #+4
   \   000000F4   ........           LDR      R7,[R10], #+4
    258          
    259          		f0 = MULSHIFT32(w0, in);
    260          		f1 = MULSHIFT32(w1, in);
    261          
    262          		in = *over0;	
    263          		*out0++ = in - f0;
   \   000000F8   008099E5           LDR      R8,[R9, #+0]
   \   000000FC   C23FA0E1           ASR      R3,R2,#+31
   \   00000100   C01FA0E1           ASR      R1,R0,#+31
   \   00000104   904285E0           UMULL    R4,R5,R0,R2
   \   00000108   905325E0           MLA      R5,R0,R3,R5
   \   0000010C   915225E0           MLA      R5,R1,R2,R5
   \   00000110   04109DE5           LDR      R1,[SP, #+4]
   \   00000114   050048E0           SUB      R0,R8,R5
   \   00000118   ........           STR      R0,[R1], #+4
   \   0000011C   04108DE5           STR      R1,[SP, #+4]
    264          
    265          		in = *over1;	
    266          		*out1-- = in + f1;
   \   00000120   00809CE5           LDR      R8,[R12, #+0]
   \   00000124   0700A0E1           MOV      R0,R7
   \   00000128   C71FA0E1           ASR      R1,R7,#+31
   \   0000012C   904285E0           UMULL    R4,R5,R0,R2
   \   00000130   905325E0           MLA      R5,R0,R3,R5
   \   00000134   915225E0           MLA      R5,R1,R2,R5
   \   00000138   080085E0           ADD      R0,R5,R8
   \   0000013C   ........           STR      R0,[LR], #-4
    267          
    268          		w0 = *wndCurr++;
    269          		w1 = *wndCurr++;	
    270          		in = *buf1--;
   \   00000140   00309DE5           LDR      R3,[SP, #+0]
   \   00000144   ........           LDR      R2,[R6], #+4
   \   00000148   ........           LDR      R0,[R3], #-4
   \   0000014C   ........           LDR      R7,[R6], #+4
   \   00000150   00308DE5           STR      R3,[SP, #+0]
    271          
    272          		*over1-- = MULSHIFT32(w0, in);
   \   00000154   C01FA0E1           ASR      R1,R0,#+31
   \   00000158   C23FA0E1           ASR      R3,R2,#+31
   \   0000015C   924085E0           UMULL    R4,R5,R2,R0
   \   00000160   925125E0           MLA      R5,R2,R1,R5
    273          		*over0++ = MULSHIFT32(w1, in);
   \   00000164   0720A0E1           MOV      R2,R7
   \   00000168   935025E0           MLA      R5,R3,R0,R5
   \   0000016C   C73FA0E1           ASR      R3,R7,#+31
   \   00000170   0540A0E1           MOV      R4,R5
   \   00000174   ........           STR      R4,[R12], #-4
   \   00000178   924085E0           UMULL    R4,R5,R2,R0
   \   0000017C   925125E0           MLA      R5,R2,R1,R5
   \   00000180   935025E0           MLA      R5,R3,R0,R5
   \   00000184   0540A0E1           MOV      R4,R5
   \   00000188   ........           STR      R4,[R9], #+4
    274          	} while (over0 < over1);
   \   0000018C   0C0059E1           CMP      R9,R12
   \   00000190   D5FFFF3A           BCC      ??raac_DecWindowOverlapLongStopNoClip_1
    275          }
   \   00000194   F38FBDE8           POP      {R0,R1,R4-R11,PC}  ;; return
    276          
    277          /**************************************************************************************
    278           * Function:    DecWindowOverlapShort
    279           *
    280           * Description: apply synthesis window, do overlap-add, without clipping
    281           *                for winSequence EIGHT-SHORT (does all 8 short blocks)
    282           *
    283           * Inputs:      input buffer (output of type-IV DCT)
    284           *              overlap buffer (saved from last time)
    285           *              window type (sin or KBD) for input buffer
    286           *              window type (sin or KBD) for overlap buffer
    287           *
    288           * Outputs:     one channel, one frame of 32-bit PCM, non-interleaved
    289           *
    290           * Return:      none
    291           *
    292           * Notes:       use this function when the decoded PCM is going to the SBR decoder
    293           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    294          void DecWindowOverlapShortNoClip(int *buf0, int *over0, int *out0, int winTypeCurr, int winTypePrev)
    295          {
   \                     raac_DecWindowOverlapShortNoClip:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    296          	int i, in, w0, w1, f0, f1;
    297          	int *buf1, *over1, *out1;
    298          	const int *wndPrev, *wndCurr;
    299          
    300          	wndPrev = (winTypePrev == 1 ? kbdWindow + kbdWindowOffset[0] : sinWindow + sinWindowOffset[0]);
   \   00000004   ........           LDR      R4,??DataTable14  ;; raac_sinWindowOffset
   \   00000008   ........           LDR      R5,??DataTable15  ;; raac_kbdWindow
   \   0000000C   ........           LDR      R6,??DataTable16  ;; raac_sinWindow
   \   00000010   02A0A0E1           MOV      R10,R2
   \   00000014   ........           LDR      R2,??DataTable17  ;; raac_kbdWindowOffset
   \   00000018   0CD04DE2           SUB      SP,SP,#+12
   \   0000001C   002092E5           LDR      R2,[R2, #+0]
   \   00000020   004094E5           LDR      R4,[R4, #+0]
   \   00000024   00B0A0E1           MOV      R11,R0
   \   00000028   30009DE5           LDR      R0,[SP, #+48]
   \   0000002C   010050E3           CMP      R0,#+1
   \   00000030   02E18500           ADDEQ    LR,R5,R2, LSL #+2
   \   00000034   04E18610           ADDNE    LR,R6,R4, LSL #+2
    301          	wndCurr = (winTypeCurr == 1 ? kbdWindow + kbdWindowOffset[0] : sinWindow + sinWindowOffset[0]);
   \   00000038   010053E3           CMP      R3,#+1
   \   0000003C   02C18500           ADDEQ    R12,R5,R2, LSL #+2
   \   00000040   04C18610           ADDNE    R12,R6,R4, LSL #+2
    302          
    303          	/* pcm[0-447] = 0 + overlap[0-447] */
    304          	i = 448;
   \   00000044   702FA0E3           MOV      R2,#+448
   \   00000048   00208DE5           STR      R2,[SP, #+0]
    305          	do {
    306          		f0 = *over0++;
   \                     ??raac_DecWindowOverlapShortNoClip_0:
   \   0000004C   ........           LDR      R0,[R1], #+4
    307          		f1 = *over0++;
   \   00000050   ........           LDR      R2,[R1], #+4
    308          		*out0++ = f0;
   \   00000054   ........           STR      R0,[R10], #+4
    309          		*out0++ = f1;
   \   00000058   ........           STR      R2,[R10], #+4
    310          		i -= 2;
   \   0000005C   00209DE5           LDR      R2,[SP, #+0]
   \   00000060   022042E2           SUB      R2,R2,#+2
   \   00000064   00208DE5           STR      R2,[SP, #+0]
    311          	} while (i);
   \   00000068   000052E3           CMP      R2,#+0
   \   0000006C   F6FFFF1A           BNE      ??raac_DecWindowOverlapShortNoClip_0
    312          
    313          	/* pcm[448-575] = Wp[0-127] * block0[0-127] + overlap[448-575] */
    314          	out1  = out0 + (128 - 1);
   \   00000070   7F2F8AE2           ADD      R2,R10,#+508
   \   00000074   04208DE5           STR      R2,[SP, #+4]
    315          	over1 = over0 + 128 - 1;
   \   00000078   7F0F81E2           ADD      R0,R1,#+508
    316          	buf0 += 64;
    317          	buf1  = buf0  - 1;
   \   0000007C   40BF8BE2           ADD      R11,R11,#+256
   \   00000080   04304BE2           SUB      R3,R11,#+4
   \   00000084   08308DE5           STR      R3,[SP, #+8]
    318          	do {
    319          		w0 = *wndPrev++;	/* W[0], W[1], ...W[63] */
   \                     ??raac_DecWindowOverlapShortNoClip_1:
   \   00000088   ........           LDR      R2,[LR], #+4
    320          		w1 = *wndPrev++;	/* W[127], W[126], ... W[64] */
    321          		in = *buf0++;
   \   0000008C   ........           LDR      R6,[R11], #+4
   \   00000090   ........           LDR      R8,[LR], #+4
    322          
    323          		f0 = MULSHIFT32(w0, in);
    324          		f1 = MULSHIFT32(w1, in);
    325          
    326          		in = *over0;	
    327          		*out0++ = in - f0;
   \   00000094   009091E5           LDR      R9,[R1, #+0]
   \   00000098   C67FA0E1           ASR      R7,R6,#+31
   \   0000009C   C23FA0E1           ASR      R3,R2,#+31
   \   000000A0   924685E0           UMULL    R4,R5,R2,R6
   \   000000A4   925725E0           MLA      R5,R2,R7,R5
   \   000000A8   935625E0           MLA      R5,R3,R6,R5
    328          
    329          		in = *over1;	
    330          		*out1-- = in + f1;
   \   000000AC   C83FA0E1           ASR      R3,R8,#+31
   \   000000B0   052049E0           SUB      R2,R9,R5
   \   000000B4   ........           STR      R2,[R10], #+4
   \   000000B8   009090E5           LDR      R9,[R0, #+0]
   \   000000BC   0820A0E1           MOV      R2,R8
   \   000000C0   924685E0           UMULL    R4,R5,R2,R6
   \   000000C4   925725E0           MLA      R5,R2,R7,R5
   \   000000C8   935625E0           MLA      R5,R3,R6,R5
   \   000000CC   04309DE5           LDR      R3,[SP, #+4]
   \   000000D0   092085E0           ADD      R2,R5,R9
   \   000000D4   ........           STR      R2,[R3], #-4
    331          
    332          		w0 = *wndCurr++;
    333          		w1 = *wndCurr++;
    334          		in = *buf1--;
   \   000000D8   08609DE5           LDR      R6,[SP, #+8]
   \   000000DC   04308DE5           STR      R3,[SP, #+4]
   \   000000E0   ........           LDR      R5,[R12], #+4
   \   000000E4   ........           LDR      R2,[R6], #-4
   \   000000E8   ........           LDR      R4,[R12], #+4
   \   000000EC   08608DE5           STR      R6,[SP, #+8]
    335          
    336          		/* save over0/over1 for next short block, in the slots just vacated */
    337          		*over1-- = MULSHIFT32(w0, in);
   \   000000F0   0280A0E1           MOV      R8,R2
   \   000000F4   C29FA0E1           ASR      R9,R2,#+31
   \   000000F8   0520A0E1           MOV      R2,R5
   \   000000FC   C53FA0E1           ASR      R3,R5,#+31
   \   00000100   926887E0           UMULL    R6,R7,R2,R8
   \   00000104   927927E0           MLA      R7,R2,R9,R7
   \   00000108   937827E0           MLA      R7,R3,R8,R7
    338          		*over0++ = MULSHIFT32(w1, in);
   \   0000010C   C43FA0E1           ASR      R3,R4,#+31
   \   00000110   0720A0E1           MOV      R2,R7
   \   00000114   ........           STR      R2,[R0], #-4
   \   00000118   0420A0E1           MOV      R2,R4
   \   0000011C   924885E0           UMULL    R4,R5,R2,R8
   \   00000120   925925E0           MLA      R5,R2,R9,R5
   \   00000124   935825E0           MLA      R5,R3,R8,R5
   \   00000128   0540A0E1           MOV      R4,R5
   \   0000012C   ........           STR      R4,[R1], #+4
    339          	} while (over0 < over1);
   \   00000130   000051E1           CMP      R1,R0
   \   00000134   D3FFFF3A           BCC      ??raac_DecWindowOverlapShortNoClip_1
    340          
    341          	/* pcm[576-703] = Wc[128-255] * block0[128-255] + Wc[0-127] * block1[0-127] + overlap[576-703] 
    342          	 * pcm[704-831] = Wc[128-255] * block1[128-255] + Wc[0-127] * block2[0-127] + overlap[704-831] 
    343          	 * pcm[832-959] = Wc[128-255] * block2[128-255] + Wc[0-127] * block3[0-127] + overlap[832-959] 
    344          	 */
    345          	for (i = 0; i < 3; i++) {
    346          		out0 += 64;
    347          		out1 = out0 + 128 - 1;
   \                     ??raac_DecWindowOverlapShortNoClip_2:
   \   00000138   40AF8AE2           ADD      R10,R10,#+256
   \   0000013C   7F2F8AE2           ADD      R2,R10,#+508
   \   00000140   04208DE5           STR      R2,[SP, #+4]
    348          		over0 += 64;
    349          		over1 = over0 + 128 - 1;
   \   00000144   401F81E2           ADD      R1,R1,#+256
   \   00000148   7F0F81E2           ADD      R0,R1,#+508
    350          		buf0 += 64;
    351          		buf1 = buf0 - 1;
   \   0000014C   40BF8BE2           ADD      R11,R11,#+256
   \   00000150   04304BE2           SUB      R3,R11,#+4
   \   00000154   08308DE5           STR      R3,[SP, #+8]
    352          		wndCurr -= 128;
   \   00000158   FF20E0E3           MVN      R2,#+255
   \   0000015C   402FC2E3           BIC      R2,R2,#0x100
   \   00000160   0CC082E0           ADD      R12,R2,R12
    353          
    354          		do {
    355          			w0 = *wndCurr++;	/* W[0], W[1], ...W[63] */
   \                     ??raac_DecWindowOverlapShortNoClip_3:
   \   00000164   ........           LDR      R5,[R12], #+4
    356          			w1 = *wndCurr++;	/* W[127], W[126], ... W[64] */
    357          			in = *buf0++;
   \   00000168   ........           LDR      R2,[R11], #+4
    358          
    359          			f0 = MULSHIFT32(w0, in);
    360          			f1 = MULSHIFT32(w1, in);
    361          
    362          			in  = *(over0 - 128);	/* from last short block */
    363          			in += *(over0 + 0);		/* from last full frame */
    364          			*out0++ = in - f0;
   \   0000016C   006091E5           LDR      R6,[R1, #+0]
   \   00000170   0580A0E1           MOV      R8,R5
   \   00000174   ........           LDR      R4,[R12], #+4
   \   00000178   C59FA0E1           ASR      R9,R5,#+31
   \   0000017C   005211E5           LDR      R5,[R1, #-512]
   \   00000180   C23FA0E1           ASR      R3,R2,#+31
   \   00000184   055086E0           ADD      R5,R6,R5
   \   00000188   986287E0           UMULL    R6,R7,R8,R2
    365          
    366          			in  = *(over1 - 128);	/* from last short block */
    367          			in += *(over1 + 0);		/* from last full frame */
    368          			*out1-- = in + f1;
   \   0000018C   0460A0E1           MOV      R6,R4
   \   00000190   987327E0           MLA      R7,R8,R3,R7
   \   00000194   997227E0           MLA      R7,R9,R2,R7
   \   00000198   075045E0           SUB      R5,R5,R7
   \   0000019C   ........           STR      R5,[R10], #+4
   \   000001A0   005090E5           LDR      R5,[R0, #+0]
   \   000001A4   C47FA0E1           ASR      R7,R4,#+31
   \   000001A8   004210E5           LDR      R4,[R0, #-512]
   \   000001AC   04E085E0           ADD      LR,R5,R4
   \   000001B0   964285E0           UMULL    R4,R5,R6,R2
   \   000001B4   965325E0           MLA      R5,R6,R3,R5
   \   000001B8   04309DE5           LDR      R3,[SP, #+4]
   \   000001BC   975225E0           MLA      R5,R7,R2,R5
   \   000001C0   0E2085E0           ADD      R2,R5,LR
   \   000001C4   ........           STR      R2,[R3], #-4
    369          
    370          			/* save over0/over1 for next short block, in the slots just vacated */
    371          			in = *buf1--;
   \   000001C8   08409DE5           LDR      R4,[SP, #+8]
   \   000001CC   04308DE5           STR      R3,[SP, #+4]
   \   000001D0   ........           LDR      R2,[R4], #-4
   \   000001D4   08408DE5           STR      R4,[SP, #+8]
    372          			*over1-- = MULSHIFT32(w0, in);
   \   000001D8   C23FA0E1           ASR      R3,R2,#+31
   \   000001DC   984285E0           UMULL    R4,R5,R8,R2
   \   000001E0   985325E0           MLA      R5,R8,R3,R5
   \   000001E4   995225E0           MLA      R5,R9,R2,R5
   \   000001E8   0540A0E1           MOV      R4,R5
   \   000001EC   ........           STR      R4,[R0], #-4
    373          			*over0++ = MULSHIFT32(w1, in);
   \   000001F0   964285E0           UMULL    R4,R5,R6,R2
   \   000001F4   965325E0           MLA      R5,R6,R3,R5
   \   000001F8   975225E0           MLA      R5,R7,R2,R5
   \   000001FC   0540A0E1           MOV      R4,R5
   \   00000200   ........           STR      R4,[R1], #+4
    374          		} while (over0 < over1);
   \   00000204   000051E1           CMP      R1,R0
   \   00000208   D5FFFF3A           BCC      ??raac_DecWindowOverlapShortNoClip_3
    375          	}
   \   0000020C   00209DE5           LDR      R2,[SP, #+0]
   \   00000210   012082E2           ADD      R2,R2,#+1
   \   00000214   00208DE5           STR      R2,[SP, #+0]
   \   00000218   030052E3           CMP      R2,#+3
   \   0000021C   C5FFFFBA           BLT      ??raac_DecWindowOverlapShortNoClip_2
    376          
    377          	/* pcm[960-1023] = Wc[128-191] * block3[128-191] + Wc[0-63]   * block4[0-63] + overlap[960-1023]  
    378          	 * over[0-63]    = Wc[192-255] * block3[192-255] + Wc[64-127] * block4[64-127]
    379          	 */
    380          	out0 += 64;
   \   00000220   40EF8AE2           ADD      LR,R10,#+256
    381          	over0 -= 832;				/* points at overlap[64] */
    382          	over1 = over0 + 128 - 1;	/* points at overlap[191] */
   \   00000224   FF00E0E3           MVN      R0,#+255
   \   00000228   C00EC0E3           BIC      R0,R0,#0xC00
   \   0000022C   001081E0           ADD      R1,R1,R0
   \   00000230   7F0F81E2           ADD      R0,R1,#+508
    383          	buf0 += 64;
    384          	buf1 = buf0 - 1;
   \   00000234   40BF8BE2           ADD      R11,R11,#+256
   \   00000238   04A04BE2           SUB      R10,R11,#+4
    385          	wndCurr -= 128;
   \   0000023C   FF20E0E3           MVN      R2,#+255
   \   00000240   402FC2E3           BIC      R2,R2,#0x100
   \   00000244   0CC082E0           ADD      R12,R2,R12
    386          	do {
    387          		w0 = *wndCurr++;	/* W[0], W[1], ...W[63] */
   \                     ??raac_DecWindowOverlapShortNoClip_4:
   \   00000248   ........           LDR      R5,[R12], #+4
    388          		w1 = *wndCurr++;	/* W[127], W[126], ... W[64] */
    389          		in = *buf0++;
   \   0000024C   ........           LDR      R2,[R11], #+4
    390          
    391          		f0 = MULSHIFT32(w0, in);
    392          		f1 = MULSHIFT32(w1, in);
    393          
    394          		in  = *(over0 + 768);	/* from last short block */
    395          		in += *(over0 + 896);	/* from last full frame */
    396          		*out0++ = in - f0;
   \   00000250   006E91E5           LDR      R6,[R1, #+3584]
   \   00000254   0580A0E1           MOV      R8,R5
   \   00000258   ........           LDR      R4,[R12], #+4
   \   0000025C   C59FA0E1           ASR      R9,R5,#+31
   \   00000260   005C91E5           LDR      R5,[R1, #+3072]
   \   00000264   C23FA0E1           ASR      R3,R2,#+31
   \   00000268   055086E0           ADD      R5,R6,R5
   \   0000026C   986287E0           UMULL    R6,R7,R8,R2
    397          
    398          		in  = *(over1 + 768);	/* from last short block */
    399          		*(over1 - 128) = in + f1;
   \   00000270   0460A0E1           MOV      R6,R4
   \   00000274   987327E0           MLA      R7,R8,R3,R7
   \   00000278   997227E0           MLA      R7,R9,R2,R7
   \   0000027C   075045E0           SUB      R5,R5,R7
   \   00000280   ........           STR      R5,[LR], #+4
   \   00000284   C47FA0E1           ASR      R7,R4,#+31
   \   00000288   004C90E5           LDR      R4,[R0, #+3072]
   \   0000028C   10002DE9           PUSH     {R4}
   \   00000290   964285E0           UMULL    R4,R5,R6,R2
   \   00000294   965325E0           MLA      R5,R6,R3,R5
   \   00000298   0800BDE8           POP      {R3}
   \   0000029C   975225E0           MLA      R5,R7,R2,R5
   \   000002A0   032085E0           ADD      R2,R5,R3
   \   000002A4   002200E5           STR      R2,[R0, #-512]
    400          
    401          		in = *buf1--;
   \   000002A8   ........           LDR      R2,[R10], #-4
    402          		*over1-- = MULSHIFT32(w0, in);	/* save in overlap[128-191] */
   \   000002AC   C23FA0E1           ASR      R3,R2,#+31
   \   000002B0   984285E0           UMULL    R4,R5,R8,R2
   \   000002B4   985325E0           MLA      R5,R8,R3,R5
   \   000002B8   995225E0           MLA      R5,R9,R2,R5
   \   000002BC   0540A0E1           MOV      R4,R5
   \   000002C0   ........           STR      R4,[R0], #-4
    403          		*over0++ = MULSHIFT32(w1, in);	/* save in overlap[64-127] */
   \   000002C4   964285E0           UMULL    R4,R5,R6,R2
   \   000002C8   965325E0           MLA      R5,R6,R3,R5
   \   000002CC   975225E0           MLA      R5,R7,R2,R5
   \   000002D0   0540A0E1           MOV      R4,R5
   \   000002D4   ........           STR      R4,[R1], #+4
    404          	} while (over0 < over1);
   \   000002D8   000051E1           CMP      R1,R0
   \   000002DC   D9FFFF3A           BCC      ??raac_DecWindowOverlapShortNoClip_4
    405          	
    406          	/* over0 now points at overlap[128] */
    407          	
    408          	/* over[64-191]   = Wc[128-255] * block4[128-255] + Wc[0-127] * block5[0-127] 
    409          	 * over[192-319]  = Wc[128-255] * block5[128-255] + Wc[0-127] * block6[0-127]
    410          	 * over[320-447]  = Wc[128-255] * block6[128-255] + Wc[0-127] * block7[0-127]  
    411          	 * over[448-576]  = Wc[128-255] * block7[128-255]
    412          	 */
    413          	for (i = 0; i < 3; i++) {
   \   000002E0   00E0A0E3           MOV      LR,#+0
    414          		over0 += 64;
    415          		over1 = over0 + 128 - 1;
   \                     ??raac_DecWindowOverlapShortNoClip_5:
   \   000002E4   401F81E2           ADD      R1,R1,#+256
   \   000002E8   7F0F81E2           ADD      R0,R1,#+508
    416          		buf0 += 64;
    417          		buf1 = buf0 - 1;
   \   000002EC   40BF8BE2           ADD      R11,R11,#+256
   \   000002F0   04A04BE2           SUB      R10,R11,#+4
    418          		wndCurr -= 128;
   \   000002F4   FF20E0E3           MVN      R2,#+255
   \   000002F8   402FC2E3           BIC      R2,R2,#0x100
   \   000002FC   0CC082E0           ADD      R12,R2,R12
    419          		do {
    420          			w0 = *wndCurr++;	/* W[0], W[1], ...W[63] */
   \                     ??raac_DecWindowOverlapShortNoClip_6:
   \   00000300   ........           LDR      R5,[R12], #+4
    421          			w1 = *wndCurr++;	/* W[127], W[126], ... W[64] */
    422          			in = *buf0++;
   \   00000304   ........           LDR      R2,[R11], #+4
   \   00000308   ........           LDR      R4,[R12], #+4
    423          
    424          			f0 = MULSHIFT32(w0, in);
    425          			f1 = MULSHIFT32(w1, in);
    426          
    427          			/* from last short block */
    428          			*(over0 - 128) -= f0;
   \   0000030C   C23FA0E1           ASR      R3,R2,#+31
   \   00000310   0580A0E1           MOV      R8,R5
   \   00000314   C59FA0E1           ASR      R9,R5,#+31
   \   00000318   005211E5           LDR      R5,[R1, #-512]
   \   0000031C   986287E0           UMULL    R6,R7,R8,R2
    429          			*(over1 - 128)+= f1;
   \   00000320   0460A0E1           MOV      R6,R4
   \   00000324   987327E0           MLA      R7,R8,R3,R7
   \   00000328   997227E0           MLA      R7,R9,R2,R7
   \   0000032C   075045E0           SUB      R5,R5,R7
   \   00000330   005201E5           STR      R5,[R1, #-512]
   \   00000334   C47FA0E1           ASR      R7,R4,#+31
   \   00000338   004210E5           LDR      R4,[R0, #-512]
   \   0000033C   10002DE9           PUSH     {R4}
   \   00000340   964285E0           UMULL    R4,R5,R6,R2
   \   00000344   965325E0           MLA      R5,R6,R3,R5
   \   00000348   0800BDE8           POP      {R3}
   \   0000034C   975225E0           MLA      R5,R7,R2,R5
   \   00000350   032085E0           ADD      R2,R5,R3
   \   00000354   002200E5           STR      R2,[R0, #-512]
    430          
    431          			in = *buf1--;
   \   00000358   ........           LDR      R2,[R10], #-4
    432          			*over1-- = MULSHIFT32(w0, in);
   \   0000035C   C23FA0E1           ASR      R3,R2,#+31
   \   00000360   984285E0           UMULL    R4,R5,R8,R2
   \   00000364   985325E0           MLA      R5,R8,R3,R5
   \   00000368   995225E0           MLA      R5,R9,R2,R5
   \   0000036C   0540A0E1           MOV      R4,R5
   \   00000370   ........           STR      R4,[R0], #-4
    433          			*over0++ = MULSHIFT32(w1, in);
   \   00000374   964285E0           UMULL    R4,R5,R6,R2
   \   00000378   965325E0           MLA      R5,R6,R3,R5
   \   0000037C   975225E0           MLA      R5,R7,R2,R5
   \   00000380   0540A0E1           MOV      R4,R5
   \   00000384   ........           STR      R4,[R1], #+4
    434          		} while (over0 < over1);
   \   00000388   000051E1           CMP      R1,R0
   \   0000038C   DBFFFF3A           BCC      ??raac_DecWindowOverlapShortNoClip_6
    435          	}
   \   00000390   01E08EE2           ADD      LR,LR,#+1
   \   00000394   03005EE3           CMP      LR,#+3
   \   00000398   D1FFFFBA           BLT      ??raac_DecWindowOverlapShortNoClip_5
    436          
    437          	/* over[576-1024] = 0 */ 
    438          	i = 448;
   \   0000039C   700FA0E3           MOV      R0,#+448
    439          	over0 += 64;
   \   000003A0   401F81E2           ADD      R1,R1,#+256
   \   000003A4   0020A0E3           MOV      R2,#+0
    440          	do {
    441          		*over0++ = 0;
   \                     ??raac_DecWindowOverlapShortNoClip_7:
   \   000003A8   ........           STR      R2,[R1], #+4
    442          		*over0++ = 0;
   \   000003AC   ........           STR      R2,[R1], #+4
    443          		*over0++ = 0;
   \   000003B0   ........           STR      R2,[R1], #+4
    444          		*over0++ = 0;
   \   000003B4   ........           STR      R2,[R1], #+4
    445          		i -= 4;
   \   000003B8   040050E2           SUBS     R0,R0,#+4
    446          	} while (i);
   \   000003BC   F9FFFF1A           BNE      ??raac_DecWindowOverlapShortNoClip_7
    447          }
   \   000003C0   F78FBDE8           POP      {R0-R2,R4-R11,PC}  ;; return

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   ........           DC32     raac_sinWindowOffset

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     raac_kbdWindow

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   ........           DC32     raac_sinWindow

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     raac_kbdWindowOffset

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     raac_DecWindowOverlapLongStartNoClip
                                       48
     raac_DecWindowOverlapLongStopNoClip
                                       44
     raac_DecWindowOverlapNoClip       48
     raac_DecWindowOverlapShortNoClip
                                       52


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     raac_DecWindowOverlapNoClip     464
     raac_DecWindowOverlapLongStartNoClip
                                     432
     raac_DecWindowOverlapLongStopNoClip
                                     408
     raac_DecWindowOverlapShortNoClip
                                     964
     ??DataTable14                     4
     ??DataTable15                     4
     ??DataTable16                     4
     ??DataTable17                     4
      Others                          16

 
 2 300 bytes in segment CODE
 
 2 284 bytes of CODE memory (+ 16 bytes shared)

Errors: none
Warnings: none
