//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   14/Feb/2012  15:39:50 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\MP3\mp3d /
//                       ec\scalfact.c                                       /
//    Command line    =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\MP3\mp3d /
//                       ec\scalfact.c -D NDEBUG -lC                         /
//                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\ -lA D:\SVN\SieELF\SieELF\x65_PCM_Player\Playe /
//                       r\Release\List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Pla /
//                       yer\Player\Release\Obj\ -s9 --cpu_mode arm          /
//                       --endian little --cpu ARM926EJ-S --stack_align 4    /
//                       --interwork -e --fpu None --dlib_config             /
//                       "D:\Program Files\IAR\Embedded Workbench 4.0        /
//                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude      /
//                       swilib.h -I "D:\Program Files\IAR\Embedded          /
//                       Workbench 4.0 Evaluation\ARM\INC\"                  /
//                       --inline_threshold=16                               /
//    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\scalfact.s79                                   /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME scalfact

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        MULTWEAK ??xmp3_CalcBitsUsed??rA
        MULTWEAK ??xmp3_GetBits??rA
        MULTWEAK ??xmp3_SetBitstreamPointer??rA
        MULTWEAK ??xmp3_UnpackScaleFactors??rT
        FUNCTION UnpackSFMPEG1,0203H
        LOCFRAME CSTACK, 36, STACK
        FUNCTION UnpackSFMPEG2,0203H
        LOCFRAME CSTACK, 72, STACK
        PUBLIC xmp3_UnpackScaleFactors
        FUNCTION xmp3_UnpackScaleFactors,0203H
        LOCFRAME CSTACK, 72, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
xmp3_CalcBitsUsed   SYMBOL "xmp3_CalcBitsUsed"
xmp3_GetBits        SYMBOL "xmp3_GetBits"
xmp3_SetBitstreamPointer SYMBOL "xmp3_SetBitstreamPointer"
??xmp3_CalcBitsUsed??rA SYMBOL "??rA", xmp3_CalcBitsUsed
??xmp3_GetBits??rA  SYMBOL "??rA", xmp3_GetBits
??xmp3_SetBitstreamPointer??rA SYMBOL "??rA", xmp3_SetBitstreamPointer
xmp3_UnpackScaleFactors SYMBOL "xmp3_UnpackScaleFactors"
??xmp3_UnpackScaleFactors??rT SYMBOL "??rT", xmp3_UnpackScaleFactors

        EXTERN xmp3_CalcBitsUsed
        FUNCTION xmp3_CalcBitsUsed,0202H
        EXTERN xmp3_GetBits
        FUNCTION xmp3_GetBits,0202H
        EXTERN xmp3_SetBitstreamPointer
        FUNCTION xmp3_SetBitstreamPointer,0202H

// D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\MP3\mp3dec\scalfact.c
//    1 /* ***** BEGIN LICENSE BLOCK ***** 
//    2  * Version: RCSL 1.0/RPSL 1.0 
//    3  *  
//    4  * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
//    5  *      
//    6  * The contents of this file, and the files included with this file, are 
//    7  * subject to the current version of the RealNetworks Public Source License 
//    8  * Version 1.0 (the "RPSL") available at 
//    9  * http://www.helixcommunity.org/content/rpsl unless you have licensed 
//   10  * the file under the RealNetworks Community Source License Version 1.0 
//   11  * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
//   12  * in which case the RCSL will apply. You may also obtain the license terms 
//   13  * directly from RealNetworks.  You may not use this file except in 
//   14  * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
//   15  * applicable to this file, the RCSL.  Please see the applicable RPSL or 
//   16  * RCSL for the rights, obligations and limitations governing use of the 
//   17  * contents of the file.  
//   18  *  
//   19  * This file is part of the Helix DNA Technology. RealNetworks is the 
//   20  * developer of the Original Code and owns the copyrights in the portions 
//   21  * it created. 
//   22  *  
//   23  * This file, and the files included with this file, is distributed and made 
//   24  * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
//   25  * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
//   26  * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
//   27  * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
//   28  * 
//   29  * Technology Compatibility Kit Test Suite(s) Location: 
//   30  *    http://www.helixcommunity.org/content/tck 
//   31  * 
//   32  * Contributor(s): 
//   33  *  
//   34  * ***** END LICENSE BLOCK ***** */ 
//   35 
//   36 /**************************************************************************************
//   37  * Fixed-point MP3 decoder
//   38  * Jon Recker (jrecker@real.com), Ken Cooke (kenc@real.com)
//   39  * June 2003
//   40  *
//   41  * scalfact.c - scalefactor unpacking functions
//   42  **************************************************************************************/
//   43 
//   44 #include "coder.h"
//   45 
//   46 /* scale factor lengths (num bits) */

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//   47 static const char SFLenTab[16][2] = {
SFLenTab:
        DATA
        DC8 0, 0, 0, 1, 0, 2, 0, 3, 3, 0, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 3, 3
        DC8 1, 3, 2, 3, 3, 4, 2, 4, 3

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??UnpackSFMPEG1??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE UnpackSFMPEG1
//   48 	{0, 0},    {0, 1},
//   49 	{0, 2},    {0, 3},
//   50 	{3, 0},    {1, 1},
//   51 	{1, 2},    {1, 3},
//   52 	{2, 1},    {2, 2},
//   53 	{2, 3},    {3, 1},
//   54 	{3, 2},    {3, 3},
//   55 	{4, 2},    {4, 3},
//   56 };
//   57 
//   58 /**************************************************************************************
//   59  * Function:    UnpackSFMPEG1
//   60  *
//   61  * Description: unpack MPEG 1 scalefactors from bitstream
//   62  *
//   63  * Inputs:      BitStreamInfo, SideInfoSub, ScaleFactorInfoSub structs for this
//   64  *                granule/channel
//   65  *              vector of scfsi flags from side info, length = 4 (MAX_SCFBD)
//   66  *              index of current granule
//   67  *              ScaleFactorInfoSub from granule 0 (for granule 1, if scfsi[i] is set, 
//   68  *                then we just replicate the scale factors from granule 0 in the
//   69  *                i'th set of scalefactor bands)
//   70  *
//   71  * Outputs:     updated BitStreamInfo struct
//   72  *              scalefactors in sfis (short and/or long arrays, as appropriate)
//   73  *
//   74  * Return:      none
//   75  *
//   76  * Notes:       set order of short blocks to s[band][window] instead of s[window][band]
//   77  *                so that we index through consectutive memory locations when unpacking 
//   78  *                (make sure dequantizer follows same convention)
//   79  *              Illegal Intensity Position = 7 (always) for MPEG1 scale factors
//   80  **************************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function UnpackSFMPEG1
        ARM
//   81 static void UnpackSFMPEG1(BitStreamInfo *bsi, SideInfoSub *sis, ScaleFactorInfoSub *sfis, int *scfsi, int gr, ScaleFactorInfoSub *sfisGr0)
//   82 {
UnpackSFMPEG1:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        MOV      R5,R2
        LDR      R2,[R1, #+12]
        LDR      R7,[SP, #+40]
        MOV      R6,R3
        LDR      R3,??UnpackSFMPEG1_0  ;; SFLenTab
        MOV      R4,R0
        LDR      R0,[SP, #+36]
        ADD      R2,R3,R2, LSL #+1
        LDRB     R8,[R2, #+0]
//   83 	int sfb;
//   84 	int slen0, slen1;
//   85 	
//   86 	/* these can be 0, so make sure GetBits(bsi, 0) returns 0 (no >> 32 or anything) */
//   87 	slen0 = (int)SFLenTab[sis->sfCompress][0];
//   88 	slen1 = (int)SFLenTab[sis->sfCompress][1];
        LDRB     R9,[R2, #+1]
//   89 	
//   90 	if (sis->blockType == 2) {
        LDR      R2,[R1, #+20]
        MOV      R10,#+0
        CMP      R2,#+2
        BNE      ??UnpackSFMPEG1_1
//   91 		/* short block, type 2 (implies winSwitchFlag == 1) */
//   92 		if (sis->mixedBlock) {          
        LDR      R0,[R1, #+24]
        CMP      R0,#+0
        BEQ      ??UnpackSFMPEG1_2
//   93 			/* do long block portion */
//   94 			for (sfb = 0; sfb < 8; sfb++)
        MOV      R6,#+0
//   95 				sfis->l[sfb] =    (char)GetBits(bsi, slen0);
??UnpackSFMPEG1_3:
        MOV      R1,R8
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R6, +R5]
        ADD      R6,R6,#+1
        CMP      R6,#+8
        BLT      ??UnpackSFMPEG1_3
//   96 			sfb = 3;
        MOV      R11,#+3
        B        ??UnpackSFMPEG1_4
//   97 		} else {
//   98 			/* all short blocks */
//   99 			sfb = 0;
??UnpackSFMPEG1_2:
        MOV      R11,#+0
//  100 		}
//  101 
//  102 		for (      ; sfb < 6; sfb++) {
//  103 			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
??UnpackSFMPEG1_4:
        ADD      R0,R11,R11, LSL #+1
        ADD      R6,R0,R5
        MOV      R1,R8
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R6, #+23]
//  104 			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
        MOV      R1,R8
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R6, #+24]
//  105 			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
        MOV      R1,R8
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R6, #+25]
//  106 		}
        ADD      R11,R11,#+1
        CMP      R11,#+6
        BLT      ??UnpackSFMPEG1_4
//  107 
//  108 		for (      ; sfb < 12; sfb++) {
??UnpackSFMPEG1_5:
        CMP      R11,#+12
        BGE      ??UnpackSFMPEG1_6
//  109 			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
        ADD      R0,R11,R11, LSL #+1
        ADD      R6,R0,R5
        MOV      R1,R9
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R6, #+23]
//  110 			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
        MOV      R1,R9
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R6, #+24]
//  111 			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
        MOV      R1,R9
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R6, #+25]
//  112 		}
        ADD      R11,R11,#+1
        B        ??UnpackSFMPEG1_5
//  113 
//  114 		/* last sf band not transmitted */
//  115 		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
??UnpackSFMPEG1_6:
        STRB     R10,[R5, #+61]
        STRB     R10,[R5, #+60]
        STRB     R10,[R5, #+59]
        POP      {R4-R11,PC}
//  116 	} else {
//  117 		/* long blocks, type 0, 1, or 3 */
//  118 		if(gr == 0) {
??UnpackSFMPEG1_1:
        CMP      R0,#+0
        BNE      ??UnpackSFMPEG1_7
//  119 			/* first granule */
//  120 			for (sfb = 0;  sfb < 11; sfb++) 
        MOV      R6,#+0
//  121 				sfis->l[sfb] = (char)GetBits(bsi, slen0);
??UnpackSFMPEG1_8:
        MOV      R1,R8
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R6, +R5]
        ADD      R6,R6,#+1
        CMP      R6,#+11
        BLT      ??UnpackSFMPEG1_8
//  122 			for (sfb = 11; sfb < 21; sfb++) 
        MOV      R11,#+11
//  123 				sfis->l[sfb] = (char)GetBits(bsi, slen1);
??UnpackSFMPEG1_9:
        MOV      R1,R9
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R11, +R5]
        ADD      R11,R11,#+1
        CMP      R11,#+21
        POPGE    {R4-R11,PC}
        B        ??UnpackSFMPEG1_9
//  124 			return;
//  125 		} else {
//  126 			/* second granule
//  127 			 * scfsi: 0 = different scalefactors for each granule, 1 = copy sf's from granule 0 into granule 1 
//  128 			 * for block type == 2, scfsi is always 0
//  129 			 */
//  130 			sfb = 0;
//  131 			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
??UnpackSFMPEG1_7:
        LDR      R0,[R6, #+0]
        MOV      R11,#+0
        CMP      R0,#+0
        BEQ      ??UnpackSFMPEG1_10
??UnpackSFMPEG1_11:
        LDRB     R0,[R11, +R7]
        STRB     R0,[R11, +R5]
        ADD      R11,R11,#+1
        CMP      R11,#+6
        BGE      ??UnpackSFMPEG1_12
        B        ??UnpackSFMPEG1_11
//  132 			else          for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
??UnpackSFMPEG1_10:
        MOV      R1,R8
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R11, +R5]
        ADD      R11,R11,#+1
        CMP      R11,#+6
        BLT      ??UnpackSFMPEG1_10
//  133 			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
??UnpackSFMPEG1_12:
        LDR      R0,[R6, #+4]
        CMP      R0,#+0
        BEQ      ??UnpackSFMPEG1_13
??UnpackSFMPEG1_14:
        CMP      R11,#+11
        BGE      ??UnpackSFMPEG1_15
        LDRB     R0,[R11, +R7]
        STRB     R0,[R11, +R5]
        ADD      R11,R11,#+1
        B        ??UnpackSFMPEG1_14
//  134 			else          for(  ; sfb <11 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
??UnpackSFMPEG1_16:
        MOV      R1,R8
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R11, +R5]
        ADD      R11,R11,#+1
??UnpackSFMPEG1_13:
        CMP      R11,#+11
        BLT      ??UnpackSFMPEG1_16
//  135 			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
??UnpackSFMPEG1_15:
        LDR      R0,[R6, #+8]
        CMP      R0,#+0
        BEQ      ??UnpackSFMPEG1_17
??UnpackSFMPEG1_18:
        CMP      R11,#+16
        BGE      ??UnpackSFMPEG1_19
        LDRB     R0,[R11, +R7]
        STRB     R0,[R11, +R5]
        ADD      R11,R11,#+1
        B        ??UnpackSFMPEG1_18
//  136 			else          for(  ; sfb <16 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
??UnpackSFMPEG1_20:
        MOV      R1,R9
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R11, +R5]
        ADD      R11,R11,#+1
??UnpackSFMPEG1_17:
        CMP      R11,#+16
        BLT      ??UnpackSFMPEG1_20
//  137 			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
??UnpackSFMPEG1_19:
        LDR      R0,[R6, #+12]
        CMP      R0,#+0
        BEQ      ??UnpackSFMPEG1_21
??UnpackSFMPEG1_22:
        CMP      R11,#+21
        BGE      ??UnpackSFMPEG1_23
        LDRB     R0,[R11, +R7]
        STRB     R0,[R11, +R5]
        ADD      R11,R11,#+1
        B        ??UnpackSFMPEG1_22
//  138 			else          for(  ; sfb <21 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
??UnpackSFMPEG1_24:
        MOV      R1,R9
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R11, +R5]
        ADD      R11,R11,#+1
??UnpackSFMPEG1_21:
        CMP      R11,#+21
        BLT      ??UnpackSFMPEG1_24
//  139 		}
//  140 		/* last sf band not transmitted */
//  141 		sfis->l[21] = 0;
??UnpackSFMPEG1_23:
        STRB     R10,[R5, #+21]
//  142 		sfis->l[22] = 0;
        STRB     R10,[R5, #+22]
        POP      {R4-R11,PC}      ;; return
        DATA
??UnpackSFMPEG1_0:
        DC32     SFLenTab
        CFI EndBlock cfiBlock1
//  143 	}
//  144 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??UnpackSFMPEG2??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE UnpackSFMPEG2
//  145 
//  146 /* NRTab[size + 3*is_right][block type][partition]
//  147  *   block type index: 0 = (bt0,bt1,bt3), 1 = bt2 non-mixed, 2 = bt2 mixed
//  148  *   partition: scale factor groups (sfb1 through sfb4)
//  149  * for block type = 2 (mixed or non-mixed) / by 3 is rolled into this table
//  150  *   (for 3 short blocks per long block)
//  151  * see 2.4.3.2 in MPEG 2 (low sample rate) spec
//  152  * stuff rolled into this table:
//  153  *   NRTab[x][1][y]   --> (NRTab[x][1][y])   / 3
//  154  *   NRTab[x][2][>=1] --> (NRTab[x][2][>=1]) / 3  (first partition is long block)
//  155  */

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//  156 static const char NRTab[6][3][4] = {
NRTab:
        DATA
        DC8 6, 5, 5, 5, 3, 3, 3, 3, 6, 3, 3, 3, 6, 5, 7, 3, 3, 3, 4, 2, 6, 3, 4
        DC8 2, 11, 10, 0, 0, 6, 6, 0, 0, 6, 3, 6, 0, 7, 7, 7, 0, 4, 4, 4, 0, 6
        DC8 5, 4, 0, 6, 6, 6, 3, 4, 3, 3, 2, 6, 4, 3, 2, 8, 8, 5, 0, 5, 4, 3, 0
        DC8 6, 6, 3, 0
//  157 	/* non-intensity stereo */
//  158 	{	{6, 5, 5, 5},		
//  159 		{3, 3, 3, 3},	/* includes / 3 */	
//  160 		{6, 3, 3, 3},   /* includes / 3 except for first entry */
//  161 	},
//  162 	{	{6, 5, 7, 3}, 
//  163 		{3, 3, 4, 2},
//  164 		{6, 3, 4, 2},
//  165 	},
//  166 	{	{11, 10, 0, 0},
//  167 		{6, 6, 0, 0},
//  168 		{6, 3, 6, 0},  /* spec = [15,18,0,0], but 15 = 6L + 9S, so move 9/3=3 into col 1, 18/3=6 into col 2 and adj. slen[1,2] below */
//  169 	},
//  170 	/* intensity stereo, right chan */
//  171 	{	{7, 7, 7, 0},
//  172 		{4, 4, 4, 0},
//  173 		{6, 5, 4, 0},
//  174 	},
//  175 	{	{6, 6, 6, 3}, 
//  176 		{4, 3, 3, 2},
//  177 		{6, 4, 3, 2},
//  178 	},
//  179 	{	{8, 8, 5, 0},
//  180 		{5, 4, 3, 0},
//  181 		{6, 6, 3, 0},
//  182 	}
//  183 };
//  184 
//  185 /**************************************************************************************
//  186  * Function:    UnpackSFMPEG2
//  187  *
//  188  * Description: unpack MPEG 2 scalefactors from bitstream
//  189  *
//  190  * Inputs:      BitStreamInfo, SideInfoSub, ScaleFactorInfoSub structs for this
//  191  *                granule/channel
//  192  *              index of current granule and channel
//  193  *              ScaleFactorInfoSub from this granule 
//  194  *              modeExt field from frame header, to tell whether intensity stereo is on
//  195  *              ScaleFactorJS struct for storing IIP info used in Dequant()
//  196  *
//  197  * Outputs:     updated BitStreamInfo struct
//  198  *              scalefactors in sfis (short and/or long arrays, as appropriate)
//  199  *              updated intensityScale and preFlag flags
//  200  *
//  201  * Return:      none
//  202  *
//  203  * Notes:       Illegal Intensity Position = (2^slen) - 1 for MPEG2 scale factors
//  204  *
//  205  * TODO:        optimize the / and % stuff (only do one divide, get modulo x 
//  206  *                with (x / m) * m, etc.)
//  207  **************************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function UnpackSFMPEG2
        ARM
//  208 static void UnpackSFMPEG2(BitStreamInfo *bsi, SideInfoSub *sis, ScaleFactorInfoSub *sfis, int gr, int ch, int modeExt, ScaleFactorJS *sfjs)
//  209 {
UnpackSFMPEG2:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+36
        CFI CFA R13+72
//  210 
//  211 	int i, sfb, sfcIdx, btIdx, nrIdx, iipTest;
//  212 	int slen[4], nr[4];
//  213 	int sfCompress, preFlag, intensityScale;
//  214 	
//  215 	sfCompress = sis->sfCompress;
        LDR      LR,[R1, #+12]
//  216 	preFlag = 0;
//  217 	intensityScale = 0;
//  218 
//  219 	/* stereo mode bits (1 = on): bit 1 = mid-side on/off, bit 0 = intensity on/off */
//  220 	if (! ((modeExt & 0x01) && (ch == 1)) ) {
        LDR      R7,[R1, #+24]
        MOV      R4,R0
        LDR      R0,[SP, #+76]
        MOV      R5,R2
        LDR      R2,[SP, #+80]
        MOV      R3,#+0
        MOV      R12,#+0
        MOV      R6,R3
        TST      R0,#0x1
        BEQ      ??UnpackSFMPEG2_0
        LDR      R8,[SP, #+72]
        CMP      R8,#+1
        BEQ      ??UnpackSFMPEG2_1
//  221 		/* in other words: if ((modeExt & 0x01) == 0 || ch == 0) */
//  222 		if (sfCompress < 400) {
??UnpackSFMPEG2_0:
        CMP      LR,#+400
        BGE      ??UnpackSFMPEG2_2
//  223 			/* max slen = floor[(399/16) / 5] = 4 */
//  224 			slen[0] = (sfCompress >> 4) / 5;
        LDR      R9,??UnpackSFMPEG2_3  ;; 0x66666667
        ASR      R8,LR,#+4
        SMULL    R10,R11,R9,R8
        ASR      R11,R11,#+1
        ADD      R9,R11,R8, LSR #+31
        STR      R9,[SP, #+0]
//  225 			slen[1]= (sfCompress >> 4) % 5;
        LDR      R9,??UnpackSFMPEG2_3  ;; 0x66666667
        SMULL    R10,R11,R8,R9
        MOV      R10,#+5
        ASR      R11,R11,#+1
        ADD      R11,R11,R8, LSR #+31
        MUL      R11,R10,R11
//  226 			slen[2]= (sfCompress & 0x0f) >> 2;
        AND      R9,LR,#0xF
        SUB      R8,R8,R11
        STR      R8,[SP, #+4]
        ASR      R9,R9,#+2
        STR      R9,[SP, #+8]
//  227 			slen[3]= (sfCompress & 0x03);
        AND      R9,LR,#0x3
        STR      R9,[SP, #+12]
//  228 			sfcIdx = 0;
        MOV      R8,#+0
        B        ??UnpackSFMPEG2_4
//  229 		} else if (sfCompress < 500) {
??UnpackSFMPEG2_2:
        CMP      LR,#+500
        BGE      ??UnpackSFMPEG2_5
//  230 			/* max slen = floor[(99/4) / 5] = 4 */
//  231 			sfCompress -= 400;
//  232 			slen[0] = (sfCompress >> 2) / 5;
        LDR      R9,??UnpackSFMPEG2_3  ;; 0x66666667
        MVN      R8,#+143
        BIC      R8,R8,#0x100
        ADD      LR,R8,LR
        ASR      R8,LR,#+2
        SMULL    R10,R11,R9,R8
//  233 			slen[1]= (sfCompress >> 2) % 5;
//  234 			slen[2]= (sfCompress & 0x03);
//  235 			slen[3]= 0;
        STR      R6,[SP, #+12]
        ASR      R11,R11,#+1
        ADD      R9,R11,R8, LSR #+31
        STR      R9,[SP, #+0]
        LDR      R9,??UnpackSFMPEG2_3  ;; 0x66666667
        SMULL    R10,R11,R8,R9
        MOV      R10,#+5
        ASR      R11,R11,#+1
        ADD      R11,R11,R8, LSR #+31
        MUL      R11,R10,R11
        AND      R9,LR,#0x3
        SUB      R8,R8,R11
        STR      R8,[SP, #+4]
        STR      R9,[SP, #+8]
//  236 			sfcIdx = 1;
        MOV      R8,#+1
        B        ??UnpackSFMPEG2_4
//  237 		} else {
//  238 			/* max slen = floor[11/3] = 3 (sfCompress = 9 bits in MPEG2) */
//  239 			sfCompress -= 500;
//  240 			slen[0] = sfCompress / 3;
??UnpackSFMPEG2_5:
        LDR      R8,??UnpackSFMPEG2_3+0x4  ;; 0x55555556
        MVN      R3,#+243
        BIC      R3,R3,#0x100
        ADD      LR,R3,LR
//  241 			slen[1] = sfCompress % 3;
        LDR      R3,??UnpackSFMPEG2_3+0x4  ;; 0x55555556
        SMULL    R9,R10,R8,LR
//  242 			slen[2] = slen[3] = 0;
//  243 			if (sis->mixedBlock) {
        CMP      R7,#+0
        ADD      R8,R10,LR, LSR #+31
        STR      R8,[SP, #+0]
        SMULL    R8,R9,LR,R3
        MOV      R8,#+3
        ADD      R9,R9,LR, LSR #+31
        MUL      R9,R8,R9
//  244 				/* adjust for long/short mix logic (see comment above in NRTab[] definition) */
//  245 				slen[2] = slen[1];  
//  246 				slen[1] = slen[0];
        LDRNE    R8,[SP, #+0]
        SUB      R3,LR,R9
        STR      R3,[SP, #+4]
        STR      R6,[SP, #+12]
        STR      R6,[SP, #+8]
        STRNE    R3,[SP, #+8]
        STRNE    R8,[SP, #+4]
//  247 			}  
//  248 			preFlag = 1;
        MOV      R3,#+1
//  249 			sfcIdx = 2;
        MOV      R8,#+2
        B        ??UnpackSFMPEG2_4
//  250 		}
//  251 	} else {    
//  252 		/* intensity stereo ch = 1 (right) */
//  253 		intensityScale = sfCompress & 0x01;
??UnpackSFMPEG2_1:
        AND      R12,LR,#0x1
//  254 		sfCompress >>= 1;
        ASR      LR,LR,#+1
//  255 		if (sfCompress < 180) {
        CMP      LR,#+180
        BGE      ??UnpackSFMPEG2_6
//  256 			/* max slen = floor[35/6] = 5 (from mod 36) */
//  257 			slen[0] = (sfCompress / 36);
        LDR      R9,??UnpackSFMPEG2_3+0x8  ;; 0x38e38e39
//  258 			slen[1] = (sfCompress % 36) / 6;
        LDR      R8,??UnpackSFMPEG2_3+0x8  ;; 0x38e38e39
        SMULL    R10,R11,R9,LR
//  259 			slen[2] = (sfCompress % 36) % 6;
//  260 			slen[3] = 0;
        STR      R6,[SP, #+12]
        ASR      R11,R11,#+3
        ADD      R9,R11,LR, LSR #+31
        STR      R9,[SP, #+0]
        SMULL    R9,R10,LR,R8
        MOV      R9,#+36
        ASR      R10,R10,#+3
        ADD      R10,R10,LR, LSR #+31
        MUL      R10,R9,R10
        SUB      R8,LR,R10
        LDR      R10,??UnpackSFMPEG2_3+0xC  ;; 0x2aaaaaab
        SMULL    R11,LR,R10,R8
        MOV      R11,#+6
        ADD      R10,LR,R8, LSR #+31
        ADD      LR,LR,R8, LSR #+31
        MUL      LR,R11,LR
        STR      R10,[SP, #+4]
        SUB      R8,R8,LR
        STR      R8,[SP, #+8]
//  261 			sfcIdx = 3;
        MOV      R8,#+3
        B        ??UnpackSFMPEG2_4
//  262 		} else if (sfCompress < 244) {
??UnpackSFMPEG2_6:
        CMP      LR,#+244
        BGE      ??UnpackSFMPEG2_7
//  263 			/* max slen = floor[63/16] = 3 */
//  264 			sfCompress -= 180;
        MVN      R8,#+179
        ADD      LR,R8,LR
//  265 			slen[0] = (sfCompress & 0x3f) >> 4;
        AND      R9,LR,#0x3F
        ASR      R9,R9,#+4
        STR      R9,[SP, #+0]
//  266 			slen[1] = (sfCompress & 0x0f) >> 2;
        AND      R9,LR,#0xF
        ASR      R9,R9,#+2
        STR      R9,[SP, #+4]
//  267 			slen[2] = (sfCompress & 0x03);
        AND      R9,LR,#0x3
        STR      R9,[SP, #+8]
//  268 			slen[3] = 0;
        STR      R6,[SP, #+12]
//  269 			sfcIdx = 4;
        MOV      R8,#+4
        B        ??UnpackSFMPEG2_4
//  270 		} else {
//  271 			/* max slen = floor[11/3] = 3 (max sfCompress >> 1 = 511/2 = 255) */
//  272 			sfCompress -= 244;
//  273 			slen[0] = (sfCompress / 3);
??UnpackSFMPEG2_7:
        LDR      R9,??UnpackSFMPEG2_3+0x4  ;; 0x55555556
        MVN      R8,#+243
        ADD      LR,R8,LR
        SMULL    R10,R11,R9,LR
//  274 			slen[1] = (sfCompress % 3);
        MOV      R10,#+3
        ADD      R9,R11,LR, LSR #+31
        ADD      R11,R11,LR, LSR #+31
        MUL      R11,R10,R11
        STR      R9,[SP, #+0]
        SUB      R9,LR,R11
        STR      R9,[SP, #+4]
//  275 			slen[2] = slen[3] = 0;
        STR      R6,[SP, #+12]
        STR      R6,[SP, #+8]
//  276 			sfcIdx = 5;
        MOV      R8,#+5
//  277 		}
//  278 	}
//  279 	
//  280 	/* set index based on block type: (0,1,3) --> 0, (2 non-mixed) --> 1, (2 mixed) ---> 2 */
//  281 	btIdx = 0;
//  282 	if (sis->blockType == 2) 
??UnpackSFMPEG2_4:
        LDR      R10,[R1, #+20]
        MOV      R9,#+0
        CMP      R10,#+2
        BNE      ??UnpackSFMPEG2_8
//  283 		btIdx = (sis->mixedBlock ? 2 : 1);
        CMP      R7,#+0
        MOVNE    R9,#+2
        MOVEQ    R9,#+1
//  284 	for (i = 0; i < 4; i++)
??UnpackSFMPEG2_8:
        MOV      R7,#+0
        ADD      R10,SP,#+20
//  285 		nr[i] = (int)NRTab[sfcIdx][btIdx][i];
??UnpackSFMPEG2_9:
        LDR      LR,??UnpackSFMPEG2_3+0x10  ;; NRTab
        MOV      R11,#+12
        MLA      LR,R11,R8,LR
        ADD      R11,LR,R9, LSL #+2
        LDRB     R11,[R7, +R11]
        STR      R11,[R10, +R7, LSL #+2]
        ADD      R7,R7,#+1
        CMP      R7,#+4
        BLT      ??UnpackSFMPEG2_9
//  286 
//  287 	/* save intensity stereo scale factor info */
//  288 	if( (modeExt & 0x01) && (ch == 1) ) {
        TST      R0,#0x1
        BEQ      ??UnpackSFMPEG2_10
        LDR      R0,[SP, #+72]
        CMP      R0,#+1
        BNE      ??UnpackSFMPEG2_10
//  289 		for (i = 0; i < 4; i++) {
        MOV      R7,#+0
//  290 			sfjs->slen[i] = slen[i];
??UnpackSFMPEG2_11:
        MOV      R8,SP
        LDR      R8,[R8, +R7, LSL #+2]
        ADD      R0,R2,R7, LSL #+2
        STR      R8,[R0, #+4]
//  291 			sfjs->nr[i] = nr[i];
        ADD      R8,SP,#+20
        LDR      R8,[R8, +R7, LSL #+2]
//  292 		}
        ADD      R7,R7,#+1
        STR      R8,[R0, #+20]
        CMP      R7,#+4
        BLT      ??UnpackSFMPEG2_11
//  293 		sfjs->intensityScale = intensityScale;
        STR      R12,[R2, #+0]
//  294 	}
//  295 	sis->preFlag = preFlag;
??UnpackSFMPEG2_10:
        STR      R3,[R1, #+60]
//  296 
//  297 	/* short blocks */
//  298 	if(sis->blockType == 2) {
        LDR      R0,[R1, #+20]
        CMP      R0,#+2
        BNE      ??UnpackSFMPEG2_12
//  299 		if(sis->mixedBlock) {
        LDR      R0,[R1, #+24]
        CMP      R0,#+0
        BEQ      ??UnpackSFMPEG2_13
//  300 			/* do long block portion */
//  301 			iipTest = (1 << slen[0]) - 1;
//  302 			for (sfb=0; sfb < 6; sfb++) {
        MOV      R7,#+0
//  303 				sfis->l[sfb] = (char)GetBits(bsi, slen[0]);
??UnpackSFMPEG2_14:
        LDR      R1,[SP, #+0]
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R7, +R5]
//  304 			}
        ADD      R7,R7,#+1
        CMP      R7,#+6
        BLT      ??UnpackSFMPEG2_14
//  305 			sfb = 3;  /* start sfb for short */
        MOV      R8,#+3
//  306 			nrIdx = 1;
        MOV      R9,#+1
        B        ??UnpackSFMPEG2_15
//  307 		} else {      
//  308 			/* all short blocks, so start nr, sfb at 0 */
//  309 			sfb = 0;
??UnpackSFMPEG2_13:
        MOV      R8,#+0
//  310 			nrIdx = 0;
        MOV      R9,R6
//  311 		}
//  312 
//  313 		/* remaining short blocks, sfb just keeps incrementing */
//  314 		for (    ; nrIdx <= 3; nrIdx++) {
//  315 			iipTest = (1 << slen[nrIdx]) - 1;
//  316 			for (i=0; i < nr[nrIdx]; i++, sfb++) {
??UnpackSFMPEG2_15:
        ADD      R1,SP,#+20
        LDR      R1,[R1, +R9, LSL #+2]
        MOV      R7,#+0
        STR      R1,[SP, #+16]
        CMP      R1,#+1
        BGE      ??UnpackSFMPEG2_16
        B        ??UnpackSFMPEG2_17
//  317 				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
??UnpackSFMPEG2_18:
        MOV      R0,SP
        LDR      R10,[R0, +R9, LSL #+2]
        ADD      R0,R8,R8, LSL #+1
        ADD      R11,R0,R5
        MOV      R1,R10
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R11, #+23]
//  318 				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
        MOV      R1,R10
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R11, #+24]
//  319 				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
        MOV      R1,R10
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R11, #+25]
//  320 			}
        ADD      R7,R7,#+1
        ADD      R8,R8,#+1
??UnpackSFMPEG2_16:
        LDR      R0,[SP, #+16]
        CMP      R7,R0
        BLT      ??UnpackSFMPEG2_18
//  321 		}
??UnpackSFMPEG2_17:
        ADD      R9,R9,#+1
        CMP      R9,#+4
        BLT      ??UnpackSFMPEG2_15
//  322 		/* last sf band not transmitted */
//  323 		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
        STRB     R6,[R5, #+61]
        STRB     R6,[R5, #+60]
        STRB     R6,[R5, #+59]
        ADD      SP,SP,#+36
        CFI CFA R13+36
        POP      {R4-R11,PC}
        CFI CFA R13+72
//  324 	} else {
//  325 		/* long blocks */
//  326 		sfb = 0;
??UnpackSFMPEG2_12:
        MOV      R8,#+0
//  327 		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
        MOV      R9,R6
//  328 			iipTest = (1 << slen[nrIdx]) - 1;
//  329 			for(i=0; i < nr[nrIdx]; i++, sfb++) {
??UnpackSFMPEG2_19:
        ADD      R0,SP,#+20
        LDR      R10,[R0, +R9, LSL #+2]
        MOV      R7,#+0
        CMP      R10,#+1
        BGE      ??UnpackSFMPEG2_20
        B        ??UnpackSFMPEG2_21
//  330 				sfis->l[sfb] = (char)GetBits(bsi, slen[nrIdx]);
??UnpackSFMPEG2_22:
        MOV      R0,SP
        LDR      R1,[R0, +R9, LSL #+2]
        MOV      R0,R4
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
        STRB     R0,[R8, +R5]
//  331 			}
        ADD      R7,R7,#+1
        ADD      R8,R8,#+1
??UnpackSFMPEG2_20:
        CMP      R7,R10
        BLT      ??UnpackSFMPEG2_22
//  332 		}
??UnpackSFMPEG2_21:
        ADD      R9,R9,#+1
        CMP      R9,#+4
        BLT      ??UnpackSFMPEG2_19
//  333 		/* last sf band not transmitted */
//  334 		sfis->l[21] = sfis->l[22] = 0;
        STRB     R6,[R5, #+22]
        MOV      R0,#+0
        STRB     R0,[R5, #+21]
//  335 
//  336 	}
//  337 }
        ADD      SP,SP,#+36
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??UnpackSFMPEG2_3:
        DC32     0x66666667
        DC32     0x55555556
        DC32     0x38e38e39
        DC32     0x2aaaaaab
        DC32     NRTab
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??xmp3_UnpackScaleFactors??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE xmp3_UnpackScaleFactors
//  338 
//  339 /**************************************************************************************
//  340  * Function:    UnpackScaleFactors
//  341  *
//  342  * Description: parse the fields of the MP3 scale factor data section
//  343  *
//  344  * Inputs:      MP3DecInfo structure filled by UnpackFrameHeader() and UnpackSideInfo()
//  345  *              buffer pointing to the MP3 scale factor data
//  346  *              pointer to bit offset (0-7) indicating starting bit in buf[0]
//  347  *              number of bits available in data buffer
//  348  *              index of current granule and channel
//  349  *
//  350  * Outputs:     updated platform-specific ScaleFactorInfo struct
//  351  *              updated bitOffset
//  352  *
//  353  * Return:      length (in bytes) of scale factor data, -1 if null input pointers
//  354  **************************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function xmp3_UnpackScaleFactors
        ARM
//  355 int UnpackScaleFactors(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int bitsAvail, int gr, int ch)
//  356 {
xmp3_UnpackScaleFactors:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+24
        CFI CFA R13+60
        LDR      R7,[SP, #+60]
        LDR      R8,[SP, #+64]
        MOV      R4,R0
//  357 	int bitsUsed;
//  358 	unsigned char *startBuf;
//  359 	BitStreamInfo bitStreamInfo, *bsi;
//  360 	FrameHeader *fh;
//  361 	SideInfo *si;
//  362 	ScaleFactorInfo *sfi;
//  363 
//  364 	/* validate pointers */
//  365 	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS)
        CMP      R4,#+0
        LDRNE    R0,[R4, #+0]
        MOV      R5,R1
        CMPNE    R0,#+0
        LDRNE    R0,[R4, #+4]
        MOV      R6,R2
        CMPNE    R0,#+0
        LDRNE    R0,[R4, #+8]
        CMPNE    R0,#+0
//  366 		return -1;
        MVNEQ    R0,#+0
        BEQ      ??xmp3_UnpackScaleFactors_0
//  367 	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
        LDR      R1,[R4, #+0]
//  368 	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
//  369 	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));
//  370 
//  371 	/* init GetBits reader */
//  372 	startBuf = buf;
//  373 	bsi = &bitStreamInfo;
//  374 	SetBitstreamPointer(bsi, (bitsAvail + *bitOffset + 7) / 8, buf);
        MOV      R2,R5
        STR      R1,[SP, #+0]
        LDR      R9,[R4, #+4]
        LDR      R10,[R4, #+8]
        STR      R5,[SP, #+4]
        LDR      R0,[R6, #+0]
        ADD      R0,R0,R3
        ADD      R0,R0,#+7
        ASR      R1,R0,#+2
        ADD      R0,R0,R1, LSR #+29
        ASR      R1,R0,#+3
        ADD      R0,SP,#+8
        _BLF     xmp3_SetBitstreamPointer,??xmp3_SetBitstreamPointer??rA
//  375 	if (*bitOffset)
        LDR      R1,[R6, #+0]
        CMP      R1,#+0
        BEQ      ??xmp3_UnpackScaleFactors_1
//  376 		GetBits(bsi, *bitOffset);
        ADD      R0,SP,#+8
        _BLF     xmp3_GetBits,??xmp3_GetBits??rA
//  377 
//  378 	if (fh->ver == MPEG1) 
??xmp3_UnpackScaleFactors_1:
        MOV      R0,#+72
        MOV      R1,#+144
        MLA      R2,R1,R7,R9
        MOV      R1,#+62
        MLA      R11,R0,R8,R2
        MUL      R0,R1,R8
        MOV      R1,#+124
        MLA      R2,R1,R7,R10
        LDR      R1,[SP, #+0]
        ADD      R2,R0,R2
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE      ??xmp3_UnpackScaleFactors_2
//  379 		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
        ADD      R0,R0,R10
        PUSH     {R0}
        CFI CFA R13+64
        ADD      R1,R11,#+40
        MOV      R0,R7
        PUSH     {R0}
        CFI CFA R13+68
        ADD      R0,R9,R8, LSL #+4
        ADD      R3,R0,#+8
        ADD      R0,SP,#+16
        BL       UnpackSFMPEG1
        ADD      SP,SP,#+8
        CFI CFA R13+60
        B        ??xmp3_UnpackScaleFactors_3
//  380 	else 
//  381 		UnpackSFMPEG2(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], gr, ch, fh->modeExt, &sfi->sfjs);
??xmp3_UnpackScaleFactors_2:
        ADD      R0,R10,#+248
        PUSH     {R0}
        CFI CFA R13+64
        LDR      R0,[SP, #+4]
        MOV      R3,R7
        LDR      R0,[R0, #+32]
        ADD      R1,R11,#+40
        PUSH     {R0}
        CFI CFA R13+68
        MOV      R0,R8
        PUSH     {R0}
        CFI CFA R13+72
        ADD      R0,SP,#+20
        BL       UnpackSFMPEG2
        ADD      SP,SP,#+12
        CFI CFA R13+60
//  382 
//  383 	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
??xmp3_UnpackScaleFactors_3:
        LDR      R1,[R11, #+40]
        ADD      R0,R4,R7, LSL #+3
        ADD      R0,R0,R8, LSL #+2
        STR      R1,[R0, #+2016]
//  384 
//  385 	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
        LDR      R2,[R6, #+0]
        MOV      R1,R5
        ADD      R0,SP,#+8
        _BLF     xmp3_CalcBitsUsed,??xmp3_CalcBitsUsed??rA
//  386 	buf += (bitsUsed + *bitOffset) >> 3;
        LDR      R1,[R6, #+0]
        ADD      R0,R1,R0
        ADD      R5,R5,R0, ASR #+3
//  387 	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
        AND      R0,R0,#0x7
        STR      R0,[R6, #+0]
//  388 
//  389 	return (buf - startBuf);
        LDR      R0,[SP, #+4]
        SUB      R0,R5,R0
??xmp3_UnpackScaleFactors_0:
        ADD      SP,SP,#+24       ;; stack cleaning
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        CFI EndBlock cfiBlock5
//  390 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon1
        CFI NoFunction
        ARM
??xmp3_GetBits??rA:
        LDR      R12,??Subroutine3_0  ;; xmp3_GetBits
        BX       R12
        DATA
??Subroutine3_0:
        DC32     xmp3_GetBits
        CFI EndBlock cfiBlock6

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI NoFunction
        ARM
??xmp3_SetBitstreamPointer??rA:
        LDR      R12,??Subroutine4_0  ;; xmp3_SetBitstreamPointer
        BX       R12
        DATA
??Subroutine4_0:
        DC32     xmp3_SetBitstreamPointer
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon1
        CFI NoFunction
        ARM
??xmp3_CalcBitsUsed??rA:
        LDR      R12,??Subroutine5_0  ;; xmp3_CalcBitsUsed
        BX       R12
        DATA
??Subroutine5_0:
        DC32     xmp3_CalcBitsUsed
        CFI EndBlock cfiBlock8

        END
//  391 
// 
// 2 080 bytes in segment CODE
//   104 bytes in segment DATA_C
// 
// 2 032 bytes of CODE  memory (+ 48 bytes shared)
//   104 bytes of CONST memory
//
//Errors: none
//Warnings: 2
