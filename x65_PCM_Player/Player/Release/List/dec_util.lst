##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    14/Feb/2012  15:39:44 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\dec_u #
#                       til.c                                                #
#    Command line    =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\dec_u #
#                       til.c -D NDEBUG -lC D:\SVN\SieELF\SieELF\x65_PCM_Pla #
#                       yer\Player\Release\List\ -lA                         #
#                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\R #
#                       elease\Obj\ -s9 --cpu_mode arm --endian little       #
#                       --cpu ARM926EJ-S --stack_align 4 --interwork -e      #
#                       --fpu None --dlib_config "D:\Program                 #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude       #
#                       swilib.h -I "D:\Program Files\IAR\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=16                                #
#    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\dec_util.lst                                     #
#    Object file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\O #
#                       bj\dec_util.r79                                      #
#                                                                            #
#                                                                            #
##############################################################################

D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\dec_util.c
      1          /*
      2           *===================================================================
      3           *  3GPP AMR Wideband Floating-point Speech Codec
      4           *===================================================================
      5           */
      6          #include <math.h>
      7          #include "typedef.h"

  #endif
        ^
"D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\typedef.h",19  Warning[Pe001]: 
          last line of file ends without a newline
      8          #include "dec_main.h"

  #endif
        ^
"D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\typedef.h",19  Warning[Pe001]: 
          last line of file ends without a newline

  #endif
        ^
"D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\typedef.h",19  Warning[Pe001]: 
          last line of file ends without a newline
      9          #include "dec_lpc.h"

  #endif
        ^
"D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\typedef.h",19  Warning[Pe001]: 
          last line of file ends without a newline
     10          
     11          #define MAX_16       (Word16)0x7FFF
     12          #define MIN_16       (Word16)0x8000
     13          #define L_SUBFR      64       /* Subframe size                    */
     14          #define L_SUBFR16k   80       /* Subframe size at 16kHz           */
     15          #define M16k         20       /* Order of LP filter               */
     16          #define PREEMPH_FAC  22282    /* preemphasis factor (0.68 in Q15) */
     17          #define FAC4         4
     18          #define FAC5         5
     19          #define UP_FAC       20480    /* 5/4 in Q14                       */
     20          #define INV_FAC5     6554     /* 1/5 in Q15                       */
     21          #define NB_COEF_UP   12
     22          #define L_FIR        31
     23          #define MODE_7k      0
     24          #define MODE_24k     8
     25          
     26          
     27          extern const Word16 D_ROM_pow2[];
     28          extern const Word16 D_ROM_isqrt[];
     29          extern const Word16 D_ROM_log2[];
     30          extern const Word16 D_ROM_fir_up[];
     31          extern const Word16 D_ROM_fir_6k_7k[];
     32          extern const Word16 D_ROM_fir_7k[];
     33          extern const Word16 D_ROM_hp_gain[];
     34          
     35          #ifdef WIN32
     36          #pragma warning( disable : 4310)
     37          #endif
     38          /*
     39           * D_UTIL_random
     40           *
     41           * Parameters:
     42           *    seed        I/O: seed for random number
     43           *
     44           * Function:
     45           *    Signed 16 bits random generator.
     46           *
     47           * Returns:
     48           *    random number
     49           */

   \                                 In segment CODE, align 4, keep-with-next
     50          Word16 D_UTIL_random(Word16 *seed)
     51          {
     52             /*static Word16 seed = 21845;*/
     53             *seed = (Word16)(*seed * 31821L + 13849L);
   \                     D_UTIL_random:
   \   00000000   F010D0E1           LDRSH    R1,[R0, #+0]
   \   00000004   4D20A0E3           MOV      R2,#+77
   \   00000008   7C2C82E3           ORR      R2,R2,#0x7C00
   \   0000000C   1930A0E3           MOV      R3,#+25
   \   00000010   D83D83E3           ORR      R3,R3,#0x3600
   \   00000014   923121E0           MLA      R1,R2,R1,R3
   \   00000018   B010C0E1           STRH     R1,[R0, #+0]
     54             return(*seed);
   \   0000001C   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000020   1EFF2FE1           BX       LR               ;; return
     55          }
     56          
     57          
     58          /*
     59           * D_UTIL_pow2
     60           *
     61           * Parameters:
     62           *    exponant    I: (Q0) Integer part.      (range: 0 <= val <= 30)
     63           *    fraction    I: (Q15) Fractionnal part. (range: 0.0 <= val < 1.0)
     64           *
     65           * Function:
     66           *    L_x = pow(2.0, exponant.fraction)         (exponant = interger part)
     67           *        = pow(2.0, 0.fraction) << exponant
     68           *
     69           *    Algorithm:
     70           *
     71           *    The function Pow2(L_x) is approximated by a table and linear
     72           *    interpolation.
     73           *
     74           *    1 - i = bit10 - b15 of fraction,   0 <= i <= 31
     75           *    2 - a = bit0 - b9   of fraction
     76           *    3 - L_x = table[i] << 16 - (table[i] - table[i + 1]) * a * 2
     77           *    4 - L_x = L_x >> (30-exponant)     (with rounding)
     78           *
     79           * Returns:
     80           *    range 0 <= val <= 0x7fffffff
     81           */

   \                                 In segment CODE, align 4, keep-with-next
     82          Word32 D_UTIL_pow2(Word16 exponant, Word16 fraction)
     83          {
     84          	Word32 L_x, tmp, i, exp;
     85          	Word16 a;
     86          
     87          	L_x = fraction * 32;          /* L_x = fraction<<6             */
     88          	i = L_x >> 15;                /* Extract b10-b16 of fraction   */
     89          	a = (Word16)(L_x);            /* Extract b0-b9   of fraction   */
     90          	a = (Word16)(a & (Word16)0x7fff);
     91          	L_x = D_ROM_pow2[i] << 16;    /* table[i] << 16                */
     92          	tmp = D_ROM_pow2[i] - D_ROM_pow2[i + 1];  /* table[i] - table[i+1] */
     93          	tmp = L_x - ((tmp * a) << 1); /* L_x -= tmp*a*2                */
   \                     D_UTIL_pow2:
   \   00000000   58309FE5           LDR      R3,??D_UTIL_pow2_0  ;; D_ROM_pow2
   \   00000004   8112A0E1           LSL      R1,R1,#+5
   \   00000008   C127A0E1           ASR      R2,R1,#+15
   \   0000000C   822083E0           ADD      R2,R3,R2, LSL #+1
   \   00000010   F030D2E1           LDRSH    R3,[R2, #+0]
   \   00000014   F220D2E1           LDRSH    R2,[R2, #+2]
   \   00000018   8118A0E1           LSL      R1,R1,#+17
   \   0000001C   A118A0E1           LSR      R1,R1,#+17
   \   00000020   022043E0           SUB      R2,R3,R2
   \   00000024   910202E0           MUL      R2,R1,R2
   \   00000028   03C8A0E1           LSL      R12,R3,#+16
   \   0000002C   82104CE0           SUB      R1,R12,R2, LSL #+1
     94          	exp = 30 - exponant;
   \   00000030   1E2060E2           RSB      R2,R0,#+30
     95          	if (exp <= 31)
   \   00000034   200052E3           CMP      R2,#+32
   \   00000038   060000AA           BGE      ??D_UTIL_pow2_1
     96          	{
     97          		L_x = tmp >> exp;
   \   0000003C   5102A0E1           ASR      R0,R1,R2
     98          
     99          		if ((1 << (exp - 1)) & tmp)
   \   00000040   0130A0E3           MOV      R3,#+1
   \   00000044   012042E2           SUB      R2,R2,#+1
   \   00000048   130211E1           TST      R1,R3, LSL R2
   \   0000004C   1EFF2F01           BXEQ     LR
    100          		{
    101          			L_x++;
   \   00000050   010080E2           ADD      R0,R0,#+1
   \   00000054   1EFF2FE1           BX       LR
    102          		}
    103          	}
    104          	else
    105          	{
    106          		L_x = 0;
   \                     ??D_UTIL_pow2_1:
   \   00000058   0000A0E3           MOV      R0,#+0
    107          	}
    108          
    109          	return(L_x);
   \   0000005C   1EFF2FE1           BX       LR               ;; return
   \                     ??D_UTIL_pow2_0:
   \   00000060   ........           DC32     D_ROM_pow2
    110          }
    111          
    112          
    113          /*
    114           * D_UTIL_norm_l
    115           *
    116           * Parameters:
    117           *    L_var1      I: 32 bit Word32 signed integer (Word32) whose value
    118           *                   falls in the range 0x8000 0000 <= var1 <= 0x7fff ffff.
    119           *
    120           * Function:
    121           *    Produces the number of left shifts needed to normalize the 32 bit
    122           *    variable L_var1 for positive values on the interval with minimum of
    123           *    1073741824 and maximum of 2147483647, and for negative values on
    124           *    the interval with minimum of -2147483648 and maximum of -1073741824;
    125           *    in order to normalize the result, the following operation must be done :
    126           *    norm_L_var1 = L_shl(L_var1,norm_l(L_var1)).
    127           *
    128           * Returns:
    129           *    16 bit Word16 signed integer (Word16) whose value falls in the range
    130           *    0x0000 0000 <= var_out <= 0x0000 001f.
    131           */

   \                                 In segment CODE, align 4, keep-with-next
    132          Word16 D_UTIL_norm_l(Word32 L_var1)
    133          {
    134             Word16 var_out;
    135          
    136             if(L_var1 == 0)
   \                     D_UTIL_norm_l:
   \   00000000   0010A0E3           MOV      R1,#+0
   \   00000004   000050E3           CMP      R0,#+0
   \   00000008   0A00000A           BEQ      ??D_UTIL_norm_l_0
    137             {
    138                var_out = 0;
    139             }
    140             else
    141             {
    142                if(L_var1 == (Word32)0xffffffffL)
   \   0000000C   010070E3           CMN      R0,#+1
    143                {
    144                   var_out = 31;
   \   00000010   1F10A003           MOVEQ    R1,#+31
   \   00000014   0700000A           BEQ      ??D_UTIL_norm_l_0
    145                }
    146                else
    147                {
    148                   if(L_var1 < 0)
   \   00000018   000050E3           CMP      R0,#+0
    149                   {
    150                      L_var1 = ~L_var1;
   \   0000001C   0000E041           MVNMI    R0,R0
    151                   }
    152          
    153                   for(var_out = 0; L_var1 < (Word32)0x40000000L; var_out++)
   \   00000020   400450E3           CMP      R0,#+1073741824
   \   00000024   030000AA           BGE      ??D_UTIL_norm_l_0
    154                   {
    155                      L_var1 <<= 1;
   \                     ??D_UTIL_norm_l_1:
   \   00000028   8000A0E1           LSL      R0,R0,#+1
    156                   }
   \   0000002C   011081E2           ADD      R1,R1,#+1
   \   00000030   400450E3           CMP      R0,#+1073741824
   \   00000034   FBFFFFBA           BLT      ??D_UTIL_norm_l_1
    157                }
    158             }
    159          
    160             return(var_out);
   \                     ??D_UTIL_norm_l_0:
   \   00000038   0108A0E1           MOV      R0,R1, LSL #+16
   \   0000003C   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000040   1EFF2FE1           BX       LR               ;; return
    161          }
    162          
    163          
    164          /*
    165           * D_UTIL_norm_s
    166           *
    167           * Parameters:
    168           *    L_var1      I: 32 bit Word32 signed integer (Word32) whose value
    169           *                   falls in the range 0xffff 8000 <= var1 <= 0x0000 7fff.
    170           *
    171           * Function:
    172           *    Produces the number of left shift needed to normalize the 16 bit
    173           *    variable var1 for positive values on the interval with minimum
    174           *    of 16384 and maximum of 32767, and for negative values on
    175           *    the interval with minimum of -32768 and maximum of -16384.
    176           *
    177           * Returns:
    178           *    16 bit Word16 signed integer (Word16) whose value falls in the range
    179           *    0x0000 0000 <= var_out <= 0x0000 000f.
    180           */

   \                                 In segment CODE, align 4, keep-with-next
    181          Word16 D_UTIL_norm_s(Word16 var1)
    182          {
    183             Word16 var_out;
    184          
    185             if(var1 == 0)
   \                     D_UTIL_norm_s:
   \   00000000   000050E3           CMP      R0,#+0
    186             {
    187                var_out = 0;
   \   00000004   0010A003           MOVEQ    R1,#+0
   \   00000008   0F00000A           BEQ      ??D_UTIL_norm_s_0
    188             }
    189             else
    190             {
    191                if(var1 == -1)
   \   0000000C   0010E0E3           MVN      R1,#+0
   \   00000010   010050E1           CMP      R0,R1
    192                {
    193                   var_out = 15;
   \   00000014   0F10A003           MOVEQ    R1,#+15
   \   00000018   0B00000A           BEQ      ??D_UTIL_norm_s_0
    194                }
    195                else
    196                {
    197                   if(var1 < 0)
   \   0000001C   000050E3           CMP      R0,#+0
    198                   {
    199                      var1 = (Word16)~var1;
   \   00000020   0000E041           MVNMI    R0,R0
    200                   }
    201          
    202                   for(var_out = 0; var1 < 0x4000; var_out++)
   \   00000024   0010A0E3           MOV      R1,#+0
   \   00000028   0008A0E1           MOV      R0,R0, LSL #+16
   \   0000002C   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000030   400C50E3           CMP      R0,#+16384
   \   00000034   040000AA           BGE      ??D_UTIL_norm_s_0
    203                   {
    204                      var1 <<= 1;
   \                     ??D_UTIL_norm_s_1:
   \   00000038   8008A0E1           LSL      R0,R0,#+17
    205                   }
   \   0000003C   011081E2           ADD      R1,R1,#+1
   \   00000040   4008A0E1           ASR      R0,R0,#+16
   \   00000044   400C50E3           CMP      R0,#+16384
   \   00000048   FAFFFFBA           BLT      ??D_UTIL_norm_s_1
    206                }
    207             }
    208             return(var_out);
   \                     ??D_UTIL_norm_s_0:
   \   0000004C   0108A0E1           MOV      R0,R1, LSL #+16
   \   00000050   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000054   1EFF2FE1           BX       LR               ;; return
    209          }
    210          
    211          
    212          /*
    213           * D_UTIL_dot_product12
    214           *
    215           * Parameters:
    216           *    x        I: 12bit x vector
    217           *    y        I: 12bit y vector
    218           *    lg       I: vector length
    219           *    exp      O: exponent of result (0..+30)
    220           *
    221           * Function:
    222           *    Compute scalar product of <x[],y[]> using accumulator.
    223           *    The result is normalized (in Q31) with exponent (0..30).
    224           *
    225           * Returns:
    226           *    Q31 normalised result (1 < val <= -1)
    227           */

   \                                 In segment CODE, align 4, keep-with-next
    228          Word32 D_UTIL_dot_product12(Word16 x[], Word16 y[], Word16 lg, Word16 *exp)
    229          {
   \                     D_UTIL_dot_product12:
   \   00000000   70002DE9           PUSH     {R4-R6}
    230             Word32 sum, i, sft;
    231          
    232             sum = 0L;
   \   00000004   00C0A0E3           MOV      R12,#+0
    233          
    234             for(i = 0; i < lg; i++)
   \   00000008   0040A0E3           MOV      R4,#+0
   \   0000000C   010052E3           CMP      R2,#+1
   \   00000010   080000BA           BLT      ??D_UTIL_dot_product12_0
   \   00000014   050000EA           B        ??D_UTIL_dot_product12_1
    235             {
    236                sum += x[i] * y[i];
   \                     ??D_UTIL_dot_product12_2:
   \   00000018   845080E0           ADD      R5,R0,R4, LSL #+1
   \   0000001C   F050D5E1           LDRSH    R5,[R5, #+0]
   \   00000020   846081E0           ADD      R6,R1,R4, LSL #+1
   \   00000024   F060D6E1           LDRSH    R6,[R6, #+0]
    237             }
   \   00000028   014084E2           ADD      R4,R4,#+1
   \   0000002C   96C52CE0           MLA      R12,R6,R5,R12
   \                     ??D_UTIL_dot_product12_1:
   \   00000030   020054E1           CMP      R4,R2
   \   00000034   F7FFFFBA           BLT      ??D_UTIL_dot_product12_2
    238             sum = (sum << 1) + 1;
   \                     ??D_UTIL_dot_product12_0:
   \   00000038   0100A0E3           MOV      R0,#+1
   \   0000003C   8C0080E0           ADD      R0,R0,R12, LSL #+1
    239          
    240             /* Normalize acc in Q31 */
    241             sft = D_UTIL_norm_l(sum);
   \   00000040   0010B0E1           MOVS     R1,R0
   \   00000044   0020A0E3           MOV      R2,#+0
   \   00000048   0A00000A           BEQ      ??D_UTIL_dot_product12_3
   \   0000004C   010071E3           CMN      R1,#+1
   \   00000050   1F20A003           MOVEQ    R2,#+31
   \   00000054   0700000A           BEQ      ??D_UTIL_dot_product12_3
   \   00000058   000051E3           CMP      R1,#+0
   \   0000005C   0110E041           MVNMI    R1,R1
   \   00000060   400451E3           CMP      R1,#+1073741824
   \   00000064   030000AA           BGE      ??D_UTIL_dot_product12_3
   \                     ??D_UTIL_dot_product12_4:
   \   00000068   8110A0E1           LSL      R1,R1,#+1
   \   0000006C   012082E2           ADD      R2,R2,#+1
   \   00000070   400451E3           CMP      R1,#+1073741824
   \   00000074   FBFFFFBA           BLT      ??D_UTIL_dot_product12_4
   \                     ??D_UTIL_dot_product12_3:
   \   00000078   0228A0E1           MOV      R2,R2, LSL #+16
   \   0000007C   4228A0E1           MOV      R2,R2, ASR #+16
    242             sum = sum << sft;
    243             *exp = (Word16)(30 - sft);   /* exponent = 0..30 */
   \   00000080   0210A0E1           MOV      R1,R2
   \   00000084   1E1061E2           RSB      R1,R1,#+30
   \   00000088   B010C3E1           STRH     R1,[R3, #+0]
    244          
    245             return(sum);
   \   0000008C   7000BDE8           POP      {R4-R6}
   \   00000090   1002A0E1           LSL      R0,R0,R2
   \   00000094   1EFF2FE1           BX       LR               ;; return
    246          }
    247          
    248          
    249          /*
    250           * D_UTIL_normalised_inverse_sqrt
    251           *
    252           * Parameters:
    253           *    frac     I/O: (Q31) normalized value (1.0 < frac <= 0.5)
    254           *    exp      I/O: exponent (value = frac x 2^exponent)
    255           *
    256           * Function:
    257           *    Compute 1/sqrt(value).
    258           *    If value is negative or zero, result is 1 (frac=7fffffff, exp=0).
    259           *
    260           *    The function 1/sqrt(value) is approximated by a table and linear
    261           *    interpolation.
    262           *    1. If exponant is odd then shift fraction right once.
    263           *    2. exponant = -((exponant - 1) >> 1)
    264           *    3. i = bit25 - b30 of fraction, 16 <= i <= 63 ->because of normalization.
    265           *    4. a = bit10 - b24
    266           *    5. i -= 16
    267           *    6. fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2
    268           *
    269           * Returns:
    270           *    void
    271           */

   \                                 In segment CODE, align 4, keep-with-next
    272          void D_UTIL_normalised_inverse_sqrt(Word32 *frac, Word16 *exp)
    273          {
    274             Word32 i, tmp;
    275             Word16 a;
    276          
    277             if(*frac <= (Word32)0)
   \                     D_UTIL_normalised_inverse_sqrt:
   \   00000000   002090E5           LDR      R2,[R0, #+0]
   \   00000004   010052E3           CMP      R2,#+1
   \   00000008   030000AA           BGE      ??D_UTIL_normalised_inverse_sqrt_0
    278             {
    279                *exp = 0;
   \   0000000C   0020A0E3           MOV      R2,#+0
   \   00000010   B020C1E1           STRH     R2,[R1, #+0]
    280                *frac = 0x7fffffffL;
   \   00000014   8014E0E3           MVN      R1,#-2147483648
   \   00000018   170000EA           B        ??D_UTIL_normalised_inverse_sqrt_1
    281                return;
    282             }
    283          
    284             if((*exp & 0x1) == 1)   /* If exponant odd -> shift right */
   \                     ??D_UTIL_normalised_inverse_sqrt_0:
   \   0000001C   F030D1E1           LDRSH    R3,[R1, #+0]
   \   00000020   010013E3           TST      R3,#0x1
    285             {
    286                *frac = *frac >> 1;
   \   00000024   C220A011           ASRNE    R2,R2,#+1
   \   00000028   00208015           STRNE    R2,[R0, #+0]
    287             }
    288             *exp = (Word16)(-((*exp - 1) >> 1));
   \   0000002C   012043E2           SUB      R2,R3,#+1
    289             *frac = *frac >> 9;
    290             i = *frac >>16;      /* Extract b25-b31   */
    291             *frac = *frac >> 1;
    292             a = (Word16)(*frac); /* Extract b10-b24   */
    293             a = (Word16)(a & (Word16)0x7fff);
    294             i = i - 16;
    295             *frac = D_ROM_isqrt[i] << 16; /* table[i] << 16    */
    296             tmp = D_ROM_isqrt[i] - D_ROM_isqrt[i + 1];   /* table[i] - table[i+1]) */
    297             *frac = *frac - ((tmp * a) << 1);   /* frac -=  tmp*a*2  */
   \   00000030   ........           LDR      R3,??DataTable1  ;; D_ROM_isqrt
   \   00000034   C220A0E1           ASR      R2,R2,#+1
   \   00000038   002062E2           RSB      R2,R2,#+0
   \   0000003C   B020C1E1           STRH     R2,[R1, #+0]
   \   00000040   001090E5           LDR      R1,[R0, #+0]
   \   00000044   C114A0E1           ASR      R1,R1,#+9
   \   00000048   001080E5           STR      R1,[R0, #+0]
   \   0000004C   4128A0E1           ASR      R2,R1,#+16
   \   00000050   102042E2           SUB      R2,R2,#+16
   \   00000054   822083E0           ADD      R2,R3,R2, LSL #+1
   \   00000058   F030D2E1           LDRSH    R3,[R2, #+0]
   \   0000005C   F220D2E1           LDRSH    R2,[R2, #+2]
   \   00000060   C110A0E1           ASR      R1,R1,#+1
   \   00000064   8118A0E1           LSL      R1,R1,#+17
   \   00000068   022043E0           SUB      R2,R3,R2
   \   0000006C   A118A0E1           LSR      R1,R1,#+17
   \   00000070   910202E0           MUL      R2,R1,R2
   \   00000074   03C8A0E1           LSL      R12,R3,#+16
   \   00000078   82104CE0           SUB      R1,R12,R2, LSL #+1
   \                     ??D_UTIL_normalised_inverse_sqrt_1:
   \   0000007C   001080E5           STR      R1,[R0, #+0]
    298          
    299             return;
   \   00000080   1EFF2FE1           BX       LR               ;; return
    300          }
    301          
    302          
    303          /*
    304           * D_UTIL_inverse_sqrt
    305           *
    306           * Parameters:
    307           *    L_x     I/O: (Q0) input value (range: 0<=val<=7fffffff)
    308           *
    309           * Function:
    310           *    Compute 1/sqrt(L_x).
    311           *    If value is negative or zero, result is 1 (7fffffff).
    312           *
    313           *    The function 1/sqrt(value) is approximated by a table and linear
    314           *    interpolation.
    315           *    1. Normalization of L_x
    316           *    2. call Normalised_Inverse_sqrt(L_x, exponant)
    317           *    3. L_y = L_x << exponant
    318           *
    319           * Returns:
    320           *    (Q31) output value (range: 0 <= val < 1)
    321           */

   \                                 In segment CODE, align 4, keep-with-next
    322          Word32 D_UTIL_inverse_sqrt(Word32 L_x)
    323          {
    324             Word32 L_y;
    325             Word16 exp;
    326          
    327             exp = D_UTIL_norm_l(L_x);
   \                     D_UTIL_inverse_sqrt:
   \   00000000   0020B0E1           MOVS     R2,R0
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0030A003           MOVEQ    R3,#+0
   \   0000000C   0B00000A           BEQ      ??D_UTIL_inverse_sqrt_0
   \   00000010   010072E3           CMN      R2,#+1
   \   00000014   1F30A003           MOVEQ    R3,#+31
   \   00000018   0800000A           BEQ      ??D_UTIL_inverse_sqrt_0
   \   0000001C   000052E3           CMP      R2,#+0
   \   00000020   0220E041           MVNMI    R2,R2
   \   00000024   0030A0E3           MOV      R3,#+0
   \   00000028   400452E3           CMP      R2,#+1073741824
   \   0000002C   030000AA           BGE      ??D_UTIL_inverse_sqrt_0
   \                     ??D_UTIL_inverse_sqrt_1:
   \   00000030   8220A0E1           LSL      R2,R2,#+1
   \   00000034   013083E2           ADD      R3,R3,#+1
   \   00000038   400452E3           CMP      R2,#+1073741824
   \   0000003C   FBFFFFBA           BLT      ??D_UTIL_inverse_sqrt_1
    328             L_x = (L_x << exp);   /* L_x is normalized */
   \                     ??D_UTIL_inverse_sqrt_0:
   \   00000040   1003A0E1           LSL      R0,R0,R3
    329             exp = (Word16)(31 - exp);
   \   00000044   1F2063E2           RSB      R2,R3,#+31
    330             D_UTIL_normalised_inverse_sqrt(&L_x, &exp);
   \   00000048   010050E3           CMP      R0,#+1
   \   0000004C   020000AA           BGE      ??D_UTIL_inverse_sqrt_2
   \   00000050   8004E0E3           MVN      R0,#-2147483648
    331          
    332             if(exp < 0)
    333             {
    334                L_y = (L_x >> -exp);   /* denormalization   */
    335             }
    336             else
    337             {
    338                L_y = (L_x << exp);   /* denormalization   */
   \                     ??D_UTIL_inverse_sqrt_3:
   \   00000054   1001A0E1           LSL      R0,R0,R1
    339             }
    340          
    341             return(L_y);
   \   00000058   1EFF2FE1           BX       LR               ;; return
   \                     ??D_UTIL_inverse_sqrt_2:
   \   0000005C   ........           LDR      R3,??DataTable1  ;; D_ROM_isqrt
   \   00000060   010012E3           TST      R2,#0x1
   \   00000064   C000A011           ASRNE    R0,R0,#+1
   \   00000068   0228A0E1           MOV      R2,R2, LSL #+16
   \   0000006C   4228A0E1           MOV      R2,R2, ASR #+16
   \   00000070   011042E2           SUB      R1,R2,#+1
   \   00000074   C004A0E1           ASR      R0,R0,#+9
   \   00000078   4028A0E1           ASR      R2,R0,#+16
   \   0000007C   102042E2           SUB      R2,R2,#+16
   \   00000080   822083E0           ADD      R2,R3,R2, LSL #+1
   \   00000084   F030D2E1           LDRSH    R3,[R2, #+0]
   \   00000088   F220D2E1           LDRSH    R2,[R2, #+2]
   \   0000008C   C000A0E1           ASR      R0,R0,#+1
   \   00000090   8008A0E1           LSL      R0,R0,#+17
   \   00000094   022043E0           SUB      R2,R3,R2
   \   00000098   A008A0E1           LSR      R0,R0,#+17
   \   0000009C   900202E0           MUL      R2,R0,R2
   \   000000A0   C110A0E1           ASR      R1,R1,#+1
   \   000000A4   001061E2           RSB      R1,R1,#+0
   \   000000A8   03C8A0E1           LSL      R12,R3,#+16
   \   000000AC   82004CE0           SUB      R0,R12,R2, LSL #+1
   \   000000B0   0118A0E1           MOV      R1,R1, LSL #+16
   \   000000B4   4118B0E1           MOVS     R1,R1, ASR #+16
   \   000000B8   E5FFFF5A           BPL      ??D_UTIL_inverse_sqrt_3
   \   000000BC   001061E2           RSB      R1,R1,#+0
   \   000000C0   5001A0E1           ASR      R0,R0,R1
   \   000000C4   1EFF2FE1           BX       LR
    342          }
    343          
    344          
    345          /*
    346           * D_UTIL_normalised_log2
    347           *
    348           * Parameters:
    349           *    L_x      I: input value (normalized)
    350           *    exp      I: norm_l (L_x)
    351           *    exponent O: Integer part of Log2.   (range: 0<=val<=30)
    352           *    fraction O: Fractional part of Log2. (range: 0<=val<1)
    353           *
    354           * Function:
    355           *    Computes log2(L_x, exp),  where   L_x is positive and
    356           *    normalized, and exp is the normalisation exponent
    357           *    If L_x is negative or zero, the result is 0.
    358           *
    359           *    The function Log2(L_x) is approximated by a table and linear
    360           *    interpolation. The following steps are used to compute Log2(L_x)
    361           *
    362           *    1. exponent = 30 - norm_exponent
    363           *    2. i = bit25 - b31 of L_x;  32 <= i <= 63  (because of normalization).
    364           *    3. a = bit10 - b24
    365           *    4. i -= 32
    366           *    5. fraction = table[i] << 16 - (table[i] - table[i + 1]) * a * 2
    367           *
    368           *
    369           * Returns:
    370           *    void
    371           */
    372          static void D_UTIL_normalised_log2(Word32 L_x, Word16 exp, Word16 *exponent,
    373                                             Word16 *fraction)
    374          {
    375             Word32 i, a, tmp;
    376             Word32 L_y;
    377          
    378             if (L_x <= 0)
    379             {
    380                *exponent = 0;
    381                *fraction = 0;
    382                return;
    383             }
    384          
    385             *exponent = (Word16)(30 - exp);
    386          
    387             L_x = L_x >> 10;
    388             i = L_x >> 15;         /* Extract b25-b31               */
    389             a = L_x;               /* Extract b10-b24 of fraction   */
    390             a = a & 0x00007fff;
    391             i = i - 32;
    392             L_y = D_ROM_log2[i] << 16;               /* table[i] << 16        */
    393             tmp = D_ROM_log2[i] - D_ROM_log2[i + 1]; /* table[i] - table[i+1] */
    394             L_y = L_y - ((tmp * a) << 1);            /* L_y -= tmp*a*2        */
    395             *fraction = (Word16)(L_y >> 16);
    396          
    397             return;
    398          }
    399          
    400          
    401          /*
    402           * D_UTIL_log2
    403           *
    404           * Parameters:
    405           *    L_x      I: input value
    406           *    exponent O: Integer part of Log2.   (range: 0<=val<=30)
    407           *    fraction O: Fractional part of Log2. (range: 0<=val<1)
    408           *
    409           * Function:
    410           *    Computes log2(L_x),  where   L_x is positive.
    411           *    If L_x is negative or zero, the result is 0.
    412           *
    413           * Returns:
    414           *    void
    415           */

   \                                 In segment CODE, align 4, keep-with-next
    416          void D_UTIL_log2(Word32 L_x, Word16 *exponent, Word16 *fraction)
    417          {
   \                     D_UTIL_log2:
   \   00000000   10002DE9           PUSH     {R4}
    418             Word16 exp;
    419          
    420             exp = D_UTIL_norm_l(L_x);
   \   00000004   0030B0E1           MOVS     R3,R0
   \   00000008   00C0A0E3           MOV      R12,#+0
   \   0000000C   0040A003           MOVEQ    R4,#+0
   \   00000010   0B00000A           BEQ      ??D_UTIL_log2_0
   \   00000014   010073E3           CMN      R3,#+1
   \   00000018   1F40A003           MOVEQ    R4,#+31
   \   0000001C   0800000A           BEQ      ??D_UTIL_log2_0
   \   00000020   000053E3           CMP      R3,#+0
   \   00000024   0330E041           MVNMI    R3,R3
   \   00000028   0040A0E3           MOV      R4,#+0
   \   0000002C   400453E3           CMP      R3,#+1073741824
   \   00000030   030000AA           BGE      ??D_UTIL_log2_0
   \                     ??D_UTIL_log2_1:
   \   00000034   8330A0E1           LSL      R3,R3,#+1
   \   00000038   014084E2           ADD      R4,R4,#+1
   \   0000003C   400453E3           CMP      R3,#+1073741824
   \   00000040   FBFFFFBA           BLT      ??D_UTIL_log2_1
   \                     ??D_UTIL_log2_0:
   \   00000044   0448A0E1           MOV      R4,R4, LSL #+16
   \   00000048   4448A0E1           MOV      R4,R4, ASR #+16
    421             D_UTIL_normalised_log2((L_x <<exp), exp, exponent, fraction);
   \   0000004C   1004A0E1           LSL      R0,R0,R4
   \   00000050   010050E3           CMP      R0,#+1
   \   00000054   B0C0C1B1           STRHLT   R12,[R1, #+0]
   \   00000058   0F0000BA           BLT      ??D_UTIL_log2_2
   \   0000005C   1E3064E2           RSB      R3,R4,#+30
   \   00000060   B030C1E1           STRH     R3,[R1, #+0]
   \   00000064   3C309FE5           LDR      R3,??D_UTIL_log2_3  ;; D_ROM_log2
   \   00000068   4005A0E1           ASR      R0,R0,#+10
   \   0000006C   C017A0E1           ASR      R1,R0,#+15
   \   00000070   201041E2           SUB      R1,R1,#+32
   \   00000074   811083E0           ADD      R1,R3,R1, LSL #+1
   \   00000078   F030D1E1           LDRSH    R3,[R1, #+0]
   \   0000007C   F210D1E1           LDRSH    R1,[R1, #+2]
   \   00000080   8008A0E1           LSL      R0,R0,#+17
   \   00000084   A008A0E1           LSR      R0,R0,#+17
   \   00000088   011043E0           SUB      R1,R3,R1
   \   0000008C   900101E0           MUL      R1,R0,R1
   \   00000090   0348A0E1           LSL      R4,R3,#+16
   \   00000094   810044E0           SUB      R0,R4,R1, LSL #+1
   \   00000098   40C8A0E1           ASR      R12,R0,#+16
   \                     ??D_UTIL_log2_2:
   \   0000009C   B0C0C2E1           STRH     R12,[R2, #+0]
    422          }
   \   000000A0   1000BDE8           POP      {R4}
   \   000000A4   1EFF2FE1           BX       LR               ;; return
   \                     ??D_UTIL_log2_3:
   \   000000A8   ........           DC32     D_ROM_log2
    423          
    424          
    425          /*
    426           * D_UTIL_l_extract
    427           *
    428           * Parameters:
    429           *    L_32        I: 32 bit integer.
    430           *    hi          O: b16 to b31 of L_32
    431           *    lo          O: (L_32 - hi<<16)>>1
    432           *
    433           * Function:
    434           *    Extract from a 32 bit integer two 16 bit DPF.
    435           *
    436           * Returns:
    437           *    void
    438           */

   \                                 In segment CODE, align 4, keep-with-next
    439          void D_UTIL_l_extract(Word32 L_32, Word16 *hi, Word16 *lo)
    440          {
    441             *hi = (Word16)(L_32 >> 16);
   \                     D_UTIL_l_extract:
   \   00000000   4038A0E1           ASR      R3,R0,#+16
   \   00000004   B030C1E1           STRH     R3,[R1, #+0]
    442             *lo = (Word16)((L_32 >> 1) - (*hi * 32768));
   \   00000008   F010D1E1           LDRSH    R1,[R1, #+0]
   \   0000000C   C000A0E1           ASR      R0,R0,#+1
   \   00000010   810740E0           SUB      R0,R0,R1, LSL #+15
   \   00000014   B000C2E1           STRH     R0,[R2, #+0]
    443          
    444             return;
   \   00000018   1EFF2FE1           BX       LR               ;; return
    445          }
    446          
    447          
    448          /*
    449           * D_UTIL_mpy_32_16
    450           *
    451           * Parameters:
    452           *    hi          I: hi part of 32 bit number
    453           *    lo          I: lo part of 32 bit number
    454           *    n           I: 16 bit number
    455           *
    456           * Function:
    457           *    Multiply a 16 bit integer by a 32 bit (DPF). The result is divided
    458           *    by 2^15.
    459           *
    460           *    L_32 = (hi1*lo2)<<1 + ((lo1*lo2)>>15)<<1
    461           *
    462           * Returns:
    463           *    32 bit result
    464           */

   \                                 In segment CODE, align 4, keep-with-next
    465          Word32 D_UTIL_mpy_32_16(Word16 hi, Word16 lo, Word16 n)
    466          {
    467             Word32 L_32;
    468          
    469             L_32 = hi * n;
    470             L_32 += (lo * n) >> 15;
    471          
    472             return(L_32 << 1);
   \                     D_UTIL_mpy_32_16:
   \   00000000   920000E0           MUL      R0,R2,R0
   \   00000004   920101E0           MUL      R1,R2,R1
   \   00000008   C10780E0           ADD      R0,R0,R1, ASR #+15
   \   0000000C   8000A0E1           LSL      R0,R0,#+1
   \   00000010   1EFF2FE1           BX       LR               ;; return
    473          }
    474          
    475          
    476          /*
    477           * D_UTIL_mpy_32
    478           *
    479           * Parameters:
    480           *    hi1         I: hi part of first number
    481           *    lo1         I: lo part of first number
    482           *    hi2         I: hi part of second number
    483           *    lo2         I: lo part of second number
    484           *
    485           * Function:
    486           *    Multiply two 32 bit integers (DPF). The result is divided by 2^31
    487           *
    488           *    L_32 = (hi1*lo2)<<1 + ((lo1*lo2)>>15)<<1
    489           *
    490           * Returns:
    491           *    32 bit result
    492           */

   \                                 In segment CODE, align 4, keep-with-next
    493          Word32 D_UTIL_mpy_32(Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2)
    494          {
    495             Word32 L_32;
    496          
    497             L_32 = hi1 * hi2;
    498             L_32 += (hi1 * lo2) >> 15;
    499             L_32 += (lo1 * hi2) >> 15;
    500          
    501             return(L_32 << 1);
   \                     D_UTIL_mpy_32:
   \   00000000   92000CE0           MUL      R12,R2,R0
   \   00000004   930000E0           MUL      R0,R3,R0
   \   00000008   920101E0           MUL      R1,R2,R1
   \   0000000C   C0078CE0           ADD      R0,R12,R0, ASR #+15
   \   00000010   C10780E0           ADD      R0,R0,R1, ASR #+15
   \   00000014   8000A0E1           LSL      R0,R0,#+1
   \   00000018   1EFF2FE1           BX       LR               ;; return
    502          }
    503          
    504          /*
    505           * D_UTIL_saturate
    506           *
    507           * Parameters:
    508           *    inp        I: 32-bit number
    509           *
    510           * Function:
    511           *    Saturation to 16-bit number
    512           *
    513           * Returns:
    514           *    16-bit number
    515           */

   \                                 In segment CODE, align 4, keep-with-next
    516          Word16 D_UTIL_saturate(Word32 inp)
    517          {
    518            Word16 out;
    519            if ((inp < MAX_16) & (inp > MIN_16))
   \                     D_UTIL_saturate:
   \   00000000   FF10A0E3           MOV      R1,#+255
   \   00000004   7F1C81E3           ORR      R1,R1,#0x7F00
   \   00000008   010050E1           CMP      R0,R1
   \   0000000C   020000AA           BGE      ??D_UTIL_saturate_0
   \   00000010   002061E2           RSB      R2,R1,#+0
   \   00000014   020050E1           CMP      R0,R2
   \   00000018   020000AA           BGE      ??D_UTIL_saturate_1
    520            {
    521               out = (Word16)inp;
    522            }
    523            else
    524            {
    525               if (inp > 0)
   \                     ??D_UTIL_saturate_0:
   \   0000001C   010050E3           CMP      R0,#+1
    526               {
    527                  out = MAX_16;
   \   00000020   0100A0A1           MOVGE    R0,R1
    528               }
    529               else
    530               {
    531                  out = MIN_16;
   \   00000024   0100E0B1           MVNLT    R0,R1
    532               }
    533            }
    534          
    535            return(out);
   \                     ??D_UTIL_saturate_1:
   \   00000028   0008A0E1           MOV      R0,R0, LSL #+16
   \   0000002C   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000030   1EFF2FE1           BX       LR               ;; return
    536          }
    537          
    538          /*
    539           * D_UTIL_signal_up_scale
    540           *
    541           * Parameters:
    542           *    x         I/O: signal to scale
    543           *    lg          I: size of x[]
    544           *    exp         I: exponent: x = round(x << exp)
    545           *
    546           * Function:
    547           *    Scale signal up to get maximum of dynamic.
    548           *
    549           * Returns:
    550           *    32 bit result
    551           */

   \                                 In segment CODE, align 4, keep-with-next
    552          void D_UTIL_signal_up_scale(Word16 x[], Word16 lg, Word16 exp)
    553          {
   \                     D_UTIL_signal_up_scale:
   \   00000000   70002DE9           PUSH     {R4-R6}
    554              Word32 i, tmp;
    555          
    556              for (i = 0; i < lg; i++)
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   010051E3           CMP      R1,#+1
   \   0000000C   120000BA           BLT      ??D_UTIL_signal_up_scale_0
   \   00000010   FE60E0E3           MVN      R6,#+254
   \   00000014   7F6CC6E3           BIC      R6,R6,#0x7F00
   \   00000018   010000EA           B        ??D_UTIL_signal_up_scale_1
    557              {
    558                 tmp = x[i] << exp;
    559                 x[i] = D_UTIL_saturate(tmp);
   \                     ??D_UTIL_signal_up_scale_2:
   \   0000001C   B0C0C4E1           STRH     R12,[R4, #+0]
   \   00000020   013083E2           ADD      R3,R3,#+1
   \                     ??D_UTIL_signal_up_scale_1:
   \   00000024   010053E1           CMP      R3,R1
   \   00000028   0B0000AA           BGE      ??D_UTIL_signal_up_scale_0
   \   0000002C   834080E0           ADD      R4,R0,R3, LSL #+1
   \   00000030   F050D4E1           LDRSH    R5,[R4, #+0]
   \   00000034   00C066E2           RSB      R12,R6,#+0
   \   00000038   1552A0E1           LSL      R5,R5,R2
   \   0000003C   0C0055E1           CMP      R5,R12
   \   00000040   020000AA           BGE      ??D_UTIL_signal_up_scale_3
   \   00000044   060055E1           CMP      R5,R6
   \   00000048   05C0A0A1           MOVGE    R12,R5
   \   0000004C   F2FFFFAA           BGE      ??D_UTIL_signal_up_scale_2
   \                     ??D_UTIL_signal_up_scale_3:
   \   00000050   010055E3           CMP      R5,#+1
   \   00000054   01C0C6B3           BICLT    R12,R6,#0x1
   \   00000058   EFFFFFEA           B        ??D_UTIL_signal_up_scale_2
    560              }
    561          
    562              return;
   \                     ??D_UTIL_signal_up_scale_0:
   \   0000005C   7000BDE8           POP      {R4-R6}
   \   00000060   1EFF2FE1           BX       LR               ;; return
    563          }
    564          
    565          
    566          /*
    567           * D_UTIL_signal_down_scale
    568           *
    569           * Parameters:
    570           *    x         I/O: signal to scale
    571           *    lg          I: size of x[]
    572           *    exp         I: exponent: x = round(x << exp)
    573           *
    574           * Function:
    575           *    Scale signal up to get maximum of dynamic.
    576           *
    577           * Returns:
    578           *    32 bit result
    579           */

   \                                 In segment CODE, align 4, keep-with-next
    580          void D_UTIL_signal_down_scale(Word16 x[], Word16 lg, Word16 exp)
    581          {
   \                     D_UTIL_signal_down_scale:
   \   00000000   30002DE9           PUSH     {R4,R5}
    582             Word32 i, tmp;
    583          
    584             for(i = 0; i < lg; i++)
   \   00000004   0030A0E3           MOV      R3,#+0
   \   00000008   010051E3           CMP      R1,#+1
   \   0000000C   0A0000BA           BLT      ??D_UTIL_signal_down_scale_0
   \   00000010   805CA0E3           MOV      R5,#+32768
   \   00000014   060000EA           B        ??D_UTIL_signal_down_scale_1
    585             {
    586                tmp = x[i] << 16;
    587                tmp = tmp >> exp;
    588                x[i] = (Word16)((tmp + 0x8000) >> 16);
   \                     ??D_UTIL_signal_down_scale_2:
   \   00000018   83C080E0           ADD      R12,R0,R3, LSL #+1
   \   0000001C   F040DCE1           LDRSH    R4,[R12, #+0]
    589             }
   \   00000020   013083E2           ADD      R3,R3,#+1
   \   00000024   0448A0E1           LSL      R4,R4,#+16
   \   00000028   544285E0           ADD      R4,R5,R4, ASR R2
   \   0000002C   4448A0E1           ASR      R4,R4,#+16
   \   00000030   B040CCE1           STRH     R4,[R12, #+0]
   \                     ??D_UTIL_signal_down_scale_1:
   \   00000034   010053E1           CMP      R3,R1
   \   00000038   F6FFFFBA           BLT      ??D_UTIL_signal_down_scale_2
    590          
    591             return;
   \                     ??D_UTIL_signal_down_scale_0:
   \   0000003C   3000BDE8           POP      {R4,R5}
   \   00000040   1EFF2FE1           BX       LR               ;; return
    592          }
    593          
    594          
    595          /*
    596           * D_UTIL_deemph_32
    597           *
    598           * Parameters:
    599           *    x_hi           I: input signal (bit31..16)
    600           *    x_lo           I: input signal (bit15..4)
    601           *    y              O: output signal (x16)
    602           *    mu             I: (Q15) deemphasis factor
    603           *    L              I: vector size
    604           *    mem          I/O: memory (y[-1])
    605           *
    606           * Function:
    607           *    Filtering through 1/(1-mu z^-1)
    608           *
    609           * Returns:
    610           *    void
    611           */

   \                                 In segment CODE, align 4, keep-with-next
    612          static void D_UTIL_deemph_32(Word16 x_hi[], Word16 x_lo[], Word16 y[],
    613                                       Word16 mu, Word16 L, Word16 *mem)
    614          {
   \                     D_UTIL_deemph_32:
   \   00000000   F00F2DE9           PUSH     {R4-R11}
    615             Word32 i, fac;
    616             Word32 tmp;
    617          
    618             fac = mu >> 1;   /* Q15 --> Q14 */
    619          
    620             /* L_tmp = hi<<16 + lo<<4 */
    621             tmp = (x_hi[0] << 12) + x_lo[0];
    622             tmp = (tmp << 6) + (*mem * fac);
    623             tmp = (tmp + 0x2000) >> 14;
    624             y[0] = D_UTIL_saturate(tmp);
   \   00000004   F050D0E1           LDRSH    R5,[R0, #+0]
   \   00000008   F060D1E1           LDRSH    R6,[R1, #+0]
   \   0000000C   24C09DE5           LDR      R12,[SP, #+36]
   \   00000010   F042DDE1           LDRSH    R4,[SP, #+32]
   \   00000014   055686E0           ADD      R5,R6,R5, LSL #+12
   \   00000018   F060DCE1           LDRSH    R6,[R12, #+0]
   \   0000001C   C330A0E1           ASR      R3,R3,#+1
   \   00000020   930606E0           MUL      R6,R3,R6
   \   00000024   055386E0           ADD      R5,R6,R5, LSL #+6
   \   00000028   805D85E2           ADD      R5,R5,#+8192
   \   0000002C   4577A0E1           ASR      R7,R5,#+14
   \   00000030   FE50E0E3           MVN      R5,#+254
   \   00000034   7F5CC5E3           BIC      R5,R5,#0x7F00
   \   00000038   006065E2           RSB      R6,R5,#+0
   \   0000003C   060057E1           CMP      R7,R6
   \   00000040   010000AA           BGE      ??D_UTIL_deemph_32_0
   \   00000044   050057E1           CMP      R7,R5
   \   00000048   020000AA           BGE      ??D_UTIL_deemph_32_1
   \                     ??D_UTIL_deemph_32_0:
   \   0000004C   010057E3           CMP      R7,#+1
   \   00000050   0670A0A1           MOVGE    R7,R6
   \   00000054   0170C5B3           BICLT    R7,R5,#0x1
   \                     ??D_UTIL_deemph_32_1:
   \   00000058   B070C2E1           STRH     R7,[R2, #+0]
    625          
    626             for(i = 1; i < L; i++)
   \   0000005C   0180A0E3           MOV      R8,#+1
   \   00000060   0470A0E1           MOV      R7,R4
   \   00000064   020054E3           CMP      R4,#+2
   \   00000068   060000AA           BGE      ??D_UTIL_deemph_32_2
    627             {
    628                tmp = (x_hi[i] << 12) + x_lo[i];
    629                tmp = (tmp << 6) + (y[i - 1] * fac);
    630                tmp = (tmp + 0x2000) >> 14;
    631                y[i] = D_UTIL_saturate(tmp);
    632             }
    633          
    634             *mem = y[L - 1];
   \                     ??D_UTIL_deemph_32_3:
   \   0000006C   870082E0           ADD      R0,R2,R7, LSL #+1
   \   00000070   F20050E1           LDRSH    R0,[R0, #-2]
   \   00000074   B000CCE1           STRH     R0,[R12, #+0]
    635          
    636             return;
   \   00000078   F00FBDE8           POP      {R4-R11}
   \   0000007C   1EFF2FE1           BX       LR               ;; return
   \                     ??D_UTIL_deemph_32_4:
   \   00000080   B090C4E1           STRH     R9,[R4, #+0]
   \   00000084   018088E2           ADD      R8,R8,#+1
   \                     ??D_UTIL_deemph_32_2:
   \   00000088   070058E1           CMP      R8,R7
   \   0000008C   F6FFFFAA           BGE      ??D_UTIL_deemph_32_3
   \   00000090   884082E0           ADD      R4,R2,R8, LSL #+1
   \   00000094   F29054E1           LDRSH    R9,[R4, #-2]
   \   00000098   88A080E0           ADD      R10,R0,R8, LSL #+1
   \   0000009C   F0A0DAE1           LDRSH    R10,[R10, #+0]
   \   000000A0   88B081E0           ADD      R11,R1,R8, LSL #+1
   \   000000A4   F0B0DBE1           LDRSH    R11,[R11, #+0]
   \   000000A8   930909E0           MUL      R9,R3,R9
   \   000000AC   0AA68BE0           ADD      R10,R11,R10, LSL #+12
   \   000000B0   0A9389E0           ADD      R9,R9,R10, LSL #+6
   \   000000B4   809D89E2           ADD      R9,R9,#+8192
   \   000000B8   4997A0E1           ASR      R9,R9,#+14
   \   000000BC   060059E1           CMP      R9,R6
   \   000000C0   010000AA           BGE      ??D_UTIL_deemph_32_5
   \   000000C4   050059E1           CMP      R9,R5
   \   000000C8   ECFFFFAA           BGE      ??D_UTIL_deemph_32_4
   \                     ??D_UTIL_deemph_32_5:
   \   000000CC   010059E3           CMP      R9,#+1
   \   000000D0   0190C5B3           BICLT    R9,R5,#0x1
   \   000000D4   0690A0A1           MOVGE    R9,R6
   \   000000D8   E8FFFFEA           B        ??D_UTIL_deemph_32_4
    637          }
    638          
    639          
    640          /*
    641           * D_UTIL_synthesis_32
    642           *
    643           * Parameters:
    644           *    a              I: LP filter coefficients
    645           *    m              I: order of LP filter
    646           *    exc            I: excitation
    647           *    Qnew           I: exc scaling = 0(min) to 8(max)
    648           *    sig_hi         O: synthesis high
    649           *    sig_lo         O: synthesis low
    650           *    lg             I: size of filtering
    651           *
    652           * Function:
    653           *    Perform the synthesis filtering 1/A(z).
    654           *
    655           * Returns:
    656           *    void
    657           */

   \                                 In segment CODE, align 4, keep-with-next
    658          static void D_UTIL_synthesis_32(Word16 a[], Word16 m, Word16 exc[],
    659                                          Word16 Qnew, Word16 sig_hi[], Word16 sig_lo[],
    660                                          Word16 lg)
    661          {
   \                     D_UTIL_synthesis_32:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
    662             Word32 i, j, a0, s;
    663             Word32 tmp, tmp2;
    664          
    665             /* See if a[0] is scaled */
    666             s = D_UTIL_norm_s((Word16)a[0]) - 2;
   \   00000004   F050D0E1           LDRSH    R5,[R0, #+0]
   \   00000008   28C09DE5           LDR      R12,[SP, #+40]
   \   0000000C   2C409DE5           LDR      R4,[SP, #+44]
   \   00000010   F023DDE1           LDRSH    R2,[SP, #+48]
   \   00000014   0060A0E3           MOV      R6,#+0
   \   00000018   000055E3           CMP      R5,#+0
   \   0000001C   0E00000A           BEQ      ??D_UTIL_synthesis_32_0
   \   00000020   0670E0E1           MVN      R7,R6
   \   00000024   070055E1           CMP      R5,R7
   \   00000028   0F60A003           MOVEQ    R6,#+15
   \   0000002C   0A00000A           BEQ      ??D_UTIL_synthesis_32_0
   \   00000030   000055E3           CMP      R5,#+0
   \   00000034   0550E041           MVNMI    R5,R5
   \   00000038   0558A0E1           MOV      R5,R5, LSL #+16
   \   0000003C   4558A0E1           MOV      R5,R5, ASR #+16
   \   00000040   400C55E3           CMP      R5,#+16384
   \   00000044   040000AA           BGE      ??D_UTIL_synthesis_32_0
   \                     ??D_UTIL_synthesis_32_1:
   \   00000048   8558A0E1           LSL      R5,R5,#+17
   \   0000004C   016086E2           ADD      R6,R6,#+1
   \   00000050   4558A0E1           ASR      R5,R5,#+16
   \   00000054   400C55E3           CMP      R5,#+16384
   \   00000058   FAFFFFBA           BLT      ??D_UTIL_synthesis_32_1
   \                     ??D_UTIL_synthesis_32_0:
   \   0000005C   0668A0E1           MOV      R6,R6, LSL #+16
   \   00000060   4668A0E1           MOV      R6,R6, ASR #+16
   \   00000064   025046E2           SUB      R5,R6,#+2
    667          
    668             a0 = a[0] >> (4 + Qnew);   /* input / 16 and >>Qnew */
   \   00000068   F060D0E1           LDRSH    R6,[R0, #+0]
   \   0000006C   043083E2           ADD      R3,R3,#+4
    669          
    670             /* Do the filtering. */
    671             for(i = 0; i < lg; i++)
   \   00000070   010052E3           CMP      R2,#+1
   \   00000074   5633A0E1           ASR      R3,R6,R3
   \   00000078   0060A0E3           MOV      R6,#+0
   \   0000007C   F18FBDB8           POPLT    {R0,R4-R11,PC}
   \   00000080   140000EA           B        ??D_UTIL_synthesis_32_2
    672             {
    673                tmp = 0;
    674          
    675                for(j = 1; j <= m; j++)
    676                {
    677                   tmp -= sig_lo[i - j] * a[j];
    678                }
    679          
    680                tmp = tmp >> (15 - 4);   /* -4 : sig_lo[i] << 4 */
    681          
    682                tmp2 = exc[i] * a0;
    683          
    684                for(j = 1; j <= m; j++)
    685                {
    686                   tmp2 -= sig_hi[i - j] * a[j];
   \                     ??D_UTIL_synthesis_32_3:
   \   00000084   09B046E0           SUB      R11,R6,R9
   \   00000088   8BB08CE0           ADD      R11,R12,R11, LSL #+1
   \   0000008C   F0B0DBE1           LDRSH    R11,[R11, #+0]
   \   00000090   89E080E0           ADD      LR,R0,R9, LSL #+1
   \   00000094   F0E0DEE1           LDRSH    LR,[LR, #+0]
    687                }
   \   00000098   019089E2           ADD      R9,R9,#+1
   \   0000009C   9E0B0BE0           MUL      R11,LR,R11
   \   000000A0   0B8048E0           SUB      R8,R8,R11
   \                     ??D_UTIL_synthesis_32_4:
   \   000000A4   090051E1           CMP      R1,R9
   \   000000A8   F5FFFFAA           BGE      ??D_UTIL_synthesis_32_3
    688          
    689                tmp += tmp2 << 1;
    690                tmp <<= s;
   \                     ??D_UTIL_synthesis_32_5:
   \   000000AC   88708AE0           ADD      R7,R10,R8, LSL #+1
   \   000000B0   1775A0E1           LSL      R7,R7,R5
    691          
    692                /* sig_hi = bit16 to bit31 of synthesis */
    693                sig_hi[i] = (Word16)(tmp >> 13);
   \   000000B4   86808CE0           ADD      R8,R12,R6, LSL #+1
   \   000000B8   C796A0E1           ASR      R9,R7,#+13
   \   000000BC   B090C8E1           STRH     R9,[R8, #+0]
    694          
    695                /* sig_lo = bit4 to bit15 of synthesis */
    696                sig_lo[i] = (Word16)((tmp  >> 1) - (sig_hi[i] * 4096));
   \   000000C0   F080D8E1           LDRSH    R8,[R8, #+0]
   \   000000C4   869084E0           ADD      R9,R4,R6, LSL #+1
   \   000000C8   C770A0E1           ASR      R7,R7,#+1
   \   000000CC   087647E0           SUB      R7,R7,R8, LSL #+12
   \   000000D0   B070C9E1           STRH     R7,[R9, #+0]
   \   000000D4   016086E2           ADD      R6,R6,#+1
   \                     ??D_UTIL_synthesis_32_2:
   \   000000D8   020056E1           CMP      R6,R2
   \   000000DC   F18FBDA8           POPGE    {R0,R4-R11,PC}
   \   000000E0   0080A0E3           MOV      R8,#+0
   \   000000E4   0190A0E3           MOV      R9,#+1
   \   000000E8   010051E3           CMP      R1,#+1
   \   000000EC   080000AA           BGE      ??D_UTIL_synthesis_32_6
   \   000000F0   090000EA           B        ??D_UTIL_synthesis_32_7
   \                     ??D_UTIL_synthesis_32_8:
   \   000000F4   09A046E0           SUB      R10,R6,R9
   \   000000F8   8AA084E0           ADD      R10,R4,R10, LSL #+1
   \   000000FC   F0A0DAE1           LDRSH    R10,[R10, #+0]
   \   00000100   89B080E0           ADD      R11,R0,R9, LSL #+1
   \   00000104   F0B0DBE1           LDRSH    R11,[R11, #+0]
   \   00000108   019089E2           ADD      R9,R9,#+1
   \   0000010C   9B0A0AE0           MUL      R10,R11,R10
   \   00000110   0A8048E0           SUB      R8,R8,R10
   \                     ??D_UTIL_synthesis_32_6:
   \   00000114   090051E1           CMP      R1,R9
   \   00000118   F5FFFFAA           BGE      ??D_UTIL_synthesis_32_8
   \                     ??D_UTIL_synthesis_32_7:
   \   0000011C   C8A5A0E1           ASR      R10,R8,#+11
   \   00000120   00809DE5           LDR      R8,[SP, #+0]
   \   00000124   0190A0E3           MOV      R9,#+1
   \   00000128   868088E0           ADD      R8,R8,R6, LSL #+1
   \   0000012C   F080D8E1           LDRSH    R8,[R8, #+0]
   \   00000130   010051E3           CMP      R1,#+1
   \   00000134   930808E0           MUL      R8,R3,R8
   \   00000138   D9FFFFAA           BGE      ??D_UTIL_synthesis_32_4
   \   0000013C   DAFFFFEA           B        ??D_UTIL_synthesis_32_5
    697             }
    698          
    699             return;
    700          }
    701          
    702          
    703          /*
    704           * D_UTIL_hp50_12k8
    705           *
    706           * Parameters:
    707           *    signal       I/O: signal
    708           *    lg             I: lenght of signal
    709           *    mem          I/O: filter memory [6]
    710           *
    711           * Function:
    712           *    2nd order high pass filter with cut off frequency at 50 Hz.
    713           *
    714           *    Algorithm:
    715           *
    716           *    y[i] = b[0]*x[i] + b[1]*x[i-1] + b[2]*x[i-2]
    717           *                     + a[1]*y[i-1] + a[2]*y[i-2];
    718           *
    719           *    b[3] = {0.989501953f, -1.979003906f, 0.989501953f};
    720           *    a[3] = {1.000000000F,  1.978881836f,-0.966308594f};
    721           *
    722           *
    723           * Returns:
    724           *    void
    725           */

   \                                 In segment CODE, align 4, keep-with-next
    726          static void D_UTIL_hp50_12k8(Word16 signal[], Word16 lg, Word16 mem[])
    727          {
   \                     D_UTIL_hp50_12k8:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    728             Word32 i, L_tmp;
    729             Word16 y2_hi, y2_lo, y1_hi, y1_lo, x0, x1, x2;
    730          
    731             y2_hi = mem[0];
    732             y2_lo = mem[1];
   \   00000004   F2C0D2E1           LDRSH    R12,[R2, #+2]
    733             y1_hi = mem[2];
   \   00000008   F490D2E1           LDRSH    R9,[R2, #+4]
    734             y1_lo = mem[3];
   \   0000000C   F6A0D2E1           LDRSH    R10,[R2, #+6]
    735             x0 = mem[4];
   \   00000010   F880D2E1           LDRSH    R8,[R2, #+8]
    736             x1 = mem[5];
   \   00000014   FA60D2E1           LDRSH    R6,[R2, #+10]
   \   00000018   0030A0E1           MOV      R3,R0
   \   0000001C   0140A0E1           MOV      R4,R1
   \   00000020   F010D2E1           LDRSH    R1,[R2, #+0]
    737          
    738             for(i = 0; i < lg; i++)
   \   00000024   0050A0E3           MOV      R5,#+0
   \   00000028   010054E3           CMP      R4,#+1
   \   0000002C   350000BA           BLT      ??D_UTIL_hp50_12k8_0
   \   00000030   010000EA           B        ??D_UTIL_hp50_12k8_1
    739             {
    740                x2 = x1;
    741                x1 = x0;
    742                x0 = signal[i];
    743          
    744                /* y[i] = b[0]*x[i] + b[1]*x[i-1] + b140[2]*x[i-2]  */
    745                /* + a[1]*y[i-1] + a[2] * y[i-2];  */
    746                L_tmp = 8192L;   /* rounding to maximise precision */
    747                L_tmp = L_tmp + (y1_lo * 16211);
    748                L_tmp = L_tmp + (y2_lo * (-8021));
    749                L_tmp = L_tmp >> 14;
    750                L_tmp = L_tmp + (y1_hi * 32422);
    751                L_tmp = L_tmp + (y2_hi * (-16042));
    752                L_tmp = L_tmp + (x0 * 8106);
    753                L_tmp = L_tmp + (x1 * (-16212));
    754                L_tmp = L_tmp + (x2 * 8106);
    755                L_tmp = L_tmp << 2;  /* coeff Q11 --> Q14 */
    756                y2_hi = y1_hi;
    757                y2_lo = y1_lo;
    758                D_UTIL_l_extract(L_tmp, &y1_hi, &y1_lo);
    759                L_tmp = (L_tmp + 0x4000) >> 15;   /* coeff Q14 --> Q15 with saturation */
    760                signal[i] = D_UTIL_saturate(L_tmp);
   \                     ??D_UTIL_hp50_12k8_2:
   \   00000034   B000C7E1           STRH     R0,[R7, #+0]
   \   00000038   015085E2           ADD      R5,R5,#+1
   \                     ??D_UTIL_hp50_12k8_1:
   \   0000003C   040055E1           CMP      R5,R4
   \   00000040   300000AA           BGE      ??D_UTIL_hp50_12k8_0
   \   00000044   0600A0E1           MOV      R0,R6
   \   00000048   0860A0E1           MOV      R6,R8
   \   0000004C   857083E0           ADD      R7,R3,R5, LSL #+1
   \   00000050   F080D7E1           LDRSH    R8,[R7, #+0]
   \   00000054   54B0E0E3           MVN      R11,#+84
   \   00000058   7CBDCBE3           BIC      R11,R11,#0x1F00
   \   0000005C   00082DE9           PUSH     {R11}
   \   00000060   0AA8A0E1           MOV      R10,R10, LSL #+16
   \   00000064   4AA8A0E1           MOV      R10,R10, ASR #+16
   \   00000068   53B0A0E3           MOV      R11,#+83
   \   0000006C   FCBD8BE3           ORR      R11,R11,#0x3F00
   \   00000070   9B0A0EE0           MUL      LR,R11,R10
   \   00000074   0008BDE8           POP      {R11}
   \   00000078   9BEC2CE0           MLA      R12,R11,R12,LR
   \   0000007C   80BD8CE2           ADD      R11,R12,#+8192
   \   00000080   A6C0A0E3           MOV      R12,#+166
   \   00000084   7ECC8CE3           ORR      R12,R12,#0x7E00
   \   00000088   9C090EE0           MUL      LR,R12,R9
   \   0000008C   A9C0E0E3           MVN      R12,#+169
   \   00000090   4BB78EE0           ADD      R11,LR,R11, ASR #+14
   \   00000094   F8CDCCE3           BIC      R12,R12,#0x3E00
   \   00000098   9CB121E0           MLA      R1,R12,R1,R11
   \   0000009C   AAB0A0E3           MOV      R11,#+170
   \   000000A0   7CBD8BE3           ORR      R11,R11,#0x1F00
   \   000000A4   9B1821E0           MLA      R1,R11,R8,R1
   \   000000A8   AAB04CE2           SUB      R11,R12,#+170
   \   000000AC   9B1621E0           MLA      R1,R11,R6,R1
   \   000000B0   AAB0A0E3           MOV      R11,#+170
   \   000000B4   7CBD8BE3           ORR      R11,R11,#0x1F00
   \   000000B8   9B1020E0           MLA      R0,R11,R0,R1
   \   000000BC   0910A0E1           MOV      R1,R9
   \   000000C0   0001A0E1           LSL      R0,R0,#+2
   \   000000C4   0AC0A0E1           MOV      R12,R10
   \   000000C8   4098A0E1           ASR      R9,R0,#+16
   \   000000CC   C0A0A0E1           ASR      R10,R0,#+1
   \   000000D0   89A74AE0           SUB      R10,R10,R9, LSL #+15
   \   000000D4   400C80E2           ADD      R0,R0,#+16384
   \   000000D8   C0B7A0E1           ASR      R11,R0,#+15
   \   000000DC   FF00A0E3           MOV      R0,#+255
   \   000000E0   7F0C80E3           ORR      R0,R0,#0x7F00
   \   000000E4   00005BE1           CMP      R11,R0
   \   000000E8   030000AA           BGE      ??D_UTIL_hp50_12k8_3
   \   000000EC   00E060E2           RSB      LR,R0,#+0
   \   000000F0   0E005BE1           CMP      R11,LR
   \   000000F4   0B00A0A1           MOVGE    R0,R11
   \   000000F8   CDFFFFAA           BGE      ??D_UTIL_hp50_12k8_2
   \                     ??D_UTIL_hp50_12k8_3:
   \   000000FC   01005BE3           CMP      R11,#+1
   \   00000100   0000E0B1           MVNLT    R0,R0
   \   00000104   CAFFFFEA           B        ??D_UTIL_hp50_12k8_2
    761          
    762             }
    763             mem[0] = y2_hi;
   \                     ??D_UTIL_hp50_12k8_0:
   \   00000108   B010C2E1           STRH     R1,[R2, #+0]
    764             mem[1] = y2_lo;
   \   0000010C   B2C0C2E1           STRH     R12,[R2, #+2]
    765             mem[2] = y1_hi;
   \   00000110   B490C2E1           STRH     R9,[R2, #+4]
    766             mem[3] = y1_lo;
   \   00000114   B6A0C2E1           STRH     R10,[R2, #+6]
    767             mem[4] = x0;
   \   00000118   B880C2E1           STRH     R8,[R2, #+8]
    768             mem[5] = x1;
   \   0000011C   BA60C2E1           STRH     R6,[R2, #+10]
    769          
    770             return;
   \   00000120   F08FBDE8           POP      {R4-R11,PC}      ;; return
    771          }
    772          
    773          
    774          /*
    775           * D_UTIL_interpol
    776           *
    777           * Parameters:
    778           *    x           I: input vector
    779           *    fir         I: filter coefficient
    780           *    frac        I: fraction (0..resol)
    781           *    up_samp     I: resolution
    782           *    nb_coef     I: number of coefficients
    783           *
    784           * Function:
    785           *    Fractional interpolation of signal at position (frac/up_samp)
    786           *
    787           * Returns:
    788           *    result of interpolation
    789           */

   \                                 In segment CODE, align 4, keep-with-next
    790          Word16 D_UTIL_interpol(Word16 *x, Word16 const *fir, Word16 frac,
    791                                 Word16 resol, Word16 nb_coef)
    792          {
   \                     D_UTIL_interpol:
   \   00000000   F0002DE9           PUSH     {R4-R7}
   \   00000004   F0C1DDE1           LDRSH    R12,[SP, #+16]
    793             Word32 i, k;
    794             Word32 sum;
    795          
    796             x = x - nb_coef + 1;
    797             sum = 0L;
    798          
    799             for(i = 0, k = ((resol - 1) - frac); i < 2 * nb_coef; i++,
   \   00000008   0050A0E3           MOV      R5,#+0
   \   0000000C   016043E2           SUB      R6,R3,#+1
   \   00000010   8CC0A0E1           LSL      R12,R12,#+1
   \   00000014   0C40A0E1           MOV      R4,R12
   \   00000018   004064E2           RSB      R4,R4,#+0
   \   0000001C   000084E0           ADD      R0,R4,R0
   \   00000020   024080E2           ADD      R4,R0,#+2
   \   00000024   0000A0E3           MOV      R0,#+0
   \   00000028   022046E0           SUB      R2,R6,R2
   \   0000002C   01005CE3           CMP      R12,#+1
   \   00000030   090000AA           BGE      ??D_UTIL_interpol_0
   \   00000034   100000EA           B        ??D_UTIL_interpol_1
    800                k = (Word16)(k + resol))
    801             {
    802                sum = sum + (x[i] * fir[k]);
   \                     ??D_UTIL_interpol_2:
   \   00000038   856084E0           ADD      R6,R4,R5, LSL #+1
   \   0000003C   F060D6E1           LDRSH    R6,[R6, #+0]
   \   00000040   827081E0           ADD      R7,R1,R2, LSL #+1
   \   00000044   F070D7E1           LDRSH    R7,[R7, #+0]
    803             }
   \   00000048   015085E2           ADD      R5,R5,#+1
   \   0000004C   022083E0           ADD      R2,R3,R2
   \   00000050   970620E0           MLA      R0,R7,R6,R0
   \   00000054   0228A0E1           MOV      R2,R2, LSL #+16
   \   00000058   4228A0E1           MOV      R2,R2, ASR #+16
   \                     ??D_UTIL_interpol_0:
   \   0000005C   0C0055E1           CMP      R5,R12
   \   00000060   F4FFFFBA           BLT      ??D_UTIL_interpol_2
    804          
    805             if((sum < 536846336) & (sum > -536879104))
   \   00000064   ........           LDR      R1,??DataTable4  ;; 0x1fffa000
   \   00000068   010050E1           CMP      R0,R1
   \   0000006C   050000AA           BGE      ??D_UTIL_interpol_3
   \   00000070   ........           LDR      R1,??DataTable5  ;; 0xffffffffdfffe001
   \   00000074   010050E1           CMP      R0,R1
   \   00000078   070000BA           BLT      ??D_UTIL_interpol_4
    806             {
    807                sum = (sum + 0x2000) >> 14;
   \                     ??D_UTIL_interpol_1:
   \   0000007C   800D80E2           ADD      R0,R0,#+8192
   \   00000080   4007A0E1           ASR      R0,R0,#+14
   \   00000084   060000EA           B        ??D_UTIL_interpol_5
    808             }
    809             else if(sum > 536846336)
   \                     ??D_UTIL_interpol_3:
   \   00000088   011081E3           ORR      R1,R1,#0x1
   \   0000008C   010050E1           CMP      R0,R1
    810             {
    811                sum = 32767;
   \   00000090   FF00A0A3           MOVGE    R0,#+255
   \   00000094   7F0C80A3           ORRGE    R0,R0,#0x7F00
   \   00000098   010000AA           BGE      ??D_UTIL_interpol_5
    812             }
    813             else
    814             {
    815                sum = -32768;
   \                     ??D_UTIL_interpol_4:
   \   0000009C   FF00E0E3           MVN      R0,#+255
   \   000000A0   7F0CC0E3           BIC      R0,R0,#0x7F00
    816             }
    817          
    818             return((Word16)sum);   /* saturation can occur here */
   \                     ??D_UTIL_interpol_5:
   \   000000A4   F000BDE8           POP      {R4-R7}
   \   000000A8   0008A0E1           MOV      R0,R0, LSL #+16
   \   000000AC   4008A0E1           MOV      R0,R0, ASR #+16
   \   000000B0   1EFF2FE1           BX       LR               ;; return
    819          }
    820          
    821          
    822          /*
    823           * D_UTIL_up_samp
    824           *
    825           * Parameters:
    826           *    res_d          I: signal to upsampling
    827           *    res_u          O: upsampled output
    828           *    L_frame        I: length of output
    829           *
    830           * Function:
    831           *    Upsampling
    832           *
    833           * Returns:
    834           *    void
    835           */
    836          static void D_UTIL_up_samp(Word16 *sig_d, Word16 *sig_u, Word16 L_frame)
    837          {
    838             Word32 pos, i, j;
    839             Word16 frac;
    840          
    841             pos = 0;   /* position with 1/5 resolution */
    842          
    843             for(j = 0; j < L_frame; j++)
    844             {
    845                i = (pos * INV_FAC5) >> 15;   /* integer part = pos * 1/5 */
    846                frac = (Word16)(pos - ((i << 2) + i));   /* frac = pos - (pos/5)*5   */
    847                sig_u[j] = D_UTIL_interpol(&sig_d[i], D_ROM_fir_up, frac, FAC5, NB_COEF_UP);
    848                pos = pos + FAC4;   /* position + 4/5 */
    849             }
    850          
    851             return;
    852          }
    853          
    854          
    855          /*
    856           * D_UTIL_oversamp_16k
    857           *
    858           * Parameters:
    859           *    sig12k8        I: signal to oversampling
    860           *    lg             I: length of input
    861           *    sig16k         O: oversampled signal
    862           *    mem          I/O: memory (2*12)
    863           *
    864           * Function:
    865           *    Oversampling from 12.8kHz to 16kHz
    866           *
    867           * Returns:
    868           *    void
    869           */

   \                                 In segment CODE, align 4, keep-with-next
    870          static void D_UTIL_oversamp_16k(Word16 sig12k8[], Word16 lg, Word16 sig16k[],
    871                                          Word16 mem[])
    872          {
   \                     D_UTIL_oversamp_16k:
   \   00000000   F0432DE9           PUSH     {R4-R9,LR}
   \   00000004   B0D04DE2           SUB      SP,SP,#+176
   \   00000008   0070A0E1           MOV      R7,R0
   \   0000000C   0140A0E1           MOV      R4,R1
   \   00000010   0250A0E1           MOV      R5,R2
   \   00000014   0360A0E1           MOV      R6,R3
    873             Word16 lg_up;
    874             Word16 signal[L_SUBFR + (2 * NB_COEF_UP)];
    875          
    876             memcpy(signal, mem, (2 * NB_COEF_UP) * sizeof(Word16));
   \   00000018   3020A0E3           MOV      R2,#+48
   \   0000001C   0610A0E1           MOV      R1,R6
   \   00000020   0D00A0E1           MOV      R0,SP
   \   00000024   1E0100EF           SWI      +286
    877             memcpy(signal + (2 * NB_COEF_UP), sig12k8, lg * sizeof(Word16));
   \   00000028   8420A0E1           LSL      R2,R4,#+1
   \   0000002C   0710A0E1           MOV      R1,R7
   \   00000030   30008DE2           ADD      R0,SP,#+48
   \   00000034   1E0100EF           SWI      +286
    878             lg_up = (Word16)(((lg * UP_FAC) >> 15) << 1);
    879             D_UTIL_up_samp(signal + NB_COEF_UP, sig16k, lg_up);
   \   00000038   500CA0E3           MOV      R0,#+20480
   \   0000003C   900401E0           MUL      R1,R0,R4
   \   00000040   0020A0E3           MOV      R2,#+0
   \   00000044   C107A0E1           ASR      R0,R1,#+15
   \   00000048   8008A0E1           LSL      R0,R0,#+17
   \   0000004C   0010A0E3           MOV      R1,#+0
   \   00000050   4008A0E1           ASR      R0,R0,#+16
   \   00000054   010050E3           CMP      R0,#+1
   \   00000058   0C0000AA           BGE      ??D_UTIL_oversamp_16k_0
    880             memcpy(mem, signal + lg, (2 * NB_COEF_UP) * sizeof(Word16));
   \                     ??D_UTIL_oversamp_16k_1:
   \   0000005C   3020A0E3           MOV      R2,#+48
   \   00000060   0D00A0E1           MOV      R0,SP
   \   00000064   841080E0           ADD      R1,R0,R4, LSL #+1
   \   00000068   0600A0E1           MOV      R0,R6
   \   0000006C   1E0100EF           SWI      +286
    881          
    882             return;
   \   00000070   B0D08DE2           ADD      SP,SP,#+176
   \   00000074   F083BDE8           POP      {R4-R9,PC}       ;; return
   \                     ??D_UTIL_oversamp_16k_2:
   \   00000078   FF30E0E3           MVN      R3,#+255
   \   0000007C   7F3CC3E3           BIC      R3,R3,#0x7F00
   \                     ??D_UTIL_oversamp_16k_3:
   \   00000080   827085E0           ADD      R7,R5,R2, LSL #+1
   \   00000084   B030C7E1           STRH     R3,[R7, #+0]
   \   00000088   041081E2           ADD      R1,R1,#+4
   \   0000008C   012082E2           ADD      R2,R2,#+1
   \                     ??D_UTIL_oversamp_16k_0:
   \   00000090   000052E1           CMP      R2,R0
   \   00000094   F0FFFFAA           BGE      ??D_UTIL_oversamp_16k_1
   \   00000098   9A30A0E3           MOV      R3,#+154
   \   0000009C   643D83E3           ORR      R3,R3,#0x1900
   \   000000A0   930107E0           MUL      R7,R3,R1
   \   000000A4   0D30A0E1           MOV      R3,SP
   \   000000A8   C777A0E1           ASR      R7,R7,#+15
   \   000000AC   873083E0           ADD      R3,R3,R7, LSL #+1
   \   000000B0   0490E0E3           MVN      R9,#+4
   \   000000B4   871907E1           SMLABB   R7,R7,R9,R1
   \   000000B8   023083E2           ADD      R3,R3,#+2
   \   000000BC   00C0A0E3           MOV      R12,#+0
   \   000000C0   00E0A0E3           MOV      LR,#+0
   \   000000C4   0778A0E1           MOV      R7,R7, LSL #+16
   \   000000C8   4778A0E1           MOV      R7,R7, ASR #+16
   \   000000CC   047067E2           RSB      R7,R7,#+4
   \                     ??D_UTIL_oversamp_16k_4:
   \   000000D0   64909FE5           LDR      R9,??D_UTIL_oversamp_16k_5  ;; D_ROM_fir_up
   \   000000D4   8E8083E0           ADD      R8,R3,LR, LSL #+1
   \   000000D8   F080D8E1           LDRSH    R8,[R8, #+0]
   \   000000DC   879089E0           ADD      R9,R9,R7, LSL #+1
   \   000000E0   F090D9E1           LDRSH    R9,[R9, #+0]
   \   000000E4   01E08EE2           ADD      LR,LR,#+1
   \   000000E8   057087E2           ADD      R7,R7,#+5
   \   000000EC   99C82CE0           MLA      R12,R9,R8,R12
   \   000000F0   0778A0E1           MOV      R7,R7, LSL #+16
   \   000000F4   4778A0E1           MOV      R7,R7, ASR #+16
   \   000000F8   18005EE3           CMP      LR,#+24
   \   000000FC   F3FFFFBA           BLT      ??D_UTIL_oversamp_16k_4
   \   00000100   ........           LDR      R3,??DataTable4  ;; 0x1fffa000
   \   00000104   03005CE1           CMP      R12,R3
   \   00000108   050000AA           BGE      ??D_UTIL_oversamp_16k_6
   \   0000010C   ........           LDR      R3,??DataTable5  ;; 0xffffffffdfffe001
   \   00000110   03005CE1           CMP      R12,R3
   \   00000114   D7FFFFBA           BLT      ??D_UTIL_oversamp_16k_2
   \   00000118   803D8CE2           ADD      R3,R12,#+8192
   \   0000011C   4337A0E1           ASR      R3,R3,#+14
   \   00000120   D6FFFFEA           B        ??D_UTIL_oversamp_16k_3
   \                     ??D_UTIL_oversamp_16k_6:
   \   00000124   013083E3           ORR      R3,R3,#0x1
   \   00000128   03005CE1           CMP      R12,R3
   \   0000012C   D1FFFFBA           BLT      ??D_UTIL_oversamp_16k_2
   \   00000130   FF30A0E3           MOV      R3,#+255
   \   00000134   7F3C83E3           ORR      R3,R3,#0x7F00
   \   00000138   D0FFFFEA           B        ??D_UTIL_oversamp_16k_3
   \                     ??D_UTIL_oversamp_16k_5:
   \   0000013C   ........           DC32     D_ROM_fir_up
    883          }
    884          
    885          
    886          /*
    887           * D_UTIL_hp400_12k8
    888           *
    889           * Parameters:
    890           *    signal       I/O: signal
    891           *    lg             I: lenght of signal
    892           *    mem          I/O: filter memory [6]
    893           *
    894           * Function:
    895           *    2nd order high pass filter with cut off frequency at 400 Hz.
    896           *
    897           *    Algorithm:
    898           *
    899           *    y[i] = b[0]*x[i] + b[1]*x[i-1] + b[2]*x[i-2]
    900           *                     + a[1]*y[i-1] + a[2]*y[i-2];
    901           *
    902           *    b[3] = {0.893554687, -1.787109375,  0.893554687};
    903           *    a[3] = {1.000000000,  1.787109375, -0.864257812};
    904           *
    905           *
    906           * Returns:
    907           *    void
    908           */

   \                                 In segment CODE, align 4, keep-with-next
    909          void D_UTIL_hp400_12k8(Word16 signal[], Word16 lg, Word16 mem[])
    910          {
   \                     D_UTIL_hp400_12k8:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
    911          
    912             Word32 i, L_tmp;
    913             Word16 y2_hi, y2_lo, y1_hi, y1_lo, x0, x1, x2;
    914          
    915             y2_hi = mem[0];
    916             y2_lo = mem[1];
   \   00000004   F2C0D2E1           LDRSH    R12,[R2, #+2]
    917             y1_hi = mem[2];
   \   00000008   F490D2E1           LDRSH    R9,[R2, #+4]
    918             y1_lo = mem[3];
   \   0000000C   F6A0D2E1           LDRSH    R10,[R2, #+6]
    919             x0 = mem[4];
   \   00000010   F880D2E1           LDRSH    R8,[R2, #+8]
    920             x1 = mem[5];
   \   00000014   FA60D2E1           LDRSH    R6,[R2, #+10]
   \   00000018   0030A0E1           MOV      R3,R0
   \   0000001C   0150A0E1           MOV      R5,R1
   \   00000020   F010D2E1           LDRSH    R1,[R2, #+0]
    921          
    922             for(i = 0; i < lg; i++)
   \   00000024   0040A0E3           MOV      R4,#+0
   \   00000028   010055E3           CMP      R5,#+1
   \   0000002C   2B0000BA           BLT      ??D_UTIL_hp400_12k8_0
   \   00000030   280000EA           B        ??D_UTIL_hp400_12k8_1
    923             {
    924                x2 = x1;
   \                     ??D_UTIL_hp400_12k8_2:
   \   00000034   0600A0E1           MOV      R0,R6
    925                x1 = x0;
   \   00000038   0860A0E1           MOV      R6,R8
    926                x0 = signal[i];
   \   0000003C   847083E0           ADD      R7,R3,R4, LSL #+1
   \   00000040   F080D7E1           LDRSH    R8,[R7, #+0]
    927          
    928                /* y[i] = b[0]*x[i] + b[1]*x[i-1] + b140[2]*x[i-2]  */
    929                /* + a[1]*y[i-1] + a[2] * y[i-2];  */
    930                L_tmp = 8192L + (y1_lo * 29280);
    931                L_tmp = L_tmp + (y2_lo * (-14160));
    932                L_tmp = (L_tmp >> 14);
    933                L_tmp = L_tmp + (y1_hi * 58560);
    934                L_tmp = L_tmp + (y2_hi * (-28320));
    935                L_tmp = L_tmp + (x0 * 1830);
    936                L_tmp = L_tmp + (x1 * (-3660));
    937                L_tmp = L_tmp + (x2 * 1830);
    938                L_tmp = (L_tmp << 1);   /* coeff Q12 --> Q13 */
   \   00000044   4FB0E0E3           MVN      R11,#+79
   \   00000048   DCBDCBE3           BIC      R11,R11,#0x3700
   \   0000004C   00082DE9           PUSH     {R11}
   \   00000050   0AA8A0E1           MOV      R10,R10, LSL #+16
   \   00000054   4AA8A0E1           MOV      R10,R10, ASR #+16
    939                y2_hi = y1_hi;
    940                y2_lo = y1_lo;
    941                D_UTIL_l_extract(L_tmp, &y1_hi, &y1_lo);
    942          
    943                /* signal is divided by 16 to avoid overflow in energy computation */
    944                signal[i] = (Word16)((L_tmp + 0x8000) >> 16);
    945             }
   \   00000058   014084E2           ADD      R4,R4,#+1
   \   0000005C   60B0A0E3           MOV      R11,#+96
   \   00000060   72BC8BE3           ORR      R11,R11,#0x7200
   \   00000064   9B0A0EE0           MUL      LR,R11,R10
   \   00000068   0008BDE8           POP      {R11}
   \   0000006C   9BEC2CE0           MLA      R12,R11,R12,LR
   \   00000070   80BD8CE2           ADD      R11,R12,#+8192
   \   00000074   C0C0A0E3           MOV      R12,#+192
   \   00000078   E4CC8CE3           ORR      R12,R12,#0xE400
   \   0000007C   9C090EE0           MUL      LR,R12,R9
   \   00000080   9FC0E0E3           MVN      R12,#+159
   \   00000084   4BB78EE0           ADD      R11,LR,R11, ASR #+14
   \   00000088   6ECCCCE3           BIC      R12,R12,#0x6E00
   \   0000008C   9CB121E0           MLA      R1,R12,R1,R11
   \   00000090   26B0A0E3           MOV      R11,#+38
   \   00000094   70BE8BE3           ORR      R11,R11,#0x700
   \   00000098   9B1821E0           MLA      R1,R11,R8,R1
   \   0000009C   4BB0E0E3           MVN      R11,#+75
   \   000000A0   E0BECBE3           BIC      R11,R11,#0xE00
   \   000000A4   9B1621E0           MLA      R1,R11,R6,R1
   \   000000A8   26B0A0E3           MOV      R11,#+38
   \   000000AC   70BE8BE3           ORR      R11,R11,#0x700
   \   000000B0   9B1020E0           MLA      R0,R11,R0,R1
   \   000000B4   0910A0E1           MOV      R1,R9
   \   000000B8   8000A0E1           LSL      R0,R0,#+1
   \   000000BC   0AC0A0E1           MOV      R12,R10
   \   000000C0   4098A0E1           ASR      R9,R0,#+16
   \   000000C4   C0A0A0E1           ASR      R10,R0,#+1
   \   000000C8   89A74AE0           SUB      R10,R10,R9, LSL #+15
   \   000000CC   800C80E2           ADD      R0,R0,#+32768
   \   000000D0   4008A0E1           ASR      R0,R0,#+16
   \   000000D4   B000C7E1           STRH     R0,[R7, #+0]
   \                     ??D_UTIL_hp400_12k8_1:
   \   000000D8   050054E1           CMP      R4,R5
   \   000000DC   D4FFFFBA           BLT      ??D_UTIL_hp400_12k8_2
    946             mem[0] = y2_hi;
   \                     ??D_UTIL_hp400_12k8_0:
   \   000000E0   B010C2E1           STRH     R1,[R2, #+0]
    947             mem[1] = y2_lo;
   \   000000E4   B2C0C2E1           STRH     R12,[R2, #+2]
    948             mem[2] = y1_hi;
   \   000000E8   B490C2E1           STRH     R9,[R2, #+4]
    949             mem[3] = y1_lo;
   \   000000EC   B6A0C2E1           STRH     R10,[R2, #+6]
    950             mem[4] = x0;
   \   000000F0   B880C2E1           STRH     R8,[R2, #+8]
    951             mem[5] = x1;
   \   000000F4   BA60C2E1           STRH     R6,[R2, #+10]
    952          
    953             return;
   \   000000F8   F08FBDE8           POP      {R4-R11,PC}      ;; return
    954          }
    955          
    956          
    957          /*
    958           * D_UTIL_synthesis
    959           *
    960           * Parameters:
    961           *    a              I: LP filter coefficients
    962           *    m              I: order of LP filter
    963           *    x              I: input signal
    964           *    y              O: output signal
    965           *    lg             I: size of filtering
    966           *    mem          I/O: initial filter states
    967           *    update_m       I: update memory flag
    968           *
    969           * Function:
    970           *    Perform the synthesis filtering 1/A(z).
    971           *
    972           * Returns:
    973           *    void
    974           */

   \                                 In segment CODE, align 4, keep-with-next
    975          static void D_UTIL_synthesis(Word16 a[], Word16 m, Word16 x[], Word16 y[],
    976                                       Word16 lg, Word16 mem[], Word16 update)
    977          {
   \                     D_UTIL_synthesis:
   \   00000000   FC4F2DE9           PUSH     {R2-R11,LR}
   \   00000004   CCD04DE2           SUB      SP,SP,#+204
   \   00000008   0040A0E1           MOV      R4,R0
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   F86FDDE1           LDRSH    R6,[SP, #+248]
   \   00000014   FC709DE5           LDR      R7,[SP, #+252]
    978             Word32 i, j, tmp, s;
    979             Word16 y_buf[L_SUBFR16k + M16k], a0;
    980             Word16 *yy;
    981          
    982             yy = &y_buf[m];
   \   00000018   04008DE2           ADD      R0,SP,#+4
   \   0000001C   85A080E0           ADD      R10,R0,R5, LSL #+1
    983          
    984             /* See if a[0] is scaled */
    985             s = D_UTIL_norm_s(a[0]) - 2;
   \   00000020   F000D4E1           LDRSH    R0,[R4, #+0]
   \   00000024   408F8DE2           ADD      R8,SP,#+256
   \   00000028   F080D8E1           LDRSH    R8,[R8, #+0]
   \   0000002C   0010A0E3           MOV      R1,#+0
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0E00000A           BEQ      ??D_UTIL_synthesis_0
   \   00000038   0120E0E1           MVN      R2,R1
   \   0000003C   020050E1           CMP      R0,R2
   \   00000040   0F10A003           MOVEQ    R1,#+15
   \   00000044   0A00000A           BEQ      ??D_UTIL_synthesis_0
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0000E041           MVNMI    R0,R0
   \   00000050   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000054   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000058   400C50E3           CMP      R0,#+16384
   \   0000005C   040000AA           BGE      ??D_UTIL_synthesis_0
   \                     ??D_UTIL_synthesis_1:
   \   00000060   8008A0E1           LSL      R0,R0,#+17
   \   00000064   011081E2           ADD      R1,R1,#+1
   \   00000068   4008A0E1           ASR      R0,R0,#+16
   \   0000006C   400C50E3           CMP      R0,#+16384
   \   00000070   FAFFFFBA           BLT      ??D_UTIL_synthesis_1
   \                     ??D_UTIL_synthesis_0:
   \   00000074   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000078   4118A0E1           MOV      R1,R1, ASR #+16
   \   0000007C   021041E2           SUB      R1,R1,#+2
   \   00000080   00108DE5           STR      R1,[SP, #+0]
    986             /* copy initial filter states into synthesis buffer */
    987             memcpy(y_buf, mem, m * sizeof(Word16));
   \   00000084   85B0A0E1           LSL      R11,R5,#+1
   \   00000088   0B20A0E1           MOV      R2,R11
   \   0000008C   0710A0E1           MOV      R1,R7
   \   00000090   04008DE2           ADD      R0,SP,#+4
   \   00000094   1E0100EF           SWI      +286
    988          
    989             a0 = (Word16)(a[0] >> 1);   /* input / 2 */
   \   00000098   F000D4E1           LDRSH    R0,[R4, #+0]
    990          
    991             /* Do the filtering. */
    992             for(i = 0; i < lg; i++)
   \   0000009C   0020A0E3           MOV      R2,#+0
   \   000000A0   010056E3           CMP      R6,#+1
   \   000000A4   C010A0E1           ASR      R1,R0,#+1
   \   000000A8   0600A0E1           MOV      R0,R6
   \   000000AC   1D0000AA           BGE      ??D_UTIL_synthesis_2
    993             {
    994                tmp = x[i] * a0;
    995          
    996                for(j = 1; j <= m; j++)
    997                {
    998                   tmp -= a[j] * yy[i - j];
    999                }
   1000                tmp <<= s;
   1001          
   1002                y[i] = yy[i] = (Word16)((tmp + 0x800) >> 12);
   1003             }
   1004          
   1005             /* Update memory if required */
   1006             if(update)
   \                     ??D_UTIL_synthesis_3:
   \   000000B0   000058E3           CMP      R8,#+0
   \   000000B4   0400000A           BEQ      ??D_UTIL_synthesis_4
   1007             {
   1008                memcpy(mem, &yy[lg - m], m * sizeof(Word16));
   \   000000B8   0B20A0E1           MOV      R2,R11
   \   000000BC   050040E0           SUB      R0,R0,R5
   \   000000C0   80108AE0           ADD      R1,R10,R0, LSL #+1
   \   000000C4   0700A0E1           MOV      R0,R7
   \   000000C8   1E0100EF           SWI      +286
   1009             }
   1010          
   1011             return;
   \                     ??D_UTIL_synthesis_4:
   \   000000CC   D4D08DE2           ADD      SP,SP,#+212      ;; stack cleaning
   \   000000D0   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??D_UTIL_synthesis_5:
   \   000000D4   86C084E0           ADD      R12,R4,R6, LSL #+1
   \   000000D8   F0C0DCE1           LDRSH    R12,[R12, #+0]
   \   000000DC   06E042E0           SUB      LR,R2,R6
   \   000000E0   8EE08AE0           ADD      LR,R10,LR, LSL #+1
   \   000000E4   F0E0DEE1           LDRSH    LR,[LR, #+0]
   \   000000E8   016086E2           ADD      R6,R6,#+1
   \   000000EC   9E0C0CE0           MUL      R12,LR,R12
   \   000000F0   0C3043E0           SUB      R3,R3,R12
   \                     ??D_UTIL_synthesis_6:
   \   000000F4   060055E1           CMP      R5,R6
   \   000000F8   F5FFFFAA           BGE      ??D_UTIL_synthesis_5
   \                     ??D_UTIL_synthesis_7:
   \   000000FC   00C09DE5           LDR      R12,[SP, #+0]
   \   00000100   82608AE0           ADD      R6,R10,R2, LSL #+1
   \   00000104   80EEA0E3           MOV      LR,#+2048
   \   00000108   133C8EE0           ADD      R3,LR,R3, LSL R12
   \   0000010C   4336A0E1           ASR      R3,R3,#+12
   \   00000110   B030C6E1           STRH     R3,[R6, #+0]
   \   00000114   F060D6E1           LDRSH    R6,[R6, #+0]
   \   00000118   D0309DE5           LDR      R3,[SP, #+208]
   \   0000011C   823083E0           ADD      R3,R3,R2, LSL #+1
   \   00000120   B060C3E1           STRH     R6,[R3, #+0]
   \   00000124   012082E2           ADD      R2,R2,#+1
   \                     ??D_UTIL_synthesis_2:
   \   00000128   000052E1           CMP      R2,R0
   \   0000012C   DFFFFFAA           BGE      ??D_UTIL_synthesis_3
   \   00000130   CC309DE5           LDR      R3,[SP, #+204]
   \   00000134   0160A0E3           MOV      R6,#+1
   \   00000138   823083E0           ADD      R3,R3,R2, LSL #+1
   \   0000013C   F030D3E1           LDRSH    R3,[R3, #+0]
   \   00000140   010055E3           CMP      R5,#+1
   \   00000144   910303E0           MUL      R3,R1,R3
   \   00000148   E9FFFFAA           BGE      ??D_UTIL_synthesis_6
   \   0000014C   EAFFFFEA           B        ??D_UTIL_synthesis_7
   1012          }
   1013          
   1014          
   1015          /*
   1016           * D_UTIL_bp_6k_7k
   1017           *
   1018           * Parameters:
   1019           *    signal       I/O: signal
   1020           *    lg             I: lenght of signal
   1021           *    mem          I/O: filter memory [4]
   1022           *
   1023           * Function:
   1024           *    15th order band pass 6kHz to 7kHz FIR filter.
   1025           *
   1026           * Returns:
   1027           *    void
   1028           */

   \                                 In segment CODE, align 4, keep-with-next
   1029          void D_UTIL_bp_6k_7k(Word16 signal[], Word16 lg, Word16 mem[])
   1030          {
   \                     D_UTIL_bp_6k_7k:
   \   00000000   70002DE9           PUSH     {R4-R6}
   \   00000004   6EDF4DE2           SUB      SP,SP,#+440
   1031             Word32 x[L_SUBFR16k + (L_FIR - 1)];
   1032             Word32 i, j, tmp;
   1033          
   1034             for(i = 0; i < (L_FIR - 1); i++)
   \   00000008   0030A0E3           MOV      R3,#+0
   \   0000000C   0D40A0E1           MOV      R4,SP
   1035             {
   1036                x[i] = (Word16)mem[i];   /* gain of filter = 4 */
   \                     ??D_UTIL_bp_6k_7k_0:
   \   00000010   83C082E0           ADD      R12,R2,R3, LSL #+1
   \   00000014   F0C0DCE1           LDRSH    R12,[R12, #+0]
   \   00000018   03C184E7           STR      R12,[R4, +R3, LSL #+2]
   1037             }
   \   0000001C   013083E2           ADD      R3,R3,#+1
   \   00000020   1E0053E3           CMP      R3,#+30
   \   00000024   F9FFFFBA           BLT      ??D_UTIL_bp_6k_7k_0
   1038          
   1039             for(i = 0; i < lg; i++)
   \   00000028   00C0A0E3           MOV      R12,#+0
   \   0000002C   0130A0E1           MOV      R3,R1
   \   00000030   010051E3           CMP      R1,#+1
   \   00000034   070000AA           BGE      ??D_UTIL_bp_6k_7k_1
   \   00000038   080000EA           B        ??D_UTIL_bp_6k_7k_2
   1040             {
   1041                x[i + L_FIR - 1] = signal[i] >> 2;   /* gain of filter = 4 */
   \                     ??D_UTIL_bp_6k_7k_3:
   \   0000003C   8C5080E0           ADD      R5,R0,R12, LSL #+1
   \   00000040   F050D5E1           LDRSH    R5,[R5, #+0]
   \   00000044   0D40A0E1           MOV      R4,SP
   \   00000048   0C4184E0           ADD      R4,R4,R12, LSL #+2
   \   0000004C   4551A0E1           ASR      R5,R5,#+2
   \   00000050   785084E5           STR      R5,[R4, #+120]
   1042             }
   \   00000054   01C08CE2           ADD      R12,R12,#+1
   \                     ??D_UTIL_bp_6k_7k_1:
   \   00000058   03005CE1           CMP      R12,R3
   \   0000005C   F6FFFFBA           BLT      ??D_UTIL_bp_6k_7k_3
   1043          
   1044             for(i = 0; i < lg; i++)
   \                     ??D_UTIL_bp_6k_7k_2:
   \   00000060   00C0A0E3           MOV      R12,#+0
   \   00000064   010051E3           CMP      R1,#+1
   \   00000068   110000AA           BGE      ??D_UTIL_bp_6k_7k_4
   \   0000006C   120000EA           B        ??D_UTIL_bp_6k_7k_5
   1045             {
   1046                tmp = 0;
   \                     ??D_UTIL_bp_6k_7k_6:
   \   00000070   0010A0E3           MOV      R1,#+0
   1047          
   1048                for(j = 0; j < L_FIR; j++)
   \   00000074   0040A0E3           MOV      R4,#+0
   1049                {
   1050                   tmp += x[i + j] * D_ROM_fir_6k_7k[j];
   \                     ??D_UTIL_bp_6k_7k_7:
   \   00000078   0C5084E0           ADD      R5,R4,R12
   \   0000007C   0D60A0E1           MOV      R6,SP
   \   00000080   055196E7           LDR      R5,[R6, +R5, LSL #+2]
   \   00000084   60609FE5           LDR      R6,??D_UTIL_bp_6k_7k_8  ;; D_ROM_fir_6k_7k
   \   00000088   846086E0           ADD      R6,R6,R4, LSL #+1
   \   0000008C   F060D6E1           LDRSH    R6,[R6, #+0]
   1051                }
   \   00000090   014084E2           ADD      R4,R4,#+1
   \   00000094   1F0054E3           CMP      R4,#+31
   \   00000098   961521E0           MLA      R1,R6,R5,R1
   \   0000009C   F5FFFFBA           BLT      ??D_UTIL_bp_6k_7k_7
   1052          
   1053                signal[i] = (Word16)((tmp + 0x4000) >> 15);
   \   000000A0   8C4080E0           ADD      R4,R0,R12, LSL #+1
   \   000000A4   401C81E2           ADD      R1,R1,#+16384
   \   000000A8   C117A0E1           ASR      R1,R1,#+15
   \   000000AC   B010C4E1           STRH     R1,[R4, #+0]
   1054             }
   \   000000B0   01C08CE2           ADD      R12,R12,#+1
   \                     ??D_UTIL_bp_6k_7k_4:
   \   000000B4   03005CE1           CMP      R12,R3
   \   000000B8   ECFFFFBA           BLT      ??D_UTIL_bp_6k_7k_6
   1055          
   1056             for(i = 0; i < (L_FIR - 1); i++)
   \                     ??D_UTIL_bp_6k_7k_5:
   \   000000BC   0000A0E3           MOV      R0,#+0
   \   000000C0   0D50A0E1           MOV      R5,SP
   1057             {
   1058                mem[i] = (Word16)x[lg + i];   /* gain of filter = 4 */
   \                     ??D_UTIL_bp_6k_7k_9:
   \   000000C4   034080E0           ADD      R4,R0,R3
   \   000000C8   044195E7           LDR      R4,[R5, +R4, LSL #+2]
   \   000000CC   801082E0           ADD      R1,R2,R0, LSL #+1
   \   000000D0   B040C1E1           STRH     R4,[R1, #+0]
   1059             }
   \   000000D4   010080E2           ADD      R0,R0,#+1
   \   000000D8   1E0050E3           CMP      R0,#+30
   \   000000DC   F8FFFFBA           BLT      ??D_UTIL_bp_6k_7k_9
   1060          
   1061             return;
   \   000000E0   6EDF8DE2           ADD      SP,SP,#+440
   \   000000E4   7000BDE8           POP      {R4-R6}
   \   000000E8   1EFF2FE1           BX       LR               ;; return
   \                     ??D_UTIL_bp_6k_7k_8:
   \   000000EC   ........           DC32     D_ROM_fir_6k_7k
   1062          }
   1063          
   1064          
   1065          /*
   1066           * D_UTIL_hp_7k
   1067           *
   1068           * Parameters:
   1069           *    signal          I/O: ISF vector
   1070           *    lg                I: length of signal
   1071           *    mem             I/O: memory (30)
   1072           *
   1073           * Function:
   1074           *    15th order high pass 7kHz FIR filter
   1075           *
   1076           * Returns:
   1077           *    void
   1078           */

   \                                 In segment CODE, align 4, keep-with-next
   1079          static void D_UTIL_hp_7k(Word16 signal[], Word16 lg, Word16 mem[])
   1080          {
   \                     D_UTIL_hp_7k:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   DCD04DE2           SUB      SP,SP,#+220
   \   00000008   0050A0E1           MOV      R5,R0
   \   0000000C   0160A0E1           MOV      R6,R1
   \   00000010   0240A0E1           MOV      R4,R2
   1081          
   1082             Word32 i, j, tmp;
   1083             Word16 x[L_SUBFR16k + (L_FIR - 1)];
   1084          
   1085             memcpy(x, mem, (L_FIR - 1) * sizeof(Word16));
   \   00000014   3C20A0E3           MOV      R2,#+60
   \   00000018   0410A0E1           MOV      R1,R4
   \   0000001C   0D00A0E1           MOV      R0,SP
   \   00000020   1E0100EF           SWI      +286
   1086             memcpy(&x[L_FIR - 1], signal, lg * sizeof(Word16));
   \   00000024   8620A0E1           LSL      R2,R6,#+1
   \   00000028   0510A0E1           MOV      R1,R5
   \   0000002C   3C008DE2           ADD      R0,SP,#+60
   \   00000030   1E0100EF           SWI      +286
   1087          
   1088             for(i = 0; i < lg; i++)
   \   00000034   0010A0E3           MOV      R1,#+0
   \   00000038   0600A0E1           MOV      R0,R6
   \   0000003C   010056E3           CMP      R6,#+1
   \   00000040   120000AA           BGE      ??D_UTIL_hp_7k_0
   \   00000044   130000EA           B        ??D_UTIL_hp_7k_1
   1089             {
   1090                tmp = 0;
   \                     ??D_UTIL_hp_7k_2:
   \   00000048   0020A0E3           MOV      R2,#+0
   1091          
   1092                for(j = 0; j < L_FIR; j++)
   \   0000004C   0030A0E3           MOV      R3,#+0
   1093                {
   1094                   tmp += x[i + j] * D_ROM_fir_7k[j];
   \                     ??D_UTIL_hp_7k_3:
   \   00000050   016083E0           ADD      R6,R3,R1
   \   00000054   0DC0A0E1           MOV      R12,SP
   \   00000058   86608CE0           ADD      R6,R12,R6, LSL #+1
   \   0000005C   50C09FE5           LDR      R12,??D_UTIL_hp_7k_4  ;; D_ROM_fir_7k
   \   00000060   F060D6E1           LDRSH    R6,[R6, #+0]
   \   00000064   83C08CE0           ADD      R12,R12,R3, LSL #+1
   \   00000068   F0C0DCE1           LDRSH    R12,[R12, #+0]
   1095                }
   \   0000006C   013083E2           ADD      R3,R3,#+1
   \   00000070   1F0053E3           CMP      R3,#+31
   \   00000074   9C2622E0           MLA      R2,R12,R6,R2
   \   00000078   F4FFFFBA           BLT      ??D_UTIL_hp_7k_3
   1096          
   1097                signal[i] = (Word16)((tmp + 0x4000) >> 15);
   \   0000007C   813085E0           ADD      R3,R5,R1, LSL #+1
   \   00000080   402C82E2           ADD      R2,R2,#+16384
   \   00000084   C227A0E1           ASR      R2,R2,#+15
   \   00000088   B020C3E1           STRH     R2,[R3, #+0]
   1098             }
   \   0000008C   011081E2           ADD      R1,R1,#+1
   \                     ??D_UTIL_hp_7k_0:
   \   00000090   000051E1           CMP      R1,R0
   \   00000094   EBFFFFBA           BLT      ??D_UTIL_hp_7k_2
   1099          
   1100             memcpy(mem, x + lg, (L_FIR - 1) * sizeof(Word16));
   \                     ??D_UTIL_hp_7k_1:
   \   00000098   3C20A0E3           MOV      R2,#+60
   \   0000009C   0D10A0E1           MOV      R1,SP
   \   000000A0   801081E0           ADD      R1,R1,R0, LSL #+1
   \   000000A4   0400A0E1           MOV      R0,R4
   \   000000A8   1E0100EF           SWI      +286
   1101          
   1102             return;
   \   000000AC   DCD08DE2           ADD      SP,SP,#+220
   \   000000B0   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??D_UTIL_hp_7k_4:
   \   000000B4   ........           DC32     D_ROM_fir_7k
   1103          }
   1104          
   1105          
   1106          /*
   1107           * D_UTIL_Dec_synthesis
   1108           *
   1109           * Parameters:
   1110           *    Aq             I: quantized Az
   1111           *    exc            I: excitation at 12kHz
   1112           *    Q_new          I: scaling performed on exc
   1113           *    synth16k       O: 16kHz synthesis signal
   1114           *    prms           I: parameters
   1115           *    HfIsf        I/O: High frequency ISF:s
   1116           *    mode           I: codec mode
   1117           *    newDTXState    I: dtx state
   1118           *    bfi            I: bad frame indicator
   1119           *    st           I/O: State structure
   1120           *
   1121           * Function:
   1122           *    Synthesis of signal at 16kHz with HF extension.
   1123           *
   1124           * Returns:
   1125           *    void
   1126           */

   \                                 In segment CODE, align 4, keep-with-next
   1127          void D_UTIL_dec_synthesis(Word16 Aq[], Word16 exc[], Word16 Q_new,
   1128                                    Word16 synth16k[], Word16 prms, Word16 HfIsf[],
   1129                                    Word16 mode, Word16 newDTXState, Word16 bfi,
   1130                                    Decoder_State *st)
   1131          {
   \                     D_UTIL_dec_synthesis:
   \   00000000   FD4F2DE9           PUSH     {R0,R2-R11,LR}
   \   00000004   AEDF4DE2           SUB      SP,SP,#+696
   \   00000008   FC829DE5           LDR      R8,[SP, #+764]
   \   0000000C   0190A0E1           MOV      R9,R1
   \   00000010   BA4F8DE2           ADD      R4,SP,#+744
   \   00000014   F040D4E1           LDRSH    R4,[R4, #+0]
   \   00000018   BC5F8DE2           ADD      R5,SP,#+752
   \   0000001C   F050D5E1           LDRSH    R5,[R5, #+0]
   \   00000020   BD6F8DE2           ADD      R6,SP,#+756
   \   00000024   F060D6E1           LDRSH    R6,[R6, #+0]
   \   00000028   BE7F8DE2           ADD      R7,SP,#+760
   \   0000002C   F070D7E1           LDRSH    R7,[R7, #+0]
   1132             Word32 tmp, i;
   1133             Word16 exp;
   1134             Word16 ener, exp_ener;
   1135             Word32 fac;
   1136             Word16 synth_hi[M + L_SUBFR], synth_lo[M + L_SUBFR];
   1137             Word16 synth[L_SUBFR];
   1138             Word16 HF[L_SUBFR16k];   /* High Frequency vector      */
   1139             Word16 Ap[M16k + 1];
   1140             Word16 HfA[M16k + 1];
   1141             Word16 HF_corr_gain;
   1142             Word16 HF_gain_ind;
   1143             Word32 gain1, gain2;
   1144             Word16 weight1, weight2;
   1145          
   1146             /*
   1147              * Speech synthesis
   1148              *
   1149              * - Find synthesis speech corresponding to exc2[].
   1150              * - Perform fixed deemphasis and hp 50hz filtering.
   1151              * - Oversampling from 12.8kHz to 16kHz.
   1152              */
   1153             memcpy(synth_hi, st->mem_syn_hi, M * sizeof(Word16));
   \   00000030   5FAEA0E3           MOV      R10,#+1520
   \   00000034   2020A0E3           MOV      R2,#+32
   \   00000038   08108AE0           ADD      R1,R10,R8
   \   0000003C   0D00A0E1           MOV      R0,SP
   \   00000040   1E0100EF           SWI      +286
   1154             memcpy(synth_lo, st->mem_syn_lo, M * sizeof(Word16));
   \   00000044   61BEA0E3           MOV      R11,#+1552
   \   00000048   2020A0E3           MOV      R2,#+32
   \   0000004C   08108BE0           ADD      R1,R11,R8
   \   00000050   A0008DE2           ADD      R0,SP,#+160
   \   00000054   1E0100EF           SWI      +286
   1155             D_UTIL_synthesis_32(Aq, M, exc, Q_new, synth_hi + M, synth_lo + M, L_SUBFR);
   \   00000058   4000A0E3           MOV      R0,#+64
   \   0000005C   01002DE9           PUSH     {R0}
   \   00000060   0920A0E1           MOV      R2,R9
   \   00000064   1010A0E3           MOV      R1,#+16
   \   00000068   C4008DE2           ADD      R0,SP,#+196
   \   0000006C   01002DE9           PUSH     {R0}
   \   00000070   28008DE2           ADD      R0,SP,#+40
   \   00000074   01002DE9           PUSH     {R0}
   \   00000078   C4029DE5           LDR      R0,[SP, #+708]
   \   0000007C   B23F8DE2           ADD      R3,SP,#+712
   \   00000080   F030D3E1           LDRSH    R3,[R3, #+0]
   \   00000084   ........           BL       D_UTIL_synthesis_32
   1156             memcpy(st->mem_syn_hi, synth_hi + L_SUBFR, M * sizeof(Word16));
   \   00000088   2020A0E3           MOV      R2,#+32
   \   0000008C   8C108DE2           ADD      R1,SP,#+140
   \   00000090   08008AE0           ADD      R0,R10,R8
   \   00000094   1E0100EF           SWI      +286
   1157             memcpy(st->mem_syn_lo, synth_lo + L_SUBFR, M * sizeof(Word16));
   \   00000098   2020A0E3           MOV      R2,#+32
   \   0000009C   4B1F8DE2           ADD      R1,SP,#+300
   \   000000A0   08008BE0           ADD      R0,R11,R8
   \   000000A4   1E0100EF           SWI      +286
   1158             D_UTIL_deemph_32(synth_hi + M, synth_lo + M, synth, PREEMPH_FAC, L_SUBFR,
   1159                &(st->mem_deemph));
   \   000000A8   7E008AE2           ADD      R0,R10,#+126
   \   000000AC   080080E0           ADD      R0,R0,R8
   \   000000B0   01002DE9           PUSH     {R0}
   \   000000B4   0A30A0E3           MOV      R3,#+10
   \   000000B8   573C83E3           ORR      R3,R3,#0x5700
   \   000000BC   4000A0E3           MOV      R0,#+64
   \   000000C0   01002DE9           PUSH     {R0}
   \   000000C4   7D2F8DE2           ADD      R2,SP,#+500
   \   000000C8   D4108DE2           ADD      R1,SP,#+212
   \   000000CC   34008DE2           ADD      R0,SP,#+52
   \   000000D0   ........           BL       D_UTIL_deemph_32
   1160             D_UTIL_hp50_12k8(synth, L_SUBFR, st->mem_sig_out);
   \   000000D4   642E88E2           ADD      R2,R8,#+1600
   \   000000D8   4010A0E3           MOV      R1,#+64
   \   000000DC   7D0F8DE2           ADD      R0,SP,#+500
   \   000000E0   ........           BL       D_UTIL_hp50_12k8
   1161             D_UTIL_oversamp_16k(synth, L_SUBFR, synth16k, st->mem_oversamp);
   \   000000E4   D4229DE5           LDR      R2,[SP, #+724]
   \   000000E8   E6004AE2           SUB      R0,R10,#+230
   \   000000EC   083080E0           ADD      R3,R0,R8
   \   000000F0   4010A0E3           MOV      R1,#+64
   \   000000F4   7D0F8DE2           ADD      R0,SP,#+500
   \   000000F8   ........           BL       D_UTIL_oversamp_16k
   1162          
   1163             /*
   1164              * HF noise synthesis
   1165              *
   1166              * - Generate HF noise between 5.5 and 7.5 kHz.
   1167              * - Set energy of noise according to synthesis tilt.
   1168              *     tilt > 0.8 ==> - 14 dB (voiced)
   1169              *     tilt   0.5 ==> - 6 dB  (voiced or noise)
   1170              *     tilt < 0.0 ==>   0 dB  (noise)
   1171              */
   1172          
   1173             /* generate white noise vector */
   1174             for(i = 0; i < L_SUBFR16k; i++)
   \   000000FC   0000A0E3           MOV      R0,#+0
   \   00000100   14D08DE2           ADD      SP,SP,#+20
   \   00000104   4D30A0E3           MOV      R3,#+77
   \   00000108   7C3C83E3           ORR      R3,R3,#0x7C00
   \   0000010C   19A0A0E3           MOV      R10,#+25
   \   00000110   D8AD8AE3           ORR      R10,R10,#0x3600
   1175             {
   1176                HF[i] = (Word16)(D_UTIL_random(&(st->mem_seed2)) >> 3);
   \                     ??D_UTIL_dec_synthesis_0:
   \   00000114   62108BE3           ORR      R1,R11,#0x62
   \   00000118   081081E0           ADD      R1,R1,R8
   \   0000011C   F020D1E1           LDRSH    R2,[R1, #+0]
   \   00000120   93A222E0           MLA      R2,R3,R2,R10
   \   00000124   B020C1E1           STRH     R2,[R1, #+0]
   \   00000128   F010D1E1           LDRSH    R1,[R1, #+0]
   \   0000012C   502F8DE2           ADD      R2,SP,#+320
   \   00000130   802082E0           ADD      R2,R2,R0, LSL #+1
   \   00000134   C111A0E1           ASR      R1,R1,#+3
   \   00000138   B010C2E1           STRH     R1,[R2, #+0]
   1177             }
   \   0000013C   010080E2           ADD      R0,R0,#+1
   \   00000140   500050E3           CMP      R0,#+80
   \   00000144   F2FFFFBA           BLT      ??D_UTIL_dec_synthesis_0
   1178          
   1179             /* energy of excitation */
   1180             D_UTIL_signal_down_scale(exc, L_SUBFR, 3);
   \   00000148   0000A0E3           MOV      R0,#+0
   \   0000014C   803CA0E3           MOV      R3,#+32768
   \                     ??D_UTIL_dec_synthesis_1:
   \   00000150   801089E0           ADD      R1,R9,R0, LSL #+1
   \   00000154   F020D1E1           LDRSH    R2,[R1, #+0]
   \   00000158   010080E2           ADD      R0,R0,#+1
   \   0000015C   400050E3           CMP      R0,#+64
   \   00000160   0228A0E1           LSL      R2,R2,#+16
   \   00000164   C22183E0           ADD      R2,R3,R2, ASR #+3
   \   00000168   4228A0E1           ASR      R2,R2,#+16
   \   0000016C   B020C1E1           STRH     R2,[R1, #+0]
   \   00000170   F6FFFFBA           BLT      ??D_UTIL_dec_synthesis_1
   1181             Q_new = (Word16)(Q_new - 3);
   \   00000174   AF0F8DE2           ADD      R0,SP,#+700
   \   00000178   F000D0E1           LDRSH    R0,[R0, #+0]
   1182             ener = (Word16)(D_UTIL_dot_product12(exc, exc, L_SUBFR, &exp_ener) >> 16);
   \   0000017C   0010A0E3           MOV      R1,#+0
   \   00000180   0020A0E3           MOV      R2,#+0
   \   00000184   030040E2           SUB      R0,R0,#+3
   \                     ??D_UTIL_dec_synthesis_2:
   \   00000188   823089E0           ADD      R3,R9,R2, LSL #+1
   \   0000018C   F0A0D3E1           LDRSH    R10,[R3, #+0]
   \   00000190   012082E2           ADD      R2,R2,#+1
   \   00000194   400052E3           CMP      R2,#+64
   \   00000198   9A1A21E0           MLA      R1,R10,R10,R1
   \   0000019C   F9FFFFBA           BLT      ??D_UTIL_dec_synthesis_2
   \   000001A0   0120A0E3           MOV      R2,#+1
   \   000001A4   811082E0           ADD      R1,R2,R1, LSL #+1
   \   000001A8   0120B0E1           MOVS     R2,R1
   \   000001AC   0090E0E3           MVN      R9,#+0
   \   000001B0   00A0A0E3           MOV      R10,#+0
   \   000001B4   0030A003           MOVEQ    R3,#+0
   \   000001B8   0B00000A           BEQ      ??D_UTIL_dec_synthesis_3
   \   000001BC   090052E1           CMP      R2,R9
   \   000001C0   1F30A003           MOVEQ    R3,#+31
   \   000001C4   0800000A           BEQ      ??D_UTIL_dec_synthesis_3
   \   000001C8   000052E3           CMP      R2,#+0
   \   000001CC   0220E041           MVNMI    R2,R2
   \   000001D0   0030A0E3           MOV      R3,#+0
   \   000001D4   400452E3           CMP      R2,#+1073741824
   \   000001D8   030000AA           BGE      ??D_UTIL_dec_synthesis_3
   \                     ??D_UTIL_dec_synthesis_4:
   \   000001DC   8220A0E1           LSL      R2,R2,#+1
   \   000001E0   013083E2           ADD      R3,R3,#+1
   \   000001E4   400452E3           CMP      R2,#+1073741824
   \   000001E8   FBFFFFBA           BLT      ??D_UTIL_dec_synthesis_4
   \                     ??D_UTIL_dec_synthesis_3:
   \   000001EC   0338A0E1           MOV      R3,R3, LSL #+16
   \   000001F0   4338A0E1           MOV      R3,R3, ASR #+16
   \   000001F4   1113A0E1           LSL      R1,R1,R3
   \   000001F8   4118A0E1           ASR      R1,R1,#+16
   1183             exp_ener = (Word16)(exp_ener - (Q_new << 1));
   \   000001FC   1E2063E2           RSB      R2,R3,#+30
   \   00000200   0228A0E1           MOV      R2,R2, LSL #+16
   \   00000204   4228A0E1           MOV      R2,R2, ASR #+16
   \   00000208   0008A0E1           MOV      R0,R0, LSL #+16
   \   0000020C   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000210   802042E0           SUB      R2,R2,R0, LSL #+1
   1184          
   1185             /* set energy of white noise to energy of excitation */
   1186             tmp = (Word16)(D_UTIL_dot_product12(HF, HF, L_SUBFR16k, &exp) >> 16);
   \   00000214   0000A0E3           MOV      R0,#+0
   \   00000218   0030A0E1           MOV      R3,R0
   \                     ??D_UTIL_dec_synthesis_5:
   \   0000021C   50BF8DE2           ADD      R11,SP,#+320
   \   00000220   83B08BE0           ADD      R11,R11,R3, LSL #+1
   \   00000224   F0B0DBE1           LDRSH    R11,[R11, #+0]
   \   00000228   013083E2           ADD      R3,R3,#+1
   \   0000022C   500053E3           CMP      R3,#+80
   \   00000230   9B0B20E0           MLA      R0,R11,R11,R0
   \   00000234   F8FFFFBA           BLT      ??D_UTIL_dec_synthesis_5
   \   00000238   0130A0E3           MOV      R3,#+1
   \   0000023C   800083E0           ADD      R0,R3,R0, LSL #+1
   \   00000240   0030B0E1           MOVS     R3,R0
   \   00000244   00B0A003           MOVEQ    R11,#+0
   \   00000248   0B00000A           BEQ      ??D_UTIL_dec_synthesis_6
   \   0000024C   090053E1           CMP      R3,R9
   \   00000250   1FB0A003           MOVEQ    R11,#+31
   \   00000254   0800000A           BEQ      ??D_UTIL_dec_synthesis_6
   \   00000258   000053E3           CMP      R3,#+0
   \   0000025C   0330E041           MVNMI    R3,R3
   \   00000260   00B0A0E3           MOV      R11,#+0
   \   00000264   400453E3           CMP      R3,#+1073741824
   \   00000268   030000AA           BGE      ??D_UTIL_dec_synthesis_6
   \                     ??D_UTIL_dec_synthesis_7:
   \   0000026C   8330A0E1           LSL      R3,R3,#+1
   \   00000270   01B08BE2           ADD      R11,R11,#+1
   \   00000274   400453E3           CMP      R3,#+1073741824
   \   00000278   FBFFFFBA           BLT      ??D_UTIL_dec_synthesis_7
   \                     ??D_UTIL_dec_synthesis_6:
   \   0000027C   0BB8A0E1           MOV      R11,R11, LSL #+16
   \   00000280   4BB8A0E1           MOV      R11,R11, ASR #+16
   \   00000284   0B30A0E1           MOV      R3,R11
   \   00000288   1E3063E2           RSB      R3,R3,#+30
   \   0000028C   100BA0E1           LSL      R0,R0,R11
   \   00000290   4008A0E1           ASR      R0,R0,#+16
   1187          
   1188             if(tmp > ener)
   \   00000294   000051E1           CMP      R1,R0
   1189             {
   1190                tmp = tmp >> 1;   /* Be sure tmp < ener */
   \   00000298   C000A0B1           ASRLT    R0,R0,#+1
   1191                exp = (Word16)(exp + 1);
   \   0000029C   013083B2           ADDLT    R3,R3,#+1
   1192             }
   1193          
   1194             tmp = (tmp << 15) / ener;
   \   000002A0   8007A0E1           LSL      R0,R0,#+15
   \   000002A4   ........           _BLF     ??div32_a,??rA??div32_a
   1195          
   1196             if(tmp > 32767)
   \   000002A8   A9B8A0E1           MOV      R11,R9, LSR #+17
   \   000002AC   800C51E3           CMP      R1,#+32768
   1197             {
   1198                tmp = 32767;
   \   000002B0   0B10A0A1           MOVGE    R1,R11
   1199             }
   1200          
   1201             tmp = tmp << 16;   /* result is normalized */
   \   000002B4   0118A0E1           LSL      R1,R1,#+16
   1202             exp = (Word16)(exp - exp_ener);
   \   000002B8   020043E0           SUB      R0,R3,R2
   1203             D_UTIL_normalised_inverse_sqrt(&tmp, &exp);
   \   000002BC   010051E3           CMP      R1,#+1
   \   000002C0   0000A0B3           MOVLT    R0,#+0
   \   000002C4   8014C9B3           BICLT    R1,R9,#0x80000000
   \   000002C8   160000BA           BLT      ??D_UTIL_dec_synthesis_8
   \   000002CC   ........           LDR      R3,??DataTable6  ;; D_ROM_isqrt
   \   000002D0   010010E3           TST      R0,#0x1
   \   000002D4   C110A011           ASRNE    R1,R1,#+1
   \   000002D8   C114A0E1           ASR      R1,R1,#+9
   \   000002DC   4128A0E1           ASR      R2,R1,#+16
   \   000002E0   102042E2           SUB      R2,R2,#+16
   \   000002E4   823083E0           ADD      R3,R3,R2, LSL #+1
   \   000002E8   F0C0D3E1           LDRSH    R12,[R3, #+0]
   \   000002EC   F230D3E1           LDRSH    R3,[R3, #+2]
   \   000002F0   C110A0E1           ASR      R1,R1,#+1
   \   000002F4   01100BE0           AND      R1,R11,R1
   \   000002F8   03304CE0           SUB      R3,R12,R3
   \   000002FC   910303E0           MUL      R3,R1,R3
   \   00000300   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000304   4008A0E1           MOV      R0,R0, ASR #+16
   \   00000308   010040E2           SUB      R0,R0,#+1
   \   0000030C   C000A0E1           ASR      R0,R0,#+1
   \   00000310   000060E2           RSB      R0,R0,#+0
   \   00000314   0C28A0E1           LSL      R2,R12,#+16
   \   00000318   831042E0           SUB      R1,R2,R3, LSL #+1
   1204          
   1205             /* L_tmp x 2, L_tmp in Q31 */
   1206             /* tmp = 2 x sqrt(ener_exc/ener_hf) */
   1207             if(exp >= 0)
   \   0000031C   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000320   4008B0E1           MOVS     R0,R0, ASR #+16
   \   00000324   0200004A           BMI      ??D_UTIL_dec_synthesis_9
   1208             {
   1209                tmp = tmp >> (15 - exp);
   \                     ??D_UTIL_dec_synthesis_8:
   \   00000328   0F0060E2           RSB      R0,R0,#+15
   \   0000032C   5100A0E1           ASR      R0,R1,R0
   \   00000330   020000EA           B        ??D_UTIL_dec_synthesis_10
   1210             }
   1211             else
   1212             {
   1213                tmp = tmp >> (-exp);
   1214                tmp = tmp >> 15;
   \                     ??D_UTIL_dec_synthesis_9:
   \   00000334   000060E2           RSB      R0,R0,#+0
   \   00000338   5100A0E1           ASR      R0,R1,R0
   \   0000033C   C007A0E1           ASR      R0,R0,#+15
   1215             }
   1216          
   1217             /* saturation */
   1218             if(tmp > 0x7FFF)
   \                     ??D_UTIL_dec_synthesis_10:
   \   00000340   800C50E3           CMP      R0,#+32768
   1219             {
   1220                tmp = 0x7FFF;
   \   00000344   0B00A0A1           MOVGE    R0,R11
   1221             }
   1222          
   1223             for(i = 0; i < L_SUBFR16k; i++)
   \   00000348   0010A0E3           MOV      R1,#+0
   1224             {
   1225                HF[i] = (Word16)((HF[i] * tmp) >> 15);
   \                     ??D_UTIL_dec_synthesis_11:
   \   0000034C   502F8DE2           ADD      R2,SP,#+320
   \   00000350   812082E0           ADD      R2,R2,R1, LSL #+1
   \   00000354   F030D2E1           LDRSH    R3,[R2, #+0]
   1226             }
   \   00000358   011081E2           ADD      R1,R1,#+1
   \   0000035C   500051E3           CMP      R1,#+80
   \   00000360   900303E0           MUL      R3,R0,R3
   \   00000364   C337A0E1           ASR      R3,R3,#+15
   \   00000368   B030C2E1           STRH     R3,[R2, #+0]
   \   0000036C   F6FFFFBA           BLT      ??D_UTIL_dec_synthesis_11
   1227          
   1228             /* find tilt of synthesis speech (tilt: 1=voiced, -1=unvoiced) */
   1229             D_UTIL_hp400_12k8(synth, L_SUBFR, st->mem_hp400);
   \   00000370   4C00A0E3           MOV      R0,#+76
   \   00000374   600E80E3           ORR      R0,R0,#0x600
   \   00000378   082080E0           ADD      R2,R0,R8
   \   0000037C   4010A0E3           MOV      R1,#+64
   \   00000380   780F8DE2           ADD      R0,SP,#+480
   \   00000384   ........           BL       D_UTIL_hp400_12k8
   1230             tmp = 0L;
   \   00000388   0000A0E3           MOV      R0,#+0
   1231          
   1232             for(i = 0; i < L_SUBFR; i++)
   \   0000038C   0010A0E1           MOV      R1,R0
   1233             {
   1234                tmp = tmp + (synth[i] * synth[i]);
   \                     ??D_UTIL_dec_synthesis_12:
   \   00000390   782F8DE2           ADD      R2,SP,#+480
   \   00000394   812082E0           ADD      R2,R2,R1, LSL #+1
   \   00000398   F020D2E1           LDRSH    R2,[R2, #+0]
   1235             }
   \   0000039C   011081E2           ADD      R1,R1,#+1
   \   000003A0   400051E3           CMP      R1,#+64
   \   000003A4   920220E0           MLA      R0,R2,R2,R0
   \   000003A8   F8FFFFBA           BLT      ??D_UTIL_dec_synthesis_12
   1236          
   1237             tmp = (tmp << 1) + 1;
   \   000003AC   0110A0E3           MOV      R1,#+1
   \   000003B0   801081E0           ADD      R1,R1,R0, LSL #+1
   1238             exp = D_UTIL_norm_l(tmp);
   \   000003B4   0120B0E1           MOVS     R2,R1
   \   000003B8   0000A003           MOVEQ    R0,#+0
   \   000003BC   0B00000A           BEQ      ??D_UTIL_dec_synthesis_13
   \   000003C0   090052E1           CMP      R2,R9
   \   000003C4   1F00A003           MOVEQ    R0,#+31
   \   000003C8   0800000A           BEQ      ??D_UTIL_dec_synthesis_13
   \   000003CC   000052E3           CMP      R2,#+0
   \   000003D0   0220E041           MVNMI    R2,R2
   \   000003D4   0000A0E3           MOV      R0,#+0
   \   000003D8   400452E3           CMP      R2,#+1073741824
   \   000003DC   030000AA           BGE      ??D_UTIL_dec_synthesis_13
   \                     ??D_UTIL_dec_synthesis_14:
   \   000003E0   8220A0E1           LSL      R2,R2,#+1
   \   000003E4   010080E2           ADD      R0,R0,#+1
   \   000003E8   400452E3           CMP      R2,#+1073741824
   \   000003EC   FBFFFFBA           BLT      ??D_UTIL_dec_synthesis_14
   1239             ener = (Word16)((tmp << exp) >> 16);   /* ener = r[0] */
   \                     ??D_UTIL_dec_synthesis_13:
   \   000003F0   1110A0E1           LSL      R1,R1,R0
   \   000003F4   4118A0E1           ASR      R1,R1,#+16
   1240             tmp = 0L;
   \   000003F8   0020A0E3           MOV      R2,#+0
   1241          
   1242             for(i = 1; i < L_SUBFR; i++)
   \   000003FC   0130A0E3           MOV      R3,#+1
   1243             {
   1244                tmp = tmp + (synth[i] * synth[i - 1]);
   \                     ??D_UTIL_dec_synthesis_15:
   \   00000400   789F8DE2           ADD      R9,SP,#+480
   \   00000404   839089E0           ADD      R9,R9,R3, LSL #+1
   \   00000408   F0C0D9E1           LDRSH    R12,[R9, #+0]
   \   0000040C   F29059E1           LDRSH    R9,[R9, #-2]
   1245             }
   \   00000410   013083E2           ADD      R3,R3,#+1
   \   00000414   400053E3           CMP      R3,#+64
   \   00000418   992C22E0           MLA      R2,R9,R12,R2
   \   0000041C   F7FFFFBA           BLT      ??D_UTIL_dec_synthesis_15
   1246          
   1247             tmp = (tmp << 1) + 1;
   1248             tmp = (tmp << exp) >> 16;   /* tmp = r[1] */
   \   00000420   0130A0E3           MOV      R3,#+1
   \   00000424   822083E0           ADD      R2,R3,R2, LSL #+1
   \   00000428   1200A0E1           LSL      R0,R2,R0
   \   0000042C   4008A0E1           ASR      R0,R0,#+16
   1249          
   1250             if(tmp > 0)
   \   00000430   010050E3           CMP      R0,#+1
   \   00000434   050000BA           BLT      ??D_UTIL_dec_synthesis_16
   1251             {
   1252                fac = ((tmp << 15) / ener);
   \   00000438   8007A0E1           LSL      R0,R0,#+15
   \   0000043C   ........           _BLF     ??div32_a,??rA??div32_a
   1253          
   1254                if(fac > 32767)
   \   00000440   800C51E3           CMP      R1,#+32768
   \   00000444   020000BA           BLT      ??D_UTIL_dec_synthesis_17
   1255                {
   1256                   fac = 32767;
   \   00000448   0B10A0E1           MOV      R1,R11
   \   0000044C   000000EA           B        ??D_UTIL_dec_synthesis_17
   1257                }
   1258             }
   1259             else
   1260             {
   1261                fac = 0;
   \                     ??D_UTIL_dec_synthesis_16:
   \   00000450   0010A0E3           MOV      R1,#+0
   1262             }
   1263          
   1264             /* modify energy of white noise according to synthesis tilt */
   1265             gain1 = (32767 - fac);
   1266             gain2 = ((32767 - fac) * 20480) >> 15;
   1267             gain2 = (gain2 << 1);
   \                     ??D_UTIL_dec_synthesis_17:
   \   00000454   01004BE0           SUB      R0,R11,R1
   \   00000458   501CA0E3           MOV      R1,#+20480
   \   0000045C   910002E0           MUL      R2,R1,R0
   \   00000460   C217A0E1           ASR      R1,R2,#+15
   1268          
   1269             if(gain2 > 32767)
   1270                gain2 = 32767;
   1271          
   1272             if(st->mem_vad_hist > 0)
   \   00000464   7A20A0E3           MOV      R2,#+122
   \   00000468   602E82E3           ORR      R2,R2,#0x600
   \   0000046C   B82092E1           LDRH     R2,[R2, +R8]
   \   00000470   8110A0E1           LSL      R1,R1,#+1
   \   00000474   800C51E3           CMP      R1,#+32768
   \   00000478   0B10A0A1           MOVGE    R1,R11
   \   0000047C   000052E3           CMP      R2,#+0
   1273             {
   1274                weight1 = 0;
   \   00000480   0020A013           MOVNE    R2,#+0
   1275                weight2 = 32767;
   \   00000484   0BA0A011           MOVNE    R10,R11
   1276             }
   1277             else
   1278             {
   1279                weight1 = 32767;
   \   00000488   0B20A001           MOVEQ    R2,R11
   1280                weight2 = 0;
   1281             }
   1282          
   1283             tmp = (weight1 * gain1) >> 15;
   1284             tmp = tmp + ((weight2 * gain2) >> 15);
   \   0000048C   900202E0           MUL      R2,R0,R2
   \   00000490   910A00E0           MUL      R0,R1,R10
   \   00000494   C007A0E1           ASR      R0,R0,#+15
   \   00000498   C21790E0           ADDS     R1,R0,R2, ASR #+15
   1285          
   1286             if(tmp != 0)
   1287             {
   1288                tmp = tmp + 1;
   \   0000049C   01108112           ADDNE    R1,R1,#+1
   1289             }
   1290          
   1291             if(tmp < 3277)
   \   000004A0   CD00A0E3           MOV      R0,#+205
   \   000004A4   C00E80E3           ORR      R0,R0,#0xC00
   \   000004A8   000051E1           CMP      R1,R0
   1292             {
   1293                tmp = 3277;   /* 0.1 in Q15 */
   \   000004AC   0010A0B1           MOVLT    R1,R0
   1294             }
   1295          
   1296             if((mode == MODE_24k) & (bfi == 0))
   \   000004B0   080055E3           CMP      R5,#+8
   \   000004B4   00005703           CMPEQ    R7,#+0
   \   000004B8   3B00001A           BNE      ??D_UTIL_dec_synthesis_18
   1297             {
   1298                /* HF correction gain */
   1299                HF_gain_ind = prms;
   1300                HF_corr_gain = D_ROM_hp_gain[HF_gain_ind];
   \   000004BC   94019FE5           LDR      R0,??D_UTIL_dec_synthesis_19  ;; D_ROM_hp_gain
   \   000004C0   840080E0           ADD      R0,R0,R4, LSL #+1
   \   000004C4   F010D0E1           LDRSH    R1,[R0, #+0]
   1301          
   1302                /* HF gain */
   1303                for(i = 0; i < L_SUBFR16k; i++)
   \   000004C8   0000A0E3           MOV      R0,#+0
   1304                {
   1305                   HF[i] = (Word16)(((HF[i] * HF_corr_gain) >> 15) << 1);
   \                     ??D_UTIL_dec_synthesis_20:
   \   000004CC   502F8DE2           ADD      R2,SP,#+320
   \   000004D0   802082E0           ADD      R2,R2,R0, LSL #+1
   \   000004D4   F030D2E1           LDRSH    R3,[R2, #+0]
   1306                }
   \   000004D8   010080E2           ADD      R0,R0,#+1
   \   000004DC   500050E3           CMP      R0,#+80
   \   000004E0   910303E0           MUL      R3,R1,R3
   \   000004E4   C337A0E1           ASR      R3,R3,#+15
   \   000004E8   8330A0E1           LSL      R3,R3,#+1
   \   000004EC   B030C2E1           STRH     R3,[R2, #+0]
   \   000004F0   F5FFFFBA           BLT      ??D_UTIL_dec_synthesis_20
   1307             }
   1308             else
   1309             {
   1310                for(i = 0; i < L_SUBFR16k; i++)
   1311                {
   1312                   HF[i] = (Word16)((HF[i] * tmp) >> 15);
   1313                }
   1314             }
   1315          
   1316             if((mode <= MODE_7k) & (newDTXState == SPEECH))
   1317             {
   1318                D_LPC_isf_extrapolation(HfIsf);
   1319                D_LPC_isp_a_conversion(HfIsf, HfA, 0, M16k);
   1320                D_LPC_a_weight(HfA, Ap, 29491, M16k);   /* fac=0.9 */
   1321                D_UTIL_synthesis(Ap, M16k, HF, HF, L_SUBFR16k, st->mem_syn_hf, 1);
   1322             }
   1323             else
   1324             {
   1325                /* synthesis of noise: 4.8kHz..5.6kHz --> 6kHz..7kHz */
   1326                D_LPC_a_weight(Aq, Ap, 19661, M);   /* fac=0.6 */
   \                     ??D_UTIL_dec_synthesis_21:
   \   000004F4   B8029DE5           LDR      R0,[SP, #+696]
   \   000004F8   1030A0E3           MOV      R3,#+16
   \   000004FC   CD20A0E3           MOV      R2,#+205
   \   00000500   4C2C82E3           ORR      R2,R2,#0x4C00
   \   00000504   981F8DE2           ADD      R1,SP,#+608
   \   00000508   ........           _BLF     D_LPC_a_weight,??D_LPC_a_weight??rA
   1327                D_UTIL_synthesis(Ap, M, HF, HF, L_SUBFR16k, st->mem_syn_hf + (M16k - M), 1);
   \   0000050C   0100A0E3           MOV      R0,#+1
   \   00000510   01002DE9           PUSH     {R0}
   \   00000514   1010A0E3           MOV      R1,#+16
   \   00000518   570E88E2           ADD      R0,R8,#+1392
   \                     ??D_UTIL_dec_synthesis_22:
   \   0000051C   01002DE9           PUSH     {R0}
   \   00000520   5000A0E3           MOV      R0,#+80
   \   00000524   01002DE9           PUSH     {R0}
   \   00000528   533F8DE2           ADD      R3,SP,#+332
   \   0000052C   532F8DE2           ADD      R2,SP,#+332
   \   00000530   9B0F8DE2           ADD      R0,SP,#+620
   \   00000534   ........           BL       D_UTIL_synthesis
   \   00000538   0CD08DE2           ADD      SP,SP,#+12
   1328             }
   1329          
   1330             /* noise High Pass filtering (1ms of delay) */
   1331             D_UTIL_bp_6k_7k(HF, L_SUBFR16k, st->mem_hf);
   \   0000053C   5600A0E3           MOV      R0,#+86
   \   00000540   400E80E3           ORR      R0,R0,#0x400
   \   00000544   082080E0           ADD      R2,R0,R8
   \   00000548   5010A0E3           MOV      R1,#+80
   \   0000054C   500F8DE2           ADD      R0,SP,#+320
   \   00000550   ........           BL       D_UTIL_bp_6k_7k
   1332          
   1333             if(mode == MODE_24k)
   \   00000554   080055E3           CMP      R5,#+8
   \   00000558   0500001A           BNE      ??D_UTIL_dec_synthesis_23
   1334             {
   1335                /* Low Pass filtering (7 kHz) */
   1336                D_UTIL_hp_7k(HF, L_SUBFR16k, st->mem_hf3);
   \   0000055C   CE00A0E3           MOV      R0,#+206
   \   00000560   400E80E3           ORR      R0,R0,#0x400
   \   00000564   082080E0           ADD      R2,R0,R8
   \   00000568   5010A0E3           MOV      R1,#+80
   \   0000056C   500F8DE2           ADD      R0,SP,#+320
   \   00000570   ........           BL       D_UTIL_hp_7k
   1337             }
   1338          
   1339             /* add filtered HF noise to speech synthesis */
   1340             for(i = 0; i < L_SUBFR16k; i++)
   \                     ??D_UTIL_dec_synthesis_23:
   \   00000574   0000A0E3           MOV      R0,#+0
   1341             {
   1342                tmp = (synth16k[i] + HF[i]);
   1343                synth16k[i] = D_UTIL_saturate(tmp);
   \                     ??D_UTIL_dec_synthesis_24:
   \   00000578   C0129DE5           LDR      R1,[SP, #+704]
   \   0000057C   503F8DE2           ADD      R3,SP,#+320
   \   00000580   801081E0           ADD      R1,R1,R0, LSL #+1
   \   00000584   F020D1E1           LDRSH    R2,[R1, #+0]
   \   00000588   803083E0           ADD      R3,R3,R0, LSL #+1
   \   0000058C   F030D3E1           LDRSH    R3,[R3, #+0]
   \   00000590   022083E0           ADD      R2,R3,R2
   \   00000594   0B0052E1           CMP      R2,R11
   \   00000598   250000AA           BGE      ??D_UTIL_dec_synthesis_25
   \   0000059C   00306BE2           RSB      R3,R11,#+0
   \   000005A0   030052E1           CMP      R2,R3
   \   000005A4   220000BA           BLT      ??D_UTIL_dec_synthesis_25
   \   000005A8   240000EA           B        ??D_UTIL_dec_synthesis_26
   \                     ??D_UTIL_dec_synthesis_18:
   \   000005AC   0000A0E3           MOV      R0,#+0
   \                     ??D_UTIL_dec_synthesis_27:
   \   000005B0   502F8DE2           ADD      R2,SP,#+320
   \   000005B4   802082E0           ADD      R2,R2,R0, LSL #+1
   \   000005B8   F030D2E1           LDRSH    R3,[R2, #+0]
   \   000005BC   010080E2           ADD      R0,R0,#+1
   \   000005C0   500050E3           CMP      R0,#+80
   \   000005C4   910303E0           MUL      R3,R1,R3
   \   000005C8   C337A0E1           ASR      R3,R3,#+15
   \   000005CC   B030C2E1           STRH     R3,[R2, #+0]
   \   000005D0   F6FFFFBA           BLT      ??D_UTIL_dec_synthesis_27
   \   000005D4   010055E3           CMP      R5,#+1
   \   000005D8   C5FFFFAA           BGE      ??D_UTIL_dec_synthesis_21
   \   000005DC   000056E3           CMP      R6,#+0
   \   000005E0   C3FFFF1A           BNE      ??D_UTIL_dec_synthesis_21
   \   000005E4   EC029DE5           LDR      R0,[SP, #+748]
   \   000005E8   ........           _BLF     D_LPC_isf_extrapolation,??D_LPC_isf_extrapolation??rA
   \   000005EC   EC029DE5           LDR      R0,[SP, #+748]
   \   000005F0   1430A0E3           MOV      R3,#+20
   \   000005F4   0020A0E3           MOV      R2,#+0
   \   000005F8   A31F8DE2           ADD      R1,SP,#+652
   \   000005FC   ........           _BLF     D_LPC_isp_a_conversion,??D_LPC_isp_a_conversion??rA
   \   00000600   1430A0E3           MOV      R3,#+20
   \   00000604   3320A0E3           MOV      R2,#+51
   \   00000608   732C82E3           ORR      R2,R2,#0x7300
   \   0000060C   981F8DE2           ADD      R1,SP,#+608
   \   00000610   A30F8DE2           ADD      R0,SP,#+652
   \   00000614   ........           _BLF     D_LPC_a_weight,??D_LPC_a_weight??rA
   \   00000618   0100A0E3           MOV      R0,#+1
   \   0000061C   01002DE9           PUSH     {R0}
   \   00000620   1410A0E3           MOV      R1,#+20
   \   00000624   6800A0E3           MOV      R0,#+104
   \   00000628   500E80E3           ORR      R0,R0,#0x500
   \   0000062C   080080E0           ADD      R0,R0,R8
   \   00000630   B9FFFFEA           B        ??D_UTIL_dec_synthesis_22
   \                     ??D_UTIL_dec_synthesis_25:
   \   00000634   010052E3           CMP      R2,#+1
   \   00000638   0B20A0A1           MOVGE    R2,R11
   \   0000063C   0B20E0B1           MVNLT    R2,R11
   \                     ??D_UTIL_dec_synthesis_26:
   \   00000640   B020C1E1           STRH     R2,[R1, #+0]
   1344             }
   \   00000644   010080E2           ADD      R0,R0,#+1
   \   00000648   500050E3           CMP      R0,#+80
   \   0000064C   C9FFFFBA           BLT      ??D_UTIL_dec_synthesis_24
   1345          
   1346             return;
   \   00000650   B1DF8DE2           ADD      SP,SP,#+708      ;; stack cleaning
   \   00000654   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??D_UTIL_dec_synthesis_19:
   \   00000658   ........           DC32     D_ROM_hp_gain
   1347          }
   1348          
   1349          
   1350          /*
   1351           * D_UTIL_preemph
   1352           *
   1353           * Parameters:
   1354           *    x            I/O: signal
   1355           *    mu             I: preemphasis factor
   1356           *    lg             I: vector size
   1357           *    mem          I/O: memory (x[-1])
   1358           *
   1359           * Function:
   1360           *    Filtering through 1 - mu z^-1
   1361           *
   1362           *
   1363           * Returns:
   1364           *    void
   1365           */

   \                                 In segment CODE, align 4, keep-with-next
   1366          void D_UTIL_preemph(Word16 x[], Word16 mu, Word16 lg, Word16 *mem)
   1367          {
   \                     D_UTIL_preemph:
   \   00000000   70002DE9           PUSH     {R4-R6}
   1368             Word32 i, L_tmp;
   1369             Word16 temp;
   1370          
   1371             temp = x[lg - 1];
   \   00000004   824080E0           ADD      R4,R0,R2, LSL #+1
   \   00000008   F2C054E1           LDRSH    R12,[R4, #-2]
   1372          
   1373             for(i = lg - 1; i > 0; i--)
   \   0000000C   012042E2           SUB      R2,R2,#+1
   \   00000010   010052E3           CMP      R2,#+1
   \   00000014   0C0000BA           BLT      ??D_UTIL_preemph_0
   1374             {
   1375                L_tmp = x[i] << 15;
   1376                L_tmp = L_tmp - (x[i - 1] * mu);
   1377                x[i] = (Word16)((L_tmp + 0x4000) >> 15);
   \                     ??D_UTIL_preemph_1:
   \   00000018   026040E2           SUB      R6,R0,#+2
   \   0000001C   826086E0           ADD      R6,R6,R2, LSL #+1
   \   00000020   F060D6E1           LDRSH    R6,[R6, #+0]
   \   00000024   824080E0           ADD      R4,R0,R2, LSL #+1
   \   00000028   F050D4E1           LDRSH    R5,[R4, #+0]
   \   0000002C   910606E0           MUL      R6,R1,R6
   1378             }
   \   00000030   012042E2           SUB      R2,R2,#+1
   \   00000034   855766E0           RSB      R5,R6,R5, LSL #+15
   \   00000038   405C85E2           ADD      R5,R5,#+16384
   \   0000003C   C557A0E1           ASR      R5,R5,#+15
   \   00000040   B050C4E1           STRH     R5,[R4, #+0]
   \   00000044   010052E3           CMP      R2,#+1
   \   00000048   F2FFFFAA           BGE      ??D_UTIL_preemph_1
   1379          
   1380             L_tmp = x[0] << 15;
   1381             L_tmp = L_tmp - (*mem * mu);
   1382             x[0] = (Word16)((L_tmp + 0x4000) >> 15);
   \                     ??D_UTIL_preemph_0:
   \   0000004C   F040D3E1           LDRSH    R4,[R3, #+0]
   \   00000050   F020D0E1           LDRSH    R2,[R0, #+0]
   \   00000054   910404E0           MUL      R4,R1,R4
   \   00000058   821764E0           RSB      R1,R4,R2, LSL #+15
   \   0000005C   401C81E2           ADD      R1,R1,#+16384
   \   00000060   C117A0E1           ASR      R1,R1,#+15
   \   00000064   B010C0E1           STRH     R1,[R0, #+0]
   1383             *mem = temp;
   \   00000068   B0C0C3E1           STRH     R12,[R3, #+0]
   1384          
   1385             return;
   \   0000006C   7000BDE8           POP      {R4-R6}
   \   00000070   1EFF2FE1           BX       LR               ;; return
   1386          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     D_ROM_isqrt

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   00A0FF1F           DC32     0x1fffa000

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   01E0FFDF           DC32     0xffffffffdfffe001

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     D_ROM_isqrt

   Maximum stack usage in bytes:

     Function                       CSTACK
     --------                       ------
     D_UTIL_bp_6k_7k                  452
     D_UTIL_dec_synthesis             764
     D_UTIL_deemph_32                  32
     D_UTIL_dot_product12              12
     D_UTIL_hp400_12k8                 40
     D_UTIL_hp50_12k8                  40
     D_UTIL_hp_7k                     236
     D_UTIL_interpol                   16
     D_UTIL_inverse_sqrt                0
     D_UTIL_l_extract                   0
     D_UTIL_log2                        4
     D_UTIL_mpy_32                      0
     D_UTIL_mpy_32_16                   0
     D_UTIL_norm_l                      0
     D_UTIL_norm_s                      0
     D_UTIL_normalised_inverse_sqrt     0
     D_UTIL_oversamp_16k              204
     D_UTIL_pow2                        0
     D_UTIL_preemph                    12
     D_UTIL_random                      0
     D_UTIL_saturate                    0
     D_UTIL_signal_down_scale           8
     D_UTIL_signal_up_scale            12
     D_UTIL_synthesis                 248
     D_UTIL_synthesis_32               40


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     D_UTIL_random                    36
     D_UTIL_pow2                     100
     D_UTIL_norm_l                    68
     D_UTIL_norm_s                    88
     D_UTIL_dot_product12            152
     D_UTIL_normalised_inverse_sqrt  132
     D_UTIL_inverse_sqrt             200
     D_UTIL_log2                     172
     D_UTIL_l_extract                 28
     D_UTIL_mpy_32_16                 20
     D_UTIL_mpy_32                    28
     D_UTIL_saturate                  52
     D_UTIL_signal_up_scale          100
     D_UTIL_signal_down_scale         68
     D_UTIL_deemph_32                220
     D_UTIL_synthesis_32             320
     D_UTIL_hp50_12k8                292
     D_UTIL_interpol                 180
     D_UTIL_oversamp_16k             320
     D_UTIL_hp400_12k8               252
     D_UTIL_synthesis                336
     D_UTIL_bp_6k_7k                 240
     D_UTIL_hp_7k                    184
     D_UTIL_dec_synthesis           1628
     D_UTIL_preemph                  116
     ??DataTable1                      4
     ??DataTable4                      4
     ??DataTable5                      4
     ??DataTable6                      4
      Others                         148

 
 5 496 bytes in segment CODE
 
 5 348 bytes of CODE memory (+ 148 bytes shared)

Errors: none
Warnings: 4
