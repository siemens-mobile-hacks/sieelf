//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   14/Feb/2012  15:39:40 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\dec_ /
//                       if.c                                                /
//    Command line    =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\dec_ /
//                       if.c -D NDEBUG -lC D:\SVN\SieELF\SieELF\x65_PCM_Pla /
//                       yer\Player\Release\List\ -lA                        /
//                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player\Player /
//                       \Release\Obj\ -s9 --cpu_mode arm --endian little    /
//                       --cpu ARM926EJ-S --stack_align 4 --interwork -e     /
//                       --fpu None --dlib_config "D:\Program                /
//                       Files\IAR\Embedded Workbench 4.0                    /
//                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude      /
//                       swilib.h -I "D:\Program Files\IAR\Embedded          /
//                       Workbench 4.0 Evaluation\ARM\INC\"                  /
//                       --inline_threshold=16                               /
//    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\dec_if.s79                                     /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME dec_if

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        PUBWEAK `?*?DATA_ID`
        MULTWEAK ??D_IF_conversion??rT
        MULTWEAK ??D_IF_decode??rT
        MULTWEAK ??D_IF_exit??rT
        MULTWEAK ??D_IF_homing_frame_test??rT
        MULTWEAK ??D_IF_homing_frame_test_first??rT
        MULTWEAK ??D_IF_init??rT
        MULTWEAK ??D_IF_reset??rT
        MULTWEAK ??D_MAIN_close??rA
        MULTWEAK ??D_MAIN_decode??rA
        MULTWEAK ??D_MAIN_init??rA
        MULTWEAK ??D_MAIN_reset??rA
??DataTable0 EQU 0
??DataTable1 EQU 0
??DataTable2 EQU 0
??DataTable3 EQU 0
        MULTWEAK ??free??rA
        PUBWEAK ?init?tab?DATA_I
        PUBLIC D_IF_conversion
        FUNCTION D_IF_conversion,0203H
        LOCFRAME CSTACK, 28, STACK
        PUBLIC D_IF_decode
        FUNCTION D_IF_decode,0203H
        LOCFRAME CSTACK, 156, STACK
        PUBLIC D_IF_exit
        FUNCTION D_IF_exit,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC D_IF_homing_frame_test
        FUNCTION D_IF_homing_frame_test,0203H
        LOCFRAME CSTACK, 28, STACK
        PUBLIC D_IF_homing_frame_test_first
        FUNCTION D_IF_homing_frame_test_first,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC D_IF_init
        FUNCTION D_IF_init,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC D_IF_reset
        FUNCTION D_IF_reset,0203H
        PUBLIC nb_of_param_first
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
D_MAIN_close        SYMBOL "D_MAIN_close"
D_MAIN_decode       SYMBOL "D_MAIN_decode"
D_MAIN_init         SYMBOL "D_MAIN_init"
D_MAIN_reset        SYMBOL "D_MAIN_reset"
free                SYMBOL "free"
D_IF_conversion     SYMBOL "D_IF_conversion"
??D_IF_conversion??rT SYMBOL "??rT", D_IF_conversion
D_IF_decode         SYMBOL "D_IF_decode"
??D_IF_decode??rT   SYMBOL "??rT", D_IF_decode
D_IF_exit           SYMBOL "D_IF_exit"
??D_IF_exit??rT     SYMBOL "??rT", D_IF_exit
D_IF_homing_frame_test SYMBOL "D_IF_homing_frame_test"
??D_IF_homing_frame_test??rT SYMBOL "??rT", D_IF_homing_frame_test
D_IF_homing_frame_test_first SYMBOL "D_IF_homing_frame_test_first"
??D_IF_homing_frame_test_first??rT SYMBOL "??rT", D_IF_homing_frame_test_first
D_IF_init           SYMBOL "D_IF_init"
??D_IF_init??rT     SYMBOL "??rT", D_IF_init
D_IF_reset          SYMBOL "D_IF_reset"
??D_IF_reset??rT    SYMBOL "??rT", D_IF_reset
??D_MAIN_close??rA  SYMBOL "??rA", D_MAIN_close
??D_MAIN_decode??rA SYMBOL "??rA", D_MAIN_decode
??D_MAIN_init??rA   SYMBOL "??rA", D_MAIN_init
??D_MAIN_reset??rA  SYMBOL "??rA", D_MAIN_reset
??free??rA          SYMBOL "??rA", free

        EXTERN D_MAIN_close
        FUNCTION D_MAIN_close,0202H
        EXTERN D_MAIN_decode
        FUNCTION D_MAIN_decode,0202H
        EXTERN D_MAIN_init
        FUNCTION D_MAIN_init,0202H
        EXTERN D_MAIN_reset
        FUNCTION D_MAIN_reset,0202H
        EXTERN dhf
        EXTERN free
        FUNCTION free,0200H
        EXTERN mode_12k
        EXTERN mode_14k
        EXTERN mode_16k
        EXTERN mode_18k
        EXTERN mode_20k
        EXTERN mode_23k
        EXTERN mode_24k
        EXTERN mode_7k
        EXTERN mode_9k
        EXTERN mode_DTX
        EXTERN nb_of_param

// D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AMR\dec_if.c
//    1 /*
//    2  *===================================================================
//    3  *  3GPP AMR Wideband Floating-point Speech Codec
//    4  *===================================================================
//    5  */
//    6 
//    7 #include "typedef.h"
//    8 #include "dec_if.h"
//    9 #include "if_rom.h"
//   10 #include "dec.h"
//   11 
//   12 #define L_FRAME16k   320            /* Frame size at 16kHz  */
//   13 #define MODE_7k       0             /* modes                */
//   14 #define MODE_9k       1
//   15 #define MODE_12k      2
//   16 #define MODE_14k      3
//   17 #define MODE_16k      4
//   18 #define MODE_18k      5
//   19 #define MODE_20k      6
//   20 #define MODE_23k      7
//   21 #define MODE_24k      8
//   22 #define MRDTX        9
//   23 #define NUM_OF_MODES 10
//   24 #define LOST_FRAME   14
//   25 #define MRNO_DATA    15
//   26 #define EHF_MASK     (Word16)0x0008 /* homing frame pattern */
//   27 
//   28 typedef struct
//   29 {
//   30    Word16 reset_flag_old;     /* previous was homing frame  */
//   31    Word16 prev_ft;            /* previous frame type        */
//   32    Word16 prev_mode;          /* previous mode              */
//   33    void *decoder_state;       /* Points decoder state       */
//   34 } WB_dec_if_state;
//   35 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   36 Word16 nb_of_param_first[NUM_OF_SPMODES]=
nb_of_param_first:
        DS8 20
        REQUIRE `?<Initializer for nb_of_param_first>`

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??D_IF_homing_frame_test??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE D_IF_homing_frame_test
//   37 {
//   38 	9,  14, 15,
//   39 	15, 15, 19,
//   40 	19, 19, 19
//   41 };
//   42 
//   43 extern const Word16 mode_7k[];
//   44 extern const Word16 mode_9k[];
//   45 extern const Word16 mode_12k[];
//   46 extern const Word16 mode_14k[];
//   47 extern const Word16 mode_16k[];
//   48 extern const Word16 mode_18k[];
//   49 extern const Word16 mode_20k[];
//   50 extern const Word16 mode_23k[];
//   51 extern const Word16 mode_24k[];
//   52 extern const Word16 mode_DTX[];
//   53 
//   54 extern const Word16 nb_of_param[];
//   55 
//   56 extern const Word16 dfh_M7k[];
//   57 extern const Word16 dfh_M9k[];
//   58 extern const Word16 dfh_M12k[];
//   59 extern const Word16 dfh_M14k[];
//   60 extern const Word16 dfh_M16k[];
//   61 extern const Word16 dfh_M18k[];
//   62 extern const Word16 dfh_M20k[];
//   63 extern const Word16 dfh_M23k[];
//   64 extern const Word16 dfh_M24k[];
//   65 
//   66 /* overall table with the parameters of the
//   67    decoder homing frames for all modes */
//   68 
//   69 extern Word16 *dhf[10];
//   70 
//   71 /*
//   72  * Decoder_Interface_Homing_Frame_test
//   73  *
//   74  * Parameters:
//   75  *    input_frame    I: input parameters
//   76  *    mode           I: speech mode
//   77  *
//   78  * Function:
//   79  *    Check parameters for matching homing frame
//   80  *
//   81  * Returns:
//   82  *    If homing frame
//   83  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function D_IF_homing_frame_test
        ARM
//   84 Word16 D_IF_homing_frame_test(Word16 input_frame[], Word16 mode)
//   85 {
D_IF_homing_frame_test:
        PUSH     {R4,R6-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//   86 
//   87    if (mode != MODE_24k)
        LDR      R6,??DataTable4  ;; dhf
        MOV      R4,R0
        MOV      R7,#+1
        CMP      R1,#+8
        BEQ      ??D_IF_homing_frame_test_0
//   88    {
//   89       /* perform test for COMPLETE parameter frame */
//   90       return (Word16)!memcmp(input_frame, dhf[mode], nb_of_param[mode] * sizeof(Word16));
        LDR      R0,??DataTable6  ;; nb_of_param
        ADD      R0,R0,R1, LSL #+1
        LDRSH    R0,[R0, #+0]
        LDR      R1,[R6, +R1, LSL #+2]
        LSL      R2,R0,#+1
        MOV      R0,R4
        SWI      +284
        CMP      R0,#+0
        MOVNE    R7,#+0
        MOV      R0,R7
        POP      {R4,R6-R9,PC}
//   91    }
//   92    else
//   93    {
//   94       /* discard high-band energy */
//   95       return (Word16)!(
//   96          (memcmp(input_frame, dhf[MODE_24k], 19 * sizeof(Word16))) |
//   97          (memcmp(input_frame + 20, dhf[MODE_24k] + 20, 11 * sizeof(Word16))) |
//   98          (memcmp(input_frame + 32, dhf[MODE_24k] + 32, 11 * sizeof(Word16))) |
//   99          (memcmp(input_frame + 44, dhf[MODE_24k] + 44, 11 * sizeof(Word16))) );
??D_IF_homing_frame_test_0:
        LDR      R1,[R6, #+32]
        MOV      R2,#+38
        SWI      +284
        MOV      R8,R0
        LDR      R0,[R6, #+32]
        MOV      R2,#+22
        ADD      R1,R0,#+40
        ADD      R0,R4,#+40
        SWI      +284
        MOV      R9,R0
        LDR      R0,[R6, #+32]
        MOV      R2,#+22
        ADD      R1,R0,#+64
        ADD      R0,R4,#+64
        SWI      +284
        ORR      R1,R9,R8
        ORR      R8,R0,R1
        LDR      R0,[R6, #+32]
        MOV      R2,#+22
        ADD      R1,R0,#+88
        ADD      R0,R4,#+88
        SWI      +284
        ORRS     R0,R0,R8
        MOVNE    R7,#+0
        MOV      R0,R7
        POP      {R4,R6-R9,PC}
        CFI EndBlock cfiBlock1
//  100 
//  101    }
//  102 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??D_IF_homing_frame_test_first??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE D_IF_homing_frame_test_first
//  103 
//  104 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function D_IF_homing_frame_test_first
        ARM
//  105 Word16 D_IF_homing_frame_test_first(Word16 input_frame[], Word16 mode)
//  106 {
//  107    /* perform test for FIRST SUBFRAME of parameter frame ONLY */
//  108    return (Word16)!memcmp(input_frame, dhf[mode], nb_of_param_first[mode] * sizeof(Word16));
D_IF_homing_frame_test_first:
        LDR      R2,??DataTable5  ;; nb_of_param_first
        LDR      R3,??DataTable4  ;; dhf
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        ADD      R2,R2,R1, LSL #+1
        LDRSH    R2,[R2, #+0]
        LDR      R1,[R3, +R1, LSL #+2]
        LSL      R2,R2,#+1
        SWI      +284
        CMP      R0,#+0
        MOVEQ    R0,#+1
        POPEQ    {PC}
        MOV      R0,#+0
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock3
//  109 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??D_IF_conversion??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE D_IF_conversion
//  110 
//  111 #ifdef IF2
//  112 /*
//  113  * D_IF_conversion
//  114  *
//  115  *
//  116  * Parameters:
//  117  *    param             O: AMR parameters
//  118  *    stream            I: input bitstream
//  119  *    frame_type        O: frame type
//  120  *    speech_mode       O: speech mode in DTX
//  121  *    fqi               O: frame quality indicator
//  122  *
//  123  * Function:
//  124  *    Unpacks IF2 octet stream
//  125  *
//  126  * Returns:
//  127  *    mode              used mode
//  128  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function D_IF_conversion
        ARM
//  129 Word16 D_IF_conversion(Word16 *param, UWord8 *stream, UWord8 *frame_type,
//  130                        Word16 *speech_mode, Word16 *fqi)
//  131 {
D_IF_conversion:
        PUSH     {R4-R9,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R9 Frame(CFA, -8)
        CFI R8 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        MOV      R4,R0
        LDR      R8,[SP, #+28]
        MOV      R5,R1
        MOV      R6,R2
        MOV      R7,R3
//  132    Word32 mode;
//  133    Word32 j;
//  134    Word16 const *mask;
//  135 
//  136    memset(param, 0, PRMNO_24k << 1);
        MOV      R2,#+112
        MOV      R1,#+0
        SWI      +187
//  137    mode = *stream >> 4;
        LDRB     R1,[R5, #+0]
//  138    *fqi = (Word16)((*stream >> 3) & 0x1);
        MOV      R2,#+1
        LSR      R0,R1,#+4
        AND      R1,R2,R1, ASR #+3
        STRH     R1,[R8, #+0]
//  139    *stream <<= (HEADER_SIZE - 1);
        LDRB     R1,[R5, #+0]
//  140 
//  141    switch (mode)
        MOV      R2,#+2
        MOV      R3,R0
        LSL      R1,R1,#+5
        STRB     R1,[R5, #+0]
        MOV      R1,#+0
        CMP      R3,#+15
        BHI      ??D_IF_conversion_1
        ADR      R12,??D_IF_conversion_0
        MOV      R3,R3, LSL #+1
        LDRH     R12,[R12, R3]
        ADD      PC,PC,R12, LSL #+2
        DATA
??D_IF_conversion_0:
        DC16     +60,+88,+116,+145
        DC16     +174,+203,+232,+261
        DC16     +290,+7,+319,+319
        DC16     +319,+319,+58,+55
        ARM
//  142    {
//  143    case MRDTX:
//  144       mask = mode_DTX;
??D_IF_conversion_2:
        LDR      R2,??D_IF_conversion_3  ;; mode_DTX
//  145 
//  146       for (j = HEADER_SIZE; j < T_NBBITS_SID; j++)
        MOV      R3,#+6
//  147       {
//  148          if (*stream & 0x80)
??D_IF_conversion_4:
        LDRB     R1,[R5, #+0]
        TST      R1,#0x80
        BEQ      ??D_IF_conversion_5
//  149          {
//  150             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
        LDRSH    R12,[R2, #+0]
        LDRSH    R1,[R2, #+0]
        LDRSH    LR,[R2, #+2]
        ADD      R12,R4,R12, LSL #+1
        LDRSH    R12,[R12, #+0]
        ADD      R1,R4,R1, LSL #+1
        ADD      R12,LR,R12
        STRH     R12,[R1, #+0]
//  151          }
//  152 
//  153          mask += 2;
??D_IF_conversion_5:
        ADD      R2,R2,#+4
//  154 
//  155          if ( j % 8 )
        ASR      R1,R3,#+2
        ADD      R1,R3,R1, LSR #+29
        ASR      R1,R1,#+3
        SUBS     R1,R3,R1, LSL #+3
        BEQ      ??D_IF_conversion_6
//  156          {
//  157             *stream <<= 1;
        LDRB     R1,[R5, #+0]
        LSL      R1,R1,#+1
        STRB     R1,[R5, #+0]
        B        ??D_IF_conversion_7
//  158          }
//  159          else
//  160          {
//  161             stream++;
??D_IF_conversion_6:
        ADD      R5,R5,#+1
//  162          }
//  163       }
??D_IF_conversion_7:
        ADD      R3,R3,#+1
        CMP      R3,#+41
        BLT      ??D_IF_conversion_4
//  164 
//  165       /* get SID type bit */
//  166 
//  167       *frame_type = RX_SID_FIRST;
        MOV      R1,#+4
        STRB     R1,[R6, #+0]
//  168 
//  169       if (*stream & 0x80)
        LDRB     R1,[R5, #+0]
        TST      R1,#0x80
//  170       {
//  171          *frame_type = RX_SID_UPDATE;
        MOVNE    R1,#+5
        STRBNE   R1,[R6, #+0]
//  172       }
//  173 
//  174       *stream <<= 1;
        LDRB     R1,[R5, #+0]
        LSL      R1,R1,#+1
        STRB     R1,[R5, #+0]
//  175 
//  176       /* speech mode indicator */
//  177       *speech_mode = (Word16)(*stream >> 4);
        LSL      R1,R1,#+24
        LSR      R1,R1,#+28
        STRH     R1,[R7, #+0]
//  178       break;
//  179 
//  180    case MRNO_DATA:
//  181       *frame_type = RX_NO_DATA;
//  182       break;
//  183 
//  184    case LOST_FRAME:
//  185       *frame_type = RX_SPEECH_LOST;
//  186       break;
//  187 
//  188    case MODE_7k:
//  189       mask = mode_7k;
//  190 
//  191       for (j = HEADER_SIZE; j < T_NBBITS_7k; j++)
//  192       {
//  193          if ( *stream & 0x80 )
//  194          {
//  195             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  196          }
//  197          mask += 2;
//  198 
//  199          if (j % 8)
//  200          {
//  201             *stream <<= 1;
//  202          }
//  203          else
//  204          {
//  205             stream++;
//  206          }
//  207       }
//  208 
//  209       *frame_type = RX_SPEECH_GOOD;
//  210       break;
//  211 
//  212    case MODE_9k:
//  213       mask = mode_9k;
//  214 
//  215       for (j = HEADER_SIZE; j < T_NBBITS_9k; j++)
//  216       {
//  217          if (*stream & 0x80)
//  218          {
//  219             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  220          }
//  221          mask += 2;
//  222 
//  223          if (j % 8)
//  224          {
//  225             *stream <<= 1;
//  226          }
//  227          else
//  228          {
//  229             stream++;
//  230          }
//  231       }
//  232 
//  233       *frame_type = RX_SPEECH_GOOD;
//  234       break;
//  235 
//  236    case MODE_12k:
//  237       mask = mode_12k;
//  238 
//  239       for (j = HEADER_SIZE; j < T_NBBITS_12k; j++)
//  240       {
//  241          if (*stream & 0x80)
//  242          {
//  243             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  244          }
//  245          mask += 2;
//  246 
//  247          if ( j % 8 )
//  248          {
//  249             *stream <<= 1;
//  250          }
//  251          else
//  252          {
//  253             stream++;
//  254          }
//  255       }
//  256 
//  257       *frame_type = RX_SPEECH_GOOD;
//  258       break;
//  259 
//  260    case MODE_14k:
//  261       mask = mode_14k;
//  262 
//  263       for (j = HEADER_SIZE; j < T_NBBITS_14k; j++)
//  264       {
//  265          if (*stream & 0x80)
//  266          {
//  267             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  268          }
//  269 
//  270          mask += 2;
//  271 
//  272          if ( j % 8 )
//  273          {
//  274             *stream <<= 1;
//  275          }
//  276          else
//  277          {
//  278             stream++;
//  279          }
//  280       }
//  281 
//  282       *frame_type = RX_SPEECH_GOOD;
//  283       break;
//  284 
//  285    case MODE_16k:
//  286       mask = mode_16k;
//  287 
//  288       for (j = HEADER_SIZE; j < T_NBBITS_16k; j++)
//  289       {
//  290          if (*stream & 0x80)
//  291          {
//  292             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  293          }
//  294 
//  295          mask += 2;
//  296 
//  297          if (j % 8)
//  298          {
//  299             *stream <<= 1;
//  300          }
//  301          else
//  302          {
//  303             stream++;
//  304          }
//  305       }
//  306 
//  307       *frame_type = RX_SPEECH_GOOD;
//  308       break;
//  309 
//  310    case MODE_18k:
//  311       mask = mode_18k;
//  312 
//  313       for (j = HEADER_SIZE; j < T_NBBITS_18k; j++)
//  314       {
//  315          if (*stream & 0x80)
//  316          {
//  317             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  318          }
//  319 
//  320          mask += 2;
//  321 
//  322          if (j % 8)
//  323          {
//  324             *stream <<= 1;
//  325          }
//  326          else
//  327          {
//  328             stream++;
//  329          }
//  330       }
//  331 
//  332       *frame_type = RX_SPEECH_GOOD;
//  333       break;
//  334 
//  335    case MODE_20k:
//  336       mask = mode_20k;
//  337 
//  338       for (j = HEADER_SIZE; j < T_NBBITS_20k; j++)
//  339       {
//  340          if (*stream & 0x80)
//  341          {
//  342             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  343          }
//  344 
//  345          mask += 2;
//  346 
//  347          if (j % 8)
//  348          {
//  349             *stream <<= 1;
//  350          }
//  351          else
//  352          {
//  353             stream++;
//  354          }
//  355       }
//  356 
//  357       *frame_type = RX_SPEECH_GOOD;
//  358       break;
//  359 
//  360    case MODE_23k:
//  361       mask = mode_23k;
//  362 
//  363       for (j = HEADER_SIZE; j < T_NBBITS_23k; j++)
//  364       {
//  365          if (*stream & 0x80)
//  366          {
//  367             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  368          }
//  369 
//  370          mask += 2;
//  371 
//  372          if (j % 8)
//  373          {
//  374             *stream <<= 1;
//  375          }
//  376          else
//  377          {
//  378             stream++;
//  379          }
//  380 
//  381       }
//  382 
//  383       *frame_type = RX_SPEECH_GOOD;
//  384       break;
//  385 
//  386    case MODE_24k:
//  387       mask = mode_24k;
//  388 
//  389       for (j = HEADER_SIZE; j < T_NBBITS_24k; j++)
//  390       {
//  391          if (*stream & 0x80)
//  392          {
//  393             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  394          }
//  395 
//  396          mask += 2;
//  397 
//  398          if (j % 8)
//  399          {
//  400             *stream <<= 1;
//  401          }
//  402          else
//  403          {
//  404             stream++;
//  405          }
//  406 
//  407       }
//  408 
//  409       *frame_type = RX_SPEECH_GOOD;
//  410       break;
//  411 
//  412    default:
//  413       *frame_type = RX_SPEECH_LOST;
//  414       *fqi = 0;
//  415       break;
//  416 
//  417    }
//  418 
//  419    if (*fqi == 0)
??D_IF_conversion_8:
        LDRSH    R1,[R8, #+0]
        CMP      R1,#+0
        POPNE    {R4-R9,PC}
//  420    {
//  421       if (*frame_type == RX_SPEECH_GOOD)
??D_IF_conversion_9:
        LDRB     R1,[R6, #+0]
        CMP      R1,#+0
        BNE      ??D_IF_conversion_10
//  422       {
//  423          *frame_type = RX_SPEECH_BAD;
        MOV      R1,#+3
        STRB     R1,[R6, #+0]
        POP      {R4-R9,PC}
//  424       }
??D_IF_conversion_11:
        MOV      R1,#+7
??D_IF_conversion_12:
        STRB     R1,[R6, #+0]
        B        ??D_IF_conversion_8
??D_IF_conversion_13:
        STRB     R2,[R6, #+0]
        B        ??D_IF_conversion_8
??D_IF_conversion_14:
        LDR      R2,??D_IF_conversion_3+0x4  ;; mode_7k
        MOV      R3,#+6
??D_IF_conversion_15:
        LDRB     R7,[R5, #+0]
        TST      R7,#0x80
        BEQ      ??D_IF_conversion_16
        LDRSH    R12,[R2, #+0]
        LDRSH    R7,[R2, #+0]
        LDRSH    LR,[R2, #+2]
        ADD      R12,R4,R12, LSL #+1
        LDRSH    R12,[R12, #+0]
        ADD      R7,R4,R7, LSL #+1
        ADD      R12,LR,R12
        STRH     R12,[R7, #+0]
??D_IF_conversion_16:
        ADD      R2,R2,#+4
        ASR      R7,R3,#+2
        ADD      R7,R3,R7, LSR #+29
        ASR      R7,R7,#+3
        SUBS     R7,R3,R7, LSL #+3
        BEQ      ??D_IF_conversion_17
        LDRB     R7,[R5, #+0]
        LSL      R7,R7,#+1
        STRB     R7,[R5, #+0]
        B        ??D_IF_conversion_18
??D_IF_conversion_17:
        ADD      R5,R5,#+1
??D_IF_conversion_18:
        ADD      R3,R3,#+1
        CMP      R3,#+138
        BLT      ??D_IF_conversion_15
        B        ??D_IF_conversion_12
??D_IF_conversion_19:
        LDR      R2,??D_IF_conversion_3+0x8  ;; mode_9k
        MOV      R3,#+6
        B        ??D_IF_conversion_20
??D_IF_conversion_21:
        ADD      R5,R5,#+1
??D_IF_conversion_22:
        ADD      R3,R3,#+1
        CMP      R3,#+183
        BGE      ??D_IF_conversion_12
??D_IF_conversion_20:
        LDRB     R7,[R5, #+0]
        TST      R7,#0x80
        BEQ      ??D_IF_conversion_23
        LDRSH    R12,[R2, #+0]
        LDRSH    R7,[R2, #+0]
        LDRSH    LR,[R2, #+2]
        ADD      R12,R4,R12, LSL #+1
        LDRSH    R12,[R12, #+0]
        ADD      R7,R4,R7, LSL #+1
        ADD      R12,LR,R12
        STRH     R12,[R7, #+0]
??D_IF_conversion_23:
        ADD      R2,R2,#+4
        ASR      R7,R3,#+2
        ADD      R7,R3,R7, LSR #+29
        ASR      R7,R7,#+3
        SUBS     R7,R3,R7, LSL #+3
        BEQ      ??D_IF_conversion_21
        LDRB     R7,[R5, #+0]
        LSL      R7,R7,#+1
        STRB     R7,[R5, #+0]
        B        ??D_IF_conversion_22
??D_IF_conversion_24:
        LDR      R2,??D_IF_conversion_3+0xC  ;; mode_12k
        MOV      R3,#+6
        ADD      R7,R3,#+253
        B        ??D_IF_conversion_25
??D_IF_conversion_26:
        ADD      R5,R5,#+1
??D_IF_conversion_27:
        ADD      R3,R3,#+1
        CMP      R3,R7
        BGE      ??D_IF_conversion_12
??D_IF_conversion_25:
        LDRB     R12,[R5, #+0]
        TST      R12,#0x80
        BEQ      ??D_IF_conversion_28
        LDRSH    LR,[R2, #+0]
        LDRSH    R12,[R2, #+0]
        LDRSH    R9,[R2, #+2]
        ADD      LR,R4,LR, LSL #+1
        LDRSH    LR,[LR, #+0]
        ADD      R12,R4,R12, LSL #+1
        ADD      R9,R9,LR
        STRH     R9,[R12, #+0]
??D_IF_conversion_28:
        ADD      R2,R2,#+4
        ASR      R9,R3,#+2
        ADD      R9,R3,R9, LSR #+29
        ASR      R9,R9,#+3
        SUBS     R9,R3,R9, LSL #+3
        BEQ      ??D_IF_conversion_26
        LDRB     R9,[R5, #+0]
        LSL      R9,R9,#+1
        STRB     R9,[R5, #+0]
        B        ??D_IF_conversion_27
??D_IF_conversion_29:
        LDR      R2,??D_IF_conversion_3+0x10  ;; mode_14k
        MOV      R3,#+6
        MOV      R7,#+35
        ORR      R7,R7,#0x100
        B        ??D_IF_conversion_30
??D_IF_conversion_31:
        ADD      R5,R5,#+1
??D_IF_conversion_32:
        ADD      R3,R3,#+1
        CMP      R3,R7
        BGE      ??D_IF_conversion_12
??D_IF_conversion_30:
        LDRB     R9,[R5, #+0]
        TST      R9,#0x80
        BEQ      ??D_IF_conversion_33
        LDRSH    R9,[R2, #+0]
        LDRSH    LR,[R2, #+2]
        ADD      R12,R4,R9, LSL #+1
        ADD      R9,R4,R9, LSL #+1
        LDRSH    R9,[R9, #+0]
        ADD      R9,LR,R9
        STRH     R9,[R12, #+0]
??D_IF_conversion_33:
        ADD      R2,R2,#+4
        ASR      R9,R3,#+2
        ADD      R9,R3,R9, LSR #+29
        ASR      R9,R9,#+3
        SUBS     R9,R3,R9, LSL #+3
        BEQ      ??D_IF_conversion_31
        LDRB     R9,[R5, #+0]
        LSL      R9,R9,#+1
        STRB     R9,[R5, #+0]
        B        ??D_IF_conversion_32
??D_IF_conversion_34:
        LDR      R2,??D_IF_conversion_3+0x14  ;; mode_16k
        MOV      R3,#+6
        MOV      R7,#+67
        ORR      R7,R7,#0x100
        B        ??D_IF_conversion_35
??D_IF_conversion_36:
        ADD      R5,R5,#+1
??D_IF_conversion_37:
        ADD      R3,R3,#+1
        CMP      R3,R7
        BGE      ??D_IF_conversion_12
??D_IF_conversion_35:
        LDRB     R9,[R5, #+0]
        TST      R9,#0x80
        BEQ      ??D_IF_conversion_38
        LDRSH    R9,[R2, #+0]
        LDRSH    LR,[R2, #+2]
        ADD      R12,R4,R9, LSL #+1
        ADD      R9,R4,R9, LSL #+1
        LDRSH    R9,[R9, #+0]
        ADD      R9,LR,R9
        STRH     R9,[R12, #+0]
??D_IF_conversion_38:
        ADD      R2,R2,#+4
        ASR      R9,R3,#+2
        ADD      R9,R3,R9, LSR #+29
        ASR      R9,R9,#+3
        SUBS     R9,R3,R9, LSL #+3
        BEQ      ??D_IF_conversion_36
        LDRB     R9,[R5, #+0]
        LSL      R9,R9,#+1
        STRB     R9,[R5, #+0]
        B        ??D_IF_conversion_37
??D_IF_conversion_39:
        LDR      R2,??D_IF_conversion_3+0x18  ;; mode_18k
        MOV      R3,#+6
        MOV      R7,#+115
        ORR      R7,R7,#0x100
        B        ??D_IF_conversion_40
??D_IF_conversion_41:
        ADD      R5,R5,#+1
??D_IF_conversion_42:
        ADD      R3,R3,#+1
        CMP      R3,R7
        BGE      ??D_IF_conversion_12
??D_IF_conversion_40:
        LDRB     R9,[R5, #+0]
        TST      R9,#0x80
        BEQ      ??D_IF_conversion_43
        LDRSH    R9,[R2, #+0]
        LDRSH    LR,[R2, #+2]
        ADD      R12,R4,R9, LSL #+1
        ADD      R9,R4,R9, LSL #+1
        LDRSH    R9,[R9, #+0]
        ADD      R9,LR,R9
        STRH     R9,[R12, #+0]
??D_IF_conversion_43:
        ADD      R2,R2,#+4
        ASR      R9,R3,#+2
        ADD      R9,R3,R9, LSR #+29
        ASR      R9,R9,#+3
        SUBS     R9,R3,R9, LSL #+3
        BEQ      ??D_IF_conversion_41
        LDRB     R9,[R5, #+0]
        LSL      R9,R9,#+1
        STRB     R9,[R5, #+0]
        B        ??D_IF_conversion_42
??D_IF_conversion_44:
        LDR      R2,??D_IF_conversion_3+0x1C  ;; mode_20k
        MOV      R3,#+6
        MOV      R7,#+147
        ORR      R7,R7,#0x100
        B        ??D_IF_conversion_45
??D_IF_conversion_46:
        ADD      R5,R5,#+1
??D_IF_conversion_47:
        ADD      R3,R3,#+1
        CMP      R3,R7
        BGE      ??D_IF_conversion_12
??D_IF_conversion_45:
        LDRB     R9,[R5, #+0]
        TST      R9,#0x80
        BEQ      ??D_IF_conversion_48
        LDRSH    R9,[R2, #+0]
        LDRSH    LR,[R2, #+2]
        ADD      R12,R4,R9, LSL #+1
        ADD      R9,R4,R9, LSL #+1
        LDRSH    R9,[R9, #+0]
        ADD      R9,LR,R9
        STRH     R9,[R12, #+0]
??D_IF_conversion_48:
        ADD      R2,R2,#+4
        ASR      R9,R3,#+2
        ADD      R9,R3,R9, LSR #+29
        ASR      R9,R9,#+3
        SUBS     R9,R3,R9, LSL #+3
        BEQ      ??D_IF_conversion_46
        LDRB     R9,[R5, #+0]
        LSL      R9,R9,#+1
        STRB     R9,[R5, #+0]
        B        ??D_IF_conversion_47
??D_IF_conversion_49:
        LDR      R2,??D_IF_conversion_3+0x20  ;; mode_23k
        MOV      R3,#+6
        MOV      R7,#+211
        ORR      R7,R7,#0x100
        B        ??D_IF_conversion_50
??D_IF_conversion_51:
        ADD      R5,R5,#+1
??D_IF_conversion_52:
        ADD      R3,R3,#+1
        CMP      R3,R7
        BGE      ??D_IF_conversion_12
??D_IF_conversion_50:
        LDRB     R9,[R5, #+0]
        TST      R9,#0x80
        BEQ      ??D_IF_conversion_53
        LDRSH    R9,[R2, #+0]
        LDRSH    LR,[R2, #+2]
        ADD      R12,R4,R9, LSL #+1
        ADD      R9,R4,R9, LSL #+1
        LDRSH    R9,[R9, #+0]
        ADD      R9,LR,R9
        STRH     R9,[R12, #+0]
??D_IF_conversion_53:
        ADD      R2,R2,#+4
        ASR      R9,R3,#+2
        ADD      R9,R3,R9, LSR #+29
        ASR      R9,R9,#+3
        SUBS     R9,R3,R9, LSL #+3
        BEQ      ??D_IF_conversion_51
        LDRB     R9,[R5, #+0]
        LSL      R9,R9,#+1
        STRB     R9,[R5, #+0]
        B        ??D_IF_conversion_52
??D_IF_conversion_54:
        LDR      R2,??D_IF_conversion_3+0x24  ;; mode_24k
        MOV      R3,#+6
        MOV      R7,#+227
        ORR      R7,R7,#0x100
        B        ??D_IF_conversion_55
??D_IF_conversion_56:
        ADD      R5,R5,#+1
??D_IF_conversion_57:
        ADD      R3,R3,#+1
        CMP      R3,R7
        BGE      ??D_IF_conversion_12
??D_IF_conversion_55:
        LDRB     R9,[R5, #+0]
        TST      R9,#0x80
        BEQ      ??D_IF_conversion_58
        LDRSH    R9,[R2, #+0]
        LDRSH    LR,[R2, #+2]
        ADD      R12,R4,R9, LSL #+1
        ADD      R9,R4,R9, LSL #+1
        LDRSH    R9,[R9, #+0]
        ADD      R9,LR,R9
        STRH     R9,[R12, #+0]
??D_IF_conversion_58:
        ADD      R2,R2,#+4
        ASR      R9,R3,#+2
        ADD      R9,R3,R9, LSR #+29
        ASR      R9,R9,#+3
        SUBS     R9,R3,R9, LSL #+3
        BEQ      ??D_IF_conversion_56
        LDRB     R9,[R5, #+0]
        LSL      R9,R9,#+1
        STRB     R9,[R5, #+0]
        B        ??D_IF_conversion_57
??D_IF_conversion_1:
        STRB     R2,[R6, #+0]
        STRH     R1,[R8, #+0]
        B        ??D_IF_conversion_9
//  425       if ((*frame_type == RX_SID_FIRST) | (*frame_type == RX_SID_UPDATE))
??D_IF_conversion_10:
        CMP      R1,#+4
        CMPNE    R1,#+5
//  426       {
//  427          *frame_type = RX_SID_BAD;
        MOVEQ    R1,#+6
        STRBEQ   R1,[R6, #+0]
//  428       }
//  429    }
//  430 
//  431    return (Word16)mode;
        POP      {R4-R9,PC}       ;; return
        DATA
??D_IF_conversion_3:
        DC32     mode_DTX
        DC32     mode_7k
        DC32     mode_9k
        DC32     mode_12k
        DC32     mode_14k
        DC32     mode_16k
        DC32     mode_18k
        DC32     mode_20k
        DC32     mode_23k
        DC32     mode_24k
        CFI EndBlock cfiBlock5
//  432 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??D_IF_decode??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE D_IF_decode
//  433 
//  434 #else
//  435 
//  436 /*
//  437  * D_IF_mms_conversion
//  438  *
//  439  *
//  440  * Parameters:
//  441  *    param             O: AMR parameters
//  442  *    stream            I: input bitstream
//  443  *    frame_type        O: frame type
//  444  *    speech_mode       O: speech mode in DTX
//  445  *    fqi               O: frame quality indicator
//  446  *
//  447  * Function:
//  448  *    Unpacks MMS formatted octet stream (see RFC 3267, section 5.3)
//  449  *
//  450  * Returns:
//  451  *    mode              used mode
//  452  */
//  453 Word16 D_IF_mms_conversion(Word16 *param, UWord8 *stream, UWord8 *frame_type,
//  454                            Word16 *speech_mode, Word16 *fqi)
//  455 {
//  456    Word32 mode;
//  457    Word32 j;
//  458    Word16 const *mask;
//  459 
//  460    memset(param, 0, PRMNO_24k << 1);
//  461 
//  462    *fqi = (Word16)((*stream >> 2) & 0x01);
//  463    mode = (Word32)((*stream >> 3) & 0x0F);
//  464 
//  465    stream++;
//  466 
//  467    switch (mode)
//  468    {
//  469    case MRDTX:
//  470       mask = mode_DTX;
//  471 
//  472       for (j = 1; j <= NBBITS_SID; j++)
//  473       {
//  474          if (*stream & 0x80)
//  475          {
//  476             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  477          }
//  478 
//  479          mask += 2;
//  480 
//  481          if ( j % 8 )
//  482          {
//  483             *stream <<= 1;
//  484          }
//  485          else
//  486          {
//  487             stream++;
//  488          }
//  489       }
//  490 
//  491       /* get SID type bit */
//  492 
//  493       *frame_type = RX_SID_FIRST;
//  494 
//  495       if (*stream & 0x80)
//  496       {
//  497          *frame_type = RX_SID_UPDATE;
//  498       }
//  499 
//  500       *stream <<= 1;
//  501 
//  502       /* speech mode indicator */
//  503       *speech_mode = (Word16)(*stream >> 4);
//  504       break;
//  505 
//  506    case MRNO_DATA:
//  507       *frame_type = RX_NO_DATA;
//  508       break;
//  509 
//  510    case LOST_FRAME:
//  511       *frame_type = RX_SPEECH_LOST;
//  512       break;
//  513 
//  514    case MODE_7k:
//  515       mask = mode_7k;
//  516 
//  517       for (j = 1; j <= NBBITS_7k; j++)
//  518       {
//  519          if ( *stream & 0x80 )
//  520          {
//  521             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  522          }
//  523          mask += 2;
//  524 
//  525          if (j % 8)
//  526          {
//  527             *stream <<= 1;
//  528          }
//  529          else
//  530          {
//  531             stream++;
//  532          }
//  533       }
//  534 
//  535       *frame_type = RX_SPEECH_GOOD;
//  536       break;
//  537 
//  538    case MODE_9k:
//  539       mask = mode_9k;
//  540 
//  541       for (j = 1; j <= NBBITS_9k; j++)
//  542       {
//  543          if (*stream & 0x80)
//  544          {
//  545             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  546          }
//  547          mask += 2;
//  548 
//  549          if (j % 8)
//  550          {
//  551             *stream <<= 1;
//  552          }
//  553          else
//  554          {
//  555             stream++;
//  556          }
//  557       }
//  558 
//  559       *frame_type = RX_SPEECH_GOOD;
//  560       break;
//  561 
//  562    case MODE_12k:
//  563       mask = mode_12k;
//  564 
//  565       for (j = 1; j <= NBBITS_12k; j++)
//  566       {
//  567          if (*stream & 0x80)
//  568          {
//  569             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  570          }
//  571          mask += 2;
//  572 
//  573          if ( j % 8 )
//  574          {
//  575             *stream <<= 1;
//  576          }
//  577          else
//  578          {
//  579             stream++;
//  580          }
//  581       }
//  582 
//  583       *frame_type = RX_SPEECH_GOOD;
//  584       break;
//  585 
//  586    case MODE_14k:
//  587       mask = mode_14k;
//  588 
//  589       for (j = 1; j <= NBBITS_14k; j++)
//  590       {
//  591          if (*stream & 0x80)
//  592          {
//  593             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  594          }
//  595 
//  596          mask += 2;
//  597 
//  598          if ( j % 8 )
//  599          {
//  600             *stream <<= 1;
//  601          }
//  602          else
//  603          {
//  604             stream++;
//  605          }
//  606       }
//  607 
//  608       *frame_type = RX_SPEECH_GOOD;
//  609       break;
//  610 
//  611    case MODE_16k:
//  612       mask = mode_16k;
//  613 
//  614       for (j = 1; j <= NBBITS_16k; j++)
//  615       {
//  616          if (*stream & 0x80)
//  617          {
//  618             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  619          }
//  620 
//  621          mask += 2;
//  622 
//  623          if (j % 8)
//  624          {
//  625             *stream <<= 1;
//  626          }
//  627          else
//  628          {
//  629             stream++;
//  630          }
//  631       }
//  632 
//  633       *frame_type = RX_SPEECH_GOOD;
//  634       break;
//  635 
//  636    case MODE_18k:
//  637       mask = mode_18k;
//  638 
//  639       for (j = 1; j <= NBBITS_18k; j++)
//  640       {
//  641          if (*stream & 0x80)
//  642          {
//  643             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  644          }
//  645 
//  646          mask += 2;
//  647 
//  648          if (j % 8)
//  649          {
//  650             *stream <<= 1;
//  651          }
//  652          else
//  653          {
//  654             stream++;
//  655          }
//  656       }
//  657 
//  658       *frame_type = RX_SPEECH_GOOD;
//  659       break;
//  660 
//  661    case MODE_20k:
//  662       mask = mode_20k;
//  663 
//  664       for (j = 1; j <= NBBITS_20k; j++)
//  665       {
//  666          if (*stream & 0x80)
//  667          {
//  668             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  669          }
//  670 
//  671          mask += 2;
//  672 
//  673          if (j % 8)
//  674          {
//  675             *stream <<= 1;
//  676          }
//  677          else
//  678          {
//  679             stream++;
//  680          }
//  681       }
//  682 
//  683       *frame_type = RX_SPEECH_GOOD;
//  684       break;
//  685 
//  686    case MODE_23k:
//  687       mask = mode_23k;
//  688 
//  689       for (j = 1; j <= NBBITS_23k; j++)
//  690       {
//  691          if (*stream & 0x80)
//  692          {
//  693             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  694          }
//  695 
//  696          mask += 2;
//  697 
//  698          if (j % 8)
//  699          {
//  700             *stream <<= 1;
//  701          }
//  702          else
//  703          {
//  704             stream++;
//  705          }
//  706 
//  707       }
//  708 
//  709       *frame_type = RX_SPEECH_GOOD;
//  710       break;
//  711 
//  712    case MODE_24k:
//  713       mask = mode_24k;
//  714 
//  715       for (j = 1; j <= NBBITS_24k; j++)
//  716       {
//  717          if (*stream & 0x80)
//  718          {
//  719             param[*mask] = (Word16)(param[*mask] + *(mask + 1));
//  720          }
//  721 
//  722          mask += 2;
//  723 
//  724          if (j % 8)
//  725          {
//  726             *stream <<= 1;
//  727          }
//  728          else
//  729          {
//  730             stream++;
//  731          }
//  732 
//  733       }
//  734 
//  735       *frame_type = RX_SPEECH_GOOD;
//  736       break;
//  737 
//  738    default:
//  739       *frame_type = RX_SPEECH_LOST;
//  740       *fqi = 0;
//  741       break;
//  742 
//  743    }
//  744 
//  745    if (*fqi == 0)
//  746    {
//  747       if (*frame_type == RX_SPEECH_GOOD)
//  748       {
//  749          *frame_type = RX_SPEECH_BAD;
//  750       }
//  751       if ((*frame_type == RX_SID_FIRST) | (*frame_type == RX_SID_UPDATE))
//  752       {
//  753          *frame_type = RX_SID_BAD;
//  754       }
//  755    }
//  756 
//  757    return (Word16)mode;
//  758 }
//  759 
//  760 #endif
//  761 
//  762 /*
//  763  * D_IF_decode
//  764  *
//  765  *
//  766  * Parameters:
//  767  *    st       B: pointer to state structure
//  768  *    bits     I: bitstream form the encoder
//  769  *    synth    O: decoder output
//  770  *    lfi      I: lost frame indicator
//  771  *                _good_frame, _bad_frame, _lost_frame, _no_frame
//  772  *
//  773  * Function:
//  774  *    Decoding one frame of speech. Lost frame indicator can be used
//  775  *    to inform encoder about the problems in the received frame.
//  776  *    _good_frame:good speech or sid frame is received.
//  777  *    _bad_frame: frame with possible bit errors
//  778  *    _lost_frame:speech of sid frame is lost in transmission
//  779  *    _no_frame:  indicates non-received frames in dtx-operation
//  780  * Returns:
//  781  *
//  782  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function D_IF_decode
        ARM
//  783 void D_IF_decode( void *st, UWord8 *bits, Word16 *synth, Word32 lfi)
//  784 {
D_IF_decode:
        PUSH     {R4-R7,R9,R10,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R7 Frame(CFA, -16)
        CFI R6 Frame(CFA, -20)
        CFI R5 Frame(CFA, -24)
        CFI R4 Frame(CFA, -28)
        CFI CFA R13+28
        SUB      SP,SP,#+120
        CFI CFA R13+148
        MOV      R4,R0
        MOV      R9,R2
//  785    Word32 i;
//  786    Word16 mode = 0;                 /* AMR mode                */
//  787    Word16 speech_mode = MODE_7k;    /* speech mode             */
        MOV      R5,#+0
        STRH     R5,[SP, #+2]
//  788    Word16 fqi;                      /* frame quality indicator */
//  789 
//  790    Word16 prm[PRMNO_24k];           /* AMR parameters          */
//  791 
//  792    UWord8 frame_type;               /* frame type              */
//  793    Word16 reset_flag = 0;           /* reset flag              */
        MOV      R10,#+0
//  794    WB_dec_if_state * s;             /* pointer to structure    */
//  795 
//  796    s = (WB_dec_if_state*)st;
//  797 
//  798    /* bits -> param, if needed */
//  799    if ((lfi == _good_frame) | (lfi == _bad_frame))
        CMP      R3,#+0
        CMPNE    R3,#+1
        BEQ      ??D_IF_decode_0
//  800    {
//  801       /* add fqi data */
//  802 #ifdef IF2
//  803       *bits = (UWord8)((Word32)*bits & ~(lfi << 3));
//  804 #else
//  805       *bits = (UWord8)((Word32)*bits & ~(lfi << 2));
//  806 #endif
//  807       /*
//  808        * extract mode information and frame_type,
//  809        * octets to parameters
//  810        */
//  811 #ifdef IF2
//  812       mode = D_IF_conversion( prm, bits, &frame_type, &speech_mode, &fqi);
//  813 #else
//  814       mode = D_IF_mms_conversion( prm, bits, &frame_type, &speech_mode, &fqi);
//  815 #endif
//  816 
//  817    }
//  818    else if (lfi == _no_frame)
        CMP      R3,#+3
        MOVNE    R1,#+2
//  819    {
//  820       frame_type = RX_NO_DATA;
        MOVEQ    R1,#+7
        STRB     R1,[SP, #+0]
        B        ??D_IF_decode_1
//  821    }
??D_IF_decode_0:
        LDRB     R0,[R1, #+0]
        MVN      R2,R3, LSL #+3
        AND      R0,R2,R0
        STRB     R0,[R1, #+0]
        ADD      R0,SP,#+4
        PUSH     {R0}
        CFI CFA R13+152
        ADD      R3,SP,#+6
        ADD      R2,SP,#+4
        ADD      R0,SP,#+12
        BL       D_IF_conversion
        MOV      R6,R0
//  822    else
//  823    {
//  824       frame_type = RX_SPEECH_LOST;
//  825    }
//  826 
//  827    /*
//  828     * if no mode information
//  829     * guess one from the previous frame
//  830     */
//  831    if ((frame_type == RX_SPEECH_LOST) | (frame_type == RX_NO_DATA))
        LDRB     R0,[SP, #+4]
        ADD      SP,SP,#+4
        CFI CFA R13+148
        CMP      R0,#+2
        CMPNE    R0,#+7
        BNE      ??D_IF_decode_2
//  832    {
//  833       mode = s->prev_mode;
??D_IF_decode_1:
        LDRSH    R6,[R4, #+4]
//  834    }
//  835 
//  836    if (mode == MRDTX)
//  837    {
//  838       mode = speech_mode;
//  839    }
//  840 
//  841    /* if homed: check if this frame is another homing frame */
//  842    if (s->reset_flag_old == 1)
??D_IF_decode_2:
        LDRSH    R0,[R4, #+0]
        LDR      R7,??DataTable4  ;; dhf
        CMP      R6,#+9
        LDRSHEQ  R6,[SP, #+2]
        CMP      R0,#+1
        BNE      ??D_IF_decode_3
//  843    {
//  844       /* only check until end of first subframe */
//  845       reset_flag = D_IF_homing_frame_test_first(prm, mode);
        LDR      R0,??DataTable5  ;; nb_of_param_first
        LDR      R1,[R7, +R6, LSL #+2]
        ADD      R0,R0,R6, LSL #+1
        LDRSH    R0,[R0, #+0]
        LSL      R2,R0,#+1
        ADD      R0,SP,#+8
        SWI      +284
        CMP      R0,#+0
        BNE      ??D_IF_decode_3
        LDRSH    R0,[R4, #+0]
        MOV      R10,#+1
        CMP      R0,#+0
        BEQ      ??D_IF_decode_3
//  846    }
//  847 
//  848    /* produce encoder homing frame if homed & input=decoder homing frame */
//  849    if ((reset_flag != 0) && (s->reset_flag_old != 0))
//  850    {
//  851       for (i = 0; i < L_FRAME16k; i++)
        MOV      R0,#+0
        MOV      R2,#+8
//  852       {
//  853          synth[i] = EHF_MASK;
??D_IF_decode_4:
        ADD      R1,R9,R0, LSL #+1
        STRH     R2,[R1, #+0]
//  854       }
        ADD      R0,R0,#+1
        CMP      R0,#+320
        BGE      ??D_IF_decode_5
        B        ??D_IF_decode_4
//  855    }
//  856    else
//  857    {
//  858       D_MAIN_decode(mode, prm, synth, s->decoder_state, frame_type);
??D_IF_decode_3:
        LDRB     R0,[SP, #+0]
        MOV      R2,R9
        PUSH     {R0}
        CFI CFA R13+152
        LDR      R3,[R4, #+8]
        ADD      R1,SP,#+12
        MOV      R0,R6
        _BLF     D_MAIN_decode,??D_MAIN_decode??rA
        ADD      SP,SP,#+4
        CFI CFA R13+148
//  859    }
//  860 
//  861    for (i = 0; i < L_FRAME16k; i++)   /* Delete the 2 LSBs (14-bit input) */
??D_IF_decode_5:
        MOV      R0,#+0
        MVN      R3,#+3
//  862    {
//  863       synth[i] = (Word16) (synth[i] & 0xfffC);
??D_IF_decode_6:
        ADD      R1,R9,R0, LSL #+1
        LDRSH    R2,[R1, #+0]
//  864    }
        ADD      R0,R0,#+1
        CMP      R0,#+320
        AND      R2,R3,R2
        STRH     R2,[R1, #+0]
        BLT      ??D_IF_decode_6
//  865 
//  866    /* if not homed: check whether current frame is a homing frame */
//  867    if ((s->reset_flag_old == 0) & (mode < 9))
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+0
        BNE      ??D_IF_decode_7
        CMP      R6,#+9
        BGE      ??D_IF_decode_7
//  868    {
//  869       /* check whole frame */
//  870       reset_flag = D_IF_homing_frame_test(prm, mode);
        MOV      R0,R6
        CMP      R0,#+8
        BEQ      ??D_IF_decode_8
        LDR      R1,??DataTable6  ;; nb_of_param
        ADD      R1,R1,R0, LSL #+1
        LDRSH    R1,[R1, #+0]
        LSL      R2,R1,#+1
        LDR      R1,[R7, +R0, LSL #+2]
        ADD      R0,SP,#+8
        SWI      +284
        CMP      R0,#+0
        BNE      ??D_IF_decode_9
??D_IF_decode_10:
        MOV      R10,#+1
        B        ??D_IF_decode_11
??D_IF_decode_9:
        MOV      R10,#+0
        B        ??D_IF_decode_12
??D_IF_decode_8:
        LDR      R1,[R7, #+32]
        MOV      R2,#+38
        ADD      R0,SP,#+8
        SWI      +284
        MOV      R9,R0
        LDR      R0,[R7, #+32]
        MOV      R2,#+22
        ADD      R1,R0,#+40
        ADD      R0,SP,#+48
        SWI      +284
        MOV      R10,R0
        LDR      R0,[R7, #+32]
        MOV      R2,#+22
        ADD      R1,R0,#+64
        ADD      R0,SP,#+72
        SWI      +284
        ORR      R1,R10,R9
        ORR      R9,R0,R1
        LDR      R0,[R7, #+32]
        MOV      R2,#+22
        ADD      R1,R0,#+88
        ADD      R0,SP,#+96
        SWI      +284
        ORRS     R0,R0,R9
        BNE      ??D_IF_decode_9
        B        ??D_IF_decode_10
//  871    }
//  872    /* reset decoder if current frame is a homing frame */
//  873    if (reset_flag != 0)
??D_IF_decode_7:
        CMP      R10,#+0
        BEQ      ??D_IF_decode_12
//  874    {
//  875       D_MAIN_reset(s->decoder_state, 1);
??D_IF_decode_11:
        LDR      R0,[R4, #+8]
        MOV      R1,#+1
        _BLF     D_MAIN_reset,??D_MAIN_reset??rA
//  876    }
//  877    s->reset_flag_old = reset_flag;
??D_IF_decode_12:
        STRH     R10,[R4, #+0]
//  878 
//  879    s->prev_ft = frame_type;
        LDRB     R0,[SP, #+0]
        STRH     R0,[R4, #+2]
//  880    s->prev_mode = mode;
        STRH     R6,[R4, #+4]
//  881 }
        ADD      SP,SP,#+120
        CFI CFA R13+28
        POP      {R4-R7,R9,R10,PC}
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable4:
        DC32     dhf

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     nb_of_param_first

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable6:
        DC32     nb_of_param

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??D_IF_reset??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE D_IF_reset
//  882 
//  883 /*
//  884  * D_IF_reset
//  885  *
//  886  * Parameters:
//  887  *    st                O: state struct
//  888  *
//  889  * Function:
//  890  *    Reset homing frame counter
//  891  *
//  892  * Returns:
//  893  *    void
//  894  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function D_IF_reset
        ARM
//  895 void D_IF_reset(WB_dec_if_state *st)
//  896 {
//  897    st->reset_flag_old = 1;
D_IF_reset:
        MOV      R1,#+1
        STRH     R1,[R0, #+0]
//  898    st->prev_ft = RX_SPEECH_GOOD;
        MOV      R1,#+0
        STRH     R1,[R0, #+2]
//  899    st->prev_mode = MODE_7k;   /* minimum bitrate */
        STRH     R1,[R0, #+4]
//  900 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??D_IF_init??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE D_IF_init
//  901 
//  902 /*
//  903  * D_IF_init
//  904  *
//  905  * Parameters:
//  906  *
//  907  * Function:
//  908  *    Allocates state memory and initializes state memory
//  909  *
//  910  * Returns:
//  911  *    pointer to encoder interface structure
//  912  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function D_IF_init
        ARM
//  913 void *D_IF_init( void)
//  914 {
D_IF_init:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
//  915    WB_dec_if_state *s = NULL;
//  916 
//  917    /* allocate memory */
//  918    if ((s = (WB_dec_if_state*) malloc(sizeof(WB_dec_if_state))) == NULL)
        MOV      R0,#+12
        SWI      +20
        MOVS     R4,R0
        BEQ      ??D_IF_init_0
//  919    {
//  920       return NULL;
//  921    }
//  922 
//  923    D_MAIN_init(&(s->decoder_state));
        ADD      R0,R4,#+8
        _BLF     D_MAIN_init,??D_MAIN_init??rA
//  924    if (s->decoder_state == NULL)
        LDR      R0,[R4, #+8]
        CMP      R0,#+0
        BNE      ??D_IF_init_1
//  925    {
//  926       free(s);
        MOV      R0,R4
        _BLF     free,??free??rA
//  927       return NULL;
??D_IF_init_0:
        MOV      R0,#+0
        POP      {R4,PC}
//  928    }
//  929 
//  930    D_IF_reset(s);
??D_IF_init_1:
        MOV      R0,#+1
        STRH     R0,[R4, #+0]
        MOV      R0,#+0
        STRH     R0,[R4, #+2]
        STRH     R0,[R4, #+4]
//  931 
//  932    return s;
        MOV      R0,R4
        POP      {R4,PC}          ;; return
        CFI EndBlock cfiBlock11
//  933 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??D_IF_exit??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE D_IF_exit
//  934 
//  935 /*
//  936  * D_IF_exit
//  937  *
//  938  * Parameters:
//  939  *    state             I: state structure
//  940  *
//  941  * Function:
//  942  *    The memory used for state memory is freed
//  943  *
//  944  * Returns:
//  945  *    Void
//  946  */

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function D_IF_exit
        ARM
//  947 void D_IF_exit(void *state)
//  948 {
D_IF_exit:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOV      R4,R0
//  949    WB_dec_if_state *s;
//  950 
//  951    s = (WB_dec_if_state *)state;
//  952 
//  953    /* free memory */
//  954    D_MAIN_close(&s->decoder_state);
        ADD      R0,R4,#+8
        _BLF     D_MAIN_close,??D_MAIN_close??rA
//  955    free(s);
        MOV      R0,R4
        POP      {R4,LR}          ;; Pop
        CFI R4 SameValue
        CFI ?RET R14
        CFI CFA R13+0
        _BF      free,??free??rA  ;; tailcall
        CFI EndBlock cfiBlock13
//  956    state = NULL;
//  957 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon1
        CFI NoFunction
        ARM
??D_MAIN_decode??rA:
        LDR      R12,??Subroutine7_0  ;; D_MAIN_decode
        BX       R12
        DATA
??Subroutine7_0:
        DC32     D_MAIN_decode
        CFI EndBlock cfiBlock14

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI NoFunction
        ARM
??D_MAIN_reset??rA:
        LDR      R12,??Subroutine8_0  ;; D_MAIN_reset
        BX       R12
        DATA
??Subroutine8_0:
        DC32     D_MAIN_reset
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon1
        CFI NoFunction
        ARM
??D_MAIN_init??rA:
        LDR      R12,??Subroutine9_0  ;; D_MAIN_init
        BX       R12
        DATA
??Subroutine9_0:
        DC32     D_MAIN_init
        CFI EndBlock cfiBlock16

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI NoFunction
        ARM
??free??rA:
        LDR      R12,??Subroutine10_0  ;; free
        BX       R12
        DATA
??Subroutine10_0:
        DC32     free
        CFI EndBlock cfiBlock17

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon1
        CFI NoFunction
        ARM
??D_MAIN_close??rA:
        LDR      R12,??Subroutine11_0  ;; D_MAIN_close
        BX       R12
        DATA
??Subroutine11_0:
        DC32     D_MAIN_close
        CFI EndBlock cfiBlock18

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for nb_of_param_first>`:
        DATA
        DC16 9, 14, 15, 15, 15, 19, 19, 19, 19
        DC8 0, 0

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        END
// 
// 2 452 bytes in segment CODE
//    20 bytes in segment DATA_I
//    20 bytes in segment DATA_ID
//    12 bytes in segment INITTAB
// 
// 2 364 bytes of CODE  memory (+ 100 bytes shared)
//    20 bytes of CONST memory
//    20 bytes of DATA  memory
//
//Errors: none
//Warnings: 6
