##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    14/Feb/2012  15:39:24 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDE #
#                       C\AAC_FILE (24).c                                    #
#    Command line    =  "D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACD #
#                       EC\AAC_FILE (24).c" -D NDEBUG -lC                    #
#                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\ -lA D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\ #
#                       Release\List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Player #
#                       \Player\Release\Obj\ -s9 --cpu_mode arm --endian     #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None --dlib_config "D:\Program              #
#                       Files\IAR\Embedded Workbench 4.0                     #
#                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude       #
#                       swilib.h -I "D:\Program Files\IAR\Embedded           #
#                       Workbench 4.0 Evaluation\ARM\INC\"                   #
#                       --inline_threshold=16                                #
#    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\L #
#                       ist\AAC_FILE (24).lst                                #
#    Object file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\O #
#                       bj\AAC_FILE (24).r79                                 #
#                                                                            #
#                                                                            #
##############################################################################

D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDEC\AAC_FILE (24).c
      1          /* ***** BEGIN LICENSE BLOCK *****  
      2           * Source last modified: $Id: pns.c,v 1.2 2005/03/10 17:01:56 jrecker Exp $ 
      3           *   
      4           * Portions Copyright (c) 1995-2005 RealNetworks, Inc. All Rights Reserved.  
      5           *       
      6           * The contents of this file, and the files included with this file, 
      7           * are subject to the current version of the RealNetworks Public 
      8           * Source License (the "RPSL") available at 
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed 
     10           * the file under the current version of the RealNetworks Community 
     11           * Source License (the "RCSL") available at 
     12           * http://www.helixcommunity.org/content/rcsl, in which case the RCSL 
     13           * will apply. You may also obtain the license terms directly from 
     14           * RealNetworks.  You may not use this file except in compliance with 
     15           * the RPSL or, if you have a valid RCSL with RealNetworks applicable 
     16           * to this file, the RCSL.  Please see the applicable RPSL or RCSL for 
     17           * the rights, obligations and limitations governing use of the 
     18           * contents of the file. 
     19           *   
     20           * This file is part of the Helix DNA Technology. RealNetworks is the 
     21           * developer of the Original Code and owns the copyrights in the 
     22           * portions it created. 
     23           *   
     24           * This file, and the files included with this file, is distributed 
     25           * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY 
     26           * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS 
     27           * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES 
     28           * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET 
     29           * ENJOYMENT OR NON-INFRINGEMENT. 
     30           *  
     31           * Technology Compatibility Kit Test Suite(s) Location:  
     32           *    http://www.helixcommunity.org/content/tck  
     33           *  
     34           * Contributor(s):  
     35           *   
     36           * ***** END LICENSE BLOCK ***** */  
     37          
     38          /**************************************************************************************
     39           * Fixed-point HE-AAC decoder
     40           * Jon Recker (jrecker@real.com)
     41           * February 2005
     42           *
     43           * pns.c - perceptual noise substitution
     44           **************************************************************************************/
     45          
     46          #include "coder_aac.h"
     47          #include "assembly_aac.h"
     48          extern unsigned int Get32BitVal(unsigned int *last);
     49          /**************************************************************************************
     50           * Function:    Get32BitVal
     51           *
     52           * Description: generate 32-bit unsigned random number
     53           *
     54           * Inputs:      last number calculated (seed, first time through)
     55           *
     56           * Outputs:     new number, saved in *last
     57           *
     58           * Return:      32-bit number, uniformly distributed between [0, 2^32)
     59           *
     60           * Notes:       uses simple linear congruential generator
     61           **************************************************************************************/
     62          
     63          
     64          /* pow(2, i/4.0) for i = [0,1,2,3], format = Q30 */

   \                                 In segment DATA_C, align 4, align-sorted
     65          static const int pow14[4] = { 
   \                     pow14:
   \   00000000   0000004029F8       DC32 1073741824, 1276901417, 1518500250, 1805811301
   \              1B4C9A79825A
   \              657EA26B    
     66          	0x40000000, 0x4c1bf829, 0x5a82799a, 0x6ba27e65
     67          };
     68          
     69          #define NUM_ITER_INVSQRT	4
     70          
     71          #define X0_COEF_2	0xc0000000	/* Q29: -2.0 */
     72          #define X0_OFF_2	0x60000000	/* Q29:  3.0 */
     73          #define Q26_3		0x0c000000	/* Q26:  3.0 */
     74          
     75          
     76          
     77          /**************************************************************************************
     78           * Function:    InvRootR
     79           *
     80           * Description: use Newton's method to solve for x = 1/sqrt(r)
     81           *
     82           * Inputs:      r in Q30 format, range = [0.25, 1] (normalize inputs to this range)
     83           *
     84           * Outputs:     none
     85           *
     86           * Return:      x = Q29, range = (1, 2)
     87           *
     88           * Notes:       guaranteed to converge and not overflow for any r in this range
     89           *              
     90           *              xn+1  = xn - f(xn)/f'(xn)
     91           *              f(x)  = 1/sqrt(r) - x = 0 (find root)
     92           *                    = 1/x^2 - r
     93           *              f'(x) = -2/x^3
     94           *
     95           *              so xn+1 = xn/2 * (3 - r*xn^2)
     96           *
     97           *              NUM_ITER_INVSQRT = 3, maxDiff = 1.3747e-02
     98           *              NUM_ITER_INVSQRT = 4, maxDiff = 3.9832e-04
     99           **************************************************************************************/
    100          static int InvRootR(int r)
    101          {
    102          	int i, xn, t;
    103          
    104          	/* use linear equation for initial guess
    105          	 * x0 = -2*r + 3 (so x0 always >= correct answer in range [0.25, 1))
    106          	 * xn = Q29 (at every step)
    107          	 */
    108          	xn = (MULSHIFT32(r, X0_COEF_2) << 2) + X0_OFF_2;
    109          
    110          	for (i = 0; i < NUM_ITER_INVSQRT; i++) {
    111          		t = MULSHIFT32(xn, xn);					/* Q26 = Q29*Q29 */
    112          		t = Q26_3 - (MULSHIFT32(r, t) << 2);	/* Q26 = Q26 - (Q31*Q26 << 1) */
    113          		xn = MULSHIFT32(xn, t) << (6 - 1);		/* Q29 = (Q29*Q26 << 6), and -1 for division by 2 */
    114          	}
    115          
    116          	/* clip to range (1.0, 2.0) 
    117          	 * (because of rounding, this can converge to xn slightly > 2.0 when r is near 0.25)
    118          	 */
    119          	if (xn >> 30)
    120          		xn = (1 << 30) - 1;
    121          
    122          	return xn;
    123          }
    124          
    125          
    126          
    127          /**************************************************************************************
    128           * Function:    ScaleNoiseVector
    129           *
    130           * Description: apply scaling to vector of noise coefficients for one scalefactor band
    131           *
    132           * Inputs:      unscaled coefficients
    133           *              number of coefficients in vector (one scalefactor band of coefs)
    134           *              scalefactor for this band (i.e. noise energy)
    135           *
    136           * Outputs:     nVals coefficients in Q(FBITS_OUT_DQ_OFF)
    137           *
    138           * Return:      guard bit mask (OR of abs value of all noise coefs)
    139           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    140          static int ScaleNoiseVector(int *coef, int nVals, int sf)
    141          {
   \                     ScaleNoiseVector:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   04D04DE2           SUB      SP,SP,#+4
   \   00000008   00A0A0E1           MOV      R10,R0
   \   0000000C   0190A0E1           MOV      R9,R1
    142          	int i, c, spec, energy, sq, scalef, scalei, invSqrtEnergy, z, gbMask;
    143          	
    144          	energy = 0;
   \   00000010   0000A0E3           MOV      R0,#+0
    145          	for (i = 0; i < nVals; i++) {
   \   00000014   00C0A0E3           MOV      R12,#+0
   \   00000018   010059E3           CMP      R9,#+1
   \   0000001C   050000AA           BGE      ??ScaleNoiseVector_0
   \   00000020   0000A0E3           MOV      R0,#+0
   \   00000024   F28FBDE8           POP      {R1,R4-R11,PC}
    146          		spec = coef[i];
   \                     ??ScaleNoiseVector_1:
   \   00000028   0C119AE7           LDR      R1,[R10, +R12, LSL #+2]
    147          
    148          		/* max nVals = max SFB width = 96, so energy can gain < 2^7 bits in accumulation */
    149          		sq = (spec * spec) >> 8;		/* spec*spec range = (-2^30, 2^30) */
    150          		energy += sq;
    151          	}
   \   0000002C   01C08CE2           ADD      R12,R12,#+1
   \   00000030   910103E0           MUL      R3,R1,R1
   \   00000034   430480E0           ADD      R0,R0,R3, ASR #+8
   \                     ??ScaleNoiseVector_0:
   \   00000038   09005CE1           CMP      R12,R9
   \   0000003C   F9FFFFBA           BLT      ??ScaleNoiseVector_1
    152          
    153          	/* unless nVals == 1 (or the number generator is broken...), this should not happen */
    154          	if (energy == 0)
   \   00000040   000050E3           CMP      R0,#+0
    155          		return 0;	/* coef[i] must = 0 for i = [0, nVals-1], so gbMask = 0 */
   \   00000044   0000A003           MOVEQ    R0,#+0
   \   00000048   F28FBD08           POPEQ    {R1,R4-R11,PC}
    156          
    157          	/* pow(2, sf/4) * pow(2, FBITS_OUT_DQ_OFF) */
    158          	scalef = pow14[sf & 0x3];
   \   0000004C   EC419FE5           LDR      R4,??ScaleNoiseVector_2  ;; pow14
   \   00000050   033002E2           AND      R3,R2,#0x3
   \   00000054   033194E7           LDR      R3,[R4, +R3, LSL #+2]
    159          	scalei = (sf >> 2) + FBITS_OUT_DQ_OFF;
   \   00000058   0510A0E3           MOV      R1,#+5
   \   0000005C   00308DE5           STR      R3,[SP, #+0]
   \   00000060   42E181E0           ADD      LR,R1,R2, ASR #+2
    160          
    161          	/* energy has implied factor of 2^-8 since we shifted the accumulator 
    162          	 * normalize energy to range [0.25, 1.0), calculate 1/sqrt(1), and denormalize
    163          	 *   i.e. divide input by 2^(30-z) and convert to Q30
    164          	 *        output of 1/sqrt(i) now has extra factor of 2^((30-z)/2)
    165          	 *        for energy > 0, z is an even number between 0 and 28
    166          	 * final scaling of invSqrtEnergy:
    167          	 *  2^(15 - z/2) to compensate for implicit 2^(30-z) factor in input
    168          	 *  +4 to compensate for implicit 2^-8 factor in input
    169          	 */
    170          	z = CLZ(energy) - 2;					/* energy has at least 2 leading zeros (see acc loop) */
   \   00000064   0010A0E1           MOV      R1,R0
   \   00000068   0120A0E3           MOV      R2,#+1
   \   0000006C   2138B0E1           LSRS     R3,R1,#+16
   \   00000070   1120A003           MOVEQ    R2,#+17
   \   00000074   0118A001           LSLEQ    R1,R1,#+16
   \   00000078   213CB0E1           LSRS     R3,R1,#+24
   \   0000007C   08208202           ADDEQ    R2,R2,#+8
   \   00000080   0114A001           LSLEQ    R1,R1,#+8
   \   00000084   213EB0E1           LSRS     R3,R1,#+28
   \   00000088   04208202           ADDEQ    R2,R2,#+4
   \   0000008C   0112A001           LSLEQ    R1,R1,#+4
   \   00000090   213FB0E1           LSRS     R3,R1,#+30
   \   00000094   02208202           ADDEQ    R2,R2,#+2
   \   00000098   0111A001           LSLEQ    R1,R1,#+2
   \   0000009C   A11F42E0           SUB      R1,R2,R1, LSR #+31
   \   000000A0   021041E2           SUB      R1,R1,#+2
    171          	z &= 0xfffffffe;						/* force even */
   \   000000A4   0180C1E3           BIC      R8,R1,#0x1
    172          	invSqrtEnergy = InvRootR(energy << z);	/* energy << z must be in range [0x10000000, 0x40000000] */
   \   000000A8   1028A0E1           LSL      R2,R0,R8
   \   000000AC   C23FA0E1           ASR      R3,R2,#+31
   \   000000B0   0200A0E1           MOV      R0,R2
   \   000000B4   0310A0E1           MOV      R1,R3
   \   000000B8   011FA0E1           LSL      R1,R1,#+30
   \   000000BC   201181E1           ORR      R1,R1,R0, LSR #+2
   \   000000C0   000FA0E1           LSL      R0,R0,#+30
   \   000000C4   000070E2           RSBS     R0,R0,#+0
   \   000000C8   0010E1E2           RSC      R1,R1,#+0
   \   000000CC   0100A0E1           MOV      R0,R1
   \   000000D0   6014A0E3           MOV      R1,#+1610612736
   \   000000D4   004181E0           ADD      R4,R1,R0, LSL #+2
   \   000000D8   00C0A0E3           MOV      R12,#+0
   \   000000DC   C0B6A0E3           MOV      R11,#+201326592
   \                     ??ScaleNoiseVector_3:
   \   000000E0   C45FA0E1           ASR      R5,R4,#+31
   \   000000E4   940481E0           UMULL    R0,R1,R4,R4
   \   000000E8   01C08CE2           ADD      R12,R12,#+1
   \   000000EC   941521E0           MLA      R1,R4,R5,R1
   \   000000F0   04005CE3           CMP      R12,#+4
   \   000000F4   951421E0           MLA      R1,R5,R4,R1
   \   000000F8   0160A0E1           MOV      R6,R1
   \   000000FC   C17FA0E1           ASR      R7,R1,#+31
   \   00000100   920681E0           UMULL    R0,R1,R2,R6
   \   00000104   921721E0           MLA      R1,R2,R7,R1
   \   00000108   931621E0           MLA      R1,R3,R6,R1
   \   0000010C   01014BE0           SUB      R0,R11,R1, LSL #+2
   \   00000110   C01FA0E1           ASR      R1,R0,#+31
   \   00000114   946087E0           UMULL    R6,R7,R4,R0
   \   00000118   947127E0           MLA      R7,R4,R1,R7
   \   0000011C   957027E0           MLA      R7,R5,R0,R7
   \   00000120   8742A0E1           LSL      R4,R7,#+5
   \   00000124   EDFFFFBA           BLT      ??ScaleNoiseVector_3
   \   00000128   440FB0E1           ASRS     R0,R4,#+30
   \   0000012C   C044E013           MVNNE    R4,#-1073741824
    173          	scalei -= (15 - z/2 + 4);				/* nInt = 1/sqrt(energy) in Q29 */
   \   00000130   A80F88E0           ADD      R0,R8,R8, LSR #+31
   \   00000134   C000A0E1           ASR      R0,R0,#+1
   \   00000138   130040E2           SUB      R0,R0,#+19
   \   0000013C   0E0080E0           ADD      R0,R0,LR
    174          
    175          	/* normalize for final scaling */
    176          	z = CLZ(invSqrtEnergy) - 1;
   \   00000140   0410B0E1           MOVS     R1,R4
   \   00000144   2010A003           MOVEQ    R1,#+32
   \   00000148   0D00000A           BEQ      ??ScaleNoiseVector_4
   \   0000014C   0120A0E3           MOV      R2,#+1
   \   00000150   2138B0E1           LSRS     R3,R1,#+16
   \   00000154   1120A003           MOVEQ    R2,#+17
   \   00000158   0118A001           LSLEQ    R1,R1,#+16
   \   0000015C   213CB0E1           LSRS     R3,R1,#+24
   \   00000160   08208202           ADDEQ    R2,R2,#+8
   \   00000164   0114A001           LSLEQ    R1,R1,#+8
   \   00000168   213EB0E1           LSRS     R3,R1,#+28
   \   0000016C   04208202           ADDEQ    R2,R2,#+4
   \   00000170   0112A001           LSLEQ    R1,R1,#+4
   \   00000174   213FB0E1           LSRS     R3,R1,#+30
   \   00000178   02208202           ADDEQ    R2,R2,#+2
   \   0000017C   0111A001           LSLEQ    R1,R1,#+2
   \   00000180   A11F42E0           SUB      R1,R2,R1, LSR #+31
   \                     ??ScaleNoiseVector_4:
   \   00000184   011041E2           SUB      R1,R1,#+1
    177          	invSqrtEnergy <<= z;
    178          	scalei -= (z - 3 - 2);	/* -2 for scalef, z-3 for invSqrtEnergy */
   \   00000188   010040E0           SUB      R0,R0,R1
   \   0000018C   058080E2           ADD      R8,R0,#+5
    179          	scalef = MULSHIFT32(scalef, invSqrtEnergy);	/* scalef (input) = Q30, invSqrtEnergy = Q29 * 2^z */
   \   00000190   00009DE5           LDR      R0,[SP, #+0]
   \   00000194   1411A0E1           LSL      R1,R4,R1
   \   00000198   9021C3E0           SMULL    R2,R3,R0,R1
    180          	gbMask = 0;
    181          
    182          	if (scalei < 0) {
   \   0000019C   000058E3           CMP      R8,#+0
   \   000001A0   0320A0E1           MOV      R2,R3
   \   000001A4   0030A0E3           MOV      R3,#+0
   \   000001A8   1100005A           BPL      ??ScaleNoiseVector_5
    183          		scalei = -scalei;
   \   000001AC   008068E2           RSB      R8,R8,#+0
    184          		if (scalei > 31)
   \   000001B0   200058E3           CMP      R8,#+32
    185          			scalei = 31;
   \   000001B4   1F80A0A3           MOVGE    R8,#+31
    186          		for (i = 0; i < nVals; i++) {
   \   000001B8   00C0A0E3           MOV      R12,#+0
   \                     ??ScaleNoiseVector_6:
   \   000001BC   09005CE1           CMP      R12,R9
   \   000001C0   1C0000AA           BGE      ??ScaleNoiseVector_7
    187          			c = MULSHIFT32(coef[i], scalef) >> scalei;
   \   000001C4   0C418AE0           ADD      R4,R10,R12, LSL #+2
   \   000001C8   006094E5           LDR      R6,[R4, #+0]
    188          			gbMask |= FASTABS(c);
    189          			coef[i] = c;
    190          		}
   \   000001CC   01C08CE2           ADD      R12,R12,#+1
   \   000001D0   9602C1E0           SMULL    R0,R1,R6,R2
   \   000001D4   0100A0E1           MOV      R0,R1
   \   000001D8   5008A0E1           ASR      R0,R0,R8
   \   000001DC   C01FA0E1           ASR      R1,R0,#+31
   \   000001E0   006021E0           EOR      R6,R1,R0
   \   000001E4   011046E0           SUB      R1,R6,R1
   \   000001E8   033081E1           ORR      R3,R1,R3
   \   000001EC   000084E5           STR      R0,[R4, #+0]
   \   000001F0   F1FFFFEA           B        ??ScaleNoiseVector_6
    191          	} else {
    192          		/* for scalei <= 16, no clipping possible (coef[i] is < 2^15 before scaling) 
    193          		 * for scalei > 16, just saturate exponent (rare)
    194          		 *   scalef is close to full-scale (since we normalized invSqrtEnergy)
    195          		 * remember, we are just producing noise here
    196          		 */
    197          		if (scalei > 16)
   \                     ??ScaleNoiseVector_5:
   \   000001F4   110058E3           CMP      R8,#+17
    198          			scalei = 16;
   \   000001F8   1080A0A3           MOVGE    R8,#+16
    199          		for (i = 0; i < nVals; i++) {
   \   000001FC   00C0A0E3           MOV      R12,#+0
   \   00000200   0A0000EA           B        ??ScaleNoiseVector_8
    200          			c = MULSHIFT32(coef[i] << scalei, scalef);
   \                     ??ScaleNoiseVector_9:
   \   00000204   0C418AE0           ADD      R4,R10,R12, LSL #+2
   \   00000208   000094E5           LDR      R0,[R4, #+0]
    201          			coef[i] = c;
    202          			gbMask |= FASTABS(c);
    203          		}
   \   0000020C   01C08CE2           ADD      R12,R12,#+1
   \   00000210   1068A0E1           LSL      R6,R0,R8
   \   00000214   9602C1E0           SMULL    R0,R1,R6,R2
   \   00000218   0100A0E1           MOV      R0,R1
   \   0000021C   000084E5           STR      R0,[R4, #+0]
   \   00000220   C01FA0E1           ASR      R1,R0,#+31
   \   00000224   000021E0           EOR      R0,R1,R0
   \   00000228   010040E0           SUB      R0,R0,R1
   \   0000022C   033080E1           ORR      R3,R0,R3
   \                     ??ScaleNoiseVector_8:
   \   00000230   09005CE1           CMP      R12,R9
   \   00000234   F2FFFFBA           BLT      ??ScaleNoiseVector_9
    204          	}
    205          
    206          	return gbMask;
   \                     ??ScaleNoiseVector_7:
   \   00000238   0300A0E1           MOV      R0,R3
   \   0000023C   F28FBDE8           POP      {R1,R4-R11,PC}   ;; return
   \                     ??ScaleNoiseVector_2:
   \   00000240   ........           DC32     pow14
    207          }
    208          
    209          /**************************************************************************************
    210           * Function:    GenerateNoiseVector
    211           *
    212           * Description: create vector of noise coefficients for one scalefactor band
    213           *
    214           * Inputs:      seed for number generator
    215           *              number of coefficients to generate
    216           *
    217           * Outputs:     buffer of nVals coefficients, range = [-2^15, 2^15)
    218           *              updated seed for number generator
    219           *
    220           * Return:      none
    221           **************************************************************************************/
    222          static void GenerateNoiseVector(int *coef, int *last, int nVals)
    223          {
    224          	int i;
    225          	
    226          	for (i = 0; i < nVals; i++)
    227          		coef[i] = ((signed int)Get32BitVal((unsigned int *)last)) >> 16;
    228          }
    229          
    230          /**************************************************************************************
    231           * Function:    CopyNoiseVector
    232           *
    233           * Description: copy vector of noise coefficients for one scalefactor band from L to R
    234           *
    235           * Inputs:      buffer of left coefficients
    236           *              number of coefficients to copy
    237           *
    238           * Outputs:     buffer of right coefficients
    239           *
    240           * Return:      none
    241           **************************************************************************************/
    242          static void CopyNoiseVector(int *coefL, int *coefR, int nVals)
    243          {
    244          	int i;
    245          
    246          	for (i = 0; i < nVals; i++)
    247          		coefR[i] = coefL[i];
    248          }
    249          
    250          /**************************************************************************************
    251           * Function:    PNS
    252           *
    253           * Description: apply perceptual noise substitution, if enabled (MPEG-4 only)
    254           *
    255           * Inputs:      valid AACDecInfo struct
    256           *              index of current channel
    257           *
    258           * Outputs:     shaped noise in scalefactor bands where PNS is active
    259           *              updated minimum guard bit count for this channel
    260           *
    261           * Return:      0 if successful, -1 if error
    262           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    263          int PNS(AACDecInfo *aacDecInfo, int ch)
    264          {
   \                     raac_PNS:
   \   00000000   F24F2DE9           PUSH     {R1,R4-R11,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
    265          	int gp, sfb, win, width, nSamps, gb, gbMask;
    266          	int *coef;
    267          	const short *sfbTab;
    268          	unsigned char *sfbCodeBook;
    269          	short *scaleFactors;
    270          	int msMaskOffset, checkCorr, genNew;
    271          	unsigned char msMask;
    272          	unsigned char *msMaskPtr;
    273          	PSInfoBase *psi;
    274          	ICSInfo *icsInfo;
    275          	
    276          	/* validate pointers */
    277          	if (!aacDecInfo || !aacDecInfo->psInfoBase)
   \   00000008   000050E3           CMP      R0,#+0
   \   0000000C   00409015           LDRNE    R4,[R0, #+0]
   \   00000010   00005413           CMPNE    R4,#+0
    278          		return -1;
   \   00000014   0000E003           MVNEQ    R0,#+0
   \   00000018   30D08D02           ADDEQ    SP,SP,#+48
   \   0000001C   F08FBD08           POPEQ    {R4-R11,PC}
    279          	psi = (PSInfoBase *)(aacDecInfo->psInfoBase);
    280          	icsInfo = (ch == 1 && psi->commonWin == 1) ? &(psi->icsInfo[0]) : &(psi->icsInfo[ch]);
   \   00000020   2C209DE5           LDR      R2,[SP, #+44]
   \   00000024   7C10A0E3           MOV      R1,#+124
   \   00000028   010052E3           CMP      R2,#+1
   \   0000002C   F0289405           LDREQ    R2,[R4, #+2288]
   \   00000030   801E81E3           ORR      R1,R1,#0x800
   \   00000034   01005203           CMPEQ    R2,#+1
   \   00000038   04508100           ADDEQ    R5,R1,R4
   \   0000003C   0300000A           BEQ      ??raac_PNS_0
   \   00000040   2C209DE5           LDR      R2,[SP, #+44]
   \   00000044   3A30A0E3           MOV      R3,#+58
   \   00000048   934222E0           MLA      R2,R3,R2,R4
   \   0000004C   025081E0           ADD      R5,R1,R2
    281          	
    282          	if (!psi->pnsUsed[ch])
   \                     ??raac_PNS_0:
   \   00000050   2C309DE5           LDR      R3,[SP, #+44]
   \   00000054   D72F81E2           ADD      R2,R1,#+860
   \   00000058   033184E0           ADD      R3,R4,R3, LSL #+2
   \   0000005C   032082E0           ADD      R2,R2,R3
   \   00000060   18208DE5           STR      R2,[SP, #+24]
   \   00000064   001092E5           LDR      R1,[R2, #+0]
   \   00000068   000051E3           CMP      R1,#+0
   \   0000006C   0000001A           BNE      ??raac_PNS_1
    283          		return 0;
   \                     ??raac_PNS_2:
   \   00000070   EB0000EA           B        ??raac_PNS_3
    284          	
    285          	if (icsInfo->winSequence == 2) {
   \                     ??raac_PNS_1:
   \   00000074   0110D5E5           LDRB     R1,[R5, #+1]
   \   00000078   782894E5           LDR      R2,[R4, #+2168]
   \   0000007C   020051E3           CMP      R1,#+2
   \   00000080   0600001A           BNE      ??raac_PNS_4
    286          		sfbTab = sfBandTabShort + sfBandTabShortOffset[psi->sampRateIdx];
   \   00000084   A4339FE5           LDR      R3,??raac_PNS_5  ;; raac_sfBandTabShortOffset
   \   00000088   022193E7           LDR      R2,[R3, +R2, LSL #+2]
   \   0000008C   A0339FE5           LDR      R3,??raac_PNS_5+0x4  ;; raac_sfBandTabShort
   \   00000090   822083E0           ADD      R2,R3,R2, LSL #+1
   \   00000094   04208DE5           STR      R2,[SP, #+4]
    287          		nSamps = NSAMPS_SHORT;
   \   00000098   8020A0E3           MOV      R2,#+128
   \   0000009C   050000EA           B        ??raac_PNS_6
    288          	} else {
    289          		sfbTab = sfBandTabLong + sfBandTabLongOffset[psi->sampRateIdx];
   \                     ??raac_PNS_4:
   \   000000A0   90339FE5           LDR      R3,??raac_PNS_5+0x8  ;; raac_sfBandTabLongOffset
   \   000000A4   022193E7           LDR      R2,[R3, +R2, LSL #+2]
   \   000000A8   8C339FE5           LDR      R3,??raac_PNS_5+0xC  ;; raac_sfBandTabLong
   \   000000AC   822083E0           ADD      R2,R3,R2, LSL #+1
   \   000000B0   04208DE5           STR      R2,[SP, #+4]
    290          		nSamps = NSAMPS_LONG;
   \   000000B4   402EA0E3           MOV      R2,#+1024
    291          	}
    292          	coef = psi->coef[ch];
    293          	sfbCodeBook = psi->sfbCodeBook[ch];
   \                     ??raac_PNS_6:
   \   000000B8   2C309DE5           LDR      R3,[SP, #+44]
   \   000000BC   1C208DE5           STR      R2,[SP, #+28]
   \   000000C0   2C209DE5           LDR      R2,[SP, #+44]
   \   000000C4   7870A0E3           MOV      R7,#+120
   \   000000C8   974323E0           MLA      R3,R7,R3,R4
   \   000000CC   4810A0E3           MOV      R1,#+72
   \   000000D0   401D81E3           ORR      R1,R1,#0x1000
   \   000000D4   022684E0           ADD      R2,R4,R2, LSL #+12
   \   000000D8   026081E0           ADD      R6,R1,R2
   \   000000DC   D420A0E3           MOV      R2,#+212
   \   000000E0   A02E82E3           ORR      R2,R2,#0xA00
   \   000000E4   032082E0           ADD      R2,R2,R3
   \   000000E8   08208DE5           STR      R2,[SP, #+8]
    294          	scaleFactors = psi->scaleFactors[ch];
    295          	checkCorr = (aacDecInfo->currBlockID == AAC_ID_CPE && psi->commonWin == 1 ? 1 : 0);
   \   000000EC   280090E5           LDR      R0,[R0, #+40]
   \   000000F0   010050E3           CMP      R0,#+1
   \   000000F4   F0089405           LDREQ    R0,[R4, #+2288]
   \   000000F8   01005003           CMPEQ    R0,#+1
   \   000000FC   0110A003           MOVEQ    R1,#+1
   \   00000100   0010A013           MOVNE    R1,#+0
   \   00000104   0C108DE5           STR      R1,[SP, #+12]
    296          	
    297          	gbMask = 0;
   \   00000108   0010A0E3           MOV      R1,#+0
   \   0000010C   10108DE5           STR      R1,[SP, #+16]
    298          	for (gp = 0; gp < icsInfo->numWinGroup; gp++) {
   \   00000110   00108DE5           STR      R1,[SP, #+0]
   \   00000114   3100D5E5           LDRB     R0,[R5, #+49]
   \   00000118   000050E3           CMP      R0,#+0
   \   0000011C   0B00001A           BNE      ??raac_PNS_7
    299          		for (win = 0; win < icsInfo->winGroupLen[gp]; win++) {
    300          			msMaskPtr = psi->msMaskBits + ((gp*icsInfo->maxSFB) >> 3);
    301          			msMaskOffset = ((gp*icsInfo->maxSFB) & 0x07);
    302          			msMask = (*msMaskPtr++) >> msMaskOffset;
    303          			
    304          			for (sfb = 0; sfb < icsInfo->maxSFB; sfb++) {
    305          				width = sfbTab[sfb+1] - sfbTab[sfb];
    306          				if (sfbCodeBook[sfb] == 13) {
    307          					if (ch == 0) {
    308          						/* generate new vector, copy into ch 1 if it's possible that the channels will be correlated 
    309          						 * if ch 1 has PNS enabled for this SFB but it's uncorrelated (i.e. ms_used == 0),
    310          						 *    the copied values will be overwritten when we process ch 1
    311          						 */
    312          						GenerateNoiseVector(coef, &psi->pnsLastVal, width);
    313          						if (checkCorr && psi->sfbCodeBook[1][gp*icsInfo->maxSFB + sfb] == 13)
    314          							CopyNoiseVector(coef, psi->coef[1] + (coef - psi->coef[0]), width);
    315          					} else {
    316          						/* generate new vector if no correlation between channels */
    317          						genNew = 1;
    318          						if (checkCorr && psi->sfbCodeBook[0][gp*icsInfo->maxSFB + sfb] == 13) {
    319          							if ( (psi->msMaskPresent == 1 && (msMask & 0x01)) || psi->msMaskPresent == 2 )
    320          								genNew = 0;
    321          						}
    322          						if (genNew)
    323          							GenerateNoiseVector(coef, &psi->pnsLastVal, width);
    324          					}
    325          					gbMask |= ScaleNoiseVector(coef, width, psi->scaleFactors[ch][gp*icsInfo->maxSFB + sfb]);
    326          				}
    327          				coef += width;
    328          				
    329          				/* get next mask bit (should be branchless on ARM) */
    330          				msMask >>= 1;
    331          				if (++msMaskOffset == 8) {
    332          					msMask = *msMaskPtr++;
    333          					msMaskOffset = 0;
    334          				}
    335          			}
    336          			coef += (nSamps - sfbTab[icsInfo->maxSFB]);
    337          		}
    338          		sfbCodeBook += icsInfo->maxSFB;
    339          		scaleFactors += icsInfo->maxSFB;
    340          	}
    341          	
    342          	/* update guard bit count if necessary */
    343          	gb = CLZ(gbMask) - 1;
   \                     ??raac_PNS_8:
   \   00000120   10009DE5           LDR      R0,[SP, #+16]
   \   00000124   000050E3           CMP      R0,#+0
   \   00000128   A800001A           BNE      ??raac_PNS_9
   \   0000012C   2000A0E3           MOV      R0,#+32
   \   00000130   B40000EA           B        ??raac_PNS_10
   \                     ??raac_PNS_11:
   \   00000134   0310D5E5           LDRB     R1,[R5, #+3]
   \   00000138   08209DE5           LDR      R2,[SP, #+8]
   \   0000013C   021081E0           ADD      R1,R1,R2
   \   00000140   08108DE5           STR      R1,[SP, #+8]
   \   00000144   00109DE5           LDR      R1,[SP, #+0]
   \   00000148   011081E2           ADD      R1,R1,#+1
   \   0000014C   00108DE5           STR      R1,[SP, #+0]
   \                     ??raac_PNS_7:
   \   00000150   3110D5E5           LDRB     R1,[R5, #+49]
   \   00000154   00009DE5           LDR      R0,[SP, #+0]
   \   00000158   010050E1           CMP      R0,R1
   \   0000015C   EFFFFFAA           BGE      ??raac_PNS_8
   \   00000160   0010A0E3           MOV      R1,#+0
   \   00000164   14108DE5           STR      R1,[SP, #+20]
   \   00000168   050080E0           ADD      R0,R0,R5
   \   0000016C   3200D0E5           LDRB     R0,[R0, #+50]
   \   00000170   000050E3           CMP      R0,#+0
   \   00000174   0A00001A           BNE      ??raac_PNS_12
   \   00000178   EDFFFFEA           B        ??raac_PNS_11
   \                     ??raac_PNS_13:
   \   0000017C   0310D5E5           LDRB     R1,[R5, #+3]
   \   00000180   04209DE5           LDR      R2,[SP, #+4]
   \   00000184   1C009DE5           LDR      R0,[SP, #+28]
   \   00000188   811082E0           ADD      R1,R2,R1, LSL #+1
   \   0000018C   F010D1E1           LDRSH    R1,[R1, #+0]
   \   00000190   010040E0           SUB      R0,R0,R1
   \   00000194   14109DE5           LDR      R1,[SP, #+20]
   \   00000198   006186E0           ADD      R6,R6,R0, LSL #+2
   \   0000019C   011081E2           ADD      R1,R1,#+1
   \   000001A0   14108DE5           STR      R1,[SP, #+20]
   \                     ??raac_PNS_12:
   \   000001A4   00109DE5           LDR      R1,[SP, #+0]
   \   000001A8   14009DE5           LDR      R0,[SP, #+20]
   \   000001AC   051081E0           ADD      R1,R1,R5
   \   000001B0   3210D1E5           LDRB     R1,[R1, #+50]
   \   000001B4   010050E1           CMP      R0,R1
   \   000001B8   DDFFFFAA           BGE      ??raac_PNS_11
   \   000001BC   0330D5E5           LDRB     R3,[R5, #+3]
   \   000001C0   00209DE5           LDR      R2,[SP, #+0]
   \   000001C4   C810A0E3           MOV      R1,#+200
   \   000001C8   930202E0           MUL      R2,R3,R2
   \   000001CC   B01E81E3           ORR      R1,R1,#0xB00
   \   000001D0   C22184E0           ADD      R2,R4,R2, ASR #+3
   \   000001D4   021081E0           ADD      R1,R1,R2
   \   000001D8   20108DE5           STR      R1,[SP, #+32]
   \   000001DC   0310D5E5           LDRB     R1,[R5, #+3]
   \   000001E0   00009DE5           LDR      R0,[SP, #+0]
   \   000001E4   0090A0E3           MOV      R9,#+0
   \   000001E8   910000E0           MUL      R0,R1,R0
   \   000001EC   20109DE5           LDR      R1,[SP, #+32]
   \   000001F0   077000E2           AND      R7,R0,#0x7
   \   000001F4   ........           LDRB     R2,[R1], #+1
   \   000001F8   20108DE5           STR      R1,[SP, #+32]
   \   000001FC   0300D5E5           LDRB     R0,[R5, #+3]
   \   00000200   5287A0E1           ASR      R8,R2,R7
   \   00000204   000050E3           CMP      R0,#+0
   \   00000208   2200001A           BNE      ??raac_PNS_14
   \   0000020C   DAFFFFEA           B        ??raac_PNS_13
   \                     ??raac_PNS_15:
   \   00000210   28009DE5           LDR      R0,[SP, #+40]
   \   00000214   ........           _BLF     Get32BitVal,??Get32BitVal??rA
   \   00000218   4008A0E1           ASR      R0,R0,#+16
   \   0000021C   0B0186E7           STR      R0,[R6, +R11, LSL #+2]
   \   00000220   01B08BE2           ADD      R11,R11,#+1
   \                     ??raac_PNS_16:
   \   00000224   0A005BE1           CMP      R11,R10
   \   00000228   F8FFFFBA           BLT      ??raac_PNS_15
   \                     ??raac_PNS_17:
   \   0000022C   0320D5E5           LDRB     R2,[R5, #+3]
   \   00000230   00109DE5           LDR      R1,[SP, #+0]
   \   00000234   10B09DE5           LDR      R11,[SP, #+16]
   \   00000238   929121E0           MLA      R1,R2,R1,R9
   \   0000023C   2C209DE5           LDR      R2,[SP, #+44]
   \   00000240   F030A0E3           MOV      R3,#+240
   \   00000244   934222E0           MLA      R2,R3,R2,R4
   \   00000248   F400A0E3           MOV      R0,#+244
   \   0000024C   800E80E3           ORR      R0,R0,#0x800
   \   00000250   811082E0           ADD      R1,R2,R1, LSL #+1
   \   00000254   F12090E1           LDRSH    R2,[R0, +R1]
   \   00000258   0A10A0E1           MOV      R1,R10
   \   0000025C   0600A0E1           MOV      R0,R6
   \   00000260   ........           BL       ScaleNoiseVector
   \   00000264   0B0080E1           ORR      R0,R0,R11
   \   00000268   10008DE5           STR      R0,[SP, #+16]
   \                     ??raac_PNS_18:
   \   0000026C   0A6186E0           ADD      R6,R6,R10, LSL #+2
   \   00000270   088CA0E1           LSL      R8,R8,#+24
   \   00000274   A88CA0E1           LSR      R8,R8,#+25
   \   00000278   017087E2           ADD      R7,R7,#+1
   \   0000027C   080057E3           CMP      R7,#+8
   \   00000280   0300001A           BNE      ??raac_PNS_19
   \   00000284   20109DE5           LDR      R1,[SP, #+32]
   \   00000288   0070A0E3           MOV      R7,#+0
   \   0000028C   ........           LDRB     R8,[R1], #+1
   \   00000290   20108DE5           STR      R1,[SP, #+32]
   \                     ??raac_PNS_19:
   \   00000294   019089E2           ADD      R9,R9,#+1
   \                     ??raac_PNS_14:
   \   00000298   0300D5E5           LDRB     R0,[R5, #+3]
   \   0000029C   000059E1           CMP      R9,R0
   \   000002A0   B5FFFFAA           BGE      ??raac_PNS_13
   \   000002A4   04009DE5           LDR      R0,[SP, #+4]
   \   000002A8   890080E0           ADD      R0,R0,R9, LSL #+1
   \   000002AC   F210D0E1           LDRSH    R1,[R0, #+2]
   \   000002B0   F000D0E1           LDRSH    R0,[R0, #+0]
   \   000002B4   00A041E0           SUB      R10,R1,R0
   \   000002B8   08009DE5           LDR      R0,[SP, #+8]
   \   000002BC   0000D9E7           LDRB     R0,[R9, +R0]
   \   000002C0   0D0050E3           CMP      R0,#+13
   \   000002C4   E8FFFF1A           BNE      ??raac_PNS_18
   \   000002C8   2C009DE5           LDR      R0,[SP, #+44]
   \   000002CC   000050E3           CMP      R0,#+0
   \   000002D0   2700001A           BNE      ??raac_PNS_20
   \   000002D4   BE1E84E2           ADD      R1,R4,#+3040
   \   000002D8   24108DE5           STR      R1,[SP, #+36]
   \   000002DC   00B0A0E3           MOV      R11,#+0
   \   000002E0   01005AE3           CMP      R10,#+1
   \   000002E4   050000AA           BGE      ??raac_PNS_21
   \   000002E8   060000EA           B        ??raac_PNS_22
   \                     ??raac_PNS_23:
   \   000002EC   24009DE5           LDR      R0,[SP, #+36]
   \   000002F0   ........           _BLF     Get32BitVal,??Get32BitVal??rA
   \   000002F4   4008A0E1           ASR      R0,R0,#+16
   \   000002F8   0B0186E7           STR      R0,[R6, +R11, LSL #+2]
   \   000002FC   01B08BE2           ADD      R11,R11,#+1
   \                     ??raac_PNS_21:
   \   00000300   0A005BE1           CMP      R11,R10
   \   00000304   F8FFFFBA           BLT      ??raac_PNS_23
   \                     ??raac_PNS_22:
   \   00000308   0C009DE5           LDR      R0,[SP, #+12]
   \   0000030C   000050E3           CMP      R0,#+0
   \   00000310   C5FFFF0A           BEQ      ??raac_PNS_17
   \   00000314   0310D5E5           LDRB     R1,[R5, #+3]
   \   00000318   00009DE5           LDR      R0,[SP, #+0]
   \   0000031C   919020E0           MLA      R0,R1,R0,R9
   \   00000320   040080E0           ADD      R0,R0,R4
   \   00000324   4C0BD0E5           LDRB     R0,[R0, #+2892]
   \   00000328   0D0050E3           CMP      R0,#+13
   \   0000032C   BEFFFF1A           BNE      ??raac_PNS_17
   \   00000330   4800A0E3           MOV      R0,#+72
   \   00000334   800D80E3           ORR      R0,R0,#0x2000
   \   00000338   2611A0E1           LSR      R1,R6,#+2
   \   0000033C   402D40E2           SUB      R2,R0,#+4096
   \   00000340   042082E0           ADD      R2,R2,R4
   \   00000344   221141E0           SUB      R1,R1,R2, LSR #+2
   \   00000348   011184E0           ADD      R1,R4,R1, LSL #+2
   \   0000034C   010080E0           ADD      R0,R0,R1
   \   00000350   0010A0E3           MOV      R1,#+0
   \   00000354   01005AE3           CMP      R10,#+1
   \   00000358   B3FFFFBA           BLT      ??raac_PNS_17
   \                     ??raac_PNS_24:
   \   0000035C   0A0051E1           CMP      R1,R10
   \   00000360   B1FFFFAA           BGE      ??raac_PNS_17
   \   00000364   012196E7           LDR      R2,[R6, +R1, LSL #+2]
   \   00000368   012180E7           STR      R2,[R0, +R1, LSL #+2]
   \   0000036C   011081E2           ADD      R1,R1,#+1
   \   00000370   F9FFFFEA           B        ??raac_PNS_24
   \                     ??raac_PNS_20:
   \   00000374   0C009DE5           LDR      R0,[SP, #+12]
   \   00000378   000050E3           CMP      R0,#+0
   \   0000037C   0D00000A           BEQ      ??raac_PNS_25
   \   00000380   0310D5E5           LDRB     R1,[R5, #+3]
   \   00000384   00009DE5           LDR      R0,[SP, #+0]
   \   00000388   919020E0           MLA      R0,R1,R0,R9
   \   0000038C   040080E0           ADD      R0,R0,R4
   \   00000390   D40AD0E5           LDRB     R0,[R0, #+2772]
   \   00000394   0D0050E3           CMP      R0,#+13
   \   00000398   0600001A           BNE      ??raac_PNS_25
   \   0000039C   C40B94E5           LDR      R0,[R4, #+3012]
   \   000003A0   010050E3           CMP      R0,#+1
   \   000003A4   0100001A           BNE      ??raac_PNS_26
   \   000003A8   010018E3           TST      R8,#0x1
   \   000003AC   9EFFFF1A           BNE      ??raac_PNS_17
   \                     ??raac_PNS_26:
   \   000003B0   020050E3           CMP      R0,#+2
   \   000003B4   9CFFFF0A           BEQ      ??raac_PNS_17
   \                     ??raac_PNS_25:
   \   000003B8   BE1E84E2           ADD      R1,R4,#+3040
   \   000003BC   28108DE5           STR      R1,[SP, #+40]
   \   000003C0   00B0A0E3           MOV      R11,#+0
   \   000003C4   01005AE3           CMP      R10,#+1
   \   000003C8   95FFFFAA           BGE      ??raac_PNS_16
   \   000003CC   96FFFFEA           B        ??raac_PNS_17
   \                     ??raac_PNS_9:
   \   000003D0   0110A0E3           MOV      R1,#+1
   \   000003D4   2028B0E1           LSRS     R2,R0,#+16
   \   000003D8   1110A003           MOVEQ    R1,#+17
   \   000003DC   0008A001           LSLEQ    R0,R0,#+16
   \   000003E0   202CB0E1           LSRS     R2,R0,#+24
   \   000003E4   08108102           ADDEQ    R1,R1,#+8
   \   000003E8   0004A001           LSLEQ    R0,R0,#+8
   \   000003EC   202EB0E1           LSRS     R2,R0,#+28
   \   000003F0   04108102           ADDEQ    R1,R1,#+4
   \   000003F4   0002A001           LSLEQ    R0,R0,#+4
   \   000003F8   202FB0E1           LSRS     R2,R0,#+30
   \   000003FC   02108102           ADDEQ    R1,R1,#+2
   \   00000400   0001A001           LSLEQ    R0,R0,#+2
   \   00000404   A00F41E0           SUB      R0,R1,R0, LSR #+31
    344          	if (psi->gbCurrent[ch] > gb)
   \                     ??raac_PNS_10:
   \   00000408   18109DE5           LDR      R1,[SP, #+24]
   \   0000040C   010040E2           SUB      R0,R0,#+1
   \   00000410   681491E5           LDR      R1,[R1, #+1128]
   \   00000414   010050E1           CMP      R0,R1
   \   00000418   010000AA           BGE      ??raac_PNS_3
    345          		psi->gbCurrent[ch] = gb;
   \   0000041C   18109DE5           LDR      R1,[SP, #+24]
   \   00000420   680481E5           STR      R0,[R1, #+1128]
   \                     ??raac_PNS_3:
   \   00000424   0000A0E3           MOV      R0,#+0
   \   00000428   30D08DE2           ADD      SP,SP,#+48
   \   0000042C   F08FBDE8           POP      {R4-R11,PC}
   \                     ??raac_PNS_5:
   \   00000430   ........           DC32     raac_sfBandTabShortOffset
   \   00000434   ........           DC32     raac_sfBandTabShort
   \   00000438   ........           DC32     raac_sfBandTabLongOffset
   \   0000043C   ........           DC32     raac_sfBandTabLong
    346          	
    347          	return 0;
    348          }
    349          
    350          /*
    351          static unsigned int Get32BitVal(unsigned int *last)
    352          {
    353          	//unsigned int r = *last;
    354          	/* use same coefs as MPEG reference code (classic LCG)
                 	^
Warning[Pe009]: nested comment is not allowed
    355          	 * use unsigned multiply to force reliable wraparound behavior in C (mod 2^32)
    356          	
    357          	//r =1013904223U+ (1664525U * r);
    358          
    359          	//*last =1013904223U+ (*last*1664525U);
                 	 ^
Warning[Pe009]: nested comment is not allowed
    360          
    361          	return *last;
    362          }
    363          */
                   ^
Warning[Pe001]: last line of file ends without a newline

   Maximum stack usage in bytes:

     Function         CSTACK
     --------         ------
     ScaleNoiseVector    40
     raac_PNS            84


   Segment part sizes:

     Function/Label   Bytes
     --------------   -----
     pow14              16
     ScaleNoiseVector  580
     raac_PNS         1088
      Others            20

 
 1 688 bytes in segment CODE
    16 bytes in segment DATA_C
 
 1 668 bytes of CODE  memory (+ 20 bytes shared)
    16 bytes of CONST memory

Errors: none
Warnings: 3
