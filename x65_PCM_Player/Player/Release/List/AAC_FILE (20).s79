//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   14/Feb/2012  15:39:21 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACD /
//                       EC\AAC_FILE (20).c                                  /
//    Command line    =  "D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AAC /
//                       DEC\AAC_FILE (20).c" -D NDEBUG -lC                  /
//                       D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\ -lA D:\SVN\SieELF\SieELF\x65_PCM_Player\Playe /
//                       r\Release\List\ -o D:\SVN\SieELF\SieELF\x65_PCM_Pla /
//                       yer\Player\Release\Obj\ -s9 --cpu_mode arm          /
//                       --endian little --cpu ARM926EJ-S --stack_align 4    /
//                       --interwork -e --fpu None --dlib_config             /
//                       "D:\Program Files\IAR\Embedded Workbench 4.0        /
//                       Evaluation\ARM\LIB\dl5tpainl8n.h" --preinclude      /
//                       swilib.h -I "D:\Program Files\IAR\Embedded          /
//                       Workbench 4.0 Evaluation\ARM\INC\"                  /
//                       --inline_threshold=16                               /
//    List file       =  D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\Release\ /
//                       List\AAC_FILE (20).s79                              /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME `AAC_FILE (20)`

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

??DataTable0 EQU 0
??DataTable1 EQU 0
??DataTable2 EQU 0
??DataTable3 EQU 0
        MULTWEAK ??raac_AdvanceBitstream??rA
        MULTWEAK ??raac_DecodeHuffmanScalar??rT
        MULTWEAK ??raac_DecodeSpectrumLong??rT
        MULTWEAK ??raac_DecodeSpectrumShort??rT
        MULTWEAK ??raac_GetBits??rA
        MULTWEAK ??raac_GetBitsNoAdvance??rA
        FUNCTION UnpackPairsEsc,0203H
        LOCFRAME CSTACK, 52, STACK
        FUNCTION UnpackPairsNoEsc,0203H
        LOCFRAME CSTACK, 48, STACK
        FUNCTION UnpackQuads,0203H
        LOCFRAME CSTACK, 52, STACK
        PUBLIC raac_DecodeHuffmanScalar
        FUNCTION raac_DecodeHuffmanScalar,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC raac_DecodeSpectrumLong
        FUNCTION raac_DecodeSpectrumLong,0203H
        LOCFRAME CSTACK, 48, STACK
        PUBLIC raac_DecodeSpectrumShort
        FUNCTION raac_DecodeSpectrumShort,0203H
        LOCFRAME CSTACK, 48, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
raac_AdvanceBitstream SYMBOL "raac_AdvanceBitstream"
raac_GetBits        SYMBOL "raac_GetBits"
raac_GetBitsNoAdvance SYMBOL "raac_GetBitsNoAdvance"
??raac_AdvanceBitstream??rA SYMBOL "??rA", raac_AdvanceBitstream
raac_DecodeHuffmanScalar SYMBOL "raac_DecodeHuffmanScalar"
??raac_DecodeHuffmanScalar??rT SYMBOL "??rT", raac_DecodeHuffmanScalar
raac_DecodeSpectrumLong SYMBOL "raac_DecodeSpectrumLong"
??raac_DecodeSpectrumLong??rT SYMBOL "??rT", raac_DecodeSpectrumLong
raac_DecodeSpectrumShort SYMBOL "raac_DecodeSpectrumShort"
??raac_DecodeSpectrumShort??rT SYMBOL "??rT", raac_DecodeSpectrumShort
??raac_GetBits??rA  SYMBOL "??rA", raac_GetBits
??raac_GetBitsNoAdvance??rA SYMBOL "??rA", raac_GetBitsNoAdvance

        EXTERN raac_AdvanceBitstream
        FUNCTION raac_AdvanceBitstream,0202H
        EXTERN raac_GetBits
        FUNCTION raac_GetBits,0202H
        EXTERN raac_GetBitsNoAdvance
        FUNCTION raac_GetBitsNoAdvance,0202H
        EXTERN raac_huffTabSpec
        EXTERN raac_huffTabSpecInfo
        EXTERN raac_sfBandTabLong
        EXTERN raac_sfBandTabLongOffset
        EXTERN raac_sfBandTabShort
        EXTERN raac_sfBandTabShortOffset


        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??raac_DecodeHuffmanScalar??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE raac_DecodeHuffmanScalar
// D:\SVN\SieELF\SieELF\x65_PCM_Player\Player\AAC\AACDEC\AAC_FILE (20).c
//    1 /* ***** BEGIN LICENSE BLOCK *****  
//    2  * Source last modified: $Id: huffman.c,v 1.1 2005/02/26 01:47:34 jrecker Exp $ 
//    3  *   
//    4  * Portions Copyright (c) 1995-2005 RealNetworks, Inc. All Rights Reserved.  
//    5  *       
//    6  * The contents of this file, and the files included with this file, 
//    7  * are subject to the current version of the RealNetworks Public 
//    8  * Source License (the "RPSL") available at 
//    9  * http://www.helixcommunity.org/content/rpsl unless you have licensed 
//   10  * the file under the current version of the RealNetworks Community 
//   11  * Source License (the "RCSL") available at 
//   12  * http://www.helixcommunity.org/content/rcsl, in which case the RCSL 
//   13  * will apply. You may also obtain the license terms directly from 
//   14  * RealNetworks.  You may not use this file except in compliance with 
//   15  * the RPSL or, if you have a valid RCSL with RealNetworks applicable 
//   16  * to this file, the RCSL.  Please see the applicable RPSL or RCSL for 
//   17  * the rights, obligations and limitations governing use of the 
//   18  * contents of the file. 
//   19  *   
//   20  * This file is part of the Helix DNA Technology. RealNetworks is the 
//   21  * developer of the Original Code and owns the copyrights in the 
//   22  * portions it created. 
//   23  *   
//   24  * This file, and the files included with this file, is distributed 
//   25  * and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY 
//   26  * KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS 
//   27  * ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES 
//   28  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET 
//   29  * ENJOYMENT OR NON-INFRINGEMENT. 
//   30  *  
//   31  * Technology Compatibility Kit Test Suite(s) Location:  
//   32  *    http://www.helixcommunity.org/content/tck  
//   33  *  
//   34  * Contributor(s):  
//   35  *   
//   36  * ***** END LICENSE BLOCK ***** */  
//   37 
//   38 /**************************************************************************************
//   39  * Fixed-point HE-AAC decoder
//   40  * Jon Recker (jrecker@real.com)
//   41  * February 2005
//   42  *
//   43  * huffman.c - Huffman decoding
//   44  **************************************************************************************/
//   45 
//   46 #include "coder_aac.h"
//   47 
//   48 /**************************************************************************************
//   49  * Function:    DecodeHuffmanScalar
//   50  *
//   51  * Description: decode one Huffman symbol from bitstream
//   52  *
//   53  * Inputs:      pointers to Huffman table and info struct
//   54  *              left-aligned bit buffer with >= huffTabInfo->maxBits bits
//   55  *
//   56  * Outputs:     decoded symbol in *val
//   57  *
//   58  * Return:      number of bits in symbol
//   59  *
//   60  * Notes:       assumes canonical Huffman codes:
//   61  *                first CW always 0, we have "count" CW's of length "nBits" bits
//   62  *                starting CW for codes of length nBits+1 = 
//   63  *                  (startCW[nBits] + count[nBits]) << 1
//   64  *                if there are no codes at nBits, then we just keep << 1 each time 
//   65  *                  (since count[nBits] = 0)
//   66  **************************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function raac_DecodeHuffmanScalar
        ARM
//   67 int DecodeHuffmanScalar(const signed short *huffTab, const HuffInfo *huffTabInfo, unsigned int bitBuf, signed int *val)
//   68 {
raac_DecodeHuffmanScalar:
        PUSH     {R4-R7}
        CFI R7 Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//   69     unsigned int count, start, shift, t;
//   70 	const unsigned char *countPtr;
//   71 	const signed short *map;
//   72 
//   73 	map = huffTab + huffTabInfo->offset;
        LDR      R4,[R1, #+24]
//   74 	countPtr = huffTabInfo->count;
        ADD      R12,R1,#+4
        ADD      R0,R0,R4, LSL #+1
//   75 
//   76 	start = 0;
        MOV      R4,#+0
//   77 	count = 0;
        MOV      R5,#+0
//   78 	shift = 32;
        MOV      R6,#+32
//   79 	do {
//   80 		start += count;
//   81 		start <<= 1;
??raac_DecodeHuffmanScalar_0:
        ADD      R4,R5,R4
//   82 		map += count;
        ADD      R0,R0,R5, LSL #+1
//   83 		count = *countPtr++;
        LDRB     R5,[R12], #+1
        LSL      R4,R4,#+1
//   84 		shift--;
        SUB      R6,R6,#+1
//   85 		t = (bitBuf >> shift) - start;
        RSB      R7,R4,R2, LSR R6
//   86 	} while (t >= count);
        CMP      R7,R5
        BCS      ??raac_DecodeHuffmanScalar_0
//   87 	
//   88 	*val = (signed int)map[t];
        ADD      R0,R0,R7, LSL #+1
        LDRSH    R0,[R0, #+0]
        STR      R0,[R3, #+0]
//   89 	return (countPtr - huffTabInfo->count);
        POP      {R4-R7}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI CFA R13+0
        ADD      R0,R1,#+4
        SUB      R0,R12,R0
        BX       LR               ;; return
        CFI EndBlock cfiBlock1
//   90 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        THUMB
??UnpackQuads??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock2
        REQUIRE UnpackQuads
//   91 
//   92 #define APPLY_SIGN(v, s)		{(v) ^= ((signed int)(s) >> 31); (v) -= ((signed int)(s) >> 31);}
//   93 
//   94 #define GET_QUAD_SIGNBITS(v)	(((unsigned int)(v) << 17) >> 29)	/* bits 14-12, unsigned */
//   95 #define GET_QUAD_W(v)			(((signed int)(v) << 20) >>   29)	/* bits 11-9, sign-extend */
//   96 #define GET_QUAD_X(v)			(((signed int)(v) << 23) >>   29)	/* bits  8-6, sign-extend */
//   97 #define GET_QUAD_Y(v)			(((signed int)(v) << 26) >>   29)	/* bits  5-3, sign-extend */
//   98 #define GET_QUAD_Z(v)			(((signed int)(v) << 29) >>   29)	/* bits  2-0, sign-extend */
//   99 
//  100 #define GET_PAIR_SIGNBITS(v)	(((unsigned int)(v) << 20) >> 30)	/* bits 11-10, unsigned */
//  101 #define GET_PAIR_Y(v)			(((signed int)(v) << 22) >>   27)	/* bits  9-5, sign-extend */
//  102 #define GET_PAIR_Z(v)			(((signed int)(v) << 27) >>   27)	/* bits  4-0, sign-extend */
//  103 
//  104 #define GET_ESC_SIGNBITS(v)		(((unsigned int)(v) << 18) >> 30)	/* bits 13-12, unsigned */
//  105 #define GET_ESC_Y(v)			(((signed int)(v) << 20) >>   26)	/* bits 11-6, sign-extend */
//  106 #define GET_ESC_Z(v)			(((signed int)(v) << 26) >>   26)	/* bits  5-0, sign-extend */
//  107 
//  108 /**************************************************************************************
//  109  * Function:    UnpackZeros
//  110  *
//  111  * Description: fill a section of coefficients with zeros
//  112  *
//  113  * Inputs:      number of coefficients
//  114  *
//  115  * Outputs:     nVals zeros, starting at coef
//  116  *
//  117  * Return:      none
//  118  *
//  119  * Notes:       assumes nVals is always a multiple of 4 because all scalefactor bands
//  120  *                are a multiple of 4 coefficients long
//  121  **************************************************************************************/
//  122 static void UnpackZeros(int nVals, int *coef)
//  123 {
//  124 	while (nVals > 0) {
//  125 		*coef++ = 0;
//  126 		*coef++ = 0;
//  127 		*coef++ = 0;
//  128 		*coef++ = 0;
//  129 		nVals -= 4;
//  130 	}
//  131 }
//  132 
//  133 /**************************************************************************************
//  134  * Function:    UnpackQuads
//  135  *
//  136  * Description: decode a section of 4-way vector Huffman coded coefficients
//  137  *
//  138  * Inputs       BitStreamInfo struct pointing to start of codewords for this section
//  139  *              index of Huffman codebook
//  140  *              number of coefficients
//  141  *
//  142  * Outputs:     nVals coefficients, starting at coef
//  143  *
//  144  * Return:      none
//  145  *
//  146  * Notes:       assumes nVals is always a multiple of 4 because all scalefactor bands
//  147  *                are a multiple of 4 coefficients long
//  148  **************************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon1
        CFI Function UnpackQuads
        ARM
//  149 static void UnpackQuads(BitStreamInfo *bsi, int cb, int nVals, int *coef)
//  150 {
UnpackQuads:
        PUSH     {R0,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
        MOV      R4,R2
        MOV      R5,R3
//  151 	int w, x, y, z, maxBits, nCodeBits, nSignBits, val;
//  152 	unsigned int bitBuf;
//  153 
//  154 	maxBits = huffTabSpecInfo[cb - HUFFTAB_SPEC_OFFSET].maxBits + 4;
        LDR      R3,??DataTable4  ;; raac_huffTabSpecInfo
        MOV      R2,#+28
        MLA      R1,R2,R1,R3
        SUB      SP,SP,#+12
        CFI CFA R13+52
        STR      R1,[SP, #+0]
        LDR      R1,[R1, #-28]
        CMP      R4,#+1
        ADD      R1,R1,#+4
        STR      R1,[SP, #+4]
        POPLT    {R0-R11,PC}
        RSB      R1,R1,#+32
        STRB     R1,[SP, #+8]
//  155 	while (nVals > 0) {
//  156 		/* decode quad */
//  157 		bitBuf = GetBitsNoAdvance(bsi, maxBits) << (32 - maxBits);
??UnpackQuads_0:
        LDR      R1,[SP, #+4]
        LDR      R0,[SP, #+12]
//  158 		nCodeBits = DecodeHuffmanScalar(huffTabSpec, &huffTabSpecInfo[cb - HUFFTAB_SPEC_OFFSET], bitBuf, &val);
        MOV      R6,#+0
        _BLF     raac_GetBitsNoAdvance,??raac_GetBitsNoAdvance??rA
        LDRB     R1,[SP, #+8]
        LDR      R3,??DataTable5  ;; raac_huffTabSpec
        MOV      R7,#+0
        LSL      R0,R0,R1
        LDR      R1,[SP, #+0]
        MOV      R8,#+32
        SUB      R1,R1,#+28
        LDR      R2,[R1, #+24]
        ADD      R2,R3,R2, LSL #+1
        ADD      R3,R1,#+4
??UnpackQuads_1:
        ADD      R7,R6,R7
        ADD      R2,R2,R6, LSL #+1
        LDRB     R6,[R3], #+1
        LSL      R7,R7,#+1
        SUB      R8,R8,#+1
        RSB      R9,R7,R0, LSR R8
        CMP      R9,R6
        BCS      ??UnpackQuads_1
        ADD      R2,R2,R9, LSL #+1
        LDRSH    R2,[R2, #+0]
        ADD      R1,R1,#+4
        SUB      R1,R3,R1
//  159 
//  160 		w = GET_QUAD_W(val);
        LSL      R3,R2,#+20
        ASR      R6,R3,#+29
//  161 		x = GET_QUAD_X(val);
        LSL      R3,R2,#+23
        ASR      R7,R3,#+29
//  162 		y = GET_QUAD_Y(val);
        LSL      R3,R2,#+26
        ASR      R8,R3,#+29
//  163 		z = GET_QUAD_Z(val);
        LSL      R3,R2,#+29
        ASR      R9,R3,#+29
//  164 
//  165 		bitBuf <<= nCodeBits;
        LSL      R10,R0,R1
//  166 		nSignBits = (int)GET_QUAD_SIGNBITS(val);
        LSL      R0,R2,#+17
        LSR      R11,R0,#+29
//  167 		AdvanceBitstream(bsi, nCodeBits + nSignBits);
        LDR      R0,[SP, #+12]
        ADD      R1,R11,R1
        _BLF     raac_AdvanceBitstream,??raac_AdvanceBitstream??rA
//  168 		if (nSignBits) {
        CMP      R11,#+0
        BEQ      ??UnpackQuads_2
//  169 			if (w)	{APPLY_SIGN(w, bitBuf); bitBuf <<= 1;}
        CMP      R6,#+0
        BEQ      ??UnpackQuads_3
        ASR      R0,R10,#+31
        EOR      R1,R0,R6
        SUB      R6,R1,R0
        LSL      R10,R10,#+1
//  170 			if (x)	{APPLY_SIGN(x, bitBuf); bitBuf <<= 1;}
??UnpackQuads_3:
        CMP      R7,#+0
        BEQ      ??UnpackQuads_4
        ASR      R0,R10,#+31
        EOR      R1,R0,R7
        SUB      R7,R1,R0
        LSL      R10,R10,#+1
//  171 			if (y)	{APPLY_SIGN(y, bitBuf); bitBuf <<= 1;}
??UnpackQuads_4:
        CMP      R8,#+0
        BEQ      ??UnpackQuads_5
        ASR      R0,R10,#+31
        EOR      R1,R0,R8
        SUB      R8,R1,R0
        LSL      R10,R10,#+1
//  172 			if (z)	{APPLY_SIGN(z, bitBuf); bitBuf <<= 1;}
??UnpackQuads_5:
        CMP      R9,#+0
        ASRNE    R0,R10,#+31
        EORNE    R1,R0,R9
        SUBNE    R9,R1,R0
//  173 		}
//  174 		*coef++ = w; *coef++ = x; *coef++ = y; *coef++ = z;
??UnpackQuads_2:
        STR      R6,[R5], #+4
        STR      R7,[R5], #+4
        STR      R8,[R5], #+4
        STR      R9,[R5], #+4
//  175 		nVals -= 4;
        SUB      R4,R4,#+4
//  176 	}
        CMP      R4,#+1
        BGE      ??UnpackQuads_0
//  177 }
        POP      {R0-R11,PC}      ;; return
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        THUMB
??UnpackPairsNoEsc??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock4
        REQUIRE UnpackPairsNoEsc
//  178 
//  179 /**************************************************************************************
//  180  * Function:    UnpackPairsNoEsc
//  181  *
//  182  * Description: decode a section of 2-way vector Huffman coded coefficients,
//  183  *                using non-esc tables (5 through 10)
//  184  *
//  185  * Inputs       BitStreamInfo struct pointing to start of codewords for this section
//  186  *              index of Huffman codebook (must not be the escape codebook)
//  187  *              number of coefficients
//  188  *
//  189  * Outputs:     nVals coefficients, starting at coef
//  190  *
//  191  * Return:      none
//  192  *
//  193  * Notes:       assumes nVals is always a multiple of 2 because all scalefactor bands
//  194  *                are a multiple of 4 coefficients long
//  195  **************************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon1
        CFI Function UnpackPairsNoEsc
        ARM
//  196 static void UnpackPairsNoEsc(BitStreamInfo *bsi, int cb, int nVals, int *coef)
//  197 {
UnpackPairsNoEsc:
        PUSH     {R0,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
        MOV      R4,R2
        MOV      R5,R3
//  198 	int y, z, maxBits, nCodeBits, nSignBits, val;
//  199 	unsigned int bitBuf;
//  200 
//  201 	maxBits = huffTabSpecInfo[cb - HUFFTAB_SPEC_OFFSET].maxBits + 2;
        LDR      R3,??DataTable4  ;; raac_huffTabSpecInfo
        MOV      R2,#+28
        MLA      R1,R2,R1,R3
        SUB      SP,SP,#+8
        CFI CFA R13+48
        STR      R1,[SP, #+0]
        RSB      R6,R2,#+0
        LDR      R0,[R6, +R1]
        CMP      R4,#+1
        ADD      R7,R0,#+2
        POPLT    {R0-R2,R4-R11,PC}
        MOV      R1,R7
        RSB      R1,R1,#+32
        STRB     R1,[SP, #+4]
//  202 	while (nVals > 0) {
//  203 		/* decode pair */
//  204 		bitBuf = GetBitsNoAdvance(bsi, maxBits) << (32 - maxBits);
??UnpackPairsNoEsc_0:
        LDR      R0,[SP, #+8]
        MOV      R1,R7
        _BLF     raac_GetBitsNoAdvance,??raac_GetBitsNoAdvance??rA
        LDRB     R1,[SP, #+4]
//  205 		nCodeBits = DecodeHuffmanScalar(huffTabSpec, &huffTabSpecInfo[cb-HUFFTAB_SPEC_OFFSET], bitBuf, &val);
        LDR      R3,??DataTable5  ;; raac_huffTabSpec
        MOV      R8,#+0
        LSL      R0,R0,R1
        LDR      R1,[SP, #+0]
        MOV      R9,#+0
        ADD      R1,R6,R1
        LDR      R2,[R1, #+24]
        MOV      R10,#+32
        ADD      R3,R3,R2, LSL #+1
        ADD      R2,R1,#+4
??UnpackPairsNoEsc_1:
        ADD      R9,R8,R9
        ADD      R3,R3,R8, LSL #+1
        LDRB     R8,[R2], #+1
        LSL      R9,R9,#+1
        SUB      R10,R10,#+1
        RSB      R11,R9,R0, LSR R10
        CMP      R11,R8
        BCS      ??UnpackPairsNoEsc_1
        ADD      R3,R3,R11, LSL #+1
        LDRSH    R3,[R3, #+0]
        ADD      R1,R1,#+4
        SUB      R1,R2,R1
//  206 
//  207 		y = GET_PAIR_Y(val);
        LSL      R2,R3,#+22
        ASR      R8,R2,#+27
//  208 		z = GET_PAIR_Z(val);
        LSL      R2,R3,#+27
        ASR      R9,R2,#+27
//  209 
//  210 		bitBuf <<= nCodeBits;
        LSL      R10,R0,R1
//  211 		nSignBits = GET_PAIR_SIGNBITS(val);
        LSL      R0,R3,#+20
        LSR      R11,R0,#+30
//  212 		AdvanceBitstream(bsi, nCodeBits + nSignBits);
        LDR      R0,[SP, #+8]
        ADD      R1,R11,R1
        _BLF     raac_AdvanceBitstream,??raac_AdvanceBitstream??rA
//  213 		if (nSignBits) {
        CMP      R11,#+0
        BEQ      ??UnpackPairsNoEsc_2
//  214 			if (y)	{APPLY_SIGN(y, bitBuf); bitBuf <<= 1;}
        CMP      R8,#+0
        BEQ      ??UnpackPairsNoEsc_3
        ASR      R0,R10,#+31
        EOR      R1,R0,R8
        SUB      R8,R1,R0
        LSL      R10,R10,#+1
//  215 			if (z)	{APPLY_SIGN(z, bitBuf); bitBuf <<= 1;}
??UnpackPairsNoEsc_3:
        CMP      R9,#+0
        ASRNE    R0,R10,#+31
        EORNE    R1,R0,R9
        SUBNE    R9,R1,R0
//  216 		}
//  217 		*coef++ = y; *coef++ = z;
??UnpackPairsNoEsc_2:
        STR      R8,[R5], #+4
        STR      R9,[R5], #+4
//  218 		nVals -= 2;
        SUB      R4,R4,#+2
//  219 	}
        CMP      R4,#+1
        BGE      ??UnpackPairsNoEsc_0
//  220 }
        POP      {R0-R2,R4-R11,PC}  ;; return
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??UnpackPairsEsc??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE UnpackPairsEsc
//  221 
//  222 /**************************************************************************************
//  223  * Function:    UnpackPairsEsc
//  224  *
//  225  * Description: decode a section of 2-way vector Huffman coded coefficients,
//  226  *                using esc table (11)
//  227  *
//  228  * Inputs       BitStreamInfo struct pointing to start of codewords for this section
//  229  *              index of Huffman codebook (must be the escape codebook)
//  230  *              number of coefficients
//  231  *
//  232  * Outputs:     nVals coefficients, starting at coef
//  233  *
//  234  * Return:      none
//  235  *
//  236  * Notes:       assumes nVals is always a multiple of 2 because all scalefactor bands
//  237  *                are a multiple of 4 coefficients long
//  238  **************************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function UnpackPairsEsc
        ARM
//  239 static void UnpackPairsEsc(BitStreamInfo *bsi, int cb, int nVals, int *coef)
//  240 {
UnpackPairsEsc:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        MOV      R5,R2
        MOV      R6,R3
//  241 	int y, z, maxBits, nCodeBits, nSignBits, n, val;
//  242 	unsigned int bitBuf;
//  243 
//  244 	maxBits = huffTabSpecInfo[cb - HUFFTAB_SPEC_OFFSET].maxBits + 2;
        LDR      R3,??DataTable4  ;; raac_huffTabSpecInfo
        MOV      R2,#+28
        MLA      R1,R2,R1,R3
        SUB      SP,SP,#+16
        CFI CFA R13+52
        STR      R1,[SP, #+4]
        LDR      R1,[R1, #-28]
        MOV      R4,R0
        ADD      R1,R1,#+2
        STR      R1,[SP, #+8]
        CMP      R5,#+1
        POPLT    {R0-R11,PC}
        RSB      R1,R1,#+32
        STRB     R1,[SP, #+12]
        MOV      R10,#+1
//  245 	while (nVals > 0) {
//  246 		/* decode pair with escape value */
//  247 		bitBuf = GetBitsNoAdvance(bsi, maxBits) << (32 - maxBits);
??UnpackPairsEsc_0:
        LDR      R1,[SP, #+8]
        MOV      R0,R4
        _BLF     raac_GetBitsNoAdvance,??raac_GetBitsNoAdvance??rA
        LDRB     R1,[SP, #+12]
//  248 		nCodeBits = DecodeHuffmanScalar(huffTabSpec, &huffTabSpecInfo[cb-HUFFTAB_SPEC_OFFSET], bitBuf, &val);
        LDR      R3,??DataTable5  ;; raac_huffTabSpec
        MOV      R7,#+0
        LSL      R0,R0,R1
        LDR      R1,[SP, #+4]
        MOV      R8,#+0
        SUB      R1,R1,#+28
        LDR      R2,[R1, #+24]
        MOV      R9,#+32
        ADD      R3,R3,R2, LSL #+1
        ADD      R2,R1,#+4
??UnpackPairsEsc_1:
        ADD      R8,R7,R8
        ADD      R3,R3,R7, LSL #+1
        LDRB     R7,[R2], #+1
        LSL      R8,R8,#+1
        SUB      R9,R9,#+1
        RSB      R12,R8,R0, LSR R9
        CMP      R12,R7
        BCS      ??UnpackPairsEsc_1
        ADD      R3,R3,R12, LSL #+1
        LDRSH    R3,[R3, #+0]
        ADD      R1,R1,#+4
        SUB      R1,R2,R1
//  249 
//  250 		y = GET_ESC_Y(val);
        LSL      R2,R3,#+20
        ASR      R7,R2,#+26
//  251 		z = GET_ESC_Z(val);
        LSL      R2,R3,#+26
        ASR      R8,R2,#+26
//  252 
//  253 		bitBuf <<= nCodeBits;
        LSL      R9,R0,R1
//  254 		nSignBits = GET_ESC_SIGNBITS(val);
        LSL      R2,R3,#+18
        LSR      R2,R2,#+30
        STR      R2,[SP, #+0]
//  255 		AdvanceBitstream(bsi, nCodeBits + nSignBits);
        ADD      R1,R2,R1
        MOV      R0,R4
        _BLF     raac_AdvanceBitstream,??raac_AdvanceBitstream??rA
//  256 	
//  257 		if (y == 16) {
        CMP      R7,#+16
        BNE      ??UnpackPairsEsc_2
//  258 			n = 4;
        MOV      R11,#+4
        B        ??UnpackPairsEsc_3
//  259 			while (GetBits(bsi, 1) == 1)
//  260 				n++;
??UnpackPairsEsc_4:
        ADD      R11,R11,#+1
??UnpackPairsEsc_3:
        MOV      R1,#+1
        MOV      R0,R4
        _BLF     raac_GetBits,??raac_GetBits??rA
        CMP      R0,#+1
        BEQ      ??UnpackPairsEsc_4
//  261 			y = (1 << n) + GetBits(bsi, n);
        MOV      R1,R11
        MOV      R0,R4
        _BLF     raac_GetBits,??raac_GetBits??rA
        ADD      R7,R0,R10, LSL R11
//  262 		}
//  263 		if (z == 16) {
??UnpackPairsEsc_2:
        CMP      R8,#+16
        BNE      ??UnpackPairsEsc_5
//  264 			n = 4;
        MOV      R11,#+4
        B        ??UnpackPairsEsc_6
//  265 			while (GetBits(bsi, 1) == 1)
//  266 				n++;
??UnpackPairsEsc_7:
        ADD      R11,R11,#+1
??UnpackPairsEsc_6:
        MOV      R1,#+1
        MOV      R0,R4
        _BLF     raac_GetBits,??raac_GetBits??rA
        CMP      R0,#+1
        BEQ      ??UnpackPairsEsc_7
//  267 			z = (1 << n) + GetBits(bsi, n);
        MOV      R1,R11
        MOV      R0,R4
        _BLF     raac_GetBits,??raac_GetBits??rA
        ADD      R8,R0,R10, LSL R11
//  268 		}
//  269 
//  270 		if (nSignBits) {
??UnpackPairsEsc_5:
        LDR      R0,[SP, #+0]
        CMP      R0,#+0
        BEQ      ??UnpackPairsEsc_8
//  271 			if (y)	{APPLY_SIGN(y, bitBuf); bitBuf <<= 1;}
        CMP      R7,#+0
        BEQ      ??UnpackPairsEsc_9
        ASR      R0,R9,#+31
        EOR      R1,R0,R7
        SUB      R7,R1,R0
        LSL      R9,R9,#+1
//  272 			if (z)	{APPLY_SIGN(z, bitBuf); bitBuf <<= 1;}
??UnpackPairsEsc_9:
        CMP      R8,#+0
        ASRNE    R0,R9,#+31
        EORNE    R1,R0,R8
        SUBNE    R8,R1,R0
//  273 		}
//  274 
//  275 		*coef++ = y; *coef++ = z;
??UnpackPairsEsc_8:
        STR      R7,[R6], #+4
        STR      R8,[R6], #+4
//  276 		nVals -= 2;
        SUB      R5,R5,#+2
//  277 	}
        CMP      R5,#+1
        BGE      ??UnpackPairsEsc_0
//  278 }
        POP      {R0-R11,PC}      ;; return
        CFI EndBlock cfiBlock7

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable4:
        DC32     raac_huffTabSpecInfo

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     raac_huffTabSpec

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        THUMB
??raac_DecodeSpectrumLong??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock8
        REQUIRE raac_DecodeSpectrumLong
//  279 
//  280 /**************************************************************************************
//  281  * Function:    DecodeSpectrumLong
//  282  *
//  283  * Description: decode transform coefficients for frame with one long block
//  284  *
//  285  * Inputs:      platform specific info struct
//  286  *              BitStreamInfo struct pointing to start of spectral data
//  287  *                (14496-3, table 4.4.29) 
//  288  *              index of current channel
//  289  *
//  290  * Outputs:     decoded, quantized coefficients for this channel
//  291  *
//  292  * Return:      none
//  293  *
//  294  * Notes:       adds in pulse data if present
//  295  *              fills coefficient buffer with zeros in any region not coded with
//  296  *                codebook in range [1, 11] (including sfb's above sfbMax)
//  297  **************************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function raac_DecodeSpectrumLong
        ARM
//  298 void DecodeSpectrumLong(PSInfoBase *psi, BitStreamInfo *bsi, int ch)
//  299 {
raac_DecodeSpectrumLong:
        PUSH     {R2,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
        SUB      SP,SP,#+8
        CFI CFA R13+48
        MOV      R5,R0
        MOV      R8,R1
//  300 	int i, sfb, cb, nVals, offset;
//  301 	const short *sfbTab;
//  302 	unsigned char *sfbCodeBook;
//  303 	int *coef;
//  304 	ICSInfo *icsInfo;
//  305 	PulseInfo *pi;
//  306 
//  307 	coef = psi->coef[ch];
        MOV      R1,#+72
        ORR      R1,R1,#0x1000
        ADD      R2,R5,R2, LSL #+12
        ADD      R1,R1,R2
        STR      R1,[SP, #+4]
        MOV      R4,R1
//  308 	icsInfo = (ch == 1 && psi->commonWin == 1) ? &(psi->icsInfo[0]) : &(psi->icsInfo[ch]);
        LDR      R1,[SP, #+8]
        MOV      R0,#+124
        CMP      R1,#+1
        LDREQ    R1,[R5, #+2288]
        ORR      R0,R0,#0x800
        CMPEQ    R1,#+1
        ADDEQ    R9,R0,R5
        BEQ      ??raac_DecodeSpectrumLong_0
        LDR      R1,[SP, #+8]
        MOV      R2,#+58
        MLA      R1,R2,R1,R5
        ADD      R9,R0,R1
//  309 
//  310 	/* decode long block */
//  311 	sfbTab = sfBandTabLong + sfBandTabLongOffset[psi->sampRateIdx];
??raac_DecodeSpectrumLong_0:
        LDR      R1,[R5, #+2168]
        LDR      R2,??raac_DecodeSpectrumLong_1  ;; raac_sfBandTabLongOffset
//  312 	sfbCodeBook = psi->sfbCodeBook[ch];
        ADD      R0,R0,#+600
        LDR      R1,[R2, +R1, LSL #+2]
        LDR      R2,??raac_DecodeSpectrumLong_1+0x4  ;; raac_sfBandTabLong
//  313 	for (sfb = 0; sfb < icsInfo->maxSFB; sfb++) {
        MOV      R6,#+0
        ADD      R1,R2,R1, LSL #+1
        STR      R1,[SP, #+0]
        LDR      R1,[SP, #+8]
        MOV      R2,#+120
        MLA      R1,R2,R1,R5
        MOV      R7,#+0
        ADD      R10,R0,R1
        LDRB     R0,[R9, #+3]
        CMP      R0,#+0
        BNE      ??raac_DecodeSpectrumLong_2
//  314 		cb = *sfbCodeBook++;
//  315 		nVals = sfbTab[sfb+1] - sfbTab[sfb];
//  316 		
//  317 		if (cb == 0)
//  318 			UnpackZeros(nVals, coef);
//  319 		else if (cb <= 4)
//  320 			UnpackQuads(bsi, cb, nVals, coef);
//  321 		else if (cb <= 10)
//  322 			UnpackPairsNoEsc(bsi, cb, nVals, coef);
//  323 		else if (cb == 11)
//  324 			UnpackPairsEsc(bsi, cb, nVals, coef);
//  325 		else
//  326 			UnpackZeros(nVals, coef);
//  327 
//  328 		coef += nVals;
//  329 	}
//  330 
//  331 	/* fill with zeros above maxSFB */
//  332 	nVals = NSAMPS_LONG - sfbTab[sfb];
//  333 	UnpackZeros(nVals, coef);
??raac_DecodeSpectrumLong_3:
        LDR      R0,[SP, #+0]
        ADD      R0,R0,R6, LSL #+1
        LDRSH    R0,[R0, #+0]
        RSB      R0,R0,#+1024
        CMP      R0,#+1
        BLT      ??raac_DecodeSpectrumLong_4
??raac_DecodeSpectrumLong_5:
        STR      R7,[R4], #+4
        STR      R7,[R4], #+4
        STR      R7,[R4], #+4
        STR      R7,[R4], #+4
        SUB      R0,R0,#+4
        CMP      R0,#+1
        BGE      ??raac_DecodeSpectrumLong_5
//  334 
//  335 	/* add pulse data, if present */
//  336 	pi = &psi->pulseInfo[ch];
??raac_DecodeSpectrumLong_4:
        LDR      R1,[SP, #+8]
        MOV      R2,#+11
        MLA      R1,R2,R1,R5
        MOV      R0,#+236
        ORR      R0,R0,#0xB00
        ADD      R0,R0,R1
//  337 	if (pi->pulseDataPresent) {
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        POPEQ    {R0-R2,R4-R11,PC}
//  338 		coef = psi->coef[ch];
//  339 		offset = sfbTab[pi->startSFB];
        LDRB     R1,[R0, #+2]
//  340 		for (i = 0; i < pi->numPulse; i++) {
        LDRB     R3,[R0, #+1]
        LDR      R2,[SP, #+0]
        LDR      R4,[SP, #+4]
        ADD      R1,R2,R1, LSL #+1
        LDRSH    R2,[R1, #+0]
        MOV      R1,#+0
        CMP      R3,#+0
        BNE      ??raac_DecodeSpectrumLong_6
//  341 			offset += pi->offset[i];
//  342 			if (coef[offset] > 0)
//  343 				coef[offset] += pi->amp[i];
//  344 			else
//  345 				coef[offset] -= pi->amp[i];
//  346 		}
//  347 		ASSERT(offset < NSAMPS_LONG);
//  348 	}
//  349 }
        POP      {R0-R2,R4-R11,PC}  ;; return
??raac_DecodeSpectrumLong_7:
        MOV      R0,R4
        MOV      R1,R11
        CMP      R1,#+1
        BLT      ??raac_DecodeSpectrumLong_8
??raac_DecodeSpectrumLong_9:
        STR      R7,[R0], #+4
        STR      R7,[R0], #+4
        STR      R7,[R0], #+4
        STR      R7,[R0], #+4
        SUB      R1,R1,#+4
        CMP      R1,#+1
        BGE      ??raac_DecodeSpectrumLong_9
??raac_DecodeSpectrumLong_8:
        ADD      R4,R4,R11, LSL #+2
        ADD      R6,R6,#+1
??raac_DecodeSpectrumLong_2:
        LDRB     R0,[R9, #+3]
        CMP      R6,R0
        BGE      ??raac_DecodeSpectrumLong_3
        LDR      R0,[SP, #+0]
        LDRB     R1,[R10], #+1
        ADD      R0,R0,R6, LSL #+1
        LDRSH    R2,[R0, #+2]
        LDRSH    R0,[R0, #+0]
        CMP      R1,#+0
        SUB      R11,R2,R0
        BNE      ??raac_DecodeSpectrumLong_10
        MOV      R0,R4
        MOV      R1,R11
        CMP      R1,#+1
        BLT      ??raac_DecodeSpectrumLong_8
??raac_DecodeSpectrumLong_11:
        STR      R7,[R0], #+4
        STR      R7,[R0], #+4
        STR      R7,[R0], #+4
        STR      R7,[R0], #+4
        SUB      R1,R1,#+4
        CMP      R1,#+1
        BLT      ??raac_DecodeSpectrumLong_8
        B        ??raac_DecodeSpectrumLong_11
??raac_DecodeSpectrumLong_10:
        CMP      R1,#+5
        BGE      ??raac_DecodeSpectrumLong_12
        MOV      R3,R4
        MOV      R2,R11
        MOV      R0,R8
        BL       UnpackQuads
        B        ??raac_DecodeSpectrumLong_8
??raac_DecodeSpectrumLong_12:
        CMP      R1,#+11
        BGE      ??raac_DecodeSpectrumLong_13
        MOV      R3,R4
        MOV      R2,R11
        MOV      R0,R8
        BL       UnpackPairsNoEsc
        B        ??raac_DecodeSpectrumLong_8
??raac_DecodeSpectrumLong_13:
        BNE      ??raac_DecodeSpectrumLong_7
        MOV      R3,R4
        MOV      R2,R11
        MOV      R1,#+11
        MOV      R0,R8
        BL       UnpackPairsEsc
        B        ??raac_DecodeSpectrumLong_8
??raac_DecodeSpectrumLong_14:
        STR      R5,[R3, #+0]
        ADD      R1,R1,#+1
??raac_DecodeSpectrumLong_6:
        LDRB     R3,[R0, #+1]
        CMP      R1,R3
        POPGE    {R0-R2,R4-R11,PC}
        ADD      R3,R1,R0
        LDRB     R3,[R3, #+3]
        ADD      R6,R1,R0
        LDRB     R6,[R6, #+7]
        ADD      R2,R3,R2
        ADD      R3,R4,R2, LSL #+2
        LDR      R5,[R3, #+0]
        CMP      R5,#+1
        SUBLT    R5,R5,R6
        ADDGE    R5,R6,R5
        B        ??raac_DecodeSpectrumLong_14
        DATA
??raac_DecodeSpectrumLong_1:
        DC32     raac_sfBandTabLongOffset
        DC32     raac_sfBandTabLong
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??raac_DecodeSpectrumShort??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock10
        REQUIRE raac_DecodeSpectrumShort
//  350 
//  351 /**************************************************************************************
//  352  * Function:    DecodeSpectrumShort
//  353  *
//  354  * Description: decode transform coefficients for frame with eight short blocks
//  355  *
//  356  * Inputs:      platform specific info struct
//  357  *              BitStreamInfo struct pointing to start of spectral data
//  358  *                (14496-3, table 4.4.29) 
//  359  *              index of current channel
//  360  *
//  361  * Outputs:     decoded, quantized coefficients for this channel
//  362  *
//  363  * Return:      none
//  364  *
//  365  * Notes:       fills coefficient buffer with zeros in any region not coded with
//  366  *                codebook in range [1, 11] (including sfb's above sfbMax)
//  367  *              deinterleaves window groups into 8 windows
//  368  **************************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function raac_DecodeSpectrumShort
        ARM
//  369 void DecodeSpectrumShort(PSInfoBase *psi, BitStreamInfo *bsi, int ch)
//  370 {
raac_DecodeSpectrumShort:
        PUSH     {R1,R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+40
        SUB      SP,SP,#+8
        CFI CFA R13+48
//  371 	int gp, cb, nVals, win, offset, sfb;
//  372 	const short *sfbTab;
//  373 	unsigned char *sfbCodeBook;
//  374 	int *coef;
//  375 	ICSInfo *icsInfo;
//  376 
//  377 	coef = psi->coef[ch];
        MOV      R1,#+72
        ORR      R1,R1,#0x1000
        ADD      R3,R0,R2, LSL #+12
        ADD      R5,R1,R3
//  378 	icsInfo = (ch == 1 && psi->commonWin == 1) ? &(psi->icsInfo[0]) : &(psi->icsInfo[ch]);
//  379 
//  380 	/* decode short blocks, deinterleaving in-place */
//  381 	sfbTab = sfBandTabShort + sfBandTabShortOffset[psi->sampRateIdx];
        LDR      R7,??raac_DecodeSpectrumShort_0  ;; raac_sfBandTabShortOffset
        CMP      R2,#+1
        LDREQ    R3,[R0, #+2288]
        MOV      R1,#+124
        CMPEQ    R3,#+1
        MOVNE    R3,#+58
        MLANE    R4,R3,R2,R0
        LDR      R3,[R0, #+2168]
        ORR      R1,R1,#0x800
        LDR      R3,[R7, +R3, LSL #+2]
        LDR      R7,??raac_DecodeSpectrumShort_0+0x4  ;; raac_sfBandTabShort
        ADDEQ    R4,R1,R0
        ADD      R3,R7,R3, LSL #+1
//  382 	sfbCodeBook = psi->sfbCodeBook[ch];
        MOV      R7,#+120
        MLA      R0,R7,R2,R0
        ADDNE    R4,R1,R4
        STR      R3,[SP, #+0]
        ADD      R3,R1,#+600
        ADD      R0,R3,R0
        STR      R0,[SP, #+4]
//  383 	for (gp = 0; gp < icsInfo->numWinGroup; gp++) {
        LDRB     R0,[R4, #+49]
        MOV      R7,#+0
        MOV      R10,#+0
        CMP      R0,#+0
        BNE      ??raac_DecodeSpectrumShort_1
//  384 		for (sfb = 0; sfb < icsInfo->maxSFB; sfb++) {
//  385 			nVals = sfbTab[sfb+1] - sfbTab[sfb];
//  386 			cb = *sfbCodeBook++;
//  387 
//  388 			for (win = 0; win < icsInfo->winGroupLen[gp]; win++) {
//  389 				offset = win*NSAMPS_SHORT;
//  390 				if (cb == 0)
//  391 					UnpackZeros(nVals, coef + offset);
//  392 				else if (cb <= 4)
//  393 					UnpackQuads(bsi, cb, nVals, coef + offset);
//  394 				else if (cb <= 10)
//  395 					UnpackPairsNoEsc(bsi, cb, nVals, coef + offset);
//  396 				else if (cb == 11)
//  397 					UnpackPairsEsc(bsi, cb, nVals, coef + offset);
//  398 				else 
//  399 					UnpackZeros(nVals, coef + offset);
//  400 			}
//  401 			coef += nVals;
//  402 		}
//  403 
//  404 		/* fill with zeros above maxSFB */
//  405 		for (win = 0; win < icsInfo->winGroupLen[gp]; win++) {
//  406 			offset = win*NSAMPS_SHORT;
//  407 			nVals = NSAMPS_SHORT - sfbTab[sfb];
//  408 			UnpackZeros(nVals, coef + offset);
//  409 		}
//  410 		coef += nVals;
//  411 		coef += (icsInfo->winGroupLen[gp] - 1)*NSAMPS_SHORT;
//  412 	}
//  413 
//  414 	ASSERT(coef == psi->coef[ch] + NSAMPS_LONG);
//  415 }
        POP      {R0-R2,R4-R11,PC}  ;; return
??raac_DecodeSpectrumShort_2:
        LDR      R0,[SP, #+0]
        ADD      R0,R0,R8, LSL #+1
        LDRSH    R0,[R0, #+0]
        RSB      R6,R0,#+128
        ADD      R0,R5,R9, LSL #+9
        MOV      R1,R6
        CMP      R1,#+1
        BLT      ??raac_DecodeSpectrumShort_3
??raac_DecodeSpectrumShort_4:
        STR      R10,[R0], #+4
        STR      R10,[R0], #+4
        STR      R10,[R0], #+4
        STR      R10,[R0], #+4
        SUB      R1,R1,#+4
        CMP      R1,#+1
        BGE      ??raac_DecodeSpectrumShort_4
??raac_DecodeSpectrumShort_3:
        ADD      R9,R9,#+1
??raac_DecodeSpectrumShort_5:
        ADD      R0,R7,R4
        LDRB     R0,[R0, #+50]
        CMP      R9,R0
        BLT      ??raac_DecodeSpectrumShort_2
??raac_DecodeSpectrumShort_6:
        ADD      R1,R7,R4
        LDRB     R1,[R1, #+50]
        MVN      R0,#+255
        BIC      R0,R0,#0x100
        ADD      R1,R5,R1, LSL #+9
        ADD      R1,R1,R6, LSL #+2
        ADD      R5,R0,R1
        ADD      R7,R7,#+1
??raac_DecodeSpectrumShort_1:
        LDRB     R0,[R4, #+49]
        CMP      R7,R0
        POPGE    {R0-R2,R4-R11,PC}
        LDRB     R0,[R4, #+3]
        MOV      R8,#+0
        CMP      R0,#+0
        BNE      ??raac_DecodeSpectrumShort_7
??raac_DecodeSpectrumShort_8:
        ADD      R0,R7,R4
        LDRB     R0,[R0, #+50]
        MOV      R9,#+0
        CMP      R0,#+0
        BNE      ??raac_DecodeSpectrumShort_5
        B        ??raac_DecodeSpectrumShort_6
??raac_DecodeSpectrumShort_9:
        ADD      R5,R5,R6, LSL #+2
        ADD      R8,R8,#+1
??raac_DecodeSpectrumShort_7:
        LDRB     R0,[R4, #+3]
        CMP      R8,R0
        BGE      ??raac_DecodeSpectrumShort_8
        LDR      R0,[SP, #+0]
        MOV      R9,#+0
        ADD      R0,R0,R8, LSL #+1
        LDRSH    R1,[R0, #+2]
        LDRSH    R0,[R0, #+0]
        SUB      R6,R1,R0
        LDR      R1,[SP, #+4]
        ADD      R0,R7,R4
        LDRB     R11,[R1], #+1
        STR      R1,[SP, #+4]
        LDRB     R0,[R0, #+50]
        CMP      R0,#+0
        BNE      ??raac_DecodeSpectrumShort_10
        B        ??raac_DecodeSpectrumShort_9
??raac_DecodeSpectrumShort_11:
        MOV      R0,R6
        CMP      R0,#+1
        BLT      ??raac_DecodeSpectrumShort_12
??raac_DecodeSpectrumShort_13:
        STR      R10,[R3], #+4
        STR      R10,[R3], #+4
        STR      R10,[R3], #+4
        STR      R10,[R3], #+4
        SUB      R0,R0,#+4
        CMP      R0,#+1
        BGE      ??raac_DecodeSpectrumShort_13
??raac_DecodeSpectrumShort_12:
        ADD      R9,R9,#+1
??raac_DecodeSpectrumShort_10:
        ADD      R0,R7,R4
        LDRB     R0,[R0, #+50]
        CMP      R9,R0
        BGE      ??raac_DecodeSpectrumShort_9
        LSL      R0,R9,#+7
        CMP      R11,#+0
        BNE      ??raac_DecodeSpectrumShort_14
        ADD      R0,R5,R0, LSL #+2
        MOV      R1,R6
        CMP      R1,#+1
        BLT      ??raac_DecodeSpectrumShort_12
??raac_DecodeSpectrumShort_15:
        STR      R10,[R0], #+4
        STR      R10,[R0], #+4
        STR      R10,[R0], #+4
        STR      R10,[R0], #+4
        SUB      R1,R1,#+4
        CMP      R1,#+1
        BLT      ??raac_DecodeSpectrumShort_12
        B        ??raac_DecodeSpectrumShort_15
??raac_DecodeSpectrumShort_14:
        ADD      R3,R5,R0, LSL #+2
        CMP      R11,#+5
        BGE      ??raac_DecodeSpectrumShort_16
        LDR      R0,[SP, #+8]
        MOV      R2,R6
        MOV      R1,R11
        BL       UnpackQuads
        B        ??raac_DecodeSpectrumShort_12
??raac_DecodeSpectrumShort_16:
        CMP      R11,#+11
        BGE      ??raac_DecodeSpectrumShort_17
        LDR      R0,[SP, #+8]
        MOV      R2,R6
        MOV      R1,R11
        BL       UnpackPairsNoEsc
        B        ??raac_DecodeSpectrumShort_12
??raac_DecodeSpectrumShort_17:
        BNE      ??raac_DecodeSpectrumShort_11
        LDR      R0,[SP, #+8]
        MOV      R2,R6
        MOV      R1,#+11
        BL       UnpackPairsEsc
        B        ??raac_DecodeSpectrumShort_12
        DATA
??raac_DecodeSpectrumShort_0:
        DC32     raac_sfBandTabShortOffset
        DC32     raac_sfBandTabShort
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon1
        CFI NoFunction
        ARM
??raac_GetBitsNoAdvance??rA:
        LDR      R12,??Subroutine6_0  ;; raac_GetBitsNoAdvance
        BX       R12
        DATA
??Subroutine6_0:
        DC32     raac_GetBitsNoAdvance
        CFI EndBlock cfiBlock12

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI NoFunction
        ARM
??raac_AdvanceBitstream??rA:
        LDR      R12,??Subroutine7_0  ;; raac_AdvanceBitstream
        BX       R12
        DATA
??Subroutine7_0:
        DC32     raac_AdvanceBitstream
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon1
        CFI NoFunction
        ARM
??raac_GetBits??rA:
        LDR      R12,??Subroutine8_0  ;; raac_GetBits
        BX       R12
        DATA
??Subroutine8_0:
        DC32     raac_GetBits
        CFI EndBlock cfiBlock14

        END
// 
// 2 348 bytes in segment CODE
// 
// 2 288 bytes of CODE memory (+ 60 bytes shared)
//
//Errors: none
//Warnings: none
