##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Aug/2008  18:45:28 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\polyphase.c   #
#    Command line    =  G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\polyphase.c   #
#                       -lC G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\    #
#                       -lA G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\    #
#                       -o G:\Arm\SieELF\cbn_SRC\MP3Player\Release\Obj\ -s9  #
#                       --no_unroll --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e            #
#                       --char_is_signed --fpu None -I                       #
#                       D:\ewarm_442\arm\INC\ --inline_threshold=2           #
#    List file       =  G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\polypha #
#                       se.lst                                               #
#    Object file     =  G:\Arm\SieELF\cbn_SRC\MP3Player\Release\Obj\polyphas #
#                       e.r79                                                #
#                                                                            #
#                                                                            #
##############################################################################

G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\polyphase.c
      1          /* ***** BEGIN LICENSE BLOCK *****
      2           * Version: RCSL 1.0/RPSL 1.0
      3           *
      4           * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved.
      5           *
      6           * The contents of this file, and the files included with this file, are
      7           * subject to the current version of the RealNetworks Public Source License
      8           * Version 1.0 (the "RPSL") available at
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed
     10           * the file under the RealNetworks Community Source License Version 1.0
     11           * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl,
     12           * in which case the RCSL will apply. You may also obtain the license terms
     13           * directly from RealNetworks.  You may not use this file except in
     14           * compliance with the RPSL or, if you have a valid RCSL with RealNetworks
     15           * applicable to this file, the RCSL.  Please see the applicable RPSL or
     16           * RCSL for the rights, obligations and limitations governing use of the
     17           * contents of the file.
     18           *
     19           * This file is part of the Helix DNA Technology. RealNetworks is the
     20           * developer of the Original Code and owns the copyrights in the portions
     21           * it created.
     22           *
     23           * This file, and the files included with this file, is distributed and made
     24           * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
     25           * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES,
     26           * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS
     27           * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
     28           *
     29           * Technology Compatibility Kit Test Suite(s) Location:
     30           *    http://www.helixcommunity.org/content/tck
     31           *
     32           * Contributor(s):
     33           *
     34           * ***** END LICENSE BLOCK ***** */
     35          
     36          /**************************************************************************************
     37           * Fixed-point MP3 decoder
     38           * Jon Recker (jrecker@real.com), Ken Cooke (kenc@real.com)
     39           * June 2003
     40           *
     41           * polyphase.c - final stage of subband transform (polyphase synthesis filter)
     42           *
     43           * This is the C reference version using __int64
     44           * Look in the appropriate subdirectories for optimized asm implementations
     45           *   (e.g. arm/asmpoly.s)
     46           **************************************************************************************/
     47          
     48          #include "coder.h"

  /* ***** BEGIN LICENSE BLOCK ***** 
                                    ^
"G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\coder.h",1  Warning[Pa050]: non-native
          end of line sequence detected (this diagnostic is only issued once)
     49          #include "assembly.h"
     50          
     51          /* input to Polyphase = Q(DQ_FRACBITS_OUT-2), gain 2 bits in convolution
     52           *  we also have the implicit bias of 2^15 to add back, so net fraction bits =
     53           *    DQ_FRACBITS_OUT - 2 - 2 - 15
     54           *  (see comment on Dequantize() for more info)
     55           */
     56          #define DEF_NFRACBITS	(DQ_FRACBITS_OUT - 2 - 2 - 15)
     57          #define CSHIFT	12	/* coefficients have 12 leading sign bits for early-terminating mulitplies */
     58          
     59          static  short ClipToShort(int x, int fracBits)
     60          {
     61          	int sign;
     62          
     63          	/* assumes you've already rounded (x += (1 << (fracBits-1))) */
     64          	x >>= fracBits;
     65          
     66          	/* Ken's trick: clips to [-32768, 32767] */
     67          	sign = x >> 31;
     68          	if (sign != (x >> 15))
     69          		x = sign ^ ((1 << 15) - 1);
     70          
     71          	return (short)x;
     72          }
     73          
     74          #define MC0M(x)	{ \
     75          	c1 = *coef;		coef++;		c2 = *coef;		coef++; \
     76          	vLo = *(vb1+(x));			vHi = *(vb1+(23-(x))); \
     77          	sum1L = MADD64(sum1L, vLo,  c1);	sum1L = MADD64(sum1L, vHi, -c2); \
     78          }
     79          
     80          #define MC1M(x)	{ \
     81          	c1 = *coef;		coef++; \
     82          	vLo = *(vb1+(x)); \
     83          	sum1L = MADD64(sum1L, vLo,  c1); \
     84          }
     85          
     86          #define MC2M(x)	{ \
     87          		c1 = *coef;		coef++;		c2 = *coef;		coef++; \
     88          		vLo = *(vb1+(x));	vHi = *(vb1+(23-(x))); \
     89          		sum1L = MADD64(sum1L, vLo,  c1);	sum2L = MADD64(sum2L, vLo,  c2); \
     90          		sum1L = MADD64(sum1L, vHi, -c2);	sum2L = MADD64(sum2L, vHi,  c1); \
     91          }
     92          
     93          /**************************************************************************************
     94           * Function:    PolyphaseMono
     95           *
     96           * Description: filter one subband and produce 32 output PCM samples for one channel
     97           *
     98           * Inputs:      pointer to PCM output buffer
     99           *              number of "extra shifts" (vbuf format = Q(DQ_FRACBITS_OUT-2))
    100           *              pointer to start of vbuf (preserved from last call)
    101           *              start of filter coefficient table (in proper, shuffled order)
    102           *              no minimum number of guard bits is required for input vbuf
    103           *                (see additional scaling comments below)
    104           *
    105           * Outputs:     32 samples of one channel of decoded PCM data, (i.e. Q16.0)
    106           *
    107           * Return:      none
    108           *
    109           * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
    110           *                (note max filter gain - see polyCoef[] comments)
    111           **************************************************************************************/
    112          
    113          //extern void PolyphaseMono(short *pcm, int *vbuf, const int *coefBase);
    114          /*
    115          {
    116          	int i;
    117          	const int *coef;
    118          	int *vb1;
    119          	int vLo, vHi, c1, c2;
    120          	Word64 sum1L, sum2L, rndVal;
    121          
    122          	rndVal = (Word64)( 1 << (DEF_NFRACBITS - 1 + (32 - CSHIFT)) );
    123          
    124          	///* special case, output sample 0 
                 	  ^
Warning[Pe009]: nested comment is not allowed
    125          	coef = coefBase;
    126          	vb1 = vbuf;
    127          	sum1L = rndVal;
    128          
    129          	MC0M(0)
    130          	MC0M(1)
    131          	MC0M(2)
    132          	MC0M(3)
    133          	MC0M(4)
    134          	MC0M(5)
    135          	MC0M(6)
    136          	MC0M(7)
    137          
    138          	*(pcm + 0) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
    139          
    140          	///* special case, output sample 16 
                 	  ^
Warning[Pe009]: nested comment is not allowed
    141          	coef = coefBase + 256;
    142          	vb1 = vbuf + 64*16;
    143          	sum1L = rndVal;
    144          
    145          	MC1M(0)
    146          	MC1M(1)
    147          	MC1M(2)
    148          	MC1M(3)
    149          	MC1M(4)
    150          	MC1M(5)
    151          	MC1M(6)
    152          	MC1M(7)
    153          
    154          	*(pcm + 16) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
    155          
    156          	///* main convolution loop: sum1L = samples 1, 2, 3, ... 15   sum2L = samples 31, 30, ... 17 
                 	  ^
Warning[Pe009]: nested comment is not allowed
    157          	coef = coefBase + 16;
    158          	vb1 = vbuf + 64;
    159          	pcm++;
    160          
    161          	/* right now, the compiler creates bad asm from this... 
                 	^
Warning[Pe009]: nested comment is not allowed
    162          	for (i = 15; i > 0; i--) {
    163          		sum1L = sum2L = rndVal;
    164          
    165          		MC2M(0)
    166          		MC2M(1)
    167          		MC2M(2)
    168          		MC2M(3)
    169          		MC2M(4)
    170          		MC2M(5)
    171          		MC2M(6)
    172          		MC2M(7)
    173          
    174          		vb1 += 64;
    175          		*(pcm)       = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
    176          		*(pcm + 2*i) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
    177          		pcm++;
    178          	}
    179          }
    180          
    181          #define MC0S(x)	{ \
    182          	c1 = *coef;		coef++;		c2 = *coef;		coef++; \
    183          	vLo = *(vb1+(x));		vHi = *(vb1+(23-(x))); \
    184          	sum1L = MADD64(sum1L, vLo,  c1);	sum1L = MADD64(sum1L, vHi, -c2); \
    185          	vLo = *(vb1+32+(x));	vHi = *(vb1+32+(23-(x))); \
    186          	sum1R = MADD64(sum1R, vLo,  c1);	sum1R = MADD64(sum1R, vHi, -c2); \
    187          }
    188          
    189          #define MC1S(x)	{ \
    190          	c1 = *coef;		coef++; \
    191          	vLo = *(vb1+(x)); \
    192          	sum1L = MADD64(sum1L, vLo,  c1); \
    193          	vLo = *(vb1+32+(x)); \
    194          	sum1R = MADD64(sum1R, vLo,  c1); \
    195          }
    196          
    197          #define MC2S(x)	{ \
    198          		c1 = *coef;		coef++;		c2 = *coef;		coef++; \
    199          		vLo = *(vb1+(x));	vHi = *(vb1+(23-(x))); \
    200          		sum1L = MADD64(sum1L, vLo,  c1);	sum2L = MADD64(sum2L, vLo,  c2); \
    201          		sum1L = MADD64(sum1L, vHi, -c2);	sum2L = MADD64(sum2L, vHi,  c1); \
    202          		vLo = *(vb1+32+(x));	vHi = *(vb1+32+(23-(x))); \
    203          		sum1R = MADD64(sum1R, vLo,  c1);	sum2R = MADD64(sum2R, vLo,  c2); \
    204          		sum1R = MADD64(sum1R, vHi, -c2);	sum2R = MADD64(sum2R, vHi,  c1); \
    205          }
    206          
    207          /**************************************************************************************
                 ^
Warning[Pe009]: nested comment is not allowed
    208           * Function:    PolyphaseStereo
    209           *
    210           * Description: filter one subband and produce 32 output PCM samples for each channel
    211           *
    212           * Inputs:      pointer to PCM output buffer
    213           *              number of "extra shifts" (vbuf format = Q(DQ_FRACBITS_OUT-2))
    214           *              pointer to start of vbuf (preserved from last call)
    215           *              start of filter coefficient table (in proper, shuffled order)
    216           *              no minimum number of guard bits is required for input vbuf
    217           *                (see additional scaling comments below)
    218           *
    219           * Outputs:     32 samples of two channels of decoded PCM data, (i.e. Q16.0)
    220           *
    221           * Return:      none
    222           *
    223           * Notes:       interleaves PCM samples LRLRLR...
    224           *
    225           * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
    226           **************************************************************************************/
    227          //extern void PolyphaseStereo(short *pcm, int *vbuf, const int *coefBase);
    228          /*
    229          {
    230          	int i;
    231          	const int *coef;
    232          	int *vb1;
    233          	int vLo, vHi, c1, c2;
    234          	Word64 sum1L, sum2L, sum1R, sum2R, rndVal;
    235          
    236          	rndVal = (Word64)( 1 << (DEF_NFRACBITS - 1 + (32 - CSHIFT)) );
    237          
    238          	/* special case, output sample 0 
                 	^
Warning[Pe009]: nested comment is not allowed
    239          	coef = coefBase;
    240          	vb1 = vbuf;
    241          	sum1L = sum1R = rndVal;
    242          
    243          	MC0S(0)
    244          	MC0S(1)
    245          	MC0S(2)
    246          	MC0S(3)
    247          	MC0S(4)
    248          	MC0S(5)
    249          	MC0S(6)
    250          	MC0S(7)
    251          
    252          	*(pcm + 0) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
    253          	*(pcm + 1) = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
    254          
    255          	/* special case, output sample 16 
                 	^
Warning[Pe009]: nested comment is not allowed
    256          	coef = coefBase + 256;
    257          	vb1 = vbuf + 64*16;
    258          	sum1L = sum1R = rndVal;
    259          
    260          	MC1S(0)
    261          	MC1S(1)
    262          	MC1S(2)
    263          	MC1S(3)
    264          	MC1S(4)
    265          	MC1S(5)
    266          	MC1S(6)
    267          	MC1S(7)
    268          
    269          	*(pcm + 2*16 + 0) = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
    270          	*(pcm + 2*16 + 1) = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
    271          
    272          	/* main convolution loop: sum1L = samples 1, 2, 3, ... 15   sum2L = samples 31, 30, ... 17 
                 	^
Warning[Pe009]: nested comment is not allowed
    273          	coef = coefBase + 16;
    274          	vb1 = vbuf + 64;
    275          	pcm += 2;
    276          
    277          	/* right now, the compiler creates bad asm from this... 
                 	^
Warning[Pe009]: nested comment is not allowed
    278          	for (i = 15; i > 0; i--) {
    279          		sum1L = sum2L = rndVal;
    280          		sum1R = sum2R = rndVal;
    281          
    282          		MC2S(0)
    283          		MC2S(1)
    284          		MC2S(2)
    285          		MC2S(3)
    286          		MC2S(4)
    287          		MC2S(5)
    288          		MC2S(6)
    289          		MC2S(7)
    290          
    291          		vb1 += 64;
    292          		*(pcm + 0)         = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
    293          		*(pcm + 1)         = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
    294          		*(pcm + 2*2*i + 0) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
    295          		*(pcm + 2*2*i + 1) = ClipToShort((int)SAR64(sum2R, (32-CSHIFT)), DEF_NFRACBITS);
    296          		pcm += 2;
    297          	}
    298          }
    299          */
                   ^
Warning[Pe001]: last line of file ends without a newline

  static  short ClipToShort(int x, int fracBits)
                ^
"G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\polyphase.c",59  Warning[Pe177]: 
          function "ClipToShort" was declared but never referenced


   Segment part sizes:

     Function/Label Bytes
     -------------- -----

 
 
 0 bytes of memory

Errors: none
Warnings: 12
