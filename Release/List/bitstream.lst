##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Aug/2008  18:45:19 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\bitstream.c   #
#    Command line    =  G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\bitstream.c   #
#                       -lC G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\    #
#                       -lA G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\    #
#                       -o G:\Arm\SieELF\cbn_SRC\MP3Player\Release\Obj\ -s9  #
#                       --no_unroll --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e            #
#                       --char_is_signed --fpu None -I                       #
#                       D:\ewarm_442\arm\INC\ --inline_threshold=2           #
#    List file       =  G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\bitstre #
#                       am.lst                                               #
#    Object file     =  G:\Arm\SieELF\cbn_SRC\MP3Player\Release\Obj\bitstrea #
#                       m.r79                                                #
#                                                                            #
#                                                                            #
##############################################################################

G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\bitstream.c
      1          /* ***** BEGIN LICENSE BLOCK *****
                                                  ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * Version: RCSL 1.0/RPSL 1.0
      3           *
      4           * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved.
      5           *
      6           * The contents of this file, and the files included with this file, are
      7           * subject to the current version of the RealNetworks Public Source License
      8           * Version 1.0 (the "RPSL") available at
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed
     10           * the file under the RealNetworks Community Source License Version 1.0
     11           * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl,
     12           * in which case the RCSL will apply. You may also obtain the license terms
     13           * directly from RealNetworks.  You may not use this file except in
     14           * compliance with the RPSL or, if you have a valid RCSL with RealNetworks
     15           * applicable to this file, the RCSL.  Please see the applicable RPSL or
     16           * RCSL for the rights, obligations and limitations governing use of the
     17           * contents of the file.
     18           *
     19           * This file is part of the Helix DNA Technology. RealNetworks is the
     20           * developer of the Original Code and owns the copyrights in the portions
     21           * it created.
     22           *
     23           * This file, and the files included with this file, is distributed and made
     24           * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
     25           * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES,
     26           * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS
     27           * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
     28           *
     29           * Technology Compatibility Kit Test Suite(s) Location:
     30           *    http://www.helixcommunity.org/content/tck
     31           *
     32           * Contributor(s):
     33           *
     34           * ***** END LICENSE BLOCK ***** */
     35          
     36          /**************************************************************************************
     37           * Fixed-point MP3 decoder
     38           * Jon Recker (jrecker@real.com), Ken Cooke (kenc@real.com)
     39           * June 2003
     40           *
     41           * bitstream.c - bitstream unpacking, frame header parsing, side info parsing
     42           **************************************************************************************/
     43          
     44          #include "coder.h"
     45          #include "assembly.h"
     46          
     47          /**************************************************************************************
     48           * Function:    SetBitstreamPointer
     49           *
     50           * Description: initialize bitstream reader
     51           *
     52           * Inputs:      pointer to BitStreamInfo struct
     53           *              number of bytes in bitstream
     54           *              pointer to byte-aligned buffer of data to read from
     55           *
     56           * Outputs:     filled bitstream info struct
     57           *
     58           * Return:      none
     59           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     60          void SetBitstreamPointer(BitStreamInfo *bsi, int nBytes, unsigned char *buf)
     61          {
     62          	/* init bitstream */
     63          	bsi->bytePtr = buf;
   \                     xmp3_SetBitstreamPointer:
   \   00000000   002080E5           STR      R2,[R0, #+0]
     64          	bsi->iCache = 0;		/* 4-byte unsigned int */
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   042080E5           STR      R2,[R0, #+4]
     65          	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
   \   0000000C   082080E5           STR      R2,[R0, #+8]
     66          	bsi->nBytes = nBytes;
   \   00000010   0C1080E5           STR      R1,[R0, #+12]
     67          }
   \   00000014   1EFF2FE1           BX       LR               ;; return
     68          
     69          /**************************************************************************************
     70           * Function:    RefillBitstreamCache
     71           *
     72           * Description: read new data from bitstream buffer into bsi cache
     73           *
     74           * Inputs:      pointer to initialized BitStreamInfo struct
     75           *
     76           * Outputs:     updated bitstream info struct
     77           *
     78           * Return:      none
     79           *
     80           * Notes:       only call when iCache is completely drained (resets bitOffset to 0)
     81           *              always loads 4 new bytes except when bsi->nBytes < 4 (end of buffer)
     82           *              stores data as big-endian in cache, regardless of machine endian-ness
     83           *
     84           * TODO:        optimize for ARM
     85           *              possibly add little/big-endian modes for doing 32-bit loads
     86           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     87          static  void RefillBitstreamCache(BitStreamInfo *bsi)
     88          {
   \                     RefillBitstreamCache:
   \   00000000   10002DE9           PUSH     {R4}
     89          	int nBytes = bsi->nBytes;
   \   00000004   0C1090E5           LDR      R1,[R0, #+12]
   \   00000008   0130A0E1           MOV      R3,R1
     90          
     91          	/* optimize for common case, independent of machine endian-ness */
     92          	if (nBytes >= 4) {
   \   0000000C   040053E3           CMP      R3,#+4
   \   00000010   1C0000BA           BLT      ??RefillBitstreamCache_0
     93          		bsi->iCache  = (*bsi->bytePtr++) << 24;
   \   00000014   002090E5           LDR      R2,[R0, #+0]
     94          		bsi->iCache |= (*bsi->bytePtr++) << 16;
     95          		bsi->iCache |= (*bsi->bytePtr++) <<  8;
     96          		bsi->iCache |= (*bsi->bytePtr++);
     97          		bsi->cachedBits = 32;
     98          		bsi->nBytes -= 4;
   \   00000018   041041E2           SUB      R1,R1,#+4
   \   0000001C   013082E2           ADD      R3,R2,#+1
   \   00000020   003080E5           STR      R3,[R0, #+0]
   \   00000024   0020D2E5           LDRB     R2,[R2, #+0]
   \   00000028   022CA0E1           LSL      R2,R2,#+24
   \   0000002C   042080E5           STR      R2,[R0, #+4]
   \   00000030   0320A0E1           MOV      R2,R3
   \   00000034   013082E2           ADD      R3,R2,#+1
   \   00000038   003080E5           STR      R3,[R0, #+0]
   \   0000003C   0020D2E5           LDRB     R2,[R2, #+0]
   \   00000040   043090E5           LDR      R3,[R0, #+4]
   \   00000044   022883E1           ORR      R2,R3,R2, LSL #+16
   \   00000048   042080E5           STR      R2,[R0, #+4]
   \   0000004C   003090E5           LDR      R3,[R0, #+0]
   \   00000050   01C083E2           ADD      R12,R3,#+1
   \   00000054   00C080E5           STR      R12,[R0, #+0]
   \   00000058   0030D3E5           LDRB     R3,[R3, #+0]
   \   0000005C   032482E1           ORR      R2,R2,R3, LSL #+8
   \   00000060   042080E5           STR      R2,[R0, #+4]
   \   00000064   0C30A0E1           MOV      R3,R12
   \   00000068   01C083E2           ADD      R12,R3,#+1
   \   0000006C   00C080E5           STR      R12,[R0, #+0]
   \   00000070   0030D3E5           LDRB     R3,[R3, #+0]
   \   00000074   022083E1           ORR      R2,R3,R2
   \   00000078   042080E5           STR      R2,[R0, #+4]
   \   0000007C   2030A0E3           MOV      R3,#+32
   \   00000080   0C1080E5           STR      R1,[R0, #+12]
   \   00000084   160000EA           B        ??RefillBitstreamCache_1
     99          	} else {
    100          		bsi->iCache = 0;
   \                     ??RefillBitstreamCache_0:
   \   00000088   0020A0E3           MOV      R2,#+0
   \   0000008C   042080E5           STR      R2,[R0, #+4]
   \   00000090   070000EA           B        ??RefillBitstreamCache_2
    101          		while (nBytes--) {
    102          			bsi->iCache |= (*bsi->bytePtr++);
   \                     ??RefillBitstreamCache_3:
   \   00000094   00C090E5           LDR      R12,[R0, #+0]
   \   00000098   01408CE2           ADD      R4,R12,#+1
   \   0000009C   004080E5           STR      R4,[R0, #+0]
    103          			bsi->iCache <<= 8;
   \   000000A0   00C0DCE5           LDRB     R12,[R12, #+0]
   \   000000A4   044090E5           LDR      R4,[R0, #+4]
   \   000000A8   04408CE1           ORR      R4,R12,R4
   \   000000AC   0444A0E1           LSL      R4,R4,#+8
   \   000000B0   044080E5           STR      R4,[R0, #+4]
    104          		}
   \                     ??RefillBitstreamCache_2:
   \   000000B4   03C0A0E1           MOV      R12,R3
   \   000000B8   01304CE2           SUB      R3,R12,#+1
   \   000000BC   00005CE3           CMP      R12,#+0
   \   000000C0   F3FFFF1A           BNE      ??RefillBitstreamCache_3
    105          		bsi->iCache <<= ((3 - bsi->nBytes)*8);
   \   000000C4   043090E5           LDR      R3,[R0, #+4]
   \   000000C8   0140A0E1           MOV      R4,R1
   \   000000CC   034064E2           RSB      R4,R4,#+3
   \   000000D0   8441A0E1           LSL      R4,R4,#+3
   \   000000D4   1334A0E1           LSL      R3,R3,R4
   \   000000D8   043080E5           STR      R3,[R0, #+4]
    106          		bsi->cachedBits = 8*bsi->nBytes;
   \   000000DC   8131A0E1           LSL      R3,R1,#+3
    107          		bsi->nBytes = 0;
   \   000000E0   0C2080E5           STR      R2,[R0, #+12]
   \                     ??RefillBitstreamCache_1:
   \   000000E4   083080E5           STR      R3,[R0, #+8]
    108          	}
    109          }
   \   000000E8   1000BDE8           POP      {R4}
   \   000000EC   1EFF2FE1           BX       LR               ;; return
    110          
    111          /**************************************************************************************
    112           * Function:    GetBits
    113           *
    114           * Description: get bits from bitstream, advance bitstream pointer
    115           *
    116           * Inputs:      pointer to initialized BitStreamInfo struct
    117           *              number of bits to get from bitstream
    118           *
    119           * Outputs:     updated bitstream info struct
    120           *
    121           * Return:      the next nBits bits of data from bitstream buffer
    122           *
    123           * Notes:       nBits must be in range [0, 31], nBits outside this range masked by 0x1f
    124           *              for speed, does not indicate error if you overrun bit buffer
    125           *              if nBits = 0, returns 0 (useful for scalefactor unpacking)
    126           *
    127           * TODO:        optimize for ARM
    128           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    129          unsigned int GetBits(BitStreamInfo *bsi, int nBits)
    130          {
   \                     xmp3_GetBits:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040A0E1           MOV      R4,R0
    131          	unsigned int data, lowBits;
    132          
    133          	nBits &= 0x1f;							/* nBits mod 32 to avoid unpredictable results like >> by negative amount */
   \   00000008   1F0001E2           AND      R0,R1,#0x1F
    134          	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
    135          	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
   \   0000000C   041094E5           LDR      R1,[R4, #+4]
   \   00000010   0020A0E1           MOV      R2,R0
   \   00000014   1F2062E2           RSB      R2,R2,#+31
   \   00000018   3122A0E1           LSR      R2,R1,R2
    136          	bsi->iCache <<= nBits;					/* left-justify cache */
   \   0000001C   1110A0E1           LSL      R1,R1,R0
   \   00000020   041084E5           STR      R1,[R4, #+4]
    137          	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
   \   00000024   081094E5           LDR      R1,[R4, #+8]
   \   00000028   A250A0E1           LSR      R5,R2,#+1
   \   0000002C   000051E0           SUBS     R0,R1,R0
   \   00000030   080084E5           STR      R0,[R4, #+8]
    138          
    139          	/* if we cross an int boundary, refill the cache */
    140          	if (bsi->cachedBits < 0) {
   \   00000034   0B00005A           BPL      ??xmp3_GetBits_0
    141          		lowBits = -bsi->cachedBits;
   \   00000038   006060E2           RSB      R6,R0,#+0
    142          		RefillBitstreamCache(bsi);
   \   0000003C   0400A0E1           MOV      R0,R4
   \   00000040   ........           BL       RefillBitstreamCache
    143          		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
   \   00000044   040094E5           LDR      R0,[R4, #+4]
   \   00000048   0610A0E1           MOV      R1,R6
   \   0000004C   201061E2           RSB      R1,R1,#+32
   \   00000050   305185E1           ORR      R5,R5,R0, LSR R1
    144          
    145          		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
   \   00000054   081094E5           LDR      R1,[R4, #+8]
    146          		bsi->iCache <<= lowBits;			/* left-justify cache */
   \   00000058   1006A0E1           LSL      R0,R0,R6
   \   0000005C   061041E0           SUB      R1,R1,R6
   \   00000060   081084E5           STR      R1,[R4, #+8]
   \   00000064   040084E5           STR      R0,[R4, #+4]
    147          	}
    148          
    149          	return data;
   \                     ??xmp3_GetBits_0:
   \   00000068   0500A0E1           MOV      R0,R5
   \   0000006C   7080BDE8           POP      {R4-R6,PC}       ;; return
    150          }
    151          
    152          /**************************************************************************************
    153           * Function:    CalcBitsUsed
    154           *
    155           * Description: calculate how many bits have been read from bitstream
    156           *
    157           * Inputs:      pointer to initialized BitStreamInfo struct
    158           *              pointer to start of bitstream buffer
    159           *              bit offset into first byte of startBuf (0-7)
    160           *
    161           * Outputs:     none
    162           *
    163           * Return:      number of bits read from bitstream, as offset from startBuf:startOffset
    164           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    165          int CalcBitsUsed(BitStreamInfo *bsi, unsigned char *startBuf, int startOffset)
    166          {
    167          	int bitsUsed;
    168          
    169          	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
    170          	bitsUsed -= bsi->cachedBits;
    171          	bitsUsed -= startOffset;
    172          
    173          	return bitsUsed;
   \                     xmp3_CalcBitsUsed:
   \   00000000   003090E5           LDR      R3,[R0, #+0]
   \   00000004   080090E5           LDR      R0,[R0, #+8]
   \   00000008   011043E0           SUB      R1,R3,R1
   \   0000000C   810160E0           RSB      R0,R0,R1, LSL #+3
   \   00000010   020040E0           SUB      R0,R0,R2
   \   00000014   1EFF2FE1           BX       LR               ;; return
    174          }
    175          
    176          /**************************************************************************************
    177           * Function:    CheckPadBit
    178           *
    179           * Description: check whether padding byte is present in an MP3 frame
    180           *
    181           * Inputs:      MP3DecInfo struct with valid FrameHeader struct
    182           *                (filled by UnpackFrameHeader())
    183           *
    184           * Outputs:     none
    185           *
    186           * Return:      1 if pad bit is set, 0 if not, -1 if null input pointer
    187           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    188          int CheckPadBit(MP3DecInfo *mp3DecInfo)
    189          {
    190          	FrameHeader *fh;
    191          
    192          	/* validate pointers */
    193          	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS)
   \                     xmp3_CheckPadBit:
   \   00000000   000050E3           CMP      R0,#+0
   \   00000004   00009015           LDRNE    R0,[R0, #+0]
   \   00000008   00005013           CMPNE    R0,#+0
    194          		return -1;
   \   0000000C   0000E003           MVNEQ    R0,#+0
   \   00000010   1EFF2F01           BXEQ     LR
    195          
    196          	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
    197          
    198          	return (fh->paddingBit ? 1 : 0);
   \   00000014   140090E5           LDR      R0,[R0, #+20]
   \   00000018   000050E3           CMP      R0,#+0
   \   0000001C   0100A013           MOVNE    R0,#+1
   \   00000020   1EFF2FE1           BX       LR               ;; return
    199          }
    200          
    201          /**************************************************************************************
    202           * Function:    UnpackFrameHeader
    203           *
    204           * Description: parse the fields of the MP3 frame header
    205           *
    206           * Inputs:      buffer pointing to a complete MP3 frame header (4 bytes, plus 2 if CRC)
    207           *
    208           * Outputs:     filled frame header info in the MP3DecInfo structure
    209           *              updated platform-specific FrameHeader struct
    210           *
    211           * Return:      length (in bytes) of frame header (for caller to calculate offset to
    212           *                first byte following frame header)
    213           *              -1 if null frameHeader or invalid header
    214           *
    215           * TODO:        check for valid modes, depending on capabilities of decoder
    216           *              test CRC on actual stream (verify no endian problems)
    217           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    218          int UnpackFrameHeader(MP3DecInfo *mp3DecInfo, unsigned char *buf)
    219          {
   \                     xmp3_UnpackFrameHeader:
   \   00000000   F0472DE9           PUSH     {R4-R10,LR}
   \   00000004   0020A0E1           MOV      R2,R0
    220          
    221          	int verIdx;
    222          	FrameHeader *fh;
    223          
    224          	/* validate pointers and sync word */
    225          	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
   \   00000008   000052E3           CMP      R2,#+0
   \   0000000C   00409215           LDRNE    R4,[R2, #+0]
   \   00000010   0130A0E1           MOV      R3,R1
   \   00000014   00005413           CMPNE    R4,#+0
   \   00000018   0600000A           BEQ      ??xmp3_UnpackFrameHeader_0
   \   0000001C   0000D3E5           LDRB     R0,[R3, #+0]
   \   00000020   FF0050E3           CMP      R0,#+255
   \   00000024   0300001A           BNE      ??xmp3_UnpackFrameHeader_0
   \   00000028   0100D3E5           LDRB     R0,[R3, #+1]
   \   0000002C   E00000E2           AND      R0,R0,#0xE0
   \   00000030   E00050E3           CMP      R0,#+224
   \   00000034   0100000A           BEQ      ??xmp3_UnpackFrameHeader_1
    226          		return -1;
   \                     ??xmp3_UnpackFrameHeader_0:
   \   00000038   0000E0E3           MVN      R0,#+0
   \   0000003C   F087BDE8           POP      {R4-R10,PC}
    227          
    228          	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
    229          
    230          	/* read header fields - use bitmasks instead of GetBits() for speed, since format never varies */
    231          	verIdx =         (buf[1] >> 3) & 0x03;
   \                     ??xmp3_UnpackFrameHeader_1:
   \   00000040   0100D3E5           LDRB     R0,[R3, #+1]
   \   00000044   0310A0E3           MOV      R1,#+3
   \   00000048   C00111E0           ANDS     R0,R1,R0, ASR #+3
    232          	fh->ver =        (MPEGVersion)( verIdx == 0 ? MPEG25 : ((verIdx & 0x01) ? MPEG1 : MPEG2) );
   \   0000004C   0200A003           MOVEQ    R0,#+2
   \   00000050   01000012           ANDNE    R0,R0,#0x1
   \   00000054   01002012           EORNE    R0,R0,#0x1
   \   00000058   0000C4E5           STRB     R0,[R4, #+0]
    233          	fh->layer = 4 - ((buf[1] >> 1) & 0x03);     /* easy mapping of index to layer number, 4 = error */
   \   0000005C   0100D3E5           LDRB     R0,[R3, #+1]
   \   00000060   C00001E0           AND      R0,R1,R0, ASR #+1
   \   00000064   040060E2           RSB      R0,R0,#+4
   \   00000068   040084E5           STR      R0,[R4, #+4]
    234          	fh->crc =   1 - ((buf[1] >> 0) & 0x01);
   \   0000006C   0100D3E5           LDRB     R0,[R3, #+1]
   \   00000070   010000E2           AND      R0,R0,#0x1
   \   00000074   010060E2           RSB      R0,R0,#+1
   \   00000078   080084E5           STR      R0,[R4, #+8]
    235          	fh->brIdx =      (buf[2] >> 4) & 0x0f;
   \   0000007C   0200D3E5           LDRB     R0,[R3, #+2]
   \   00000080   2002A0E1           LSR      R0,R0,#+4
   \   00000084   0C0084E5           STR      R0,[R4, #+12]
    236          	fh->srIdx =      (buf[2] >> 2) & 0x03;
   \   00000088   0200D3E5           LDRB     R0,[R3, #+2]
   \   0000008C   400101E0           AND      R0,R1,R0, ASR #+2
   \   00000090   100084E5           STR      R0,[R4, #+16]
    237          	fh->paddingBit = (buf[2] >> 1) & 0x01;
   \   00000094   0200D3E5           LDRB     R0,[R3, #+2]
   \   00000098   0110A0E3           MOV      R1,#+1
   \   0000009C   C00001E0           AND      R0,R1,R0, ASR #+1
   \   000000A0   140084E5           STR      R0,[R4, #+20]
    238          	fh->privateBit = (buf[2] >> 0) & 0x01;
   \   000000A4   0200D3E5           LDRB     R0,[R3, #+2]
    239          	fh->sMode =      (StereoMode)((buf[3] >> 6) & 0x03);      /* maps to correct enum (see definition) */
    240          	fh->modeExt =    (buf[3] >> 4) & 0x03;
   \   000000A8   0310A0E3           MOV      R1,#+3
   \   000000AC   010000E2           AND      R0,R0,#0x1
   \   000000B0   180084E5           STR      R0,[R4, #+24]
   \   000000B4   0300D3E5           LDRB     R0,[R3, #+3]
   \   000000B8   2003A0E1           LSR      R0,R0,#+6
   \   000000BC   1C00C4E5           STRB     R0,[R4, #+28]
   \   000000C0   0300D3E5           LDRB     R0,[R3, #+3]
   \   000000C4   400201E0           AND      R0,R1,R0, ASR #+4
   \   000000C8   200084E5           STR      R0,[R4, #+32]
    241          	fh->copyFlag =   (buf[3] >> 3) & 0x01;
   \   000000CC   0300D3E5           LDRB     R0,[R3, #+3]
   \   000000D0   0110A0E3           MOV      R1,#+1
   \   000000D4   C00101E0           AND      R0,R1,R0, ASR #+3
   \   000000D8   240084E5           STR      R0,[R4, #+36]
    242          	fh->origFlag =   (buf[3] >> 2) & 0x01;
   \   000000DC   0300D3E5           LDRB     R0,[R3, #+3]
   \   000000E0   400101E0           AND      R0,R1,R0, ASR #+2
   \   000000E4   280084E5           STR      R0,[R4, #+40]
    243          	fh->emphasis =   (buf[3] >> 0) & 0x03;
   \   000000E8   0300D3E5           LDRB     R0,[R3, #+3]
   \   000000EC   030000E2           AND      R0,R0,#0x3
   \   000000F0   2C0084E5           STR      R0,[R4, #+44]
    244          
    245          	/* check parameters to avoid indexing tables with bad values */
    246          	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
   \   000000F4   100094E5           LDR      R0,[R4, #+16]
   \   000000F8   030050E3           CMP      R0,#+3
   \   000000FC   04109415           LDRNE    R1,[R4, #+4]
   \   00000100   04005113           CMPNE    R1,#+4
   \   00000104   0C109415           LDRNE    R1,[R4, #+12]
   \   00000108   0F005113           CMPNE    R1,#+15
   \   0000010C   C9FFFF0A           BEQ      ??xmp3_UnpackFrameHeader_0
    247          		return -1;
    248          
    249          	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
   \   00000110   D050D4E1           LDRSB    R5,[R4, #+0]
   \   00000114   7C719FE5           LDR      R7,??xmp3_UnpackFrameHeader_2  ;; xmp3_sfBandTable
   \   00000118   4A10A0E3           MOV      R1,#+74
   \   0000011C   DE60A0E3           MOV      R6,#+222
   \   00000120   967525E0           MLA      R5,R6,R5,R7
    250          	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
    251          		fh->modeExt = 0;
    252          
    253          	/* init user-accessible data */
    254          	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
    255          	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
   \   00000124   70719FE5           LDR      R7,??xmp3_UnpackFrameHeader_2+0x4  ;; xmp3_samplerateTab
   \   00000128   915020E0           MLA      R0,R1,R0,R5
   \   0000012C   0050A0E3           MOV      R5,#+0
   \   00000130   340084E5           STR      R0,[R4, #+52]
   \   00000134   DC01D4E1           LDRSB    R0,[R4, #+28]
   \   00000138   0C60A0E3           MOV      R6,#+12
   \   0000013C   010050E3           CMP      R0,#+1
   \   00000140   20508415           STRNE    R5,[R4, #+32]
   \   00000144   030050E3           CMP      R0,#+3
   \   00000148   0100A003           MOVEQ    R0,#+1
   \   0000014C   0200A013           MOVNE    R0,#+2
   \   00000150   BC0782E5           STR      R0,[R2, #+1980]
   \   00000154   D010D4E1           LDRSB    R1,[R4, #+0]
   \   00000158   100094E5           LDR      R0,[R4, #+16]
   \   0000015C   967121E0           MLA      R1,R6,R1,R7
    256          	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
    257          	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
   \   00000160   38719FE5           LDR      R7,??xmp3_UnpackFrameHeader_2+0x8  ;; xmp3_samplesPerFrameTab
   \   00000164   000191E7           LDR      R0,[R1, +R0, LSL #+2]
   \   00000168   0660A0E3           MOV      R6,#+6
   \   0000016C   C00782E5           STR      R0,[R2, #+1984]
   \   00000170   D000D4E1           LDRSB    R0,[R4, #+0]
   \   00000174   000050E3           CMP      R0,#+0
   \   00000178   0200A003           MOVEQ    R0,#+2
   \   0000017C   0100A013           MOVNE    R0,#+1
   \   00000180   C40782E5           STR      R0,[R2, #+1988]
   \   00000184   D010D4E1           LDRSB    R1,[R4, #+0]
   \   00000188   040094E5           LDR      R0,[R4, #+4]
   \   0000018C   967121E0           MLA      R1,R6,R1,R7
   \   00000190   800081E0           ADD      R0,R1,R0, LSL #+1
   \   00000194   F20050E1           LDRSH    R0,[R0, #-2]
   \   00000198   C41792E5           LDR      R1,[R2, #+1988]
   \   0000019C   ........           _BLF     ??div32_a,??rA??div32_a
   \   000001A0   C81782E5           STR      R1,[R2, #+1992]
    258          	mp3DecInfo->layer = fh->layer;
   \   000001A4   040094E5           LDR      R0,[R4, #+4]
   \   000001A8   D00782E5           STR      R0,[R2, #+2000]
    259          	mp3DecInfo->version = fh->ver;
   \   000001AC   D000D4E1           LDRSB    R0,[R4, #+0]
   \   000001B0   D407C2E5           STRB     R0,[R2, #+2004]
    260          
    261          	/* get bitrate and nSlots from table, unless brIdx == 0 (free mode) in which case caller must figure it out himself
    262          	 * question - do we want to overwrite mp3DecInfo->bitrate with 0 each time if it's free mode, and
    263          	 *  copy the pre-calculated actual free bitrate into it in mp3dec.c (according to the spec,
    264          	 *  this shouldn't be necessary, since it should be either all frames free or none free)
    265          	 */
    266          	if (fh->brIdx) {
   \   000001B4   0C0094E5           LDR      R0,[R4, #+12]
   \   000001B8   000050E3           CMP      R0,#+0
   \   000001BC   2900000A           BEQ      ??xmp3_UnpackFrameHeader_3
    267          		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
   \   000001C0   D070D4E1           LDRSB    R7,[R4, #+0]
   \   000001C4   041094E5           LDR      R1,[R4, #+4]
   \   000001C8   D4E09FE5           LDR      LR,??xmp3_UnpackFrameHeader_2+0xC  ;; xmp3_bitrateTab
   \   000001CC   1E60A0E3           MOV      R6,#+30
    268          
    269          		/* nSlots = total frame bytes (from table) - sideInfo bytes - header - CRC (if present) + pad (if present) */
    270          		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] -
    271          			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] -
    272          			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
   \   000001D0   D0A09FE5           LDR      R10,??xmp3_UnpackFrameHeader_2+0x10  ;; xmp3_slotTab
   \   000001D4   5AC0A0E3           MOV      R12,#+90
   \   000001D8   9CE727E0           MLA      R7,R12,R7,LR
   \   000001DC   5A90A0E3           MOV      R9,#+90
   \   000001E0   967121E0           MLA      R1,R6,R1,R7
   \   000001E4   1E70A0E3           MOV      R7,#+30
   \   000001E8   800081E0           ADD      R0,R1,R0, LSL #+1
   \   000001EC   FE0150E1           LDRSH    R0,[R0, #-30]
   \   000001F0   FA1FA0E3           MOV      R1,#+1000
   \   000001F4   910000E0           MUL      R0,R1,R0
   \   000001F8   B80782E5           STR      R0,[R2, #+1976]
   \   000001FC   DC01D4E1           LDRSB    R0,[R4, #+28]
   \   00000200   D0E0D4E1           LDRSB    LR,[R4, #+0]
   \   00000204   081094E5           LDR      R1,[R4, #+8]
   \   00000208   146094E5           LDR      R6,[R4, #+20]
   \   0000020C   108094E5           LDR      R8,[R4, #+16]
   \   00000210   030050E3           CMP      R0,#+3
   \   00000214   0000A003           MOVEQ    R0,#+0
   \   00000218   0100A013           MOVNE    R0,#+1
   \   0000021C   000051E3           CMP      R1,#+0
   \   00000220   0210A013           MOVNE    R1,#+2
   \   00000224   000056E3           CMP      R6,#+0
   \   00000228   0C6094E5           LDR      R6,[R4, #+12]
   \   0000022C   99AE2AE0           MLA      R10,R9,LR,R10
   \   00000230   01C0A013           MOVNE    R12,#+1
   \   00000234   97A828E0           MLA      R8,R7,R8,R10
   \   00000238   6C709FE5           LDR      R7,??xmp3_UnpackFrameHeader_2+0x14  ;; xmp3_sideBytesTab
   \   0000023C   866088E0           ADD      R6,R8,R6, LSL #+1
   \   00000240   F060D6E1           LDRSH    R6,[R6, #+0]
   \   00000244   0E7187E0           ADD      R7,R7,LR, LSL #+2
   \   00000248   800087E0           ADD      R0,R7,R0, LSL #+1
   \   0000024C   F000D0E1           LDRSH    R0,[R0, #+0]
   \   00000250   00C0A003           MOVEQ    R12,#+0
   \   00000254   000046E0           SUB      R0,R6,R0
   \   00000258   040040E2           SUB      R0,R0,#+4
   \   0000025C   010040E0           SUB      R0,R0,R1
   \   00000260   00008CE0           ADD      R0,R12,R0
   \   00000264   CC0782E5           STR      R0,[R2, #+1996]
    273          	}
    274          
    275          	/* load crc word, if enabled, and return length of frame header (in bytes) */
    276          	if (fh->crc) {
   \                     ??xmp3_UnpackFrameHeader_3:
   \   00000268   080094E5           LDR      R0,[R4, #+8]
   \   0000026C   000050E3           CMP      R0,#+0
   \   00000270   0500000A           BEQ      ??xmp3_UnpackFrameHeader_4
    277          		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
   \   00000274   0400D3E5           LDRB     R0,[R3, #+4]
   \   00000278   0510D3E5           LDRB     R1,[R3, #+5]
   \   0000027C   000481E1           ORR      R0,R1,R0, LSL #+8
   \   00000280   300084E5           STR      R0,[R4, #+48]
    278          		return 6;
   \   00000284   0600A0E3           MOV      R0,#+6
   \   00000288   F087BDE8           POP      {R4-R10,PC}
    279          	} else {
    280          		fh->CRCWord = 0;
   \                     ??xmp3_UnpackFrameHeader_4:
   \   0000028C   305084E5           STR      R5,[R4, #+48]
    281          		return 4;
   \   00000290   0400A0E3           MOV      R0,#+4
   \   00000294   F087BDE8           POP      {R4-R10,PC}      ;; return
   \                     ??xmp3_UnpackFrameHeader_2:
   \   00000298   ........           DC32     xmp3_sfBandTable
   \   0000029C   ........           DC32     xmp3_samplerateTab
   \   000002A0   ........           DC32     xmp3_samplesPerFrameTab
   \   000002A4   ........           DC32     xmp3_bitrateTab
   \   000002A8   ........           DC32     xmp3_slotTab
   \   000002AC   ........           DC32     xmp3_sideBytesTab
    282          	}
    283          }
    284          
    285          /**************************************************************************************
    286           * Function:    UnpackSideInfo
    287           *
    288           * Description: parse the fields of the MP3 side info header
    289           *
    290           * Inputs:      MP3DecInfo structure filled by UnpackFrameHeader()
    291           *              buffer pointing to the MP3 side info data
    292           *
    293           * Outputs:     updated mainDataBegin in MP3DecInfo struct
    294           *              updated private (platform-specific) SideInfo struct
    295           *
    296           * Return:      length (in bytes) of side info data
    297           *              -1 if null input pointers
    298           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    299          int UnpackSideInfo(MP3DecInfo *mp3DecInfo, unsigned char *buf)
    300          {
   \                     xmp3_UnpackSideInfo:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   10D04DE2           SUB      SP,SP,#+16
   \   00000008   0040A0E1           MOV      R4,R0
    301          	int gr, ch, bd, nBytes;
    302          	BitStreamInfo bitStreamInfo, *bsi;
    303          	FrameHeader *fh;
    304          	SideInfo *si;
    305          	SideInfoSub *sis;
    306          
    307          	/* validate pointers and sync word */
    308          	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS)
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   00609415           LDRNE    R6,[R4, #+0]
   \   00000014   0120A0E1           MOV      R2,R1
   \   00000018   00005613           CMPNE    R6,#+0
   \   0000001C   04709415           LDRNE    R7,[R4, #+4]
   \   00000020   00005713           CMPNE    R7,#+0
    309          		return -1;
   \   00000024   0000E003           MVNEQ    R0,#+0
   \   00000028   4000000A           BEQ      ??xmp3_UnpackSideInfo_0
    310          
    311          	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
    312          	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
    313          
    314          	bsi = &bitStreamInfo;
    315          	if (fh->ver == MPEG1) {
   \   0000002C   D000D6E1           LDRSB    R0,[R6, #+0]
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   DC01D6E1           LDRSB    R0,[R6, #+28]
   \   00000038   2300001A           BNE      ??xmp3_UnpackSideInfo_1
    316          		/* MPEG 1 */
    317          		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
   \   0000003C   030050E3           CMP      R0,#+3
   \   00000040   1150A003           MOVEQ    R5,#+17
   \   00000044   2050A013           MOVNE    R5,#+32
    318          		SetBitstreamPointer(bsi, nBytes, buf);
   \   00000048   0510A0E1           MOV      R1,R5
   \   0000004C   0D00A0E1           MOV      R0,SP
   \   00000050   ........           BL       xmp3_SetBitstreamPointer
    319          		si->mainDataBegin = GetBits(bsi, 9);
   \   00000054   0910A0E3           MOV      R1,#+9
   \   00000058   0D00A0E1           MOV      R0,SP
   \   0000005C   ........           BL       xmp3_GetBits
   \   00000060   000087E5           STR      R0,[R7, #+0]
    320          		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
   \   00000064   DC01D6E1           LDRSB    R0,[R6, #+28]
    321          
    322          		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
   \   00000068   0090A0E3           MOV      R9,#+0
   \   0000006C   030050E3           CMP      R0,#+3
   \   00000070   0510A003           MOVEQ    R1,#+5
   \   00000074   0310A013           MOVNE    R1,#+3
   \   00000078   0D00A0E1           MOV      R0,SP
   \   0000007C   ........           BL       xmp3_GetBits
   \   00000080   040087E5           STR      R0,[R7, #+4]
   \   00000084   BC0794E5           LDR      R0,[R4, #+1980]
   \   00000088   010050E3           CMP      R0,#+1
   \   0000008C   1F0000BA           BLT      ??xmp3_UnpackSideInfo_2
   \                     ??xmp3_UnpackSideInfo_3:
   \   00000090   BC0794E5           LDR      R0,[R4, #+1980]
   \   00000094   000059E1           CMP      R9,R0
   \   00000098   1C0000AA           BGE      ??xmp3_UnpackSideInfo_2
    323          			for (bd = 0; bd < MAX_SCFBD; bd++)
   \   0000009C   0080A0E3           MOV      R8,#+0
    324          				si->scfsi[ch][bd] = GetBits(bsi, 1);
   \                     ??xmp3_UnpackSideInfo_4:
   \   000000A0   0110A0E3           MOV      R1,#+1
   \   000000A4   0D00A0E1           MOV      R0,SP
   \   000000A8   ........           BL       xmp3_GetBits
   \   000000AC   091287E0           ADD      R1,R7,R9, LSL #+4
   \   000000B0   081181E0           ADD      R1,R1,R8, LSL #+2
   \   000000B4   080081E5           STR      R0,[R1, #+8]
   \   000000B8   018088E2           ADD      R8,R8,#+1
   \   000000BC   040058E3           CMP      R8,#+4
   \   000000C0   F6FFFFBA           BLT      ??xmp3_UnpackSideInfo_4
   \   000000C4   019089E2           ADD      R9,R9,#+1
   \   000000C8   F0FFFFEA           B        ??xmp3_UnpackSideInfo_3
    325          	} else {
    326          		/* MPEG 2, MPEG 2.5 */
    327          		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
   \                     ??xmp3_UnpackSideInfo_1:
   \   000000CC   030050E3           CMP      R0,#+3
   \   000000D0   0950A003           MOVEQ    R5,#+9
   \   000000D4   1150A013           MOVNE    R5,#+17
    328          		SetBitstreamPointer(bsi, nBytes, buf);
   \   000000D8   0510A0E1           MOV      R1,R5
   \   000000DC   0D00A0E1           MOV      R0,SP
   \   000000E0   ........           BL       xmp3_SetBitstreamPointer
    329          		si->mainDataBegin = GetBits(bsi, 8);
   \   000000E4   0810A0E3           MOV      R1,#+8
   \   000000E8   0D00A0E1           MOV      R0,SP
   \   000000EC   ........           BL       xmp3_GetBits
   \   000000F0   000087E5           STR      R0,[R7, #+0]
    330          		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
   \   000000F4   DC01D6E1           LDRSB    R0,[R6, #+28]
   \   000000F8   030050E3           CMP      R0,#+3
   \   000000FC   0110A003           MOVEQ    R1,#+1
   \   00000100   0210A013           MOVNE    R1,#+2
   \   00000104   0D00A0E1           MOV      R0,SP
   \   00000108   ........           BL       xmp3_GetBits
   \   0000010C   040087E5           STR      R0,[R7, #+4]
    331          	}
    332          
    333          	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
   \                     ??xmp3_UnpackSideInfo_2:
   \   00000110   C40794E5           LDR      R0,[R4, #+1988]
   \   00000114   0080A0E3           MOV      R8,#+0
   \   00000118   010050E3           CMP      R0,#+1
   \   0000011C   00B0A0E3           MOV      R11,#+0
   \   00000120   050000AA           BGE      ??xmp3_UnpackSideInfo_5
    334          		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
    335          			sis = &si->sis[gr][ch];						/* side info subblock for this granule, channel */
    336          
    337          			sis->part23Length =    GetBits(bsi, 12);
    338          			sis->nBigvals =        GetBits(bsi, 9);
    339          			sis->globalGain =      GetBits(bsi, 8);
    340          			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
    341          			sis->winSwitchFlag =   GetBits(bsi, 1);
    342          
    343          			if(sis->winSwitchFlag) {
    344          				/* this is a start, stop, short, or mixed block */
    345          				sis->blockType =       GetBits(bsi, 2);		/* 0 = normal, 1 = start, 2 = short, 3 = stop */
    346          				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
    347          				sis->tableSelect[0] =  GetBits(bsi, 5);
    348          				sis->tableSelect[1] =  GetBits(bsi, 5);
    349          				sis->tableSelect[2] =  0;					/* unused */
    350          				sis->subBlockGain[0] = GetBits(bsi, 3);
    351          				sis->subBlockGain[1] = GetBits(bsi, 3);
    352          				sis->subBlockGain[2] = GetBits(bsi, 3);
    353          
    354          				/* TODO - check logic */
    355          				if (sis->blockType == 0) {
    356          					/* this should not be allowed, according to spec */
    357          					sis->nBigvals = 0;
    358          					sis->part23Length = 0;
    359          					sis->sfCompress = 0;
    360          				} else if (sis->blockType == 2 && sis->mixedBlock == 0) {
    361          					/* short block, not mixed */
    362          					sis->region0Count = 8;
    363          				} else {
    364          					/* start, stop, or short-mixed */
    365          					sis->region0Count = 7;
    366          				}
    367          				sis->region1Count = 20 - sis->region0Count;
    368          			} else {
    369          				/* this is a normal block */
    370          				sis->blockType = 0;
    371          				sis->mixedBlock = 0;
    372          				sis->tableSelect[0] =  GetBits(bsi, 5);
    373          				sis->tableSelect[1] =  GetBits(bsi, 5);
    374          				sis->tableSelect[2] =  GetBits(bsi, 5);
    375          				sis->region0Count =    GetBits(bsi, 4);
    376          				sis->region1Count =    GetBits(bsi, 3);
    377          			}
    378          			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
    379          			sis->sfactScale =        GetBits(bsi, 1);
    380          			sis->count1TableSelect = GetBits(bsi, 1);
    381          		}
    382          	}
    383          	mp3DecInfo->mainDataBegin = si->mainDataBegin;	/* needed by main decode loop */
   \                     ??xmp3_UnpackSideInfo_6:
   \   00000124   000097E5           LDR      R0,[R7, #+0]
   \   00000128   D80784E5           STR      R0,[R4, #+2008]
    384          
    385          	ASSERT(nBytes == CalcBitsUsed(bsi, buf, 0) >> 3);
    386          
    387          	return nBytes;
   \   0000012C   0500A0E1           MOV      R0,R5
   \                     ??xmp3_UnpackSideInfo_0:
   \   00000130   10D08DE2           ADD      SP,SP,#+16       ;; stack cleaning
   \   00000134   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??xmp3_UnpackSideInfo_7:
   \   00000138   018088E2           ADD      R8,R8,#+1
   \                     ??xmp3_UnpackSideInfo_5:
   \   0000013C   C40794E5           LDR      R0,[R4, #+1988]
   \   00000140   000058E1           CMP      R8,R0
   \   00000144   F6FFFFAA           BGE      ??xmp3_UnpackSideInfo_6
   \   00000148   BC0794E5           LDR      R0,[R4, #+1980]
   \   0000014C   0090A0E3           MOV      R9,#+0
   \   00000150   010050E3           CMP      R0,#+1
   \   00000154   0B0000AA           BGE      ??xmp3_UnpackSideInfo_8
   \   00000158   F6FFFFEA           B        ??xmp3_UnpackSideInfo_7
   \                     ??xmp3_UnpackSideInfo_9:
   \   0000015C   0000A0E3           MOV      R0,#+0
   \                     ??xmp3_UnpackSideInfo_10:
   \   00000160   3C008AE5           STR      R0,[R10, #+60]
   \   00000164   0110A0E3           MOV      R1,#+1
   \   00000168   0D00A0E1           MOV      R0,SP
   \   0000016C   ........           BL       xmp3_GetBits
   \   00000170   40008AE5           STR      R0,[R10, #+64]
   \   00000174   0110A0E3           MOV      R1,#+1
   \   00000178   0D00A0E1           MOV      R0,SP
   \   0000017C   ........           BL       xmp3_GetBits
   \   00000180   44008AE5           STR      R0,[R10, #+68]
   \   00000184   019089E2           ADD      R9,R9,#+1
   \                     ??xmp3_UnpackSideInfo_8:
   \   00000188   BC0794E5           LDR      R0,[R4, #+1980]
   \   0000018C   000059E1           CMP      R9,R0
   \   00000190   E8FFFFAA           BGE      ??xmp3_UnpackSideInfo_7
   \   00000194   4800A0E3           MOV      R0,#+72
   \   00000198   9010A0E3           MOV      R1,#+144
   \   0000019C   917822E0           MLA      R2,R1,R8,R7
   \   000001A0   902921E0           MLA      R1,R0,R9,R2
   \   000001A4   0D00A0E1           MOV      R0,SP
   \   000001A8   28A081E2           ADD      R10,R1,#+40
   \   000001AC   0C10A0E3           MOV      R1,#+12
   \   000001B0   ........           BL       xmp3_GetBits
   \   000001B4   00008AE5           STR      R0,[R10, #+0]
   \   000001B8   0910A0E3           MOV      R1,#+9
   \   000001BC   0D00A0E1           MOV      R0,SP
   \   000001C0   ........           BL       xmp3_GetBits
   \   000001C4   04008AE5           STR      R0,[R10, #+4]
   \   000001C8   0810A0E3           MOV      R1,#+8
   \   000001CC   0D00A0E1           MOV      R0,SP
   \   000001D0   ........           BL       xmp3_GetBits
   \   000001D4   08008AE5           STR      R0,[R10, #+8]
   \   000001D8   D000D6E1           LDRSB    R0,[R6, #+0]
   \   000001DC   000050E3           CMP      R0,#+0
   \   000001E0   0410A003           MOVEQ    R1,#+4
   \   000001E4   0910A013           MOVNE    R1,#+9
   \   000001E8   0D00A0E1           MOV      R0,SP
   \   000001EC   ........           BL       xmp3_GetBits
   \   000001F0   0C008AE5           STR      R0,[R10, #+12]
   \   000001F4   0110A0E3           MOV      R1,#+1
   \   000001F8   0D00A0E1           MOV      R0,SP
   \   000001FC   ........           BL       xmp3_GetBits
   \   00000200   10008AE5           STR      R0,[R10, #+16]
   \   00000204   000050E3           CMP      R0,#+0
   \   00000208   2C00000A           BEQ      ??xmp3_UnpackSideInfo_11
   \   0000020C   0210A0E3           MOV      R1,#+2
   \   00000210   0D00A0E1           MOV      R0,SP
   \   00000214   ........           BL       xmp3_GetBits
   \   00000218   14008AE5           STR      R0,[R10, #+20]
   \   0000021C   0110A0E3           MOV      R1,#+1
   \   00000220   0D00A0E1           MOV      R0,SP
   \   00000224   ........           BL       xmp3_GetBits
   \   00000228   18008AE5           STR      R0,[R10, #+24]
   \   0000022C   0510A0E3           MOV      R1,#+5
   \   00000230   0D00A0E1           MOV      R0,SP
   \   00000234   ........           BL       xmp3_GetBits
   \   00000238   1C008AE5           STR      R0,[R10, #+28]
   \   0000023C   0510A0E3           MOV      R1,#+5
   \   00000240   0D00A0E1           MOV      R0,SP
   \   00000244   ........           BL       xmp3_GetBits
   \   00000248   20008AE5           STR      R0,[R10, #+32]
   \   0000024C   24B08AE5           STR      R11,[R10, #+36]
   \   00000250   0310A0E3           MOV      R1,#+3
   \   00000254   0D00A0E1           MOV      R0,SP
   \   00000258   ........           BL       xmp3_GetBits
   \   0000025C   28008AE5           STR      R0,[R10, #+40]
   \   00000260   0310A0E3           MOV      R1,#+3
   \   00000264   0D00A0E1           MOV      R0,SP
   \   00000268   ........           BL       xmp3_GetBits
   \   0000026C   2C008AE5           STR      R0,[R10, #+44]
   \   00000270   0310A0E3           MOV      R1,#+3
   \   00000274   0D00A0E1           MOV      R0,SP
   \   00000278   ........           BL       xmp3_GetBits
   \   0000027C   30008AE5           STR      R0,[R10, #+48]
   \   00000280   14009AE5           LDR      R0,[R10, #+20]
   \   00000284   000050E3           CMP      R0,#+0
   \   00000288   0300001A           BNE      ??xmp3_UnpackSideInfo_12
   \   0000028C   04B08AE5           STR      R11,[R10, #+4]
   \   00000290   00B08AE5           STR      R11,[R10, #+0]
   \   00000294   0CB08AE5           STR      R11,[R10, #+12]
   \   00000298   050000EA           B        ??xmp3_UnpackSideInfo_13
   \                     ??xmp3_UnpackSideInfo_12:
   \   0000029C   020050E3           CMP      R0,#+2
   \   000002A0   18009A05           LDREQ    R0,[R10, #+24]
   \   000002A4   00005003           CMPEQ    R0,#+0
   \   000002A8   0800A003           MOVEQ    R0,#+8
   \   000002AC   0700A013           MOVNE    R0,#+7
   \   000002B0   34008AE5           STR      R0,[R10, #+52]
   \                     ??xmp3_UnpackSideInfo_13:
   \   000002B4   34009AE5           LDR      R0,[R10, #+52]
   \   000002B8   140060E2           RSB      R0,R0,#+20
   \   000002BC   140000EA           B        ??xmp3_UnpackSideInfo_14
   \                     ??xmp3_UnpackSideInfo_11:
   \   000002C0   14B08AE5           STR      R11,[R10, #+20]
   \   000002C4   18B08AE5           STR      R11,[R10, #+24]
   \   000002C8   0510A0E3           MOV      R1,#+5
   \   000002CC   0D00A0E1           MOV      R0,SP
   \   000002D0   ........           BL       xmp3_GetBits
   \   000002D4   1C008AE5           STR      R0,[R10, #+28]
   \   000002D8   0510A0E3           MOV      R1,#+5
   \   000002DC   0D00A0E1           MOV      R0,SP
   \   000002E0   ........           BL       xmp3_GetBits
   \   000002E4   20008AE5           STR      R0,[R10, #+32]
   \   000002E8   0510A0E3           MOV      R1,#+5
   \   000002EC   0D00A0E1           MOV      R0,SP
   \   000002F0   ........           BL       xmp3_GetBits
   \   000002F4   24008AE5           STR      R0,[R10, #+36]
   \   000002F8   0410A0E3           MOV      R1,#+4
   \   000002FC   0D00A0E1           MOV      R0,SP
   \   00000300   ........           BL       xmp3_GetBits
   \   00000304   34008AE5           STR      R0,[R10, #+52]
   \   00000308   0310A0E3           MOV      R1,#+3
   \   0000030C   0D00A0E1           MOV      R0,SP
   \   00000310   ........           BL       xmp3_GetBits
   \                     ??xmp3_UnpackSideInfo_14:
   \   00000314   38008AE5           STR      R0,[R10, #+56]
   \   00000318   D000D6E1           LDRSB    R0,[R6, #+0]
   \   0000031C   000050E3           CMP      R0,#+0
   \   00000320   8DFFFF1A           BNE      ??xmp3_UnpackSideInfo_9
   \   00000324   0110A0E3           MOV      R1,#+1
   \   00000328   0D00A0E1           MOV      R0,SP
   \   0000032C   ........           BL       xmp3_GetBits
   \   00000330   8AFFFFEA           B        ??xmp3_UnpackSideInfo_10
    388          }
    389          

   Maximum stack usage in bytes:

     Function                 CSTACK
     --------                 ------
     RefillBitstreamCache         4
     xmp3_CalcBitsUsed            0
     xmp3_CheckPadBit             0
     xmp3_GetBits                16
     xmp3_SetBitstreamPointer     0
     xmp3_UnpackFrameHeader      32
     xmp3_UnpackSideInfo         52


   Segment part sizes:

     Function/Label           Bytes
     --------------           -----
     xmp3_SetBitstreamPointer   24
     RefillBitstreamCache      240
     xmp3_GetBits              112
     xmp3_CalcBitsUsed          24
     xmp3_CheckPadBit           36
     xmp3_UnpackFrameHeader    688
     xmp3_UnpackSideInfo       820
      Others                    40

 
 1 984 bytes in segment CODE
 
 1 944 bytes of CODE memory (+ 40 bytes shared)

Errors: none
Warnings: 1
