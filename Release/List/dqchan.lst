##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Aug/2008  18:45:23 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\dqchan.c      #
#    Command line    =  G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\dqchan.c -lC  #
#                       G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\ -lA    #
#                       G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\ -o     #
#                       G:\Arm\SieELF\cbn_SRC\MP3Player\Release\Obj\ -s9     #
#                       --no_unroll --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e            #
#                       --char_is_signed --fpu None -I                       #
#                       D:\ewarm_442\arm\INC\ --inline_threshold=2           #
#    List file       =  G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\dqchan. #
#                       lst                                                  #
#    Object file     =  G:\Arm\SieELF\cbn_SRC\MP3Player\Release\Obj\dqchan.r #
#                       79                                                   #
#                                                                            #
#                                                                            #
##############################################################################

G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\dqchan.c
      1          /* ***** BEGIN LICENSE BLOCK ***** 
                                                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * Version: RCSL 1.0/RPSL 1.0 
      3           *  
      4           * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
      5           *      
      6           * The contents of this file, and the files included with this file, are 
      7           * subject to the current version of the RealNetworks Public Source License 
      8           * Version 1.0 (the "RPSL") available at 
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed 
     10           * the file under the RealNetworks Community Source License Version 1.0 
     11           * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
     12           * in which case the RCSL will apply. You may also obtain the license terms 
     13           * directly from RealNetworks.  You may not use this file except in 
     14           * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
     15           * applicable to this file, the RCSL.  Please see the applicable RPSL or 
     16           * RCSL for the rights, obligations and limitations governing use of the 
     17           * contents of the file.  
     18           *  
     19           * This file is part of the Helix DNA Technology. RealNetworks is the 
     20           * developer of the Original Code and owns the copyrights in the portions 
     21           * it created. 
     22           *  
     23           * This file, and the files included with this file, is distributed and made 
     24           * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
     25           * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
     26           * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
     27           * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
     28           * 
     29           * Technology Compatibility Kit Test Suite(s) Location: 
     30           *    http://www.helixcommunity.org/content/tck 
     31           * 
     32           * Contributor(s): 
     33           *  
     34           * ***** END LICENSE BLOCK ***** */ 
     35          
     36          /**************************************************************************************
     37           * Fixed-point MP3 decoder
     38           * Jon Recker (jrecker@real.com), Ken Cooke (kenc@real.com)
     39           * August 2003
     40           *
     41           * dqchan.c - dequantization of transform coefficients
     42           **************************************************************************************/
     43          
     44          #include "coder.h"
     45          #include "assembly.h"
     46          
     47          typedef int ARRAY3[3];	/* for short-block reordering */
     48          
     49          /* optional pre-emphasis for high-frequency scale factor bands */

   \                                 In segment DATA_C, align 4, align-sorted
     50          static const char preTab[22] = { 0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,2,0 };
   \                     preTab:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 2, 0
   \              000000000001
   \              010101020203
   \              03030200    
   \   00000016   0000               DC8 0, 0
     51          
     52          /* pow(2,-i/4) for i=0..3, Q31 format */

   \                                 In segment DATA_C, align 4, align-sorted
     53          static const int pow14[4] = { 
   \                     pow14:
   \   00000000   FFFFFF7F657E       DC32 2147483647, 1805811301, 1518500250, 1276901417
   \              A26B9A79825A
   \              29F81B4C    
   \   00000010   0E0000000D00       DC32 14, 13, 11, 10, 9, 7, 6, 5
   \              00000B000000
   \              0A0000000900
   \              000007000000
   \              060000000500
   \              0000        
   \   00000030   94FA9765E68B       DC32 1704458900, 1352829926, 2147483647, 1704458900, 1352829926
   \              A250FFFFFF7F
   \              94FA9765E68B
   \              A250        
   \   00000044   FFFFFF7F94FA       DC32 2147483647, 1704458900, 1352829926
   \              9765E68BA250
   \   00000050   FAA22814D61B       DC32 338207482, 366681046, 395718700, 425299333, 455403707, 486014202
   \              DB152C309617
   \              858D5919BBE8
   \              241BFAFCF71C
   \   00000068   F28AD21E2A58       DC32 517114610, 548689962, 580726382, 613210965, 646131674, 679477248
   \              B4206E2E9D22
   \              55DB8C24DA2F
   \              832600008028
   \   00000080   8722832AA870       DC32 713237127, 747401384, 781960664, 816906137, 852229450, 887922689
   \              8C2CD8C59B2E
   \              99FFB0304AFD
   \              CB3201A0EC34
   \   00000098   62CA12378860       DC32 923978338, 960389256, 997148640, 1034250007, 1071687164
   \              3E39E0476F3B
   \              1767A53DFCA5
   \              E03F        
   \   000000AC   72ED20425827       DC32 1109454194, 1147545432, 1185955452, 1224679047, 1263711219
   \              66447C3EB046
   \              871EFF48F3B3
   \              524B        
   \   000000C0   FDEBAA4D97B4       DC32 1303047165, 1342682263, 1382612066, 1422832284, 1463338785
   \              075062FC6852
   \              9CB2CE5421C7
   \              3857        
   \   000000D4   592AA75935CD       DC32 1504127577, 1545194805, 1586536745, 1628149793, 1670030463
   \              195C29A1905E
   \              21980B617FA4
   \              8A63        
   \   000000E8   0FB90D660BC9       DC32 1712175375, 1754581259, 1797244940, 1840163341, 1883333472
   \              94680CC81F6B
   \              0DAAAE6D6063
   \              4170        
   \   000000FC   B0E8D772F92E       DC32 1926752432, 1970417401, 2014325637, 2058474476, 2102861321
   \              7275852B1078
   \              ECD3B17A091E
   \              577D        
   \   00000110   000000000000       DC32 0, 268435456, 676414963, 1161452763, 213057363, 286886358
   \              0010F3455128
   \              DB5C3A4553FF
   \              B20CD6891911
   \   00000128   C831CE1503F2       DC32 365834696, 449311235, 536870912, 628164281, 722908323, 820868276
   \              C71A00000020
   \              B9067125A3B4
   \              162BB474ED30
   \   00000140   A53FF236D37B       DC32 921845669, 1025670099, 1132193366, 1241285180, 0, 225726413
   \              223D56E67B43
   \              3C82FC490000
   \              0000CD4F740D
   \   00000158   261FE721D9AB       DC32 568794918, 976661465, 179159172, 241241710, 307629085, 377824207
   \              363A84C0AD0A
   \              6E0E610E1D0C
   \              5612CF238516
   \   00000170   999FE81AA403       DC32 451452825, 528221092, 607891017, 690265191, 775176719, 862482309
   \              7C1F49AE3B24
   \              679C24290F42
   \              342E856F6833
   \   00000188   FF3DBF388201       DC32 952057343, 1043792258, 0, 189812531, 478297607, 821271125
   \              373E00000000
   \              334F500B073E
   \              821C559AF330
   \   000001A0   62CDFA081963       DC32 150654306, 202859289, 258684194, 317711021, 379625062, 444179223
   \              170C22356B0F
   \              ADE2EF12669E
   \              A01617A3791A
   \   000001B8   01E3771EB4D5       DC32 511173377, 580441524, 651843324, 725258282, 800581607, 877721168
   \              9822FC56DA26
   \              2A903A2BE7E7
   \              B72F50F65034
   \   000001D0   00000000057F       DC32 0, 159612677, 402198743, 690603945, 126684666, 170583649
   \              8309D710F917
   \              A9C72929FA0D
   \              8D0761E62A0A
   \   000001E8   5431F70CCB91       DC32 217526612, 267162059, 319225354, 373508716, 429843861, 488091197
   \              EC0F0AFE0613
   \              6C4A431695E5
   \              9E193DAE171D
   \   00000200   6AD7AB2051D5       DC32 548132714, 609867089, 673206203, 738072584
   \              5924BB4F2028
   \              0818FE2B    
   \   00000210   A9BDA0292848       DC32 698400169, -1339144152, 1498917403, 594299277, -11003815
   \              2EB01BAA5759
   \              8D496C235918
   \              58FF        
   \   00000224   63218510A4F6       DC32 277160291, -751569244, 1189691531, 667078384, -17467468
   \              33D38B40E946
   \              F0CEC227B477
   \              F5FE        
     54          	0x7fffffff, 0x6ba27e65, 0x5a82799a, 0x4c1bf829
     55          };
     56          
     57          /* pow(2,-i/4) * pow(j,4/3) for i=0..3 j=0..15, Q25 format */
     58          static const int pow43_14[4][16] = {
     59          {	0x00000000, 0x10000000, 0x285145f3, 0x453a5cdb, /* Q28 */
     60          	0x0cb2ff53, 0x111989d6, 0x15ce31c8, 0x1ac7f203, 
     61          	0x20000000, 0x257106b9, 0x2b16b4a3, 0x30ed74b4, 
     62          	0x36f23fa5, 0x3d227bd3, 0x437be656, 0x49fc823c, },
     63          
     64          {	0x00000000, 0x0d744fcd, 0x21e71f26, 0x3a36abd9, 
     65          	0x0aadc084, 0x0e610e6e, 0x12560c1d, 0x168523cf, 
     66          	0x1ae89f99, 0x1f7c03a4, 0x243bae49, 0x29249c67, 
     67          	0x2e34420f, 0x33686f85, 0x38bf3dff, 0x3e370182, },
     68          
     69          {	0x00000000, 0x0b504f33, 0x1c823e07, 0x30f39a55, 
     70          	0x08facd62, 0x0c176319, 0x0f6b3522, 0x12efe2ad, 
     71          	0x16a09e66, 0x1a79a317, 0x1e77e301, 0x2298d5b4, 
     72          	0x26da56fc, 0x2b3a902a, 0x2fb7e7e7, 0x3450f650, },
     73          
     74          {	0x00000000, 0x09837f05, 0x17f910d7, 0x2929c7a9, 
     75          	0x078d0dfa, 0x0a2ae661, 0x0cf73154, 0x0fec91cb, 
     76          	0x1306fe0a, 0x16434a6c, 0x199ee595, 0x1d17ae3d, 
     77          	0x20abd76a, 0x2459d551, 0x28204fbb, 0x2bfe1808, },
     78          };
     79          
     80          /* pow(j,4/3) for j=16..63, Q23 format */
     81          static const int pow43[] = {
     82          	0x1428a2fa, 0x15db1bd6, 0x1796302c, 0x19598d85, 
     83          	0x1b24e8bb, 0x1cf7fcfa, 0x1ed28af2, 0x20b4582a, 
     84          	0x229d2e6e, 0x248cdb55, 0x26832fda, 0x28800000, 
     85          	0x2a832287, 0x2c8c70a8, 0x2e9bc5d8, 0x30b0ff99, 
     86          	0x32cbfd4a, 0x34eca001, 0x3712ca62, 0x393e6088, 
     87          	0x3b6f47e0, 0x3da56717, 0x3fe0a5fc, 0x4220ed72, 
     88          	0x44662758, 0x46b03e7c, 0x48ff1e87, 0x4b52b3f3, 
     89          	0x4daaebfd, 0x5007b497, 0x5268fc62, 0x54ceb29c, 
     90          	0x5738c721, 0x59a72a59, 0x5c19cd35, 0x5e90a129, 
     91          	0x610b9821, 0x638aa47f, 0x660db90f, 0x6894c90b, 
     92          	0x6b1fc80c, 0x6daeaa0d, 0x70416360, 0x72d7e8b0, 
     93          	0x75722ef9, 0x78102b85, 0x7ab1d3ec, 0x7d571e09, 
     94          };
     95          
     96          /* sqrt(0.5) in Q31 format */
     97          #define SQRTHALF 0x5a82799a
     98          
     99          /*
    100           * Minimax polynomial approximation to pow(x, 4/3), over the range
    101           *  poly43lo: x = [0.5, 0.7071]
    102           *  poly43hi: x = [0.7071, 1.0]
    103           *
    104           * Relative error < 1E-7
    105           * Coefs are scaled by 4, 2, 1, 0.5, 0.25
    106           */
    107          static const int poly43lo[5] = { 0x29a0bda9, 0xb02e4828, 0x5957aa1b, 0x236c498d, 0xff581859 };
    108          static const int poly43hi[5] = { 0x10852163, 0xd333f6a4, 0x46e9408b, 0x27c2cef0, 0xfef577b4 };
    109          
    110          /* pow(2, i*4/3) as exp and frac */
    111          static const int pow2exp[8]  = { 14, 13, 11, 10, 9, 7, 6, 5 };
    112          
    113          static const int pow2frac[8] = {
    114          	0x6597fa94, 0x50a28be6, 0x7fffffff, 0x6597fa94, 
    115          	0x50a28be6, 0x7fffffff, 0x6597fa94, 0x50a28be6
    116          };
    117          
    118          /**************************************************************************************
    119           * Function:    DequantBlock
    120           *
    121           * Description: Ken's highly-optimized, low memory dequantizer performing the operation
    122           *              y = pow(x, 4.0/3.0) * pow(2, 25 - scale/4.0)
    123           *
    124           * Inputs:      input buffer of decode Huffman codewords (signed-magnitude)
    125           *              output buffer of same length (in-place (outbuf = inbuf) is allowed)
    126           *              number of samples
    127           *              
    128           * Outputs:     dequantized samples in Q25 format
    129           *
    130           * Return:      bitwise-OR of the unsigned outputs (for guard bit calculations)
    131           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    132          static int DequantBlock(int *inbuf, int *outbuf, int num, int scale)
    133          {
   \                     DequantBlock:
   \   00000000   F34F2DE9           PUSH     {R0,R1,R4-R11,LR}
    134          	int tab4[4];
    135          	int scalef, scalei, shift;
    136          	int sx, x, y;
    137          	int mask = 0;
    138          	const int *tab16, *coef;
    139          
    140          	tab16 = pow43_14[scale & 0x3];
   \   00000004   F0619FE5           LDR      R6,??DequantBlock_0  ;; pow14
   \   00000008   18D04DE2           SUB      SP,SP,#+24
   \   0000000C   031003E2           AND      R1,R3,#0x3
   \   00000010   011386E0           ADD      R1,R6,R1, LSL #+6
   \   00000014   441F81E2           ADD      R1,R1,#+272
   \   00000018   00108DE5           STR      R1,[SP, #+0]
    141          	scalef = pow14[scale & 0x3];
   \   0000001C   031003E2           AND      R1,R3,#0x3
   \   00000020   011196E7           LDR      R1,[R6, +R1, LSL #+2]
   \   00000024   0240A0E1           MOV      R4,R2
   \   00000028   0050A0E3           MOV      R5,#+0
   \   0000002C   04108DE5           STR      R1,[SP, #+4]
    142          	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
   \   00000030   4371A0E1           ASR      R7,R3,#+2
   \   00000034   1F0057E3           CMP      R7,#+31
   \   00000038   1F70A0A3           MOVGE    R7,#+31
    143          
    144          	/* cache first 4 values */
    145          	shift = MIN(scalei + 3, 31);
   \   0000003C   031087E2           ADD      R1,R7,#+3
   \   00000040   1F0051E3           CMP      R1,#+31
   \   00000044   190000AA           BGE      ??DequantBlock_1
    146          	shift = MAX(shift, 0);
   \   00000048   010051E3           CMP      R1,#+1
   \   0000004C   0010A0B3           MOVLT    R1,#+0
    147          	tab4[0] = 0;
   \                     ??DequantBlock_2:
   \   00000050   0020A0E3           MOV      R2,#+0
   \   00000054   08208DE5           STR      R2,[SP, #+8]
    148          	tab4[1] = tab16[1] >> shift;
   \   00000058   00209DE5           LDR      R2,[SP, #+0]
   \   0000005C   042092E5           LDR      R2,[R2, #+4]
   \   00000060   5221A0E1           ASR      R2,R2,R1
   \   00000064   0C208DE5           STR      R2,[SP, #+12]
    149          	tab4[2] = tab16[2] >> shift;
   \   00000068   00209DE5           LDR      R2,[SP, #+0]
   \   0000006C   082092E5           LDR      R2,[R2, #+8]
   \   00000070   5221A0E1           ASR      R2,R2,R1
   \   00000074   10208DE5           STR      R2,[SP, #+16]
    150          	tab4[3] = tab16[3] >> shift;
   \   00000078   00209DE5           LDR      R2,[SP, #+0]
   \   0000007C   0C2092E5           LDR      R2,[R2, #+12]
   \   00000080   5211A0E1           ASR      R1,R2,R1
   \   00000084   14108DE5           STR      R1,[SP, #+20]
    151          
    152          	do {
    153          
    154          		sx = *inbuf++;
   \                     ??DequantBlock_3:
   \   00000088   18109DE5           LDR      R1,[SP, #+24]
   \   0000008C   ........           LDR      R8,[R1], #+4
   \   00000090   18108DE5           STR      R1,[SP, #+24]
    155          		x = sx & 0x7fffffff;	/* sx = sign|mag */
   \   00000094   8800A0E1           LSL      R0,R8,#+1
   \   00000098   A090A0E1           LSR      R9,R0,#+1
    156          
    157          		if (x < 4) {
   \   0000009C   040059E3           CMP      R9,#+4
   \   000000A0   040000AA           BGE      ??DequantBlock_4
    158          
    159          			y = tab4[x];
   \   000000A4   08008DE2           ADD      R0,SP,#+8
   \   000000A8   090190E7           LDR      R0,[R0, +R9, LSL #+2]
   \   000000AC   460000EA           B        ??DequantBlock_5
    160          
    161          		} else if (x < 16) {
   \                     ??DequantBlock_1:
   \   000000B0   1F10A0E3           MOV      R1,#+31
   \   000000B4   E5FFFFEA           B        ??DequantBlock_2
   \                     ??DequantBlock_4:
   \   000000B8   100059E3           CMP      R9,#+16
   \   000000BC   090000AA           BGE      ??DequantBlock_6
    162          
    163          			y = tab16[x];
   \   000000C0   00009DE5           LDR      R0,[SP, #+0]
    164          			y = (scalei < 0) ? y << -scalei : y >> scalei;
   \   000000C4   000057E3           CMP      R7,#+0
   \   000000C8   090190E7           LDR      R0,[R0, +R9, LSL #+2]
   \   000000CC   0300005A           BPL      ??DequantBlock_7
   \   000000D0   0710A0E1           MOV      R1,R7
   \   000000D4   001061E2           RSB      R1,R1,#+0
   \                     ??DequantBlock_8:
   \   000000D8   1001A0E1           LSL      R0,R0,R1
   \   000000DC   3A0000EA           B        ??DequantBlock_5
   \                     ??DequantBlock_7:
   \   000000E0   5007A0E1           ASR      R0,R0,R7
   \   000000E4   380000EA           B        ??DequantBlock_5
    165          
    166          		} else {
    167          
    168          			if (x < 64) {
   \                     ??DequantBlock_6:
   \   000000E8   400059E3           CMP      R9,#+64
   \   000000EC   050000AA           BGE      ??DequantBlock_9
    169          
    170          				y = pow43[x-16];
    171          
    172          				/* fractional scale */
    173          				y = MULSHIFT32(y, scalef);
   \   000000F0   04109DE5           LDR      R1,[SP, #+4]
   \   000000F4   090186E0           ADD      R0,R6,R9, LSL #+2
   \   000000F8   100090E5           LDR      R0,[R0, #+16]
   \   000000FC   ........           _BLF     MULSHIFT32,??MULSHIFT32??rA
    174          				shift = scalei - 3;
   \   00000100   031047E2           SUB      R1,R7,#+3
   \   00000104   270000EA           B        ??DequantBlock_10
    175          
    176          			} else {
    177          
    178          				/* normalize to [0x40000000, 0x7fffffff] */
    179          				x <<= 17;
    180          				shift = 0;
    181          				if (x < 0x08000000)
    182          					x <<= 4, shift += 4;
    183          				if (x < 0x20000000)
    184          					x <<= 2, shift += 2;
    185          				if (x < 0x40000000)
    186          					x <<= 1, shift += 1;
    187          
    188          				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
   \                     ??DequantBlock_9:
   \   00000108   F0009FE5           LDR      R0,??DequantBlock_0+0x4  ;; 0x5a82799a
   \   0000010C   8998A0E1           LSL      R9,R9,#+17
   \   00000110   00A0A0E3           MOV      R10,#+0
   \   00000114   800659E3           CMP      R9,#+134217728
   \   00000118   0992A0B1           LSLLT    R9,R9,#+4
   \   0000011C   04A0A0B3           MOVLT    R10,#+4
   \   00000120   800559E3           CMP      R9,#+536870912
   \   00000124   0991A0B1           LSLLT    R9,R9,#+2
   \   00000128   02A08AB2           ADDLT    R10,R10,#+2
   \   0000012C   400459E3           CMP      R9,#+1073741824
   \   00000130   8990A0B1           LSLLT    R9,R9,#+1
   \   00000134   01A08AB2           ADDLT    R10,R10,#+1
   \   00000138   000059E1           CMP      R9,R0
   \   0000013C   84BF86B2           ADDLT    R11,R6,#+528
   \   00000140   89BF86A2           ADDGE    R11,R6,#+548
    189          
    190          				/* polynomial */
    191          				y = coef[0];
    192          				y = MULSHIFT32(y, x) + coef[1];
   \   00000144   00009BE5           LDR      R0,[R11, #+0]
   \   00000148   0910A0E1           MOV      R1,R9
   \   0000014C   ........           _BLF     MULSHIFT32,??MULSHIFT32??rA
   \   00000150   04109BE5           LDR      R1,[R11, #+4]
   \   00000154   000081E0           ADD      R0,R1,R0
    193          				y = MULSHIFT32(y, x) + coef[2];
   \   00000158   0910A0E1           MOV      R1,R9
   \   0000015C   ........           _BLF     MULSHIFT32,??MULSHIFT32??rA
   \   00000160   08109BE5           LDR      R1,[R11, #+8]
   \   00000164   000081E0           ADD      R0,R1,R0
    194          				y = MULSHIFT32(y, x) + coef[3];
   \   00000168   0910A0E1           MOV      R1,R9
   \   0000016C   ........           _BLF     MULSHIFT32,??MULSHIFT32??rA
   \   00000170   0C109BE5           LDR      R1,[R11, #+12]
   \   00000174   000081E0           ADD      R0,R1,R0
    195          				y = MULSHIFT32(y, x) + coef[4];
   \   00000178   0910A0E1           MOV      R1,R9
   \   0000017C   ........           _BLF     MULSHIFT32,??MULSHIFT32??rA
   \   00000180   10109BE5           LDR      R1,[R11, #+16]
    196          				y = MULSHIFT32(y, pow2frac[shift]) << 3;
   \   00000184   0A9186E0           ADD      R9,R6,R10, LSL #+2
   \   00000188   000081E0           ADD      R0,R1,R0
   \   0000018C   301099E5           LDR      R1,[R9, #+48]
   \   00000190   ........           _BLF     MULSHIFT32,??MULSHIFT32??rA
    197          
    198          				/* fractional scale */
    199          				y = MULSHIFT32(y, scalef);
   \   00000194   04109DE5           LDR      R1,[SP, #+4]
   \   00000198   8001A0E1           LSL      R0,R0,#+3
   \   0000019C   ........           _BLF     MULSHIFT32,??MULSHIFT32??rA
    200          				shift = scalei - pow2exp[shift];
   \   000001A0   101099E5           LDR      R1,[R9, #+16]
   \   000001A4   011047E0           SUB      R1,R7,R1
    201          			}
    202          
    203          			/* integer scale */
    204          			if (shift < 0) {
   \                     ??DequantBlock_10:
   \   000001A8   000051E3           CMP      R1,#+0
   \   000001AC   0500005A           BPL      ??DequantBlock_11
    205          				shift = -shift;
   \   000001B0   001061E2           RSB      R1,R1,#+0
    206          				if (y > (0x7fffffff >> shift))
   \   000001B4   8024E0E3           MVN      R2,#-2147483648
   \   000001B8   520150E1           CMP      R0,R2, ASR R1
   \   000001BC   C5FFFFDA           BLE      ??DequantBlock_8
    207          					y = 0x7fffffff;		/* clip */
   \   000001C0   0200A0E1           MOV      R0,R2
   \   000001C4   000000EA           B        ??DequantBlock_5
    208          				else
    209          					y <<= shift;
    210          			} else {
    211          				y >>= shift;
   \                     ??DequantBlock_11:
   \   000001C8   5001A0E1           ASR      R0,R0,R1
    212          			}
    213          		}
    214          
    215          		/* sign and store */
    216          		mask |= y;
    217          		*outbuf++ = (sx < 0) ? -y : y;
   \                     ??DequantBlock_5:
   \   000001CC   1C109DE5           LDR      R1,[SP, #+28]
   \   000001D0   055080E1           ORR      R5,R0,R5
   \   000001D4   043081E2           ADD      R3,R1,#+4
   \   000001D8   1C308DE5           STR      R3,[SP, #+28]
   \   000001DC   000058E3           CMP      R8,#+0
   \   000001E0   00006042           RSBMI    R0,R0,#+0
   \   000001E4   000081E5           STR      R0,[R1, #+0]
    218          
    219          	} while (--num);
   \   000001E8   014054E2           SUBS     R4,R4,#+1
   \   000001EC   A5FFFF1A           BNE      ??DequantBlock_3
    220          
    221          	return mask;
   \   000001F0   0500A0E1           MOV      R0,R5
   \   000001F4   20D08DE2           ADD      SP,SP,#+32
   \   000001F8   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??DequantBlock_0:
   \   000001FC   ........           DC32     pow14
   \   00000200   9A79825A           DC32     0x5a82799a
    222          }
    223          
    224          /**************************************************************************************
    225           * Function:    DequantChannel
    226           *
    227           * Description: dequantize one granule, one channel worth of decoded Huffman codewords
    228           *
    229           * Inputs:      sample buffer (decoded Huffman codewords), length = MAX_NSAMP samples
    230           *              work buffer for reordering short-block, length = MAX_REORDER_SAMPS
    231           *                samples (3 * width of largest short-block critical band)
    232           *              non-zero bound for this channel/granule
    233           *              valid FrameHeader, SideInfoSub, ScaleFactorInfoSub, and CriticalBandInfo
    234           *                structures for this channel/granule
    235           *
    236           * Outputs:     MAX_NSAMP dequantized samples in sampleBuf
    237           *              updated non-zero bound (indicating which samples are != 0 after DQ)
    238           *              filled-in cbi structure indicating start and end critical bands
    239           *
    240           * Return:      minimum number of guard bits in dequantized sampleBuf
    241           *
    242           * Notes:       dequantized samples in Q(DQ_FRACBITS_OUT) format 
    243           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    244          int DequantChannel(int *sampleBuf, int *workBuf, int *nonZeroBound, FrameHeader *fh, SideInfoSub *sis, 
    245          					ScaleFactorInfoSub *sfis, CriticalBandInfo *cbi)
    246          {
   \                     xmp3_DequantChannel:
   \   00000000   FD4F2DE9           PUSH     {R0,R2-R11,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
    247          	int i, j, w, cb;
    248          	int cbStartL, cbEndL, cbStartS, cbEndS;
                 	    ^
Warning[Pe550]: variable "cbStartL" was set but never used
    249          	int nSamps, nonZero, sfactMultiplier, gbMask;
    250          	int globalGain, gainI;
    251          	int cbMax[3];
    252          	ARRAY3 *buf;    /* short block reorder */
    253          	
    254          	/* set default start/end points for short/long blocks - will update with non-zero cb info */
    255          	if (sis->blockType == 2) {
   \   00000008   48009DE5           LDR      R0,[SP, #+72]
   \   0000000C   50509DE5           LDR      R5,[SP, #+80]
   \   00000010   140090E5           LDR      R0,[R0, #+20]
   \   00000014   0140A0E1           MOV      R4,R1
   \   00000018   020050E3           CMP      R0,#+2
   \   0000001C   0C00001A           BNE      ??xmp3_DequantChannel_0
    256          		cbStartL = 0;
    257          		if (sis->mixedBlock) { 
   \   00000020   48009DE5           LDR      R0,[SP, #+72]
   \   00000024   180090E5           LDR      R0,[R0, #+24]
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   0500000A           BEQ      ??xmp3_DequantChannel_1
    258          			cbEndL = (fh->ver == MPEG1 ? 8 : 6); 
   \   00000030   D000D3E1           LDRSB    R0,[R3, #+0]
    259          			cbStartS = 3; 
   \   00000034   0370A0E3           MOV      R7,#+3
   \   00000038   000050E3           CMP      R0,#+0
   \   0000003C   0860A003           MOVEQ    R6,#+8
   \   00000040   0660A013           MOVNE    R6,#+6
   \   00000044   040000EA           B        ??xmp3_DequantChannel_2
    260          		} else {
    261          			cbEndL = 0; 
   \                     ??xmp3_DequantChannel_1:
   \   00000048   0060A0E3           MOV      R6,#+0
    262          			cbStartS = 0;
   \   0000004C   0070A0E3           MOV      R7,#+0
   \   00000050   010000EA           B        ??xmp3_DequantChannel_2
    263          		}
    264          		cbEndS = 13;
    265          	} else {
    266          		/* long block */
    267          		cbStartL = 0;
    268          		cbEndL =   22;
   \                     ??xmp3_DequantChannel_0:
   \   00000054   1660A0E3           MOV      R6,#+22
    269          		cbStartS = 13;
   \   00000058   0D70A0E3           MOV      R7,#+13
    270          		cbEndS =   13;
    271          	}
    272          	cbMax[2] = cbMax[1] = cbMax[0] = 0;
    273          	gbMask = 0;
    274          	i = 0;
    275          
    276          	/* sfactScale = 0 --> quantizer step size = 2
    277          	 * sfactScale = 1 --> quantizer step size = sqrt(2)
    278          	 *   so sfactMultiplier = 2 or 4 (jump through globalGain by powers of 2 or sqrt(2))
    279          	 */
    280          	sfactMultiplier = 2 * (sis->sfactScale + 1);
    281          
    282          	/* offset globalGain by -2 if midSide enabled, for 1/sqrt(2) used in MidSideProc()
    283          	 *  (DequantBlock() does 0.25 * gainI so knocking it down by two is the same as 
    284          	 *   dividing every sample by sqrt(2) = multiplying by 2^-.5)
    285          	 */
    286          	globalGain = sis->globalGain;
   \                     ??xmp3_DequantChannel_2:
   \   0000005C   48009DE5           LDR      R0,[SP, #+72]
   \   00000060   0010A0E3           MOV      R1,#+0
   \   00000064   00108DE5           STR      R1,[SP, #+0]
   \   00000068   04108DE5           STR      R1,[SP, #+4]
   \   0000006C   08108DE5           STR      R1,[SP, #+8]
   \   00000070   0190A0E1           MOV      R9,R1
   \   00000074   48109DE5           LDR      R1,[SP, #+72]
   \   00000078   0080A0E3           MOV      R8,#+0
   \   0000007C   401091E5           LDR      R1,[R1, #+64]
    287          	if (fh->modeExt >> 1)
    288          		 globalGain -= 2;
    289          	globalGain += IMDCT_SCALE;		/* scale everything by sqrt(2), for fast IMDCT36 */
    290          
    291          	/* long blocks */
    292          	for (cb = 0; cb < cbEndL; cb++) {
   \   00000080   00A0A0E3           MOV      R10,#+0
   \   00000084   011081E2           ADD      R1,R1,#+1
   \   00000088   8110A0E1           LSL      R1,R1,#+1
   \   0000008C   0C108DE5           STR      R1,[SP, #+12]
   \   00000090   080090E5           LDR      R0,[R0, #+8]
   \   00000094   201093E5           LDR      R1,[R3, #+32]
   \   00000098   C110B0E1           ASRS     R1,R1,#+1
   \   0000009C   02004012           SUBNE    R0,R0,#+2
   \   000000A0   020080E2           ADD      R0,R0,#+2
   \   000000A4   14008DE5           STR      R0,[SP, #+20]
   \   000000A8   000000EA           B        ??xmp3_DequantChannel_3
   \                     ??xmp3_DequantChannel_4:
   \   000000AC   01A08AE2           ADD      R10,R10,#+1
   \                     ??xmp3_DequantChannel_3:
   \   000000B0   14109DE5           LDR      R1,[SP, #+20]
   \   000000B4   06005AE1           CMP      R10,R6
   \   000000B8   D21061E2           RSB      R1,R1,#+210
   \   000000BC   10108DE5           STR      R1,[SP, #+16]
   \   000000C0   1E0000AA           BGE      ??xmp3_DequantChannel_5
    293          
    294          		nonZero = 0;
    295          		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
   \   000000C4   20009DE5           LDR      R0,[SP, #+32]
    296          		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
   \   000000C8   4C309DE5           LDR      R3,[SP, #+76]
   \   000000CC   340090E5           LDR      R0,[R0, #+52]
   \   000000D0   D3309AE1           LDRSB    R3,[R10, +R3]
   \   000000D4   0C209DE5           LDR      R2,[SP, #+12]
   \   000000D8   8A1080E0           ADD      R1,R0,R10, LSL #+1
   \   000000DC   F210D1E1           LDRSH    R1,[R1, #+2]
   \   000000E0   8A0080E0           ADD      R0,R0,R10, LSL #+1
   \   000000E4   F000D0E1           LDRSH    R0,[R0, #+0]
   \   000000E8   00B041E0           SUB      R11,R1,R0
   \   000000EC   48009DE5           LDR      R0,[SP, #+72]
   \   000000F0   10109DE5           LDR      R1,[SP, #+16]
   \   000000F4   3C0090E5           LDR      R0,[R0, #+60]
   \   000000F8   000050E3           CMP      R0,#+0
   \   000000FC   24029F15           LDRNE    R0,??xmp3_DequantChannel_6  ;; preTab
   \   00000100   D0009A11           LDRSBNE  R0,[R10, +R0]
   \   00000104   030080E0           ADD      R0,R0,R3
   \   00000108   901223E0           MLA      R3,R0,R2,R1
    297          
    298          		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
   \   0000010C   18009DE5           LDR      R0,[SP, #+24]
   \   00000110   0B20A0E1           MOV      R2,R11
   \   00000114   090180E0           ADD      R0,R0,R9, LSL #+2
   \   00000118   0010A0E1           MOV      R1,R0
   \   0000011C   ........           BL       DequantBlock
    299          		i += nSamps;
    300          
    301          		/* update highest non-zero critical band */
    302          		if (nonZero) 
   \   00000120   000050E3           CMP      R0,#+0
    303          			cbMax[0] = cb;
   \   00000124   00A08D15           STRNE    R10,[SP, #+0]
    304          		gbMask |= nonZero;
   \   00000128   088080E1           ORR      R8,R0,R8
    305          
    306          		if (i >= *nonZeroBound) 
   \   0000012C   1C009DE5           LDR      R0,[SP, #+28]
   \   00000130   09908BE0           ADD      R9,R11,R9
   \   00000134   000090E5           LDR      R0,[R0, #+0]
   \   00000138   000059E1           CMP      R9,R0
   \   0000013C   DAFFFFBA           BLT      ??xmp3_DequantChannel_4
    307          			break;
    308          	}
    309          
    310          	/* set cbi (Type, EndS[], EndSMax will be overwritten if we proceed to do short blocks) */
    311          	cbi->cbType = 0;			/* long only */
   \                     ??xmp3_DequantChannel_5:
   \   00000140   0000A0E3           MOV      R0,#+0
   \   00000144   000085E5           STR      R0,[R5, #+0]
    312          	cbi->cbEndL  = cbMax[0];
   \   00000148   00009DE5           LDR      R0,[SP, #+0]
    313          	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
    314          	cbi->cbEndSMax = 0;
    315          
    316          	/* early exit if no short blocks */
    317          	if (cbStartS >= 12) 
   \   0000014C   0C0057E3           CMP      R7,#+12
   \   00000150   140085E5           STR      R0,[R5, #+20]
   \   00000154   0000A0E3           MOV      R0,#+0
   \   00000158   0C0085E5           STR      R0,[R5, #+12]
   \   0000015C   080085E5           STR      R0,[R5, #+8]
   \   00000160   040085E5           STR      R0,[R5, #+4]
   \   00000164   100085E5           STR      R0,[R5, #+16]
   \   00000168   0B0000BA           BLT      ??xmp3_DequantChannel_7
    318          		return CLZ(gbMask) - 1;
   \   0000016C   000058E3           CMP      R8,#+0
   \   00000170   2000A003           MOVEQ    R0,#+32
   \   00000174   6800000A           BEQ      ??xmp3_DequantChannel_8
   \   00000178   800418E3           TST      R8,#0x80000000
   \   0000017C   6600001A           BNE      ??xmp3_DequantChannel_8
   \                     ??xmp3_DequantChannel_9:
   \   00000180   010080E2           ADD      R0,R0,#+1
   \   00000184   8880A0E1           LSL      R8,R8,#+1
   \   00000188   800418E3           TST      R8,#0x80000000
   \   0000018C   FBFFFF0A           BEQ      ??xmp3_DequantChannel_9
   \   00000190   010040E2           SUB      R0,R0,#+1
   \   00000194   24D08DE2           ADD      SP,SP,#+36
   \   00000198   F08FBDE8           POP      {R4-R11,PC}
    319          	
    320          	/* short blocks */
    321          	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
   \                     ??xmp3_DequantChannel_7:
   \   0000019C   00708DE5           STR      R7,[SP, #+0]
   \   000001A0   04708DE5           STR      R7,[SP, #+4]
   \   000001A4   08708DE5           STR      R7,[SP, #+8]
    322          	for (cb = cbStartS; cb < cbEndS; cb++) {
   \   000001A8   07A0A0E1           MOV      R10,R7
    323          
    324          		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
   \                     ??xmp3_DequantChannel_10:
   \   000001AC   20009DE5           LDR      R0,[SP, #+32]
   \   000001B0   01108AE2           ADD      R1,R10,#+1
   \   000001B4   340090E5           LDR      R0,[R0, #+52]
    325          		for (w = 0; w < 3; w++) {
   \   000001B8   0070A0E3           MOV      R7,#+0
   \   000001BC   811080E0           ADD      R1,R0,R1, LSL #+1
   \   000001C0   FE12D1E1           LDRSH    R1,[R1, #+46]
   \   000001C4   8A0080E0           ADD      R0,R0,R10, LSL #+1
   \   000001C8   FE02D0E1           LDRSH    R0,[R0, #+46]
   \   000001CC   00B041E0           SUB      R11,R1,R0
    326          			nonZero =  0;
    327          			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
    328          
    329          			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
   \                     ??xmp3_DequantChannel_11:
   \   000001D0   48209DE5           LDR      R2,[SP, #+72]
   \   000001D4   4CC09DE5           LDR      R12,[SP, #+76]
   \   000001D8   18009DE5           LDR      R0,[SP, #+24]
   \   000001DC   10109DE5           LDR      R1,[SP, #+16]
   \   000001E0   072182E0           ADD      R2,R2,R7, LSL #+2
   \   000001E4   282092E5           LDR      R2,[R2, #+40]
   \   000001E8   8A308AE0           ADD      R3,R10,R10, LSL #+1
   \   000001EC   0C3083E0           ADD      R3,R3,R12
   \   000001F0   033087E0           ADD      R3,R7,R3
   \   000001F4   D7C1D3E1           LDRSB    R12,[R3, #+23]
   \   000001F8   096180E0           ADD      R6,R0,R9, LSL #+2
   \   000001FC   970B00E0           MUL      R0,R7,R11
   \   00000200   821181E0           ADD      R1,R1,R2, LSL #+3
   \   00000204   0C209DE5           LDR      R2,[SP, #+12]
   \   00000208   9C1223E0           MLA      R3,R12,R2,R1
   \   0000020C   0B20A0E1           MOV      R2,R11
   \   00000210   001184E0           ADD      R1,R4,R0, LSL #+2
   \   00000214   000186E0           ADD      R0,R6,R0, LSL #+2
   \   00000218   ........           BL       DequantBlock
    330          
    331          			/* update highest non-zero critical band */
    332          			if (nonZero)
   \   0000021C   000050E3           CMP      R0,#+0
    333          				cbMax[w] = cb;
   \   00000220   0D10A011           MOVNE    R1,SP
   \   00000224   07A18117           STRNE    R10,[R1, +R7, LSL #+2]
    334          			gbMask |= nonZero;
   \   00000228   088080E1           ORR      R8,R0,R8
    335          		}
   \   0000022C   017087E2           ADD      R7,R7,#+1
   \   00000230   030057E3           CMP      R7,#+3
   \   00000234   E5FFFFBA           BLT      ??xmp3_DequantChannel_11
    336          
    337          		/* reorder blocks */
    338          		buf = (ARRAY3 *)(sampleBuf + i);
    339          		i += 3*nSamps;
   \   00000238   8B008BE0           ADD      R0,R11,R11, LSL #+1
   \   0000023C   099080E0           ADD      R9,R0,R9
    340          		for (j = 0; j < nSamps; j++) {
   \   00000240   0000A0E3           MOV      R0,#+0
   \   00000244   01005BE3           CMP      R11,#+1
   \   00000248   0B0000AA           BGE      ??xmp3_DequantChannel_12
   \   0000024C   0C0000EA           B        ??xmp3_DequantChannel_13
    341          			buf[j][0] = workBuf[0*nSamps + j];
   \                     ??xmp3_DequantChannel_14:
   \   00000250   0C20A0E3           MOV      R2,#+12
   \   00000254   926021E0           MLA      R1,R2,R0,R6
   \   00000258   002194E7           LDR      R2,[R4, +R0, LSL #+2]
   \   0000025C   002081E5           STR      R2,[R1, #+0]
    342          			buf[j][1] = workBuf[1*nSamps + j];
   \   00000260   0B2080E0           ADD      R2,R0,R11
   \   00000264   022194E7           LDR      R2,[R4, +R2, LSL #+2]
   \   00000268   042081E5           STR      R2,[R1, #+4]
    343          			buf[j][2] = workBuf[2*nSamps + j];
   \   0000026C   8B2080E0           ADD      R2,R0,R11, LSL #+1
   \   00000270   022194E7           LDR      R2,[R4, +R2, LSL #+2]
    344          		}
   \   00000274   010080E2           ADD      R0,R0,#+1
   \   00000278   082081E5           STR      R2,[R1, #+8]
   \                     ??xmp3_DequantChannel_12:
   \   0000027C   0B0050E1           CMP      R0,R11
   \   00000280   F2FFFFBA           BLT      ??xmp3_DequantChannel_14
    345          
    346          		ASSERT(3*nSamps <= MAX_REORDER_SAMPS);
    347          
    348          		if (i >= *nonZeroBound) 
   \                     ??xmp3_DequantChannel_13:
   \   00000284   1C009DE5           LDR      R0,[SP, #+28]
   \   00000288   000090E5           LDR      R0,[R0, #+0]
   \   0000028C   000059E1           CMP      R9,R0
    349          			break;
    350          	}
   \   00000290   01A08AB2           ADDLT    R10,R10,#+1
   \   00000294   0D005AB3           CMPLT    R10,#+13
   \   00000298   C3FFFFBA           BLT      ??xmp3_DequantChannel_10
    351          
    352          	/* i = last non-zero INPUT sample processed, which corresponds to highest possible non-zero 
    353          	 *     OUTPUT sample (after reorder)
    354          	 * however, the original nzb is no longer necessarily true
    355          	 *   for each cb, buf[][] is updated with 3*nSamps samples (i increases 3*nSamps each time)
    356          	 *   (buf[j + 1][0] = 3 (input) samples ahead of buf[j][0])
    357               * so update nonZeroBound to i
    358          	 */
    359          	*nonZeroBound = i;
   \   0000029C   1C009DE5           LDR      R0,[SP, #+28]
   \   000002A0   009080E5           STR      R9,[R0, #+0]
    360          
    361          	ASSERT(*nonZeroBound <= MAX_NSAMP);
    362          
    363          	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
   \   000002A4   48009DE5           LDR      R0,[SP, #+72]
   \   000002A8   180090E5           LDR      R0,[R0, #+24]
   \   000002AC   000050E3           CMP      R0,#+0
   \   000002B0   0200A013           MOVNE    R0,#+2
   \   000002B4   0100A003           MOVEQ    R0,#+1
   \   000002B8   000085E5           STR      R0,[R5, #+0]
    364          
    365          	cbi->cbEndS[0] = cbMax[0];
   \   000002BC   00009DE5           LDR      R0,[SP, #+0]
   \   000002C0   040085E5           STR      R0,[R5, #+4]
    366          	cbi->cbEndS[1] = cbMax[1];
   \   000002C4   04009DE5           LDR      R0,[SP, #+4]
   \   000002C8   080085E5           STR      R0,[R5, #+8]
    367          	cbi->cbEndS[2] = cbMax[2];
   \   000002CC   08109DE5           LDR      R1,[SP, #+8]
   \   000002D0   0C1085E5           STR      R1,[R5, #+12]
    368          
    369          	cbi->cbEndSMax = cbMax[0];
   \   000002D4   00209DE5           LDR      R2,[SP, #+0]
   \   000002D8   102085E5           STR      R2,[R5, #+16]
    370          	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[1]);
   \   000002DC   020050E1           CMP      R0,R2
   \   000002E0   0200A0B1           MOVLT    R0,R2
   \   000002E4   100085E5           STR      R0,[R5, #+16]
    371          	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
   \   000002E8   000051E1           CMP      R1,R0
   \   000002EC   0010A0B1           MOVLT    R1,R0
   \   000002F0   101085E5           STR      R1,[R5, #+16]
    372          
    373          	return CLZ(gbMask) - 1;
   \   000002F4   000058E3           CMP      R8,#+0
   \   000002F8   2000A003           MOVEQ    R0,#+32
   \   000002FC   0600000A           BEQ      ??xmp3_DequantChannel_8
   \   00000300   0000A0E3           MOV      R0,#+0
   \   00000304   800418E3           TST      R8,#0x80000000
   \   00000308   0300001A           BNE      ??xmp3_DequantChannel_8
   \                     ??xmp3_DequantChannel_15:
   \   0000030C   010080E2           ADD      R0,R0,#+1
   \   00000310   8880A0E1           LSL      R8,R8,#+1
   \   00000314   800418E3           TST      R8,#0x80000000
   \   00000318   FBFFFF0A           BEQ      ??xmp3_DequantChannel_15
   \                     ??xmp3_DequantChannel_8:
   \   0000031C   010040E2           SUB      R0,R0,#+1
   \   00000320   24D08DE2           ADD      SP,SP,#+36
   \   00000324   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??xmp3_DequantChannel_6:
   \   00000328   ........           DC32     preTab
    374          }
    375          

   Maximum stack usage in bytes:

     Function            CSTACK
     --------            ------
     DequantBlock           68
     xmp3_DequantChannel    72


   Segment part sizes:

     Function/Label      Bytes
     --------------      -----
     preTab                24
     pow14                568
     DequantBlock         516
     xmp3_DequantChannel  812
      Others               20

 
 1 348 bytes in segment CODE
   592 bytes in segment DATA_C
 
 1 328 bytes of CODE  memory (+ 20 bytes shared)
   592 bytes of CONST memory

Errors: none
Warnings: 2
