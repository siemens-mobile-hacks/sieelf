##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    13/Aug/2008  18:45:24 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\huffman.c     #
#    Command line    =  G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\huffman.c     #
#                       -lC G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\    #
#                       -lA G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\    #
#                       -o G:\Arm\SieELF\cbn_SRC\MP3Player\Release\Obj\ -s9  #
#                       --no_unroll --cpu_mode arm --endian little --cpu     #
#                       ARM926EJ-S --stack_align 4 --interwork -e            #
#                       --char_is_signed --fpu None -I                       #
#                       D:\ewarm_442\arm\INC\ --inline_threshold=2           #
#    List file       =  G:\Arm\SieELF\cbn_SRC\MP3Player\Release\List\huffman #
#                       .lst                                                 #
#    Object file     =  G:\Arm\SieELF\cbn_SRC\MP3Player\Release\Obj\huffman. #
#                       r79                                                  #
#                                                                            #
#                                                                            #
##############################################################################

G:\Arm\SieELF\cbn_SRC\MP3Player\mp3dec\huffman.c
      1          /* ***** BEGIN LICENSE BLOCK ***** 
                                                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2           * Version: RCSL 1.0/RPSL 1.0 
      3           *  
      4           * Portions Copyright (c) 1995-2002 RealNetworks, Inc. All Rights Reserved. 
      5           *      
      6           * The contents of this file, and the files included with this file, are 
      7           * subject to the current version of the RealNetworks Public Source License 
      8           * Version 1.0 (the "RPSL") available at 
      9           * http://www.helixcommunity.org/content/rpsl unless you have licensed 
     10           * the file under the RealNetworks Community Source License Version 1.0 
     11           * (the "RCSL") available at http://www.helixcommunity.org/content/rcsl, 
     12           * in which case the RCSL will apply. You may also obtain the license terms 
     13           * directly from RealNetworks.  You may not use this file except in 
     14           * compliance with the RPSL or, if you have a valid RCSL with RealNetworks 
     15           * applicable to this file, the RCSL.  Please see the applicable RPSL or 
     16           * RCSL for the rights, obligations and limitations governing use of the 
     17           * contents of the file.  
     18           *  
     19           * This file is part of the Helix DNA Technology. RealNetworks is the 
     20           * developer of the Original Code and owns the copyrights in the portions 
     21           * it created. 
     22           *  
     23           * This file, and the files included with this file, is distributed and made 
     24           * available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER 
     25           * EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS ALL SUCH WARRANTIES, 
     26           * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS 
     27           * FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. 
     28           * 
     29           * Technology Compatibility Kit Test Suite(s) Location: 
     30           *    http://www.helixcommunity.org/content/tck 
     31           * 
     32           * Contributor(s): 
     33           *  
     34           * ***** END LICENSE BLOCK ***** */ 
     35          
     36          /**************************************************************************************
     37           * Fixed-point MP3 decoder
     38           * Jon Recker (jrecker@real.com), Ken Cooke (kenc@real.com)
     39           * July 2003
     40           *
     41           * huffman.c - Huffman decoding of transform coefficients
     42           **************************************************************************************/
     43          
     44          #include "coder.h"
     45          
     46          /* helper macros - see comments in hufftabs.c about the format of the huffman tables */
     47          #define GetMaxbits(x)   ((int)( (((unsigned short)(x)) >>  0) & 0x000f))
     48          #define GetHLen(x)      ((int)( (((unsigned short)(x)) >> 12) & 0x000f))
     49          #define GetCWY(x)       ((int)( (((unsigned short)(x)) >>  8) & 0x000f))
     50          #define GetCWX(x)       ((int)( (((unsigned short)(x)) >>  4) & 0x000f))
     51          #define GetSignBits(x)  ((int)( (((unsigned short)(x)) >>  0) & 0x000f))
     52          
     53          #define GetHLenQ(x)     ((int)( (((unsigned char)(x)) >> 4) & 0x0f))
     54          #define GetCWVQ(x)      ((int)( (((unsigned char)(x)) >> 3) & 0x01))
     55          #define GetCWWQ(x)      ((int)( (((unsigned char)(x)) >> 2) & 0x01))
     56          #define GetCWXQ(x)      ((int)( (((unsigned char)(x)) >> 1) & 0x01))
     57          #define GetCWYQ(x)      ((int)( (((unsigned char)(x)) >> 0) & 0x01))
     58          
     59          /* apply sign of s to the positive number x (save in MSB, will do two's complement in dequant) */
     60          #define ApplySign(x, s)	{ (x) |= ((s) & 0x80000000); }
     61          
     62          /**************************************************************************************
     63           * Function:    DecodeHuffmanPairs
     64           *
     65           * Description: decode 2-way vector Huffman codes in the "bigValues" region of spectrum
     66           *
     67           * Inputs:      valid BitStreamInfo struct, pointing to start of pair-wise codes
     68           *              pointer to xy buffer to received decoded values
     69           *              number of codewords to decode
     70           *              index of Huffman table to use
     71           *              number of bits remaining in bitstream
     72           *
     73           * Outputs:     pairs of decoded coefficients in vwxy
     74           *              updated BitStreamInfo struct
     75           *
     76           * Return:      number of bits used, or -1 if out of bits
     77           *
     78           * Notes:       assumes that nVals is an even number
     79           *              si_huff.bit tests every Huffman codeword in every table (though not
     80           *                necessarily all linBits outputs for x,y > 15)
     81           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
     82          static int DecodeHuffmanPairs(int *xy, int nVals, int tabIdx, int bitsLeft, unsigned char *buf, int bitOffset)
     83          {
   \                     DecodeHuffmanPairs:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   0CD04DE2           SUB      SP,SP,#+12
   \   00000008   30C09DE5           LDR      R12,[SP, #+48]
   \   0000000C   34409DE5           LDR      R4,[SP, #+52]
     84          	int i, x, y;
     85          	int cachedBits, padBits, len, startBits, linBits, maxBits, minBits;
     86          	HuffTabType tabType;
     87          	unsigned short cw, *tBase, *tCurr;
     88          	unsigned int cache;
     89          
     90          	if(nVals <= 0) 
   \   00000010   010051E3           CMP      R1,#+1
   \   00000014   010000AA           BGE      ??DecodeHuffmanPairs_0
     91          		return 0;
   \                     ??DecodeHuffmanPairs_1:
   \   00000018   0000A0E3           MOV      R0,#+0
   \   0000001C   FE8FBDE8           POP      {R1-R11,PC}      ;; return
     92          
     93          	if (bitsLeft < 0)
   \                     ??DecodeHuffmanPairs_0:
   \   00000020   000053E3           CMP      R3,#+0
   \   00000024   0100005A           BPL      ??DecodeHuffmanPairs_2
     94          		return -1;
   \                     ??DecodeHuffmanPairs_3:
   \   00000028   0000E0E3           MVN      R0,#+0
   \   0000002C   FE8FBDE8           POP      {R1-R11,PC}
     95          	startBits = bitsLeft;
     96          
     97          	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
   \                     ??DecodeHuffmanPairs_2:
   \   00000030   BC639FE5           LDR      R6,??DecodeHuffmanPairs_4  ;; xmp3_huffTabOffset
   \   00000034   BC739FE5           LDR      R7,??DecodeHuffmanPairs_4+0x4  ;; xmp3_huffTable
     98          	linBits = huffTabLookup[tabIdx].linBits;
   \   00000038   BC539FE5           LDR      R5,??DecodeHuffmanPairs_4+0x8  ;; xmp3_huffTabLookup
   \   0000003C   08308DE5           STR      R3,[SP, #+8]
   \   00000040   026196E7           LDR      R6,[R6, +R2, LSL #+2]
   \   00000044   825185E0           ADD      R5,R5,R2, LSL #+3
   \   00000048   866087E0           ADD      R6,R7,R6, LSL #+1
   \   0000004C   04608DE5           STR      R6,[SP, #+4]
   \   00000050   002095E5           LDR      R2,[R5, #+0]
     99          	tabType = huffTabLookup[tabIdx].tabType;
   \   00000054   D450D5E1           LDRSB    R5,[R5, #+4]
    100          
    101          	ASSERT(!(nVals & 0x01));
    102          	ASSERT(tabIdx < HUFF_PAIRTABS);
    103          	ASSERT(tabIdx >= 0);
    104          	ASSERT(tabType != invalidTab);
    105          
    106          	/* initially fill cache with any partial byte */
    107          	cache = 0;
   \   00000058   0060A0E3           MOV      R6,#+0
    108          	cachedBits = (8 - bitOffset) & 0x07;
   \   0000005C   084064E2           RSB      R4,R4,#+8
   \   00000060   00508DE5           STR      R5,[SP, #+0]
   \   00000064   0050A0E3           MOV      R5,#+0
   \   00000068   077014E2           ANDS     R7,R4,#0x7
    109          	if (cachedBits)
   \   0000006C   0300000A           BEQ      ??DecodeHuffmanPairs_5
    110          		cache = (unsigned int)(*buf++) << (32 - cachedBits);
   \   00000070   ........           LDRB     R4,[R12], #+1
   \   00000074   0750A0E1           MOV      R5,R7
   \   00000078   205065E2           RSB      R5,R5,#+32
   \   0000007C   1455A0E1           LSL      R5,R4,R5
    111          	bitsLeft -= cachedBits;
    112          
    113          	if (tabType == noBits) {
   \                     ??DecodeHuffmanPairs_5:
   \   00000080   00409DE5           LDR      R4,[SP, #+0]
   \   00000084   073043E0           SUB      R3,R3,R7
   \   00000088   000054E3           CMP      R4,#+0
   \   0000008C   0700001A           BNE      ??DecodeHuffmanPairs_6
    114          		/* table 0, no data, x = y = 0 */
    115          		for (i = 0; i < nVals; i+=2) {
   \   00000090   0020A0E3           MOV      R2,#+0
   \                     ??DecodeHuffmanPairs_7:
   \   00000094   010052E1           CMP      R2,R1
   \   00000098   DEFFFFAA           BGE      ??DecodeHuffmanPairs_1
    116          			xy[i+0] = 0;
   \   0000009C   023180E0           ADD      R3,R0,R2, LSL #+2
   \   000000A0   006083E5           STR      R6,[R3, #+0]
    117          			xy[i+1] = 0;
   \   000000A4   046083E5           STR      R6,[R3, #+4]
    118          		}
   \   000000A8   022082E2           ADD      R2,R2,#+2
   \   000000AC   F8FFFFEA           B        ??DecodeHuffmanPairs_7
    119          		return 0;
    120          	} else if (tabType == oneShot) {
   \                     ??DecodeHuffmanPairs_6:
   \   000000B0   00609DE5           LDR      R6,[SP, #+0]
   \   000000B4   8044A0E3           MOV      R4,#-2147483648
   \   000000B8   010056E3           CMP      R6,#+1
   \   000000BC   4400001A           BNE      ??DecodeHuffmanPairs_8
    121          		/* single lookup, no escapes */
    122          		maxBits = GetMaxbits(tBase[0]);
   \   000000C0   04609DE5           LDR      R6,[SP, #+4]
   \   000000C4   ........           LDRH     R8,[R6], #+2
   \   000000C8   04608DE5           STR      R6,[SP, #+4]
    123          		tBase++;
    124          		padBits = 0;
   \   000000CC   0060A0E3           MOV      R6,#+0
   \   000000D0   0F8008E2           AND      R8,R8,#0xF
    125          		while (nVals > 0) {
    126          			/* refill cache - assumes cachedBits <= 16 */
    127          			if (bitsLeft >= 16) {
   \                     ??DecodeHuffmanPairs_9:
   \   000000D4   0720A0E1           MOV      R2,R7
   \   000000D8   102062E2           RSB      R2,R2,#+16
   \   000000DC   0790A0E1           MOV      R9,R7
   \   000000E0   189069E2           RSB      R9,R9,#+24
   \   000000E4   100053E3           CMP      R3,#+16
   \   000000E8   060000BA           BLT      ??DecodeHuffmanPairs_10
    128          				/* load 2 new bytes into left-justified cache */
    129          				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
   \   000000EC   ........           LDRB     R10,[R12], #+1
    130          				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
    131          				cachedBits += 16;
   \   000000F0   107087E2           ADD      R7,R7,#+16
    132          				bitsLeft -= 16;
   \   000000F4   103043E2           SUB      R3,R3,#+16
   \   000000F8   1A5985E1           ORR      R5,R5,R10, LSL R9
   \   000000FC   ........           LDRB     R9,[R12], #+1
   \   00000100   195285E1           ORR      R5,R5,R9, LSL R2
   \   00000104   0D0000EA           B        ??DecodeHuffmanPairs_11
    133          			} else {
    134          				/* last time through, pad cache with zeros and drain cache */
    135          				if (cachedBits + bitsLeft <= 0)	return -1;
   \                     ??DecodeHuffmanPairs_10:
   \   00000108   077083E0           ADD      R7,R3,R7
   \   0000010C   010057E3           CMP      R7,#+1
   \   00000110   C4FFFFBA           BLT      ??DecodeHuffmanPairs_3
    136          				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
   \   00000114   010053E3           CMP      R3,#+1
   \   00000118   ........           LDRBGE   R6,[R12], #+1
   \   0000011C   165985A1           ORRGE    R5,R5,R6, LSL R9
    137          				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
   \   00000120   090053E3           CMP      R3,#+9
   \   00000124   ........           LDRBGE   R3,[R12], #+1
    138          				cachedBits += bitsLeft;
    139          				bitsLeft = 0;
    140          
    141          				cache &= (signed int)0x80000000 >> (cachedBits - 1);
    142          				padBits = 11;
   \   00000128   0B60A0E3           MOV      R6,#+11
   \   0000012C   135285A1           ORRGE    R5,R5,R3, LSL R2
   \   00000130   012047E2           SUB      R2,R7,#+1
   \   00000134   545205E0           AND      R5,R5,R4, ASR R2
   \   00000138   0030A0E3           MOV      R3,#+0
    143          				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
   \   0000013C   0B7087E2           ADD      R7,R7,#+11
   \                     ??DecodeHuffmanPairs_11:
   \   00000140   0B0057E3           CMP      R7,#+11
   \   00000144   E2FFFFBA           BLT      ??DecodeHuffmanPairs_9
    144          			}
    145          
    146          			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
    147          			while (nVals > 0 && cachedBits >= 11 ) {
    148          				cw = tBase[cache >> (32 - maxBits)];
   \   00000148   04909DE5           LDR      R9,[SP, #+4]
   \   0000014C   0820A0E1           MOV      R2,R8
   \   00000150   202062E2           RSB      R2,R2,#+32
   \   00000154   3522A0E1           LSR      R2,R5,R2
   \   00000158   822089E0           ADD      R2,R9,R2, LSL #+1
   \   0000015C   B0A0D2E1           LDRH     R10,[R2, #+0]
    149          				len = GetHLen(cw);
    150          				cachedBits -= len;
    151          				cache <<= len;
    152          
    153          				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
   \   00000160   0F20A0E3           MOV      R2,#+15
   \   00000164   2AB6A0E1           LSR      R11,R10,#+12
   \   00000168   0B7047E0           SUB      R7,R7,R11
   \   0000016C   155BA0E1           LSL      R5,R5,R11
   \   00000170   4A9212E0           ANDS     R9,R2,R10, ASR #+4
   \   00000174   0300000A           BEQ      ??DecodeHuffmanPairs_12
   \   00000178   802405E2           AND      R2,R5,#0x80000000
   \   0000017C   099082E1           ORR      R9,R2,R9
   \   00000180   8550A0E1           LSL      R5,R5,#+1
   \   00000184   017047E2           SUB      R7,R7,#+1
    154          				y = GetCWY(cw);		if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
   \                     ??DecodeHuffmanPairs_12:
   \   00000188   0F20A0E3           MOV      R2,#+15
   \   0000018C   4AA412E0           ANDS     R10,R2,R10, ASR #+8
   \   00000190   0300000A           BEQ      ??DecodeHuffmanPairs_13
   \   00000194   802405E2           AND      R2,R5,#0x80000000
   \   00000198   0AA082E1           ORR      R10,R2,R10
   \   0000019C   8550A0E1           LSL      R5,R5,#+1
   \   000001A0   017047E2           SUB      R7,R7,#+1
    155          
    156          				/* ran out of bits - should never have consumed padBits */
    157          				if (cachedBits < padBits)
   \                     ??DecodeHuffmanPairs_13:
   \   000001A4   060057E1           CMP      R7,R6
   \   000001A8   9EFFFFBA           BLT      ??DecodeHuffmanPairs_3
    158          					return -1;
    159          
    160          				*xy++ = x;
   \   000001AC   ........           STR      R9,[R0], #+4
    161          				*xy++ = y;
   \   000001B0   ........           STR      R10,[R0], #+4
    162          				nVals -= 2;
   \   000001B4   021041E2           SUB      R1,R1,#+2
    163          			}
   \   000001B8   010051E3           CMP      R1,#+1
   \   000001BC   DFFFFFAA           BGE      ??DecodeHuffmanPairs_11
    164          		}
    165          		bitsLeft += (cachedBits - padBits);
    166          		return (startBits - bitsLeft);
   \                     ??DecodeHuffmanPairs_14:
   \   000001C0   08009DE5           LDR      R0,[SP, #+8]
   \   000001C4   030040E0           SUB      R0,R0,R3
   \   000001C8   070040E0           SUB      R0,R0,R7
   \   000001CC   000086E0           ADD      R0,R6,R0
   \   000001D0   FE8FBDE8           POP      {R1-R11,PC}
    167          	} else if (tabType == loopLinbits || tabType == loopNoLinbits) {
   \                     ??DecodeHuffmanPairs_8:
   \   000001D4   030056E3           CMP      R6,#+3
   \   000001D8   02005613           CMPNE    R6,#+2
   \   000001DC   91FFFF1A           BNE      ??DecodeHuffmanPairs_3
    168          		tCurr = tBase;
   \   000001E0   04909DE5           LDR      R9,[SP, #+4]
    169          		padBits = 0;
   \   000001E4   0060A0E3           MOV      R6,#+0
    170          		while (nVals > 0) {
    171          			/* refill cache - assumes cachedBits <= 16 */
    172          			if (bitsLeft >= 16) {
   \                     ??DecodeHuffmanPairs_15:
   \   000001E8   0780A0E1           MOV      R8,R7
   \   000001EC   108068E2           RSB      R8,R8,#+16
   \   000001F0   07A0A0E1           MOV      R10,R7
   \   000001F4   18A06AE2           RSB      R10,R10,#+24
   \   000001F8   100053E3           CMP      R3,#+16
   \   000001FC   060000BA           BLT      ??DecodeHuffmanPairs_16
    173          				/* load 2 new bytes into left-justified cache */
    174          				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
   \   00000200   ........           LDRB     R11,[R12], #+1
    175          				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
    176          				cachedBits += 16;
   \   00000204   107087E2           ADD      R7,R7,#+16
    177          				bitsLeft -= 16;
   \   00000208   103043E2           SUB      R3,R3,#+16
   \   0000020C   1B5A85E1           ORR      R5,R5,R11, LSL R10
   \   00000210   ........           LDRB     R10,[R12], #+1
   \   00000214   1A5885E1           ORR      R5,R5,R10, LSL R8
   \   00000218   2E0000EA           B        ??DecodeHuffmanPairs_17
    178          			} else {
    179          				/* last time through, pad cache with zeros and drain cache */
    180          				if (cachedBits + bitsLeft <= 0)	return -1;
   \                     ??DecodeHuffmanPairs_16:
   \   0000021C   077083E0           ADD      R7,R3,R7
   \   00000220   010057E3           CMP      R7,#+1
   \   00000224   7FFFFFBA           BLT      ??DecodeHuffmanPairs_3
    181          				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
   \   00000228   010053E3           CMP      R3,#+1
   \   0000022C   ........           LDRBGE   R6,[R12], #+1
   \   00000230   165A85A1           ORRGE    R5,R5,R6, LSL R10
    182          				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
   \   00000234   090053E3           CMP      R3,#+9
   \   00000238   ........           LDRBGE   R3,[R12], #+1
    183          				cachedBits += bitsLeft;
    184          				bitsLeft = 0;
    185          
    186          				cache &= (signed int)0x80000000 >> (cachedBits - 1);
   \   0000023C   016047E2           SUB      R6,R7,#+1
    187          				padBits = 11;
    188          				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
   \   00000240   0B7087E2           ADD      R7,R7,#+11
   \   00000244   135885A1           ORRGE    R5,R5,R3, LSL R8
   \   00000248   0030A0E3           MOV      R3,#+0
   \   0000024C   545605E0           AND      R5,R5,R4, ASR R6
   \   00000250   0B60A0E3           MOV      R6,#+11
   \   00000254   1F0000EA           B        ??DecodeHuffmanPairs_17
    189          			}
    190          
    191          			/* largest maxBits = 9, plus 2 for sign bits, so make sure cache has at least 11 bits */
    192          			while (nVals > 0 && cachedBits >= 11 ) {
    193          				maxBits = GetMaxbits(tCurr[0]);
    194          				cw = tCurr[(cache >> (32 - maxBits)) + 1];
    195          				len = GetHLen(cw);
    196          				if (!len) {
    197          					cachedBits -= maxBits;
    198          					cache <<= maxBits;
    199          					tCurr += cw;
    200          					continue;
    201          				}
    202          				cachedBits -= len;
    203          				cache <<= len;
    204          			
    205          				x = GetCWX(cw);
    206          				y = GetCWY(cw);
    207          
    208          				if (x == 15 && tabType == loopLinbits) {
    209          					minBits = linBits + 1 + (y ? 1 : 0);
    210          					if (cachedBits + bitsLeft < minBits)
    211          						return -1;
    212          					while (cachedBits < minBits) {
    213          						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
    214          						cachedBits += 8;
    215          						bitsLeft -= 8;
    216          					}
    217          					if (bitsLeft < 0) {
    218          						cachedBits += bitsLeft;
    219          						bitsLeft = 0;
    220          						cache &= (signed int)0x80000000 >> (cachedBits - 1);
    221          					}
    222          					x += (int)(cache >> (32 - linBits));
    223          					cachedBits -= linBits;
    224          					cache <<= linBits;
    225          				}
    226          				if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
    227          
    228          				if (y == 15 && tabType == loopLinbits) {
    229          					minBits = linBits + 1;
    230          					if (cachedBits + bitsLeft < minBits)
    231          						return -1;
    232          					while (cachedBits < minBits) {
    233          						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
   \                     ??DecodeHuffmanPairs_18:
   \   00000258   ........           LDRB     R10,[R12], #+1
   \   0000025C   07E0A0E1           MOV      LR,R7
   \   00000260   18E06EE2           RSB      LR,LR,#+24
   \   00000264   1A5E85E1           ORR      R5,R5,R10, LSL LR
    234          						cachedBits += 8;
   \   00000268   087087E2           ADD      R7,R7,#+8
    235          						bitsLeft -= 8;
   \   0000026C   083043E2           SUB      R3,R3,#+8
    236          					}
   \                     ??DecodeHuffmanPairs_19:
   \   00000270   080057E1           CMP      R7,R8
   \   00000274   F7FFFFBA           BLT      ??DecodeHuffmanPairs_18
    237          					if (bitsLeft < 0) {
   \   00000278   000053E3           CMP      R3,#+0
   \   0000027C   0300005A           BPL      ??DecodeHuffmanPairs_20
    238          						cachedBits += bitsLeft;
   \   00000280   077083E0           ADD      R7,R3,R7
    239          						bitsLeft = 0;
    240          						cache &= (signed int)0x80000000 >> (cachedBits - 1);
   \   00000284   018047E2           SUB      R8,R7,#+1
   \   00000288   545805E0           AND      R5,R5,R4, ASR R8
   \   0000028C   0030A0E3           MOV      R3,#+0
    241          					}
    242          					y += (int)(cache >> (32 - linBits));
   \                     ??DecodeHuffmanPairs_20:
   \   00000290   0F80A0E3           MOV      R8,#+15
   \   00000294   35AB88E0           ADD      R10,R8,R5, LSR R11
    243          					cachedBits -= linBits;
   \   00000298   027047E0           SUB      R7,R7,R2
    244          					cache <<= linBits;
   \   0000029C   1552A0E1           LSL      R5,R5,R2
    245          				}
    246          				if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
   \                     ??DecodeHuffmanPairs_21:
   \   000002A0   00005AE3           CMP      R10,#+0
   \   000002A4   0300000A           BEQ      ??DecodeHuffmanPairs_22
   \                     ??DecodeHuffmanPairs_23:
   \   000002A8   808405E2           AND      R8,R5,#0x80000000
   \   000002AC   0AA088E1           ORR      R10,R8,R10
   \   000002B0   8550A0E1           LSL      R5,R5,#+1
   \   000002B4   017047E2           SUB      R7,R7,#+1
    247          
    248          				/* ran out of bits - should never have consumed padBits */
    249          				if (cachedBits < padBits)
   \                     ??DecodeHuffmanPairs_22:
   \   000002B8   060057E1           CMP      R7,R6
   \   000002BC   59FFFFBA           BLT      ??DecodeHuffmanPairs_3
    250          					return -1;
    251          
    252          				*xy++ = x;
   \   000002C0   ........           STR      R9,[R0], #+4
    253          				*xy++ = y;
   \   000002C4   ........           STR      R10,[R0], #+4
    254          				nVals -= 2;
    255          				tCurr = tBase;
   \   000002C8   04909DE5           LDR      R9,[SP, #+4]
   \   000002CC   021041E2           SUB      R1,R1,#+2
   \   000002D0   010051E3           CMP      R1,#+1
   \   000002D4   B9FFFFBA           BLT      ??DecodeHuffmanPairs_14
   \                     ??DecodeHuffmanPairs_17:
   \   000002D8   0B0057E3           CMP      R7,#+11
   \   000002DC   C1FFFFBA           BLT      ??DecodeHuffmanPairs_15
   \   000002E0   B080D9E1           LDRH     R8,[R9, #+0]
   \   000002E4   0F8008E2           AND      R8,R8,#0xF
   \   000002E8   08A0A0E1           MOV      R10,R8
   \   000002EC   20A06AE2           RSB      R10,R10,#+32
   \   000002F0   35AAA0E1           LSR      R10,R5,R10
   \   000002F4   8AA089E0           ADD      R10,R9,R10, LSL #+1
   \   000002F8   B2A0DAE1           LDRH     R10,[R10, #+2]
   \   000002FC   0AB0A0E1           MOV      R11,R10
   \   00000300   2BB6B0E1           LSRS     R11,R11,#+12
   \   00000304   0300001A           BNE      ??DecodeHuffmanPairs_24
   \   00000308   087047E0           SUB      R7,R7,R8
   \   0000030C   1558A0E1           LSL      R5,R5,R8
   \   00000310   8A9089E0           ADD      R9,R9,R10, LSL #+1
   \   00000314   EFFFFFEA           B        ??DecodeHuffmanPairs_17
   \                     ??DecodeHuffmanPairs_24:
   \   00000318   0B7047E0           SUB      R7,R7,R11
   \   0000031C   155BA0E1           LSL      R5,R5,R11
   \   00000320   0F80A0E3           MOV      R8,#+15
   \   00000324   4A9208E0           AND      R9,R8,R10, ASR #+4
   \   00000328   4AA408E0           AND      R10,R8,R10, ASR #+8
   \   0000032C   20B062E2           RSB      R11,R2,#+32
   \   00000330   0F0059E3           CMP      R9,#+15
   \   00000334   1D00001A           BNE      ??DecodeHuffmanPairs_25
   \   00000338   00809DE5           LDR      R8,[SP, #+0]
   \   0000033C   030058E3           CMP      R8,#+3
   \   00000340   1C00001A           BNE      ??DecodeHuffmanPairs_26
   \   00000344   00005AE3           CMP      R10,#+0
   \   00000348   0180A013           MOVNE    R8,#+1
   \   0000034C   0080A003           MOVEQ    R8,#+0
   \   00000350   028088E0           ADD      R8,R8,R2
   \   00000354   018088E2           ADD      R8,R8,#+1
   \   00000358   079083E0           ADD      R9,R3,R7
   \   0000035C   080059E1           CMP      R9,R8
   \   00000360   060000AA           BGE      ??DecodeHuffmanPairs_27
   \   00000364   200000EA           B        ??DecodeHuffmanPairs_28
   \                     ??DecodeHuffmanPairs_29:
   \   00000368   ........           LDRB     R9,[R12], #+1
   \   0000036C   07E0A0E1           MOV      LR,R7
   \   00000370   18E06EE2           RSB      LR,LR,#+24
   \   00000374   195E85E1           ORR      R5,R5,R9, LSL LR
   \   00000378   087087E2           ADD      R7,R7,#+8
   \   0000037C   083043E2           SUB      R3,R3,#+8
   \                     ??DecodeHuffmanPairs_27:
   \   00000380   080057E1           CMP      R7,R8
   \   00000384   F7FFFFBA           BLT      ??DecodeHuffmanPairs_29
   \   00000388   000053E3           CMP      R3,#+0
   \   0000038C   0300005A           BPL      ??DecodeHuffmanPairs_30
   \   00000390   077083E0           ADD      R7,R3,R7
   \   00000394   018047E2           SUB      R8,R7,#+1
   \   00000398   545805E0           AND      R5,R5,R4, ASR R8
   \   0000039C   0030A0E3           MOV      R3,#+0
   \                     ??DecodeHuffmanPairs_30:
   \   000003A0   0F80A0E3           MOV      R8,#+15
   \   000003A4   359B88E0           ADD      R9,R8,R5, LSR R11
   \   000003A8   027047E0           SUB      R7,R7,R2
   \   000003AC   1552A0E1           LSL      R5,R5,R2
   \                     ??DecodeHuffmanPairs_25:
   \   000003B0   000059E3           CMP      R9,#+0
   \   000003B4   0300000A           BEQ      ??DecodeHuffmanPairs_31
   \                     ??DecodeHuffmanPairs_26:
   \   000003B8   808405E2           AND      R8,R5,#0x80000000
   \   000003BC   099088E1           ORR      R9,R8,R9
   \   000003C0   8550A0E1           LSL      R5,R5,#+1
   \   000003C4   017047E2           SUB      R7,R7,#+1
   \                     ??DecodeHuffmanPairs_31:
   \   000003C8   0F005AE3           CMP      R10,#+15
   \   000003CC   B3FFFF1A           BNE      ??DecodeHuffmanPairs_21
   \   000003D0   00809DE5           LDR      R8,[SP, #+0]
   \   000003D4   030058E3           CMP      R8,#+3
   \   000003D8   B2FFFF1A           BNE      ??DecodeHuffmanPairs_23
   \   000003DC   018082E2           ADD      R8,R2,#+1
   \   000003E0   07A083E0           ADD      R10,R3,R7
   \   000003E4   08005AE1           CMP      R10,R8
   \   000003E8   A0FFFFAA           BGE      ??DecodeHuffmanPairs_19
   \                     ??DecodeHuffmanPairs_28:
   \   000003EC   0000E0E3           MVN      R0,#+0
   \   000003F0   FE8FBDE8           POP      {R1-R11,PC}
   \                     ??DecodeHuffmanPairs_4:
   \   000003F4   ........           DC32     xmp3_huffTabOffset
   \   000003F8   ........           DC32     xmp3_huffTable
   \   000003FC   ........           DC32     xmp3_huffTabLookup
    256          			}
    257          		}
    258          		bitsLeft += (cachedBits - padBits);
    259          		return (startBits - bitsLeft);
    260          	}
    261          
    262          	/* error in bitstream - trying to access unused Huffman table */
    263          	return -1;
    264          }
    265          
    266          /**************************************************************************************
    267           * Function:    DecodeHuffmanQuads
    268           *
    269           * Description: decode 4-way vector Huffman codes in the "count1" region of spectrum
    270           *
    271           * Inputs:      valid BitStreamInfo struct, pointing to start of quadword codes
    272           *              pointer to vwxy buffer to received decoded values
    273           *              maximum number of codewords to decode
    274           *              index of quadword table (0 = table A, 1 = table B)
    275           *              number of bits remaining in bitstream
    276           *
    277           * Outputs:     quadruples of decoded coefficients in vwxy
    278           *              updated BitStreamInfo struct
    279           *
    280           * Return:      index of the first "zero_part" value (index of the first sample 
    281           *                of the quad word after which all samples are 0)
    282           * 
    283           * Notes:        si_huff.bit tests every vwxy output in both quad tables
    284           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    285          static int DecodeHuffmanQuads(int *vwxy, int nVals, int tabIdx, int bitsLeft, unsigned char *buf, int bitOffset)
    286          {
   \                     DecodeHuffmanQuads:
   \   00000000   F44F2DE9           PUSH     {R2,R4-R11,LR}
   \   00000004   28C09DE5           LDR      R12,[SP, #+40]
   \   00000008   2C209DE5           LDR      R2,[SP, #+44]
    287          	int i, v, w, x, y;
    288          	int len, maxBits, cachedBits, padBits;
    289          	unsigned int cache;
    290          	unsigned char cw, *tBase;
    291          
    292          	if (bitsLeft <= 0)
   \   0000000C   010053E3           CMP      R3,#+1
    293          		return 0;
   \   00000010   0000A0B3           MOVLT    R0,#+0
   \   00000014   F28FBDB8           POPLT    {R1,R4-R11,PC}
    294          
    295          	tBase = (unsigned char *)quadTable + quadTabOffset[tabIdx];
    296          	maxBits = quadTabMaxBits[tabIdx];
   \   00000018   00409DE5           LDR      R4,[SP, #+0]
   \   0000001C   80519FE5           LDR      R5,??DecodeHuffmanQuads_0  ;; xmp3_quadTabMaxBits
    297          
    298          	/* initially fill cache with any partial byte */
    299          	cache = 0;
   \   00000020   0060A0E3           MOV      R6,#+0
   \   00000024   044195E7           LDR      R4,[R5, +R4, LSL #+2]
    300          	cachedBits = (8 - bitOffset) & 0x07;
   \   00000028   082062E2           RSB      R2,R2,#+8
   \   0000002C   077012E2           ANDS     R7,R2,#0x7
    301          	if (cachedBits)
   \   00000030   0300000A           BEQ      ??DecodeHuffmanQuads_1
    302          		cache = (unsigned int)(*buf++) << (32 - cachedBits);
   \   00000034   ........           LDRB     R2,[R12], #+1
   \   00000038   0750A0E1           MOV      R5,R7
   \   0000003C   205065E2           RSB      R5,R5,#+32
   \   00000040   1265A0E1           LSL      R6,R2,R5
    303          	bitsLeft -= cachedBits;
   \                     ??DecodeHuffmanQuads_1:
   \   00000044   073043E0           SUB      R3,R3,R7
    304          
    305          	i = padBits = 0;
   \   00000048   0050A0E3           MOV      R5,#+0
   \   0000004C   0020A0E3           MOV      R2,#+0
   \   00000050   031041E2           SUB      R1,R1,#+3
   \   00000054   3E0000EA           B        ??DecodeHuffmanQuads_2
    306          	while (i < (nVals - 3)) {
    307          		/* refill cache - assumes cachedBits <= 16 */
    308          		if (bitsLeft >= 16) {
    309          			/* load 2 new bytes into left-justified cache */
    310          			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
    311          			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
    312          			cachedBits += 16;
    313          			bitsLeft -= 16;
    314          		} else {
    315          			/* last time through, pad cache with zeros and drain cache */
    316          			if (cachedBits + bitsLeft <= 0) return i;
    317          			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
   \                     ??DecodeHuffmanQuads_3:
   \   00000058   010053E3           CMP      R3,#+1
   \   0000005C   ........           LDRBGE   R5,[R12], #+1
   \   00000060   156986A1           ORRGE    R6,R6,R5, LSL R9
    318          			if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
   \   00000064   090053E3           CMP      R3,#+9
   \   00000068   ........           LDRBGE   R3,[R12], #+1
    319          			cachedBits += bitsLeft;
    320          			bitsLeft = 0;
    321          
    322          			cache &= (signed int)0x80000000 >> (cachedBits - 1);
   \   0000006C   8054A0E3           MOV      R5,#-2147483648
   \   00000070   136886A1           ORRGE    R6,R6,R3, LSL R8
   \   00000074   0030A0E3           MOV      R3,#+0
   \   00000078   018047E2           SUB      R8,R7,#+1
   \   0000007C   556806E0           AND      R6,R6,R5, ASR R8
    323          			padBits = 10;
   \   00000080   0A50A0E3           MOV      R5,#+10
    324          			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
   \   00000084   0A7087E2           ADD      R7,R7,#+10
   \                     ??DecodeHuffmanQuads_4:
   \   00000088   0A0057E3           CMP      R7,#+10
   \   0000008C   320000BA           BLT      ??DecodeHuffmanQuads_5
    325          		}
    326          
    327          		/* largest maxBits = 6, plus 4 for sign bits, so make sure cache has at least 10 bits */
    328          		while (i < (nVals - 3) && cachedBits >= 10 ) {
    329          			cw = tBase[cache >> (32 - maxBits)];
   \   00000090   00909DE5           LDR      R9,[SP, #+0]
   \   00000094   0CA19FE5           LDR      R10,??DecodeHuffmanQuads_0+0x4  ;; xmp3_quadTabOffset
   \   00000098   0480A0E1           MOV      R8,R4
   \   0000009C   09919AE7           LDR      R9,[R10, +R9, LSL #+2]
   \   000000A0   04A19FE5           LDR      R10,??DecodeHuffmanQuads_0+0x8  ;; xmp3_quadTable
   \   000000A4   208068E2           RSB      R8,R8,#+32
   \   000000A8   0A9089E0           ADD      R9,R9,R10
   \   000000AC   368889E0           ADD      R8,R9,R6, LSR R8
   \   000000B0   0080D8E5           LDRB     R8,[R8, #+0]
    330          			len = GetHLenQ(cw);
   \   000000B4   0890A0E1           MOV      R9,R8
   \   000000B8   2992A0E1           LSR      R9,R9,#+4
    331          			cachedBits -= len;
   \   000000BC   097047E0           SUB      R7,R7,R9
    332          			cache <<= len;
   \   000000C0   1669A0E1           LSL      R6,R6,R9
    333          
    334          			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
   \   000000C4   0190A0E3           MOV      R9,#+1
   \   000000C8   C89119E0           ANDS     R9,R9,R8, ASR #+3
   \   000000CC   0300000A           BEQ      ??DecodeHuffmanQuads_6
   \   000000D0   80A406E2           AND      R10,R6,#0x80000000
   \   000000D4   09908AE1           ORR      R9,R10,R9
   \   000000D8   8660A0E1           LSL      R6,R6,#+1
   \   000000DC   017047E2           SUB      R7,R7,#+1
    335          			w = GetCWWQ(cw);	if(w) {ApplySign(w, cache); cache <<= 1; cachedBits--;}
   \                     ??DecodeHuffmanQuads_6:
   \   000000E0   01A0A0E3           MOV      R10,#+1
   \   000000E4   48A11AE0           ANDS     R10,R10,R8, ASR #+2
   \   000000E8   0300000A           BEQ      ??DecodeHuffmanQuads_7
   \   000000EC   80B406E2           AND      R11,R6,#0x80000000
   \   000000F0   0AA08BE1           ORR      R10,R11,R10
   \   000000F4   8660A0E1           LSL      R6,R6,#+1
   \   000000F8   017047E2           SUB      R7,R7,#+1
    336          			x = GetCWXQ(cw);	if(x) {ApplySign(x, cache); cache <<= 1; cachedBits--;}
   \                     ??DecodeHuffmanQuads_7:
   \   000000FC   01B0A0E3           MOV      R11,#+1
   \   00000100   C8B01BE0           ANDS     R11,R11,R8, ASR #+1
   \   00000104   0300000A           BEQ      ??DecodeHuffmanQuads_8
   \   00000108   80E406E2           AND      LR,R6,#0x80000000
   \   0000010C   0BB08EE1           ORR      R11,LR,R11
   \   00000110   8660A0E1           LSL      R6,R6,#+1
   \   00000114   017047E2           SUB      R7,R7,#+1
    337          			y = GetCWYQ(cw);	if(y) {ApplySign(y, cache); cache <<= 1; cachedBits--;}
   \                     ??DecodeHuffmanQuads_8:
   \   00000118   018018E2           ANDS     R8,R8,#0x1
   \   0000011C   0300000A           BEQ      ??DecodeHuffmanQuads_9
   \   00000120   80E406E2           AND      LR,R6,#0x80000000
   \   00000124   08808EE1           ORR      R8,LR,R8
   \   00000128   8660A0E1           LSL      R6,R6,#+1
   \   0000012C   017047E2           SUB      R7,R7,#+1
    338          
    339          			/* ran out of bits - okay (means we're done) */
    340          			if (cachedBits < padBits)
   \                     ??DecodeHuffmanQuads_9:
   \   00000130   050057E1           CMP      R7,R5
   \   00000134   180000BA           BLT      ??DecodeHuffmanQuads_10
    341          				return i;
    342          
    343          			*vwxy++ = v;
   \   00000138   ........           STR      R9,[R0], #+4
    344          			*vwxy++ = w;
   \   0000013C   ........           STR      R10,[R0], #+4
    345          			*vwxy++ = x;
   \   00000140   ........           STR      R11,[R0], #+4
    346          			*vwxy++ = y;
   \   00000144   ........           STR      R8,[R0], #+4
    347          			i += 4;
   \   00000148   042082E2           ADD      R2,R2,#+4
    348          		}
   \   0000014C   010052E1           CMP      R2,R1
   \   00000150   CCFFFFBA           BLT      ??DecodeHuffmanQuads_4
   \                     ??DecodeHuffmanQuads_2:
   \   00000154   010052E1           CMP      R2,R1
   \   00000158   0F0000AA           BGE      ??DecodeHuffmanQuads_10
   \                     ??DecodeHuffmanQuads_5:
   \   0000015C   0780A0E1           MOV      R8,R7
   \   00000160   108068E2           RSB      R8,R8,#+16
   \   00000164   0790A0E1           MOV      R9,R7
   \   00000168   189069E2           RSB      R9,R9,#+24
   \   0000016C   100053E3           CMP      R3,#+16
   \   00000170   060000BA           BLT      ??DecodeHuffmanQuads_11
   \   00000174   ........           LDRB     R10,[R12], #+1
   \   00000178   107087E2           ADD      R7,R7,#+16
   \   0000017C   103043E2           SUB      R3,R3,#+16
   \   00000180   1A6986E1           ORR      R6,R6,R10, LSL R9
   \   00000184   ........           LDRB     R9,[R12], #+1
   \   00000188   196886E1           ORR      R6,R6,R9, LSL R8
   \   0000018C   BDFFFFEA           B        ??DecodeHuffmanQuads_4
   \                     ??DecodeHuffmanQuads_11:
   \   00000190   077083E0           ADD      R7,R3,R7
   \   00000194   010057E3           CMP      R7,#+1
   \   00000198   AEFFFFAA           BGE      ??DecodeHuffmanQuads_3
   \                     ??DecodeHuffmanQuads_10:
   \   0000019C   0200A0E1           MOV      R0,R2
   \   000001A0   F28FBDE8           POP      {R1,R4-R11,PC}   ;; return
   \                     ??DecodeHuffmanQuads_0:
   \   000001A4   ........           DC32     xmp3_quadTabMaxBits
   \   000001A8   ........           DC32     xmp3_quadTabOffset
   \   000001AC   ........           DC32     xmp3_quadTable
    349          	}
    350          
    351          	/* decoded max number of quad values */
    352          	return i;
    353          }
    354          
    355          /**************************************************************************************
    356           * Function:    DecodeHuffman
    357           *
    358           * Description: decode one granule, one channel worth of Huffman codes
    359           *
    360           * Inputs:      MP3DecInfo structure filled by UnpackFrameHeader(), UnpackSideInfo(),
    361           *                and UnpackScaleFactors() (for this granule)
    362           *              buffer pointing to start of Huffman data in MP3 frame
    363           *              pointer to bit offset (0-7) indicating starting bit in buf[0]
    364           *              number of bits in the Huffman data section of the frame
    365           *                (could include padding bits)
    366           *              index of current granule and channel
    367           *
    368           * Outputs:     decoded coefficients in hi->huffDecBuf[ch] (hi pointer in mp3DecInfo)
    369           *              updated bitOffset
    370           *
    371           * Return:      length (in bytes) of Huffman codes
    372           *              bitOffset also returned in parameter (0 = MSB, 7 = LSB of 
    373           *                byte located at buf + offset)
    374           *              -1 if null input pointers, huffBlockBits < 0, or decoder runs 
    375           *                out of bits prematurely (invalid bitstream)
    376           **************************************************************************************/

   \                                 In segment CODE, align 4, keep-with-next
    377          int DecodeHuffman(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int huffBlockBits, int gr, int ch)
    378          {
   \                     xmp3_DecodeHuffman:
   \   00000000   F04F2DE9           PUSH     {R4-R11,LR}
   \   00000004   18D04DE2           SUB      SP,SP,#+24
   \   00000008   0150A0E1           MOV      R5,R1
    379          	int r1Start, r2Start, rEnd[4];	/* region boundaries */
    380          	int i, w, bitsUsed, bitsLeft;
    381          	unsigned char *startBuf = buf;
   \   0000000C   14508DE5           STR      R5,[SP, #+20]
    382          
    383          	FrameHeader *fh;
    384          	SideInfo *si;
    385          	SideInfoSub *sis;
    386          	ScaleFactorInfo *sfi;
                 	                 ^
Warning[Pe550]: variable "sfi" was set but never used
    387          	HuffmanInfo *hi;
    388          
    389          	/* validate pointers */
    390          	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || !mp3DecInfo->HuffmanInfoPS)
   \   00000010   000050E3           CMP      R0,#+0
   \   00000014   00109015           LDRNE    R1,[R0, #+0]
   \   00000018   0260A0E1           MOV      R6,R2
   \   0000001C   3C209DE5           LDR      R2,[SP, #+60]
   \   00000020   00005113           CMPNE    R1,#+0
   \   00000024   04409015           LDRNE    R4,[R0, #+4]
   \   00000028   00005413           CMPNE    R4,#+0
   \   0000002C   08709015           LDRNE    R7,[R0, #+8]
   \   00000030   00005713           CMPNE    R7,#+0
   \   00000034   0C009015           LDRNE    R0,[R0, #+12]
   \   00000038   00005013           CMPNE    R0,#+0
   \   0000003C   0200001A           BNE      ??xmp3_DecodeHuffman_0
    391          		return -1;
   \                     ??xmp3_DecodeHuffman_1:
   \   00000040   0000E0E3           MVN      R0,#+0
   \   00000044   18D08DE2           ADD      SP,SP,#+24
   \   00000048   F08FBDE8           POP      {R4-R11,PC}
    392          
    393          	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
    394          	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
    395          	sis = &si->sis[gr][ch];
   \                     ??xmp3_DecodeHuffman_0:
   \   0000004C   40709DE5           LDR      R7,[SP, #+64]
   \   00000050   4880A0E3           MOV      R8,#+72
   \   00000054   9090A0E3           MOV      R9,#+144
   \   00000058   994222E0           MLA      R2,R9,R2,R4
    396          	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));
    397          	hi = (HuffmanInfo*)(mp3DecInfo->HuffmanInfoPS);
   \   0000005C   00008DE5           STR      R0,[SP, #+0]
   \   00000060   982722E0           MLA      R2,R8,R7,R2
    398          
    399          	if (huffBlockBits < 0)
   \   00000064   000053E3           CMP      R3,#+0
   \   00000068   287082E2           ADD      R7,R2,#+40
   \   0000006C   F3FFFF4A           BMI      ??xmp3_DecodeHuffman_1
    400          		return -1;
    401          
    402          	/* figure out region boundaries (the first 2*bigVals coefficients divided into 3 regions) */
    403          	if (sis->winSwitchFlag && sis->blockType == 2) {
   \   00000070   102097E5           LDR      R2,[R7, #+16]
   \   00000074   340091E5           LDR      R0,[R1, #+52]
   \   00000078   000052E3           CMP      R2,#+0
   \   0000007C   1C00000A           BEQ      ??xmp3_DecodeHuffman_2
   \   00000080   142097E5           LDR      R2,[R7, #+20]
   \   00000084   020052E3           CMP      R2,#+2
   \   00000088   1900001A           BNE      ??xmp3_DecodeHuffman_2
    404          		if (sis->mixedBlock == 0) {
   \   0000008C   182097E5           LDR      R2,[R7, #+24]
   \   00000090   000052E3           CMP      R2,#+0
   \   00000094   0800001A           BNE      ??xmp3_DecodeHuffman_3
    405          			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
   \   00000098   341097E5           LDR      R1,[R7, #+52]
   \   0000009C   C4219FE5           LDR      R2,??xmp3_DecodeHuffman_4  ;; 0x55555556
   \   000000A0   011081E2           ADD      R1,R1,#+1
   \   000000A4   9241C8E0           SMULL    R4,R8,R2,R1
   \   000000A8   A11F88E0           ADD      R1,R8,R1, LSR #+31
   \   000000AC   810080E0           ADD      R0,R0,R1, LSL #+1
   \   000000B0   FE02D0E1           LDRSH    R0,[R0, #+46]
   \   000000B4   801080E0           ADD      R1,R0,R0, LSL #+1
   \   000000B8   0B0000EA           B        ??xmp3_DecodeHuffman_5
    406          		} else {
    407          			if (fh->ver == MPEG1) {
   \                     ??xmp3_DecodeHuffman_3:
   \   000000BC   D010D1E1           LDRSB    R1,[R1, #+0]
   \   000000C0   000051E3           CMP      R1,#+0
   \   000000C4   0300001A           BNE      ??xmp3_DecodeHuffman_6
    408          				r1Start = fh->sfBand->l[sis->region0Count + 1];
   \   000000C8   341097E5           LDR      R1,[R7, #+52]
   \   000000CC   810080E0           ADD      R0,R0,R1, LSL #+1
   \   000000D0   F210D0E1           LDRSH    R1,[R0, #+2]
   \   000000D4   040000EA           B        ??xmp3_DecodeHuffman_5
    409          			} else {
    410          				/* see MPEG2 spec for explanation */
    411          				w = fh->sfBand->s[4] - fh->sfBand->s[3];
    412          				r1Start = fh->sfBand->l[6] + 2*w;
   \                     ??xmp3_DecodeHuffman_6:
   \   000000D8   FC10D0E1           LDRSH    R1,[R0, #+12]
   \   000000DC   F623D0E1           LDRSH    R2,[R0, #+54]
   \   000000E0   F403D0E1           LDRSH    R0,[R0, #+52]
   \   000000E4   000042E0           SUB      R0,R2,R0
   \   000000E8   801081E0           ADD      R1,R1,R0, LSL #+1
    413          			}
    414          		}
    415          		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
   \                     ??xmp3_DecodeHuffman_5:
   \   000000EC   900FA0E3           MOV      R0,#+576
   \   000000F0   070000EA           B        ??xmp3_DecodeHuffman_7
    416          	} else {
    417          		r1Start = fh->sfBand->l[sis->region0Count + 1];
   \                     ??xmp3_DecodeHuffman_2:
   \   000000F4   341097E5           LDR      R1,[R7, #+52]
    418          		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
   \   000000F8   342097E5           LDR      R2,[R7, #+52]
   \   000000FC   384097E5           LDR      R4,[R7, #+56]
   \   00000100   811080E0           ADD      R1,R0,R1, LSL #+1
   \   00000104   F210D1E1           LDRSH    R1,[R1, #+2]
   \   00000108   022084E0           ADD      R2,R4,R2
   \   0000010C   820080E0           ADD      R0,R0,R2, LSL #+1
   \   00000110   F400D0E1           LDRSH    R0,[R0, #+4]
    419          	}
    420          
    421          	/* offset rEnd index by 1 so first region = rEnd[1] - rEnd[0], etc. */
    422          	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
   \                     ??xmp3_DecodeHuffman_7:
   \   00000114   042097E5           LDR      R2,[R7, #+4]
   \   00000118   4140A0E3           MOV      R4,#+65
   \   0000011C   804F84E3           ORR      R4,R4,#0x200
   \   00000120   820054E1           CMP      R4,R2, LSL #+1
   \   00000124   904FA0D3           MOVLE    R4,#+576
   \   00000128   0240A0C1           MOVGT    R4,R2
   \   0000012C   8440A0C1           LSLGT    R4,R4,#+1
   \   00000130   10408DE5           STR      R4,[SP, #+16]
    423          	rEnd[2] = MIN(r2Start, rEnd[3]);
   \   00000134   10809DE5           LDR      R8,[SP, #+16]
    424          	rEnd[1] = MIN(r1Start, rEnd[3]);
    425          	rEnd[0] = 0;
    426          
    427          	/* rounds up to first all-zero pair (we don't check last pair for (x,y) == (non-zero, zero)) */
    428          	hi->nonZeroBound[ch] = rEnd[3];
    429          
    430          	/* decode Huffman pairs (rEnd[i] are always even numbers) */
    431          	bitsLeft = huffBlockBits;
   \   00000138   0340A0E1           MOV      R4,R3
   \   0000013C   080050E1           CMP      R0,R8
   \   00000140   0C008DB5           STRLT    R0,[SP, #+12]
   \   00000144   40009DE5           LDR      R0,[SP, #+64]
   \   00000148   0C808DA5           STRGE    R8,[SP, #+12]
   \   0000014C   080051E1           CMP      R1,R8
   \   00000150   08108DB5           STRLT    R1,[SP, #+8]
   \   00000154   0010A0E3           MOV      R1,#+0
   \   00000158   04108DE5           STR      R1,[SP, #+4]
   \   0000015C   00109DE5           LDR      R1,[SP, #+0]
   \   00000160   08808DA5           STRGE    R8,[SP, #+8]
   \   00000164   000181E0           ADD      R0,R1,R0, LSL #+2
   \   00000168   489D80E2           ADD      R9,R0,#+4608
   \   0000016C   008089E5           STR      R8,[R9, #+0]
    432          	for (i = 0; i < 3; i++) {
   \   00000170   00B0A0E3           MOV      R11,#+0
    433          		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
   \                     ??xmp3_DecodeHuffman_8:
   \   00000174   40209DE5           LDR      R2,[SP, #+64]
   \   00000178   00A09DE5           LDR      R10,[SP, #+0]
   \   0000017C   04008DE2           ADD      R0,SP,#+4
   \   00000180   0B1180E0           ADD      R1,R0,R11, LSL #+2
   \   00000184   000091E5           LDR      R0,[R1, #+0]
   \   00000188   903EA0E3           MOV      R3,#+2304
   \   0000018C   93A22AE0           MLA      R10,R3,R2,R10
   \   00000190   002096E5           LDR      R2,[R6, #+0]
   \   00000194   0430A0E1           MOV      R3,R4
   \   00000198   04002DE9           PUSH     {R2}
   \   0000019C   0520A0E1           MOV      R2,R5
   \   000001A0   04002DE9           PUSH     {R2}
   \   000001A4   041091E5           LDR      R1,[R1, #+4]
   \   000001A8   0B2187E0           ADD      R2,R7,R11, LSL #+2
   \   000001AC   1C2092E5           LDR      R2,[R2, #+28]
   \   000001B0   001041E0           SUB      R1,R1,R0
   \   000001B4   00018AE0           ADD      R0,R10,R0, LSL #+2
   \   000001B8   ........           BL       DecodeHuffmanPairs
    434          		if (bitsUsed < 0 || bitsUsed > bitsLeft)	/* error - overran end of bitstream */
   \   000001BC   000050E3           CMP      R0,#+0
   \   000001C0   08D08DE2           ADD      SP,SP,#+8
   \   000001C4   9DFFFF4A           BMI      ??xmp3_DecodeHuffman_1
   \   000001C8   000054E1           CMP      R4,R0
   \   000001CC   9BFFFFBA           BLT      ??xmp3_DecodeHuffman_1
    435          			return -1;
    436          
    437          		/* update bitstream position */
    438          		buf += (bitsUsed + *bitOffset) >> 3;
   \   000001D0   001096E5           LDR      R1,[R6, #+0]
    439          		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
    440          		bitsLeft -= bitsUsed;
   \   000001D4   004044E0           SUB      R4,R4,R0
   \   000001D8   001081E0           ADD      R1,R1,R0
   \   000001DC   C15185E0           ADD      R5,R5,R1, ASR #+3
   \   000001E0   071001E2           AND      R1,R1,#0x7
   \   000001E4   001086E5           STR      R1,[R6, #+0]
    441          	}
   \   000001E8   01B08BE2           ADD      R11,R11,#+1
   \   000001EC   03005BE3           CMP      R11,#+3
   \   000001F0   DFFFFFBA           BLT      ??xmp3_DecodeHuffman_8
    442          
    443          	/* decode Huffman quads (if any) */
    444          	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
   \   000001F4   00B099E5           LDR      R11,[R9, #+0]
   \   000001F8   02002DE9           PUSH     {R1}
   \   000001FC   0500A0E1           MOV      R0,R5
   \   00000200   01002DE9           PUSH     {R0}
   \   00000204   442097E5           LDR      R2,[R7, #+68]
   \   00000208   0430A0E1           MOV      R3,R4
   \   0000020C   901F68E2           RSB      R1,R8,#+576
   \   00000210   08018AE0           ADD      R0,R10,R8, LSL #+2
   \   00000214   ........           BL       DecodeHuffmanQuads
   \   00000218   0B0080E0           ADD      R0,R0,R11
   \   0000021C   000089E5           STR      R0,[R9, #+0]
    445          
    446          	ASSERT(hi->nonZeroBound[ch] <= MAX_NSAMP);
    447          	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
   \   00000220   00B0A0E1           MOV      R11,R0
   \   00000224   900F5BE3           CMP      R11,#+576
   \   00000228   08D08DE2           ADD      SP,SP,#+8
   \   0000022C   040000AA           BGE      ??xmp3_DecodeHuffman_9
   \   00000230   0000A0E3           MOV      R0,#+0
    448          		hi->huffDecBuf[ch][i] = 0;
   \                     ??xmp3_DecodeHuffman_10:
   \   00000234   0B018AE7           STR      R0,[R10, +R11, LSL #+2]
   \   00000238   01B08BE2           ADD      R11,R11,#+1
   \   0000023C   900F5BE3           CMP      R11,#+576
   \   00000240   FBFFFFBA           BLT      ??xmp3_DecodeHuffman_10
    449          	
    450          	/* If bits used for 576 samples < huffBlockBits, then the extras are considered
    451          	 *  to be stuffing bits (throw away, but need to return correct bitstream position) 
    452          	 */
    453          	buf += (bitsLeft + *bitOffset) >> 3;
   \                     ??xmp3_DecodeHuffman_9:
   \   00000244   000096E5           LDR      R0,[R6, #+0]
   \   00000248   040080E0           ADD      R0,R0,R4
   \   0000024C   C05185E0           ADD      R5,R5,R0, ASR #+3
    454          	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
   \   00000250   070000E2           AND      R0,R0,#0x7
   \   00000254   000086E5           STR      R0,[R6, #+0]
    455          	
    456          	return (buf - startBuf);
   \   00000258   14009DE5           LDR      R0,[SP, #+20]
   \   0000025C   18D08DE2           ADD      SP,SP,#+24
   \   00000260   000045E0           SUB      R0,R5,R0
   \   00000264   F08FBDE8           POP      {R4-R11,PC}      ;; return
   \                     ??xmp3_DecodeHuffman_4:
   \   00000268   56555555           DC32     0x55555556
    457          }
    458          

   Maximum stack usage in bytes:

     Function           CSTACK
     --------           ------
     DecodeHuffmanPairs    48
     DecodeHuffmanQuads    40
     xmp3_DecodeHuffman    68


   Segment part sizes:

     Function/Label     Bytes
     --------------     -----
     DecodeHuffmanPairs 1024
     DecodeHuffmanQuads  432
     xmp3_DecodeHuffman  620
      Others              12

 
 2 088 bytes in segment CODE
 
 2 076 bytes of CODE memory (+ 12 bytes shared)

Errors: none
Warnings: 2
