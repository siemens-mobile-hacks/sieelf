##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION    08/Jun/2010  15:03:33 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  F:\SVN\cn\Master\ptcFileWork.c                       #
#    Command line    =  F:\SVN\cn\Master\ptcFileWork.c -D NEWSGOLD -lC       #
#                       F:\SVN\cn\Master\Release_NEWSGOLD\List\ -o           #
#                       F:\SVN\cn\Master\Release_NEWSGOLD\Obj\ -s9           #
#                       --no_unroll --no_clustering --cpu_mode arm --endian  #
#                       little --cpu ARM926EJ-S --stack_align 4 --interwork  #
#                       -e --fpu None --dlib_config "F:\software\Embedded    #
#                       Workbench 4.0 Evaluation\ARM\LIB\dl5tpainl8n.h" -I   #
#                       "F:\software\Embedded Workbench 4.0                  #
#                       Evaluation\ARM\INC\" --inline_threshold=2            #
#    List file       =  F:\SVN\cn\Master\Release_NEWSGOLD\List\ptcFileWork.l #
#                       st                                                   #
#    Object file     =  F:\SVN\cn\Master\Release_NEWSGOLD\Obj\ptcFileWork.r7 #
#                       9                                                    #
#                                                                            #
#                                                                            #
##############################################################################

F:\SVN\cn\Master\ptcFileWork.c
      1          /*
      2           * 文件名: ptcFileWork.c
      3           * 作者: BingK(binghelingxi)
      4           *
      5           * 最后修改日期: 2008.08.05
      6           *
      7           * 作用: 读取*.ptc进行初始化和写入*.ptc
      8           * 备注: WINTEL_DEBUG为使用在windows中使用编译器进行调试的条件编译项目
      9           *
     10           */
     11          
     12          #ifdef	WINTEL_DEBUG
     13          #include <stdio.h>
     14          #include <stdlib.h>
     15          #include <string.h>
     16          #include <memory.h>
     17          #else
     18          #include "..\inc\swilib.h"
     19          #include "optionMenu.h"
     20          #endif
     21          #include "getConfig.h"
     22          #include "ptcFileWork.h"
     23          #include "string.h"
     24          #include "main.h"
     25          
     26          #define X_CHAR		0x20
     27          
     28          #ifdef	WINTEL_DEBUG
     29          #define PATCH_DIR	"E:\\SRC\\SVN\\SieELF\\Master\\Patches\\"
     30          #define PTC_FOLDR	"ptc1\\"
     31          #define PTC_SIZE	(2*1024)
     32          char ptc_buf[PTC_SIZE];
     33          #define mfree free
     34          #endif
     35          
     36          #define _percent_08s	"%08s"
     37          

   \                                 In segment DATA_Z, align 4, align-sorted
     38          int ptcfilesize=0;
   \                     ptcfilesize:
   \   00000000                      DS8 4
     39          
     40          
     41          //逐个条目进行初始化

   \                                 In segment CODE, align 4, keep-with-next
     42          void initPatchItem(PATCH_ITEM *ptcitem)
     43          {
   \                     initPatchItem:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
     44          	int bpos;
     45          	PATCH_ITEM *pitem=ptcitem;
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   3080BD08           POPEQ    {R4,R5,PC}
     46          	while(pitem)
     47          	{
     48          		bpos=pitem->bytePos;
     49          		if(!pitem->itemData)
   \                     ??initPatchItem_1:
   \   0000000C   900094E5           LDR      R0,[R4, #+144]
   \   00000010   085094E5           LDR      R5,[R4, #+8]
   \   00000014   000050E3           CMP      R0,#+0
   \   00000018   8B00000A           BEQ      ??initPatchItem_2
     50          			goto NEXT_ITEM;
     51          		if(pitem->itemType==TYPE_SUBMENU)
   \   0000001C   8C1094E5           LDR      R1,[R4, #+140]
   \   00000020   0B0051E3           CMP      R1,#+11
   \   00000024   0100001A           BNE      ??initPatchItem_3
     52          		{
     53          			PATCH_SUBMENU *sitem=(PATCH_SUBMENU *)pitem->itemData;
     54          			initPatchItem(sitem->item);
   \   00000028   800090E5           LDR      R0,[R0, #+128]
   \   0000002C   F3FFFFEB           BL       initPatchItem
     55          		}
     56          		if(!bpos)
   \                     ??initPatchItem_3:
   \   00000030   000055E3           CMP      R5,#+0
   \   00000034   8400000A           BEQ      ??initPatchItem_2
     57          			goto NEXT_ITEM;
     58          		switch(pitem->itemType)
   \   00000038   ........           LDR      R2,??DataTable11  ;; ptc_buf
   \   0000003C   8CC094E5           LDR      R12,[R4, #+140]
   \   00000040   000092E5           LDR      R0,[R2, #+0]
   \   00000044   0130A0E3           MOV      R3,#+1
   \   00000048   001085E0           ADD      R1,R5,R0
   \   0000004C   900094E5           LDR      R0,[R4, #+144]
   \   00000050   02C04CE2           SUB      R12,R12,#+2
   \   00000054   13005CE3           CMP      R12,#+19
   \   00000058   7B00008A           BHI      ??initPatchItem_2
   \   0000005C   01EF8FE2           ADR      LR,??initPatchItem_0
   \   00000060   0CE0DEE7           LDRB     LR,[LR, R12]
   \   00000064   0EF18FE0           ADD      PC,PC,LR, LSL #+2
   \                     ??initPatchItem_0:
   \   00000068   040C1619           DC8      +4,+12,+22,+25
   \   0000006C   21242B32           DC8      +33,+36,+43,+50
   \   00000070   39784045           DC8      +57,+120,+64,+69
   \   00000074   4A4F6616           DC8      +74,+79,+102,+22
   \   00000078   6978566D           DC8      +105,+120,+86,+109
     59          		{
     60          		case TYPE_CHECKBOX:
     61          			{
     62          				DATA_CHECKBOX *chkbox=(DATA_CHECKBOX *)pitem->itemData;
     63          				chkbox->onoff=ptc_buf[bpos];
     64          				chkbox->onoff=(chkbox->onoff)<<(7-(chkbox->bitPos));
     65          				chkbox->onoff=(chkbox->onoff)>>7;
     66          				chkbox->onoff=(chkbox->onoff)&1;
   \                     ??initPatchItem_4:
   \   0000007C   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000080   002090E5           LDR      R2,[R0, #+0]
   \   00000084   072062E2           RSB      R2,R2,#+7
   \   00000088   1112A0E1           LSL      R1,R1,R2
   \   0000008C   011CA0E1           LSL      R1,R1,#+24
   \   00000090   A11FA0E1           LSR      R1,R1,#+31
   \   00000094   0410C0E5           STRB     R1,[R0, #+4]
     67          				break;
   \   00000098   6B0000EA           B        ??initPatchItem_2
     68          			}
     69          		case TYPE_POS:
     70          			{
     71          				DATA_POS *pos=(DATA_POS *)pitem->itemData;
     72          				short *sp=(short *)(ptc_buf+bpos);
     73          				pos->x=ptc_buf[bpos];
   \                     ??initPatchItem_5:
   \   0000009C   00C0D1E5           LDRB     R12,[R1, #+0]
   \   000000A0   B0C0C0E1           STRH     R12,[R0, #+0]
     74          				if(ptc_buf[bpos+1]==0x80)
   \   000000A4   002092E5           LDR      R2,[R2, #+0]
   \   000000A8   022085E0           ADD      R2,R5,R2
   \   000000AC   0120D2E5           LDRB     R2,[R2, #+1]
   \   000000B0   800052E3           CMP      R2,#+128
     75          					pos->off=1;
   \   000000B4   0230C005           STRBEQ   R3,[R0, #+2]
     76          			//	pos->x=*sp;
     77          				pos->y=*(sp+1);
   \   000000B8   F210D1E1           LDRSH    R1,[R1, #+2]
   \                     ??initPatchItem_6:
   \   000000BC   B410C0E1           STRH     R1,[R0, #+4]
     78          				break;
   \   000000C0   610000EA           B        ??initPatchItem_2
     79          			}
     80          		case TYPE_BYTE:
     81          			{
     82          				DATA_BYTE *dbyte=(DATA_BYTE *)pitem->itemData;
     83          				dbyte->initData=ptc_buf[bpos];
   \                     ??initPatchItem_7:
   \   000000C4   0010D1E5           LDRB     R1,[R1, #+0]
   \   000000C8   0210C0E5           STRB     R1,[R0, #+2]
     84          				break;
   \   000000CC   5E0000EA           B        ??initPatchItem_2
     85          			}
     86          		case TYPE_INT:
     87          			{
     88          				DATA_INT *dint=(DATA_INT *)pitem->itemData;
     89          				//读取INT型数据指针的是LDR指令，似乎只能是使用4字节对齐的地址，改用char型处理
     90          				char *p=(ptc_buf+bpos);
     91          				char *p1=(char *)(&dint->initData);
   \                     ??initPatchItem_8:
   \   000000D0   080080E2           ADD      R0,R0,#+8
     92          				int i=0;
   \   000000D4   0020A0E3           MOV      R2,#+0
     93          				for(;i<4;i++)
     94          					p1[i]=p[i];
   \                     ??initPatchItem_9:
   \   000000D8   0130D2E7           LDRB     R3,[R2, +R1]
   \   000000DC   0030C2E7           STRB     R3,[R2, +R0]
   \   000000E0   012082E2           ADD      R2,R2,#+1
   \   000000E4   040052E3           CMP      R2,#+4
   \   000000E8   570000AA           BGE      ??initPatchItem_2
   \   000000EC   F9FFFFEA           B        ??initPatchItem_9
     95          				break;
     96          			}
     97          		case TYPE_CBOX:
     98          			{
     99          				DATA_CBOX *cbox=(DATA_CBOX *)pitem->itemData;
    100          				cbox->initData=ptc_buf[bpos];
   \                     ??initPatchItem_10:
   \   000000F0   0010D1E5           LDRB     R1,[R1, #+0]
   \   000000F4   0010C0E5           STRB     R1,[R0, #+0]
    101          				break;
   \   000000F8   530000EA           B        ??initPatchItem_2
    102          			}
    103          		case TYPE_COLOR:
    104          			{
    105          				DATA_COLOR *color=(DATA_COLOR *)pitem->itemData;
    106          				char *p=(ptc_buf+bpos);
    107          				int i=0;
   \                     ??initPatchItem_11:
   \   000000FC   0020A0E3           MOV      R2,#+0
    108          				for(;i<4;i++)
    109          					color->color[i]=p[i];
   \                     ??initPatchItem_12:
   \   00000100   0130D2E7           LDRB     R3,[R2, +R1]
   \   00000104   0030C2E7           STRB     R3,[R2, +R0]
   \   00000108   012082E2           ADD      R2,R2,#+1
   \   0000010C   040052E3           CMP      R2,#+4
   \   00000110   4D0000AA           BGE      ??initPatchItem_2
   \   00000114   F9FFFFEA           B        ??initPatchItem_12
    110          				break;
    111          			}
    112          		case TYPE_ADDRESS:
    113          			{
    114          				DATA_ADDRESS *addr=(DATA_ADDRESS *)pitem->itemData;
    115          				//读取INT型数据指针的是LDR指令，似乎只能是使用4字节对齐的地址，改用char型处理
    116          				char *p=(ptc_buf+bpos);
    117          				char *p1=(char *)(&addr->addr);
    118          				int i=0;
   \                     ??initPatchItem_13:
   \   00000118   0020A0E3           MOV      R2,#+0
    119          				for(;i<4;i++)
    120          					p1[i]=p[i];
   \                     ??initPatchItem_14:
   \   0000011C   0130D2E7           LDRB     R3,[R2, +R1]
   \   00000120   0030C2E7           STRB     R3,[R2, +R0]
   \   00000124   012082E2           ADD      R2,R2,#+1
   \   00000128   040052E3           CMP      R2,#+4
   \   0000012C   460000AA           BGE      ??initPatchItem_2
   \   00000130   F9FFFFEA           B        ??initPatchItem_14
    121          				break;
    122          			}
    123          		case TYPE_STRING:
    124          			{
    125          				DATA_STRING *str=(DATA_STRING *)pitem->itemData;
    126          				if(str->maxlen)
   \                     ??initPatchItem_15:
   \   00000134   802090E5           LDR      R2,[R0, #+128]
   \   00000138   000052E3           CMP      R2,#+0
   \   0000013C   0100000A           BEQ      ??initPatchItem_16
    127          					memcpy(str->string, (ptc_buf+bpos), str->maxlen);
   \                     ??initPatchItem_17:
   \   00000140   1E0100EF           SWI      +286
   \   00000144   400000EA           B        ??initPatchItem_2
    128          				else
    129          					memcpy(str->string, (ptc_buf+bpos), sizeof(char)*0x10);
   \                     ??initPatchItem_16:
   \   00000148   1020A0E3           MOV      R2,#+16
   \   0000014C   FBFFFFEA           B        ??initPatchItem_17
    130          				break;
    131          			}
    132          		case TYPE_UNICODE:
    133          			{
    134          				DATA_UNICODE *uni=(DATA_UNICODE *)pitem->itemData;
    135          				if(uni->maxlen)
   \                     ??initPatchItem_18:
   \   00000150   002190E5           LDR      R2,[R0, #+256]
   \   00000154   000052E3           CMP      R2,#+0
   \   00000158   0100000A           BEQ      ??initPatchItem_19
    136          					memcpy(uni->ustr, (ptc_buf+bpos), sizeof(short)*uni->maxlen);
   \   0000015C   8220A0E1           LSL      R2,R2,#+1
   \                     ??initPatchItem_20:
   \   00000160   F6FFFFEA           B        ??initPatchItem_17
    137          				else
    138          					memcpy(uni->ustr, (ptc_buf+bpos), sizeof(short)*0x10);
   \                     ??initPatchItem_19:
   \   00000164   2020A0E3           MOV      R2,#+32
   \   00000168   F4FFFFEA           B        ??initPatchItem_17
    139          				break;
    140          			}
    141          		case TYPE_HEX:
    142          			{
    143          				DATA_HEX *hex=(DATA_HEX *)pitem->itemData;
    144          				memcpy(hex->hex, (ptc_buf+bpos), (hex->maxlen?hex->maxlen:1));
   \                     ??initPatchItem_21:
   \   0000016C   802090E5           LDR      R2,[R0, #+128]
   \   00000170   000052E3           CMP      R2,#+0
   \   00000174   F1FFFF1A           BNE      ??initPatchItem_17
   \   00000178   0120A0E3           MOV      R2,#+1
   \   0000017C   EFFFFFEA           B        ??initPatchItem_17
    145          				//if(hex->maxlen)
    146          				//	memcpy(hex->hex, (ptc_buf+bpos), hex->maxlen);
    147          				//else
    148          				//	memcpy(hex->hex, (ptc_buf+bpos), 0x1);
    149          				break;
    150          			}
    151          		case TYPE_SF:
    152          			{
    153          				DATA_SF *fs=(DATA_SF *)pitem->itemData;
    154          				memcpy(fs->path, (ptc_buf+bpos), fs->maxlen?fs->maxlen:58);
   \                     ??initPatchItem_22:
   \   00000180   A02090E5           LDR      R2,[R0, #+160]
   \   00000184   000052E3           CMP      R2,#+0
   \   00000188   ECFFFF1A           BNE      ??initPatchItem_17
   \   0000018C   3A20A0E3           MOV      R2,#+58
   \   00000190   EAFFFFEA           B        ??initPatchItem_17
    155          				break;
    156          			}
    157          		case TYPE_SD:
    158          			{
    159          				DATA_SD *sd=(DATA_SD *)pitem->itemData;
    160          				memcpy(sd->path, (ptc_buf+bpos), sd->maxlen?sd->maxlen:58);
   \                     ??initPatchItem_23:
   \   00000194   802090E5           LDR      R2,[R0, #+128]
   \   00000198   000052E3           CMP      R2,#+0
   \   0000019C   3A20A003           MOVEQ    R2,#+58
   \   000001A0   1E0100EF           SWI      +286
    161          				break;
   \   000001A4   280000EA           B        ??initPatchItem_2
    162          			}
    163          		case TYPE_SL:
    164          			{
    165          				DATA_SL *sl=(DATA_SL *)pitem->itemData;
    166          				sl->initData=ptc_buf[bpos];
    167          				break;
    168          			}
    169          		case TYPE_MS:
    170          			{
    171          				DATA_MS *ms=(DATA_MS *)pitem->itemData;
    172          				//读取INT型数据指针的是LDR指令，似乎只能是使用4字节对齐的地址，改用char型处理
    173          				char *p=(ptc_buf+bpos);
    174          				char *p1=(char *)(&ms->ms);
    175          				int i=0;
   \                     ??initPatchItem_24:
   \   000001A8   0020A0E3           MOV      R2,#+0
    176          				for(;i<4;i++)
    177          					p1[i]=p[i];
   \                     ??initPatchItem_25:
   \   000001AC   0130D2E7           LDRB     R3,[R2, +R1]
   \   000001B0   0030C2E7           STRB     R3,[R2, +R0]
   \   000001B4   012082E2           ADD      R2,R2,#+1
   \   000001B8   040052E3           CMP      R2,#+4
   \   000001BC   220000AA           BGE      ??initPatchItem_2
   \   000001C0   F9FFFFEA           B        ??initPatchItem_25
    178          				break;
    179          			}
    180          		case TYPE_POSB:
    181          			{
    182          				DATA_POS *pos=(DATA_POS *)pitem->itemData;
    183          				if(ptc_buf[bpos]==0xFF&&ptc_buf[bpos+1]==0xFF)
   \                     ??initPatchItem_26:
   \   000001C4   00C0D1E5           LDRB     R12,[R1, #+0]
   \   000001C8   FF005CE3           CMP      R12,#+255
   \   000001CC   01C0D105           LDRBEQ   R12,[R1, #+1]
   \   000001D0   FF005C03           CMPEQ    R12,#+255
   \   000001D4   0400001A           BNE      ??initPatchItem_27
    184          				{
    185          					pos->off=1;
   \   000001D8   0230C0E5           STRB     R3,[R0, #+2]
    186          					pos->x=66;
   \   000001DC   4210A0E3           MOV      R1,#+66
   \   000001E0   B010C0E1           STRH     R1,[R0, #+0]
    187          					pos->y=88;
   \   000001E4   5810A0E3           MOV      R1,#+88
   \   000001E8   B3FFFFEA           B        ??initPatchItem_6
    188          				}
    189          				else
    190          				{
    191          					pos->x=ptc_buf[bpos];
   \                     ??initPatchItem_27:
   \   000001EC   0010D1E5           LDRB     R1,[R1, #+0]
   \   000001F0   B010C0E1           STRH     R1,[R0, #+0]
    192          					pos->y=ptc_buf[bpos+1];
   \   000001F4   001092E5           LDR      R1,[R2, #+0]
   \   000001F8   011085E0           ADD      R1,R5,R1
   \   000001FC   0110D1E5           LDRB     R1,[R1, #+1]
   \   00000200   ADFFFFEA           B        ??initPatchItem_6
    193          				}
    194          				break;
    195          			}
    196          		case TYPE_BYTES:
    197          			{
    198          				DATA_BYTES *dbytes=(DATA_BYTES *)pitem->itemData;
    199          				memcpy(dbytes->bytes, ptc_buf+bpos, dbytes->len);
   \                     ??initPatchItem_28:
   \   00000204   042090E5           LDR      R2,[R0, #+4]
   \   00000208   080080E2           ADD      R0,R0,#+8
   \   0000020C   CBFFFFEA           B        ??initPatchItem_17
    200          				break;
    201          			}
    202          		case TYPE_INTS:
    203          			{
    204          				DATA_INTS *dints=(DATA_INTS *)pitem->itemData;
    205          				memcpy(dints->ints, ptc_buf+bpos, (dints->len)*sizeof(int));
   \                     ??initPatchItem_29:
   \   00000210   082090E5           LDR      R2,[R0, #+8]
   \   00000214   0C0080E2           ADD      R0,R0,#+12
   \   00000218   0221A0E1           LSL      R2,R2,#+2
   \   0000021C   C7FFFFEA           B        ??initPatchItem_17
    206          				break;
    207          			}
    208          		case TYPE_CONST:
    209          			{
    210          				DATA_CONST *dconst=(DATA_CONST *)pitem->itemData;
    211          				//读取INT型数据指针的是LDR指令，似乎只能是使用4字节对齐的地址，改用char型处理
    212          				char *p=(ptc_buf+bpos);
    213          				char *p1=(char *)(&dconst->data);
    214          				int i=0;
   \                     ??initPatchItem_30:
   \   00000220   043090E5           LDR      R3,[R0, #+4]
   \   00000224   0020A0E3           MOV      R2,#+0
   \   00000228   010053E3           CMP      R3,#+1
   \   0000022C   030000AA           BGE      ??initPatchItem_31
   \   00000230   050000EA           B        ??initPatchItem_2
    215          				for(;i<(dconst->len);i++)
    216          					p1[i]=p[i];
   \                     ??initPatchItem_32:
   \   00000234   0130D2E7           LDRB     R3,[R2, +R1]
   \   00000238   0030C2E7           STRB     R3,[R2, +R0]
   \   0000023C   012082E2           ADD      R2,R2,#+1
   \                     ??initPatchItem_31:
   \   00000240   043090E5           LDR      R3,[R0, #+4]
   \   00000244   030052E1           CMP      R2,R3
   \   00000248   F9FFFFBA           BLT      ??initPatchItem_32
    217          				break;
    218          			}
    219          		}
    220          	NEXT_ITEM:
    221          		pitem=pitem->next;
   \                     ??initPatchItem_2:
   \   0000024C   044094E5           LDR      R4,[R4, #+4]
    222          	}
   \   00000250   000054E3           CMP      R4,#+0
   \   00000254   6CFFFF1A           BNE      ??initPatchItem_1
    223          }
   \   00000258   3080BDE8           POP      {R4,R5,PC}       ;; return
    224          
    225          //从*.ptc读取数据，初始化配置

   \                                 In segment CODE, align 4, keep-with-next
    226          void initPatchConfig(PTC_CONFIG *ptcfg)
    227          {
    228          	char ptcpath[128];
    229          	char ptcid[16];
    230          #ifdef WINTEL_DEBUG
    231          	FILE *fp;
    232          	strcpy(ptcpath, PATCH_DIR);
    233          	strcat(ptcpath, PTC_FOLDR);
    234          	sprintf(ptcid, "%08s", ptcfg->patchInfo->patchID);
    235          	strcat(ptcpath, ptcid);
    236          	strcat(ptcpath, ".ptc");
    237          	fp=fopen(ptcpath, "rb");
    238          	if(!fp)
    239          		return;
    240          	ptcfilesize=fread(ptc_buf, 1, PTC_SIZE, fp);
    241          	fclose(fp);
    242          #else
    243          	int f;
    244          	unsigned int ferr;
    245          	strcpy(ptcpath, PATCH_DIR);
   \                     initPatchConfig:
   \   00000000   ........           LDR      R1,??DataTable7  ;; `?<Constant "0:\\\\Misc\\\\Patches\\\\">`
   \   00000004   F0402DE9           PUSH     {R4-R7,LR}
   \   00000008   94D04DE2           SUB      SP,SP,#+148
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   14008DE2           ADD      R0,SP,#+20
   \   00000014   1A0000EF           SWI      +26
    246          	strcat(ptcpath, PTC_FOLDR);
   \   00000018   ........           LDR      R1,??DataTable8  ;; `?<Constant "ptc\\\\">`
   \   0000001C   14008DE2           ADD      R0,SP,#+20
   \   00000020   170000EF           SWI      +23
    247          	sprintf(ptcid, _percent_08s, ptcfg->patchInfo->patchID);
   \   00000024   1C0094E5           LDR      R0,[R4, #+28]
   \   00000028   ........           LDR      R1,??DataTable9  ;; `?<Constant "%08s">`
   \   0000002C   802080E2           ADD      R2,R0,#+128
   \   00000030   04008DE2           ADD      R0,SP,#+4
   \   00000034   160000EF           SWI      +22
    248          	strcat(ptcpath, ptcid);
   \   00000038   04108DE2           ADD      R1,SP,#+4
   \   0000003C   14008DE2           ADD      R0,SP,#+20
   \   00000040   170000EF           SWI      +23
    249          	strcat(ptcpath, ".ptc");
   \   00000044   ........           LDR      R1,??DataTable10  ;; `?<Constant ".ptc">`
   \   00000048   14008DE2           ADD      R0,SP,#+20
   \   0000004C   170000EF           SWI      +23
    250          	f=fopen(ptcpath, A_BIN+A_ReadOnly, P_READ, &ferr);
   \   00000050   0D30A0E1           MOV      R3,SP
   \   00000054   8020A0E3           MOV      R2,#+128
   \   00000058   801CA0E3           MOV      R1,#+32768
   \   0000005C   14008DE2           ADD      R0,SP,#+20
   \   00000060   0A0000EF           SWI      +10
   \   00000064   0050A0E1           MOV      R5,R0
    251          	if(f==-1)
   \   00000068   010075E3           CMN      R5,#+1
   \   0000006C   1100000A           BEQ      ??initPatchConfig_0
    252          		return;
    253          	ptcfilesize=fread(f, ptc_buf, PTC_SIZE, &ferr);
   \   00000070   48609FE5           LDR      R6,??initPatchConfig_1  ;; ptcfilesize
   \   00000074   ........           LDR      R7,??DataTable11  ;; ptc_buf
   \   00000078   0D30A0E1           MOV      R3,SP
   \   0000007C   001097E5           LDR      R1,[R7, #+0]
   \   00000080   802EA0E3           MOV      R2,#+2048
   \   00000084   0B0000EF           SWI      +11
   \   00000088   000086E5           STR      R0,[R6, #+0]
    254          	fclose(f, &ferr);
   \   0000008C   0D10A0E1           MOV      R1,SP
   \   00000090   0500A0E1           MOV      R0,R5
   \   00000094   0D0000EF           SWI      +13
    255          #endif
    256          	if(ptcfilesize<0)
   \   00000098   000096E5           LDR      R0,[R6, #+0]
   \   0000009C   000050E3           CMP      R0,#+0
   \   000000A0   0400004A           BMI      ??initPatchConfig_0
    257          		return;
    258          	//ptc_buf[ptcfilesize]=0;
    259          	ptcfg->patchonoff=ptc_buf[0];
   \   000000A4   000097E5           LDR      R0,[R7, #+0]
   \   000000A8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000000AC   0800C4E5           STRB     R0,[R4, #+8]
    260          	initPatchItem(ptcfg->mainitem.item);
   \   000000B0   A00094E5           LDR      R0,[R4, #+160]
   \   000000B4   ........           BL       initPatchItem
    261          }
   \                     ??initPatchConfig_0:
   \   000000B8   94D08DE2           ADD      SP,SP,#+148      ;; stack cleaning
   \   000000BC   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??initPatchConfig_1:
   \   000000C0   ........           DC32     ptcfilesize
    262          
    263          //找到最近字节位置的条目

   \                                 In segment CODE, align 4, keep-with-next
    264          PATCH_ITEM *findNextBposItem(PATCH_ITEM *ptcitem, int bpos)
    265          {
   \                     findNextBposItem:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0060A0E1           MOV      R6,R0
    266          	PATCH_ITEM *pitem=ptcitem;
    267          	PATCH_ITEM *titem=0;
   \   0000000C   0050A0E3           MOV      R5,#+0
    268          	PATCH_ITEM *item2=0;
    269          	int t=0;
   \   00000010   0070A0E3           MOV      R7,#+0
    270          	int t1=0;
   \   00000014   000056E3           CMP      R6,#+0
   \   00000018   0700001A           BNE      ??findNextBposItem_0
    271          	while(pitem)
    272          	{
    273          		if(pitem->itemType==TYPE_SUBMENU)
    274          		{
    275          			PATCH_SUBMENU *submenu=(PATCH_SUBMENU *)pitem->itemData;
    276          			if(submenu&&(item2=findNextBposItem(submenu->item, bpos)))
    277          			{
    278          				if(titem)
    279          				{
    280          					if(titem->bytePos>item2->bytePos)
    281          						titem=item2;
    282          				}
    283          				else
    284          					titem=item2;
    285          			}
    286          			if(titem)
    287          				t=t1=titem->bytePos;
    288          			pitem=pitem->next;
    289          			continue;
    290          		}
    291          		else
    292          			t1=pitem->bytePos;
    293          		if(t1>bpos) //先找到一个大于bpos的值，然后找最近的；
    294          		{
    295          			if(!t)
    296          			{
    297          				t=pitem->bytePos;
    298          				titem=pitem;
    299          			}
    300          			else if(t1>bpos&&t1<t)
    301          			{
    302          				t=t1;
    303          				titem=pitem;
    304          			}
    305          		}
    306          		pitem=pitem->next;
    307          	}
    308          	return titem;
   \                     ??findNextBposItem_1:
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   F080BDE8           POP      {R4-R7,PC}       ;; return
   \                     ??findNextBposItem_2:
   \   00000024   000055E3           CMP      R5,#+0
   \   00000028   0000000A           BEQ      ??findNextBposItem_3
   \                     ??findNextBposItem_4:
   \   0000002C   087095E5           LDR      R7,[R5, #+8]
   \                     ??findNextBposItem_3:
   \   00000030   046096E5           LDR      R6,[R6, #+4]
   \   00000034   000056E3           CMP      R6,#+0
   \   00000038   F7FFFF0A           BEQ      ??findNextBposItem_1
   \                     ??findNextBposItem_0:
   \   0000003C   8C0096E5           LDR      R0,[R6, #+140]
   \   00000040   0B0050E3           CMP      R0,#+11
   \   00000044   0F00001A           BNE      ??findNextBposItem_5
   \   00000048   900096E5           LDR      R0,[R6, #+144]
   \   0000004C   000050E3           CMP      R0,#+0
   \   00000050   F3FFFF0A           BEQ      ??findNextBposItem_2
   \   00000054   800090E5           LDR      R0,[R0, #+128]
   \   00000058   0410A0E1           MOV      R1,R4
   \   0000005C   E7FFFFEB           BL       findNextBposItem
   \   00000060   000050E3           CMP      R0,#+0
   \   00000064   EEFFFF0A           BEQ      ??findNextBposItem_2
   \   00000068   000055E3           CMP      R5,#+0
   \   0000006C   0300000A           BEQ      ??findNextBposItem_6
   \   00000070   081090E5           LDR      R1,[R0, #+8]
   \   00000074   082095E5           LDR      R2,[R5, #+8]
   \   00000078   020051E1           CMP      R1,R2
   \   0000007C   EAFFFFAA           BGE      ??findNextBposItem_4
   \                     ??findNextBposItem_6:
   \   00000080   0050A0E1           MOV      R5,R0
   \   00000084   E8FFFFEA           B        ??findNextBposItem_4
   \                     ??findNextBposItem_5:
   \   00000088   080096E5           LDR      R0,[R6, #+8]
   \   0000008C   000054E1           CMP      R4,R0
   \   00000090   E6FFFFAA           BGE      ??findNextBposItem_3
   \   00000094   000057E3           CMP      R7,#+0
   \   00000098   0200001A           BNE      ??findNextBposItem_7
   \                     ??findNextBposItem_8:
   \   0000009C   0070A0E1           MOV      R7,R0
   \   000000A0   0650A0E1           MOV      R5,R6
   \   000000A4   E1FFFFEA           B        ??findNextBposItem_3
   \                     ??findNextBposItem_7:
   \   000000A8   070050E1           CMP      R0,R7
   \   000000AC   DFFFFFAA           BGE      ??findNextBposItem_3
   \   000000B0   F9FFFFEA           B        ??findNextBposItem_8
    309          }
    310          
    311          //在同一个字节上，找到下一个位的条目，用于CheckBox

   \                                 In segment CODE, align 4, keep-with-next
    312          PATCH_ITEM *getTheSameBPosCheckBox(PATCH_ITEM *ptcitem, int bpos, int bitpos, int type)
    313          {
   \                     getTheSameBPosCheckBox:
   \   00000000   F0402DE9           PUSH     {R4-R7,LR}
   \   00000004   0140A0E1           MOV      R4,R1
   \   00000008   0250A0E1           MOV      R5,R2
   \   0000000C   0070A0E1           MOV      R7,R0
   \   00000010   0360A0E1           MOV      R6,R3
    314          	//type 1:the same, 0,larger
    315          	PATCH_ITEM *pitem=ptcitem;
    316          	PATCH_ITEM *titem=0;
   \   00000014   0000A0E3           MOV      R0,#+0
   \   00000018   050000EA           B        ??getTheSameBPosCheckBox_0
    317          	while(pitem)
    318          	{
    319          		if(pitem->itemType==TYPE_SUBMENU)
    320          		{
    321          			PATCH_SUBMENU *submenu=(PATCH_SUBMENU *)pitem->itemData;
    322          			if(submenu)
    323          			{
    324          				titem=getTheSameBPosCheckBox(submenu->item, bpos, bitpos, type);
    325          				if(titem)
    326          					return titem;
    327          			}
    328          
    329          		}
    330          		if((pitem->bytePos==bpos)&&(pitem->itemType==TYPE_CHECKBOX))
    331          		{
    332          			DATA_CHECKBOX *chk=(DATA_CHECKBOX *)pitem->itemData;
    333          			if(type)
    334          			{
    335          				if(chk->bitPos==bitpos)
    336          					return pitem;
    337          			}
    338          			if(chk->bitPos>bitpos)
    339          			{
    340          				if(!titem)
    341          					titem=pitem;
    342          				else
    343          				{
    344          					DATA_CHECKBOX *chk1=(DATA_CHECKBOX *)titem->itemData;
    345          					//DATA_CHECKBOX *chk=(DATA_CHECKBOX *)titem->itemData;
    346          					if(chk1->bitPos>chk->bitPos)
   \                     ??getTheSameBPosCheckBox_1:
   \   0000001C   902090E5           LDR      R2,[R0, #+144]
   \   00000020   002092E5           LDR      R2,[R2, #+0]
   \   00000024   020051E1           CMP      R1,R2
   \   00000028   000000AA           BGE      ??getTheSameBPosCheckBox_2
    347          						titem=pitem;
   \                     ??getTheSameBPosCheckBox_3:
   \   0000002C   0700A0E1           MOV      R0,R7
    348          				}
    349          			}
    350          		}
    351          		pitem=pitem->next;
   \                     ??getTheSameBPosCheckBox_2:
   \   00000030   047097E5           LDR      R7,[R7, #+4]
   \                     ??getTheSameBPosCheckBox_0:
   \   00000034   000057E3           CMP      R7,#+0
   \   00000038   F080BD08           POPEQ    {R4-R7,PC}
   \   0000003C   8C1097E5           LDR      R1,[R7, #+140]
   \   00000040   0B0051E3           CMP      R1,#+11
   \   00000044   0900001A           BNE      ??getTheSameBPosCheckBox_4
   \   00000048   90C097E5           LDR      R12,[R7, #+144]
   \   0000004C   00005CE3           CMP      R12,#+0
   \   00000050   0600000A           BEQ      ??getTheSameBPosCheckBox_4
   \   00000054   80009CE5           LDR      R0,[R12, #+128]
   \   00000058   0630A0E1           MOV      R3,R6
   \   0000005C   0520A0E1           MOV      R2,R5
   \   00000060   0410A0E1           MOV      R1,R4
   \   00000064   E5FFFFEB           BL       getTheSameBPosCheckBox
   \   00000068   000050E3           CMP      R0,#+0
   \   0000006C   F080BD18           POPNE    {R4-R7,PC}
   \                     ??getTheSameBPosCheckBox_4:
   \   00000070   081097E5           LDR      R1,[R7, #+8]
   \   00000074   040051E1           CMP      R1,R4
   \   00000078   8C109705           LDREQ    R1,[R7, #+140]
   \   0000007C   02005103           CMPEQ    R1,#+2
   \   00000080   EAFFFF1A           BNE      ??getTheSameBPosCheckBox_2
   \   00000084   901097E5           LDR      R1,[R7, #+144]
   \   00000088   000056E3           CMP      R6,#+0
   \   0000008C   0300000A           BEQ      ??getTheSameBPosCheckBox_5
   \   00000090   002091E5           LDR      R2,[R1, #+0]
   \   00000094   050052E1           CMP      R2,R5
   \   00000098   0700A001           MOVEQ    R0,R7
   \   0000009C   F080BD08           POPEQ    {R4-R7,PC}
   \                     ??getTheSameBPosCheckBox_5:
   \   000000A0   001091E5           LDR      R1,[R1, #+0]
   \   000000A4   010055E1           CMP      R5,R1
   \   000000A8   E0FFFFAA           BGE      ??getTheSameBPosCheckBox_2
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   D9FFFF1A           BNE      ??getTheSameBPosCheckBox_1
   \   000000B4   DCFFFFEA           B        ??getTheSameBPosCheckBox_3
    352          	}
    353          	return titem;
    354          }
    355          
    356          //将数据填充到ptc_buf中，为重新写入ptc做准备

   \                                 In segment CODE, align 4, keep-with-next
    357          void fillItemDataToBuf(PATCH_ITEM *ptcitem)
    358          {
   \                     fillItemDataToBuf:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    359          	PATCH_ITEM *pitem;
    360          	int bpos=0;
   \   00000008   0050A0E3           MOV      R5,#+0
    361          	if(!ptcitem)
   \   0000000C   0200001A           BNE      ??fillItemDataToBuf_1
   \   00000010   7080BDE8           POP      {R4-R6,PC}       ;; return
    362          		return;
    363          	while((pitem=findNextBposItem(ptcitem, bpos)))
    364          	{
    365          		bpos=pitem->bytePos;
    366          		switch(pitem->itemType)
    367          		{
    368          		case TYPE_CHECKBOX:
    369          			{
    370          				//int c=ptc_buf[bpos];
    371          				int bitPos;
    372          				PATCH_ITEM *item_2;
    373          				item_2=getTheSameBPosCheckBox(ptcitem, bpos, 0, 1);
    374          				do{
    375          					DATA_CHECKBOX *chkbox=(DATA_CHECKBOX *)item_2->itemData;
    376          					char c=chkbox->onoff;
    377          					bitPos=chkbox->bitPos;
    378          					if(c)
    379          					{
    380          						c=1<<bitPos;
    381          						ptc_buf[bpos]=ptc_buf[bpos]|c;
    382          					}
    383          					else
    384          					{
    385          						c=~(1<<bitPos);
    386          						ptc_buf[bpos]=ptc_buf[bpos]&c;
    387          					}
    388          				}while(item_2=getTheSameBPosCheckBox(ptcitem, bpos, bitPos, 0));
    389          				break;
    390          			}
    391          		case TYPE_SUBMENU:
    392          			{
    393          				PATCH_SUBMENU *sitem=(PATCH_SUBMENU *)pitem->itemData;
    394          				fillItemDataToBuf(sitem->item);
   \                     ??fillItemDataToBuf_2:
   \   00000014   800091E5           LDR      R0,[R1, #+128]
   \   00000018   F8FFFFEB           BL       fillItemDataToBuf
    395          				break;
    396          			}
   \                     ??fillItemDataToBuf_1:
   \   0000001C   0510A0E1           MOV      R1,R5
   \   00000020   0400A0E1           MOV      R0,R4
   \   00000024   ........           BL       findNextBposItem
   \   00000028   000050E3           CMP      R0,#+0
   \   0000002C   7080BD08           POPEQ    {R4-R6,PC}
   \   00000030   ........           LDR      R6,??DataTable11  ;; ptc_buf
   \   00000034   082080E2           ADD      R2,R0,#+8
   \   00000038   005092E5           LDR      R5,[R2, #+0]
   \   0000003C   881092E5           LDR      R1,[R2, #+136]
   \   00000040   842092E5           LDR      R2,[R2, #+132]
   \   00000044   000096E5           LDR      R0,[R6, #+0]
   \   00000048   022042E2           SUB      R2,R2,#+2
   \   0000004C   130052E3           CMP      R2,#+19
   \   00000050   F1FFFF8A           BHI      ??fillItemDataToBuf_1
   \   00000054   023F8FE2           ADR      R3,??fillItemDataToBuf_0
   \   00000058   8220A0E1           MOV      R2,R2, LSL #+1
   \   0000005C   F23093E1           LDRSH    R3,[R3, R2]
   \   00000060   03F18FE0           ADD      PC,PC,R3, LSL #+2
   \                     ??fillItemDataToBuf_0:
   \   00000064   090022002D00       DC16     +9,+34,+45,+48
   \              3000        
   \   0000006C   39003B004300       DC16     +57,+59,+67,+75
   \              4B00        
   \   00000074   4E00EBFF5C00       DC16     +78,+65515,+92,+75
   \              4B00        
   \   0000007C   4B0069008000       DC16     +75,+105,+128,+45
   \              2D00        
   \   00000084   8500EDFF7100       DC16     +133,+65517,+113,+137
   \              8900        
   \                     ??fillItemDataToBuf_3:
   \   0000008C   0130A0E3           MOV      R3,#+1
   \   00000090   0020A0E3           MOV      R2,#+0
   \   00000094   0510A0E1           MOV      R1,R5
   \   00000098   0400A0E1           MOV      R0,R4
   \   0000009C   ........           BL       getTheSameBPosCheckBox
   \   000000A0   060000EA           B        ??fillItemDataToBuf_4
   \                     ??fillItemDataToBuf_5:
   \   000000A4   0010C0E5           STRB     R1,[R0, #+0]
   \   000000A8   0030A0E3           MOV      R3,#+0
   \   000000AC   0510A0E1           MOV      R1,R5
   \   000000B0   0400A0E1           MOV      R0,R4
   \   000000B4   ........           BL       getTheSameBPosCheckBox
   \   000000B8   000050E3           CMP      R0,#+0
   \   000000BC   D6FFFF0A           BEQ      ??fillItemDataToBuf_1
   \                     ??fillItemDataToBuf_4:
   \   000000C0   901090E5           LDR      R1,[R0, #+144]
   \   000000C4   000096E5           LDR      R0,[R6, #+0]
   \   000000C8   002091E5           LDR      R2,[R1, #+0]
   \   000000CC   0410D1E5           LDRB     R1,[R1, #+4]
   \   000000D0   000085E0           ADD      R0,R5,R0
   \   000000D4   0130A0E3           MOV      R3,#+1
   \   000000D8   000051E3           CMP      R1,#+0
   \   000000DC   0010D0E5           LDRB     R1,[R0, #+0]
   \   000000E0   1332A0E1           LSL      R3,R3,R2
   \   000000E4   0310C101           BICEQ    R1,R1,R3
   \   000000E8   01108311           ORRNE    R1,R3,R1
   \   000000EC   ECFFFFEA           B        ??fillItemDataToBuf_5
    397          		case TYPE_POS:
    398          			{
    399          				DATA_POS *pos=(DATA_POS *)pitem->itemData;
    400          				short *sp=(short *)(ptc_buf+bpos);
    401          				unsigned char *xp=(unsigned char *)(ptc_buf+bpos+1);
    402          				char *px=(char *)&pos->x;
    403          				ptc_buf[bpos]=*px;
   \                     ??fillItemDataToBuf_6:
   \   000000F0   0030D1E5           LDRB     R3,[R1, #+0]
   \   000000F4   000085E0           ADD      R0,R5,R0
   \   000000F8   012080E2           ADD      R2,R0,#+1
   \   000000FC   0030C0E5           STRB     R3,[R0, #+0]
    404          				if(pos->off)
   \   00000100   0230D1E5           LDRB     R3,[R1, #+2]
   \   00000104   000053E3           CMP      R3,#+0
    405          					*xp=0x80;
   \   00000108   8030A013           MOVNE    R3,#+128
   \   0000010C   0030C215           STRBNE   R3,[R2, #+0]
    406          				*(sp+1)=pos->y;
   \   00000110   F410D1E1           LDRSH    R1,[R1, #+4]
   \   00000114   B210C0E1           STRH     R1,[R0, #+2]
    407          				break;
   \   00000118   BFFFFFEA           B        ??fillItemDataToBuf_1
    408          			}
    409          		case TYPE_BYTE:
    410          			{
    411          				DATA_BYTE *dbyte=(DATA_BYTE *)pitem->itemData;
    412          				ptc_buf[bpos]=dbyte->initData;
   \                     ??fillItemDataToBuf_7:
   \   0000011C   0210D1E5           LDRB     R1,[R1, #+2]
   \                     ??fillItemDataToBuf_8:
   \   00000120   0010C5E7           STRB     R1,[R5, +R0]
    413          				break;
   \   00000124   BCFFFFEA           B        ??fillItemDataToBuf_1
    414          			}
    415          		case TYPE_INT:
    416          			{
    417          				DATA_INT *dint=(DATA_INT *)pitem->itemData;
    418          				char *p=ptc_buf+bpos;
   \                     ??fillItemDataToBuf_9:
   \   00000128   000085E0           ADD      R0,R5,R0
    419          				char *p1=(char *)&dint->initData;
   \   0000012C   081081E2           ADD      R1,R1,#+8
    420          				int i=0;
   \   00000130   0020A0E3           MOV      R2,#+0
    421          				for(;i<4;i++)
    422          					p[i]=p1[i];
   \                     ??fillItemDataToBuf_10:
   \   00000134   0130D2E7           LDRB     R3,[R2, +R1]
   \   00000138   0030C2E7           STRB     R3,[R2, +R0]
   \   0000013C   012082E2           ADD      R2,R2,#+1
   \   00000140   040052E3           CMP      R2,#+4
   \   00000144   B4FFFFAA           BGE      ??fillItemDataToBuf_1
   \   00000148   F9FFFFEA           B        ??fillItemDataToBuf_10
    423          				break;
    424          			}
    425          		case TYPE_CBOX:
    426          			{
    427          				DATA_CBOX *cbox=(DATA_CBOX *)pitem->itemData;
    428          				ptc_buf[bpos]=cbox->initData;
   \                     ??fillItemDataToBuf_11:
   \   0000014C   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000150   F2FFFFEA           B        ??fillItemDataToBuf_8
    429          				break;
    430          			}
    431          		case TYPE_COLOR:
    432          			{
    433          				DATA_COLOR *color=(DATA_COLOR *)pitem->itemData;
    434          				char *p=ptc_buf+bpos;
   \                     ??fillItemDataToBuf_12:
   \   00000154   000085E0           ADD      R0,R5,R0
    435          				char *p1=color->color;
    436          				int i=0;
   \   00000158   0020A0E3           MOV      R2,#+0
    437          				for(;i<4;i++)
    438          					p[i]=p1[i];
   \                     ??fillItemDataToBuf_13:
   \   0000015C   0130D2E7           LDRB     R3,[R2, +R1]
   \   00000160   0030C2E7           STRB     R3,[R2, +R0]
   \   00000164   012082E2           ADD      R2,R2,#+1
   \   00000168   040052E3           CMP      R2,#+4
   \   0000016C   AAFFFFAA           BGE      ??fillItemDataToBuf_1
   \   00000170   F9FFFFEA           B        ??fillItemDataToBuf_13
    439          				break;
    440          			}
    441          		case TYPE_ADDRESS:
    442          			{
    443          				DATA_ADDRESS *addr=(DATA_ADDRESS *)pitem->itemData;
    444          				char *p=ptc_buf+bpos;
   \                     ??fillItemDataToBuf_14:
   \   00000174   000085E0           ADD      R0,R5,R0
    445          				char *p1=(char *)&addr->addr;
    446          				int i=0;
   \   00000178   0020A0E3           MOV      R2,#+0
    447          				for(;i<4;i++)
    448          					p[i]=p1[i];
   \                     ??fillItemDataToBuf_15:
   \   0000017C   0130D2E7           LDRB     R3,[R2, +R1]
   \   00000180   0030C2E7           STRB     R3,[R2, +R0]
   \   00000184   012082E2           ADD      R2,R2,#+1
   \   00000188   040052E3           CMP      R2,#+4
   \   0000018C   A2FFFFAA           BGE      ??fillItemDataToBuf_1
   \   00000190   F9FFFFEA           B        ??fillItemDataToBuf_15
    449          				break;
    450          			}
    451          		case TYPE_STRING:
    452          			{
    453          				DATA_STRING *str=(DATA_STRING *)pitem->itemData;
    454          				char *p=ptc_buf+bpos;
    455          				char *p1=str->string;
    456          				strcpy(p, p1);
   \                     ??fillItemDataToBuf_16:
   \   00000194   000085E0           ADD      R0,R5,R0
   \   00000198   1A0000EF           SWI      +26
    457          				break;
   \   0000019C   9EFFFFEA           B        ??fillItemDataToBuf_1
    458          			}
    459          		case TYPE_UNICODE:
    460          			{
    461          				DATA_UNICODE *uni=(DATA_UNICODE *)pitem->itemData;
    462          				unsigned short *p=(unsigned short *)(ptc_buf+bpos);
    463          				unsigned short *p1=uni->ustr;
    464          				int i=0;
    465          				int n;
    466          				if(!uni->maxlen)
   \                     ??fillItemDataToBuf_17:
   \   000001A0   003191E5           LDR      R3,[R1, #+256]
   \   000001A4   000085E0           ADD      R0,R5,R0
   \   000001A8   0020A0E3           MOV      R2,#+0
   \   000001AC   000053E3           CMP      R3,#+0
    467          					n=0x10;
   \   000001B0   1030A003           MOVEQ    R3,#+16
   \   000001B4   0100000A           BEQ      ??fillItemDataToBuf_18
    468          				else
    469          					n=uni->maxlen;
    470          				for(;i<n;i++)
   \                     ??fillItemDataToBuf_19:
   \   000001B8   030052E1           CMP      R2,R3
   \   000001BC   96FFFFAA           BGE      ??fillItemDataToBuf_1
    471          					p[i]=p1[i];
   \                     ??fillItemDataToBuf_18:
   \   000001C0   82C081E0           ADD      R12,R1,R2, LSL #+1
   \   000001C4   B0C0DCE1           LDRH     R12,[R12, #+0]
   \   000001C8   826080E0           ADD      R6,R0,R2, LSL #+1
   \   000001CC   012082E2           ADD      R2,R2,#+1
   \   000001D0   B0C0C6E1           STRH     R12,[R6, #+0]
   \   000001D4   F7FFFFEA           B        ??fillItemDataToBuf_19
    472          				break;
    473          			}
    474          		case TYPE_HEX:
    475          			{
    476          				DATA_HEX *hex=(DATA_HEX *)pitem->itemData;
    477          				char *p=ptc_buf+bpos;
    478          				char *p1=(char *)hex->hex;
    479          				int i=0;
    480          				int n=(hex->maxlen?hex->maxlen:1);
   \                     ??fillItemDataToBuf_20:
   \   000001D8   803091E5           LDR      R3,[R1, #+128]
   \   000001DC   000085E0           ADD      R0,R5,R0
   \   000001E0   0020A0E3           MOV      R2,#+0
   \   000001E4   000053E3           CMP      R3,#+0
   \   000001E8   0500000A           BEQ      ??fillItemDataToBuf_21
    481          				//if(!hex->maxlen)
    482          				//	n=0x1;
    483          				//else
    484          				//	n=hex->maxlen;
    485          				for(;i<n;i++)
   \                     ??fillItemDataToBuf_22:
   \   000001EC   030052E1           CMP      R2,R3
   \   000001F0   89FFFFAA           BGE      ??fillItemDataToBuf_1
    486          					p[i]=p1[i];
   \                     ??fillItemDataToBuf_23:
   \   000001F4   0160D2E7           LDRB     R6,[R2, +R1]
   \   000001F8   0060C2E7           STRB     R6,[R2, +R0]
   \   000001FC   012082E2           ADD      R2,R2,#+1
   \   00000200   F9FFFFEA           B        ??fillItemDataToBuf_22
   \                     ??fillItemDataToBuf_21:
   \   00000204   0130A0E3           MOV      R3,#+1
   \   00000208   F9FFFFEA           B        ??fillItemDataToBuf_23
    487          				break;
    488          			}
    489          		case TYPE_SF:
    490          			{
    491          				DATA_SF *fs=(DATA_SF *)pitem->itemData;
    492          				char *p=ptc_buf+bpos;
    493          				char *p1=fs->path;
    494          				strcpy(p, p1);
    495          				break;
    496          			}
    497          		case TYPE_SD:
    498          			{
    499          				DATA_SD *sd=(DATA_SD *)pitem->itemData;
    500          				char *p=ptc_buf+bpos;
    501          				char *p1=sd->path;
    502          				strcpy(p, p1);
    503          				break;
    504          			}
    505          		case TYPE_SL:
    506          			{
    507          				DATA_SL *sl=(DATA_SL *)pitem->itemData;
    508          				ptc_buf[bpos]=sl->initData;
    509          				break;
    510          			}
    511          		case TYPE_MS:
    512          			{
    513          				DATA_MS *ms=(DATA_MS *)pitem->itemData;
    514          				char *p=ptc_buf+bpos;
   \                     ??fillItemDataToBuf_24:
   \   0000020C   000085E0           ADD      R0,R5,R0
    515          				char *p1=(char *)&ms->ms;
    516          				int i=0;
   \   00000210   0020A0E3           MOV      R2,#+0
    517          				for(;i<4;i++)
    518          					p[i]=p1[i];
   \                     ??fillItemDataToBuf_25:
   \   00000214   0130D2E7           LDRB     R3,[R2, +R1]
   \   00000218   0030C2E7           STRB     R3,[R2, +R0]
   \   0000021C   012082E2           ADD      R2,R2,#+1
   \   00000220   040052E3           CMP      R2,#+4
   \   00000224   7CFFFFAA           BGE      ??fillItemDataToBuf_1
   \   00000228   F9FFFFEA           B        ??fillItemDataToBuf_25
    519          				break;
    520          			}
    521          		case TYPE_POSB:
    522          			{
    523          				DATA_POS *pos=(DATA_POS *)pitem->itemData;
    524          				unsigned char *sp=(unsigned char *)ptc_buf+bpos;
    525          				char *px=(char *)&pos->x;
    526          				char *py=(char *)&pos->y;
    527          				//*sp=*px;
    528          				//*(sp+1)=*py;
    529          				if(pos->off)
   \                     ??fillItemDataToBuf_26:
   \   0000022C   0230D1E5           LDRB     R3,[R1, #+2]
   \   00000230   002085E0           ADD      R2,R5,R0
   \   00000234   000053E3           CMP      R3,#+0
   \   00000238   0300000A           BEQ      ??fillItemDataToBuf_27
    530          				{
    531          					*sp=0xFF;
   \   0000023C   FF00A0E3           MOV      R0,#+255
   \   00000240   0000C2E5           STRB     R0,[R2, #+0]
    532          					*(sp+1)=0xFF;
   \   00000244   0100C2E5           STRB     R0,[R2, #+1]
   \   00000248   73FFFFEA           B        ??fillItemDataToBuf_1
    533          				}
    534          				else
    535          				{
    536          					ptc_buf[bpos]=*px;
   \                     ??fillItemDataToBuf_27:
   \   0000024C   0020D1E5           LDRB     R2,[R1, #+0]
   \   00000250   0020C5E7           STRB     R2,[R5, +R0]
    537          					ptc_buf[bpos+1]=*py;
   \   00000254   0410D1E5           LDRB     R1,[R1, #+4]
   \   00000258   000096E5           LDR      R0,[R6, #+0]
   \   0000025C   000085E0           ADD      R0,R5,R0
   \   00000260   0110C0E5           STRB     R1,[R0, #+1]
   \   00000264   6CFFFFEA           B        ??fillItemDataToBuf_1
    538          				}
    539          				break;
    540          			}
    541          		case TYPE_BYTES:
    542          			{
    543          				DATA_BYTES *dbytes=(DATA_BYTES *)pitem->itemData;
    544          				memcpy(ptc_buf+bpos, dbytes->bytes, dbytes->len);
   \                     ??fillItemDataToBuf_28:
   \   00000268   042091E5           LDR      R2,[R1, #+4]
   \   0000026C   081081E2           ADD      R1,R1,#+8
   \                     ??fillItemDataToBuf_29:
   \   00000270   000085E0           ADD      R0,R5,R0
   \   00000274   1E0100EF           SWI      +286
    545          				break;
   \   00000278   67FFFFEA           B        ??fillItemDataToBuf_1
    546          			}
    547          		case TYPE_INTS:
    548          			{
    549          				DATA_INTS *dints=(DATA_INTS *)pitem->itemData;
    550          				memcpy(ptc_buf+bpos, dints->ints, (dints->len)*sizeof(int));
   \                     ??fillItemDataToBuf_30:
   \   0000027C   082091E5           LDR      R2,[R1, #+8]
   \   00000280   0C1081E2           ADD      R1,R1,#+12
   \   00000284   0221A0E1           LSL      R2,R2,#+2
   \   00000288   F8FFFFEA           B        ??fillItemDataToBuf_29
    551          				break;
    552          			}
    553          		case TYPE_CONST:
    554          			{
    555          				DATA_CONST *dconst=(DATA_CONST *)pitem->itemData;
    556          				char *p=ptc_buf+bpos;
    557          				char *p1=(char *)&dconst->data;
    558          				int i=0;
   \                     ??fillItemDataToBuf_31:
   \   0000028C   043091E5           LDR      R3,[R1, #+4]
   \   00000290   000085E0           ADD      R0,R5,R0
   \   00000294   0020A0E3           MOV      R2,#+0
   \   00000298   010053E3           CMP      R3,#+1
   \   0000029C   5EFFFFBA           BLT      ??fillItemDataToBuf_1
    559          				for(;i<(dconst->len);i++)
   \                     ??fillItemDataToBuf_32:
   \   000002A0   043091E5           LDR      R3,[R1, #+4]
   \   000002A4   030052E1           CMP      R2,R3
   \   000002A8   5BFFFFAA           BGE      ??fillItemDataToBuf_1
    560          					p[i]=p1[i];
   \   000002AC   0130D2E7           LDRB     R3,[R2, +R1]
   \   000002B0   0030C2E7           STRB     R3,[R2, +R0]
   \   000002B4   012082E2           ADD      R2,R2,#+1
   \   000002B8   F8FFFFEA           B        ??fillItemDataToBuf_32
    561          				break;
    562          			}
    563          		}
    564          	}
    565          }
    566          
    567          //获取要写入的PTC的大小

   \                                 In segment CODE, align 4, keep-with-next
    568          int getPtcSize(PATCH_ITEM *ptcitem)
    569          {
   \                     getPtcSize:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
    570          	PATCH_ITEM *pitem;
    571          	PATCH_ITEM *item=0;
    572          	int bpos=0;
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0040B0E1           MOVS     R4,R0
   \   0000000C   0050A0E3           MOV      R5,#+0
    573          	int ptcsize=1;
    574          	if(!ptcitem)
   \   00000010   0300001A           BNE      ??getPtcSize_1
    575          		return 1;
   \                     ??getPtcSize_2:
   \   00000014   0100A0E3           MOV      R0,#+1
   \   00000018   3080BDE8           POP      {R4,R5,PC}
    576          	while((pitem=findNextBposItem(ptcitem, bpos)))
    577          	{
    578          		bpos=pitem->bytePos;
   \                     ??getPtcSize_3:
   \   0000001C   081090E5           LDR      R1,[R0, #+8]
    579          		item=pitem;
   \   00000020   0050A0E1           MOV      R5,R0
    580          	}
   \                     ??getPtcSize_1:
   \   00000024   0400A0E1           MOV      R0,R4
   \   00000028   ........           BL       findNextBposItem
   \   0000002C   000050E3           CMP      R0,#+0
   \   00000030   F9FFFF1A           BNE      ??getPtcSize_3
    581          	if(!item)
   \   00000034   000055E3           CMP      R5,#+0
   \   00000038   F5FFFF0A           BEQ      ??getPtcSize_2
    582          		return 1;
    583          	ptcsize=item->bytePos;
    584          	switch(item->itemType)
   \   0000003C   8C1095E5           LDR      R1,[R5, #+140]
   \   00000040   084095E5           LDR      R4,[R5, #+8]
   \   00000044   900095E5           LDR      R0,[R5, #+144]
   \   00000048   021041E2           SUB      R1,R1,#+2
   \   0000004C   130051E3           CMP      R1,#+19
   \   00000050   2D00008A           BHI      ??getPtcSize_4
   \   00000054   012F8FE2           ADR      R2,??getPtcSize_0
   \   00000058   0120D2E7           LDRB     R2,[R2, R1]
   \   0000005C   02F18FE0           ADD      PC,PC,R2, LSL #+2
   \                     ??getPtcSize_0:
   \   00000060   040A040A           DC8      +4,+10,+4,+10
   \   00000064   040A0A0E           DC8      +4,+10,+10,+14
   \   00000068   1306191E           DC8      +19,+6,+25,+30
   \   0000006C   230A2804           DC8      +35,+10,+40,+4
   \   00000070   252A0C28           DC8      +37,+42,+12,+40
    585          	{
    586          		case TYPE_CHECKBOX:
    587          		case TYPE_BYTE:
    588          		case TYPE_SL:
    589          		case TYPE_CBOX:
    590          			{
    591          				ptcsize++;
   \                     ??getPtcSize_5:
   \   00000074   014084E2           ADD      R4,R4,#+1
    592          				break;
   \   00000078   010000EA           B        ??getPtcSize_6
    593          			}
    594          		case TYPE_SUBMENU:
    595          			{
    596          				PATCH_SUBMENU *sitem=(PATCH_SUBMENU *)item->itemData;
    597          				getPtcSize(sitem->item);
   \                     ??getPtcSize_7:
   \   0000007C   800090E5           LDR      R0,[R0, #+128]
   \   00000080   DEFFFFEB           BL       getPtcSize
    598          				break;
   \                     ??getPtcSize_6:
   \   00000084   0400A0E1           MOV      R0,R4
   \   00000088   3080BDE8           POP      {R4,R5,PC}
    599          			}
    600          		case TYPE_POS:
    601          		case TYPE_INT:
    602          		case TYPE_MS:
    603          		case TYPE_COLOR:
    604          		case TYPE_ADDRESS:
    605          			{
    606          				ptcsize+=4;
   \                     ??getPtcSize_8:
   \   0000008C   044084E2           ADD      R4,R4,#+4
    607          				break;
   \   00000090   FBFFFFEA           B        ??getPtcSize_6
    608          			}
    609          		case TYPE_POSB:
    610          			{
    611          				ptcsize+=2;
   \                     ??getPtcSize_9:
   \   00000094   024084E2           ADD      R4,R4,#+2
    612          				break;
   \   00000098   F9FFFFEA           B        ??getPtcSize_6
    613          			}
    614          		case TYPE_STRING:
    615          			{
    616          				DATA_STRING *str=(DATA_STRING *)item->itemData;
    617          				ptcsize+=(str->maxlen?(str->maxlen+1):0x10);
   \                     ??getPtcSize_10:
   \   0000009C   800090E5           LDR      R0,[R0, #+128]
   \   000000A0   000050E3           CMP      R0,#+0
   \   000000A4   1000A003           MOVEQ    R0,#+16
   \   000000A8   01008012           ADDNE    R0,R0,#+1
   \   000000AC   150000EA           B        ??getPtcSize_11
    618          				//if(!str->maxlen)
    619          				//{
    620          				//	ptcsize+=0x10;
    621          				//}
    622          				//else
    623          				//	ptcsize+=str->maxlen+1;
    624          				break;
    625          			}
    626          		case TYPE_UNICODE:
    627          			{
    628          				DATA_UNICODE *uni=(DATA_UNICODE *)item->itemData;
    629          				ptcsize+=(uni->maxlen?(2*(uni->maxlen+1)):0x20);
   \                     ??getPtcSize_12:
   \   000000B0   000190E5           LDR      R0,[R0, #+256]
   \   000000B4   000050E3           CMP      R0,#+0
   \   000000B8   2000A003           MOVEQ    R0,#+32
   \   000000BC   01008012           ADDNE    R0,R0,#+1
   \   000000C0   8000A011           LSLNE    R0,R0,#+1
   \   000000C4   0F0000EA           B        ??getPtcSize_11
    630          				//if(!uni->maxlen)
    631          				//	ptcsize+=0x20;
    632          				//else
    633          				//	ptcsize+=uni->maxlen*2;
    634          				break;
    635          			}
    636          		case TYPE_HEX:
    637          			{
    638          				DATA_HEX *hex=(DATA_HEX *)item->itemData;
    639          				ptcsize+=(hex->maxlen?hex->maxlen:1);
   \                     ??getPtcSize_13:
   \   000000C8   800090E5           LDR      R0,[R0, #+128]
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   0C00001A           BNE      ??getPtcSize_11
   \   000000D4   0100A0E3           MOV      R0,#+1
   \   000000D8   0A0000EA           B        ??getPtcSize_11
    640          				//if(hex->maxlen)
    641          				//	ptcsize+=hex->maxlen;
    642          				//else
    643          				//	ptcsize+=0x1;
    644          				break;
    645          			}
    646          		case TYPE_SF:
    647          			{
    648          				DATA_SF *fs=(DATA_SF *)item->itemData;
    649          				ptcsize+=(fs->maxlen?fs->maxlen:58);
   \                     ??getPtcSize_14:
   \   000000DC   A00090E5           LDR      R0,[R0, #+160]
   \                     ??getPtcSize_15:
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   0700001A           BNE      ??getPtcSize_11
   \   000000E8   3A00A0E3           MOV      R0,#+58
   \   000000EC   050000EA           B        ??getPtcSize_11
    650          				break;
    651          			}
    652          		case TYPE_SD:
    653          			{
    654          				DATA_SD *sd=(DATA_SD *)item->itemData;
    655          				ptcsize+=(sd->maxlen?sd->maxlen:58);
   \                     ??getPtcSize_16:
   \   000000F0   800090E5           LDR      R0,[R0, #+128]
   \   000000F4   F9FFFFEA           B        ??getPtcSize_15
    656          				break;
    657          			}
    658          		case TYPE_BYTES:
    659          			{
    660          				DATA_BYTES *dbytes=(DATA_BYTES *)item->itemData;
    661          				ptcsize+=dbytes->len;
    662          				break;
    663          			}
    664          		case TYPE_INTS:
    665          			{
    666          				DATA_INTS *dints=(DATA_INTS *)item->itemData;
    667          				ptcsize+=(dints->len)*sizeof(int);
   \                     ??getPtcSize_17:
   \   000000F8   080090E5           LDR      R0,[R0, #+8]
   \   000000FC   004184E0           ADD      R4,R4,R0, LSL #+2
    668          				break;
   \   00000100   DFFFFFEA           B        ??getPtcSize_6
    669          			}
    670          		case TYPE_CONST:
    671          			{
    672          				DATA_CONST *dconst=(DATA_CONST *)item->itemData;
    673          				ptcsize+=dconst->len;
   \                     ??getPtcSize_18:
   \   00000104   040090E5           LDR      R0,[R0, #+4]
   \                     ??getPtcSize_11:
   \   00000108   044080E0           ADD      R4,R0,R4
    674          				break;
    675          			}
    676          		//default :
    677          		//	ptcsize+=4;
    678          	}
    679          	return ptcsize;
   \                     ??getPtcSize_4:
   \   0000010C   0400A0E1           MOV      R0,R4
   \   00000110   3080BDE8           POP      {R4,R5,PC}       ;; return
    680          }
    681          
    682          

   \                                 In segment CODE, align 4, keep-with-next
    683          void savePatchConfig(PTC_CONFIG *ptcfg)
    684          {
    685          	char ptcpath[128];
    686          	char ptcid[16];
    687          	int ptcsize;
    688          #ifdef WINTEL_DEBUG
    689          	FILE *fp;
    690          	int i=0;
    691          	strcpy(ptcpath, PATCH_DIR);
    692          	strcat(ptcpath, PTC_FOLDR);
    693          	sprintf(ptcid, "%08s", ptcfg->patchInfo->patchID);
    694          	strcat(ptcpath, ptcid);
    695          	strcat(ptcpath, ".ptc");
    696          	fp=fopen(ptcpath, "wab");
    697          	if(!fp)
    698          		return;
    699          	for(;i<PTC_SIZE;i++)
    700          		ptc_buf[i]=0;
    701          	ptc_buf[0]=ptcfg->patchonoff;
    702          	fillItemDataToBuf(ptcfg->mainitem.item);
    703          	if(ptcfg->memory)
    704          		ptcsize=ptcfg->memory;
    705          	else
    706          		ptcsize=getPtcSize(ptcfg->mainitem.item);
    707          	fwrite(ptc_buf, 1, ptcsize, fp);
    708          	fclose(fp);
    709          #else
    710          	int f;
    711          	unsigned int ferr;
    712          	strcpy(ptcpath, PATCH_DIR);
   \                     savePatchConfig:
   \   00000000   ........           LDR      R1,??DataTable7  ;; `?<Constant "0:\\\\Misc\\\\Patches\\\\">`
   \   00000004   F0412DE9           PUSH     {R4-R8,LR}
   \   00000008   94D04DE2           SUB      SP,SP,#+148
   \   0000000C   0040A0E1           MOV      R4,R0
   \   00000010   14008DE2           ADD      R0,SP,#+20
   \   00000014   1A0000EF           SWI      +26
    713          	strcat(ptcpath, PTC_FOLDR);
   \   00000018   ........           LDR      R1,??DataTable8  ;; `?<Constant "ptc\\\\">`
   \   0000001C   14008DE2           ADD      R0,SP,#+20
   \   00000020   170000EF           SWI      +23
    714          	if(!isdir(ptcpath, &ferr))
   \   00000024   0D10A0E1           MOV      R1,SP
   \   00000028   14008DE2           ADD      R0,SP,#+20
   \   0000002C   910000EF           SWI      +145
   \   00000030   000050E3           CMP      R0,#+0
   \   00000034   0200001A           BNE      ??savePatchConfig_0
    715          		mkdir(ptcpath, &ferr);
   \   00000038   0D10A0E1           MOV      R1,SP
   \   0000003C   14008DE2           ADD      R0,SP,#+20
   \   00000040   100000EF           SWI      +16
    716          	sprintf(ptcid, _percent_08s, ptcfg->patchInfo->patchID);
   \                     ??savePatchConfig_0:
   \   00000044   1C0094E5           LDR      R0,[R4, #+28]
   \   00000048   ........           LDR      R1,??DataTable9  ;; `?<Constant "%08s">`
   \   0000004C   802080E2           ADD      R2,R0,#+128
   \   00000050   04008DE2           ADD      R0,SP,#+4
   \   00000054   160000EF           SWI      +22
    717          	strcat(ptcpath, ptcid);
   \   00000058   04108DE2           ADD      R1,SP,#+4
   \   0000005C   14008DE2           ADD      R0,SP,#+20
   \   00000060   170000EF           SWI      +23
    718          	strcat(ptcpath, ".ptc");
   \   00000064   ........           LDR      R1,??DataTable10  ;; `?<Constant ".ptc">`
   \   00000068   14008DE2           ADD      R0,SP,#+20
   \   0000006C   170000EF           SWI      +23
    719          	f=fopen(ptcpath, A_BIN+A_ReadWrite, P_WRITE+P_READ, &ferr);
   \   00000070   0D30A0E1           MOV      R3,SP
   \   00000074   602FA0E3           MOV      R2,#+384
   \   00000078   0210A0E3           MOV      R1,#+2
   \   0000007C   801C81E3           ORR      R1,R1,#0x8000
   \   00000080   14008DE2           ADD      R0,SP,#+20
   \   00000084   0A0000EF           SWI      +10
   \   00000088   0050A0E1           MOV      R5,R0
    720          	if(f==-1)
   \   0000008C   FF60A0E3           MOV      R6,#+255
   \   00000090   0080E0E3           MVN      R8,#+0
   \   00000094   0070A0E3           MOV      R7,#+0
   \   00000098   080055E1           CMP      R5,R8
   \   0000009C   1600001A           BNE      ??savePatchConfig_1
    721          	{
    722          		f=fopen(ptcpath, A_BIN+A_ReadWrite+A_Create+A_Truncate, P_WRITE+P_READ, &ferr);
   \   000000A0   0D30A0E1           MOV      R3,SP
   \   000000A4   602FA0E3           MOV      R2,#+384
   \   000000A8   0210A0E3           MOV      R1,#+2
   \   000000AC   831C81E3           ORR      R1,R1,#0x8300
   \   000000B0   14008DE2           ADD      R0,SP,#+20
   \   000000B4   0A0000EF           SWI      +10
   \   000000B8   0050A0E1           MOV      R5,R0
    723          		if(f==-1)
   \   000000BC   080055E1           CMP      R5,R8
   \   000000C0   2F00000A           BEQ      ??savePatchConfig_2
    724          			return;
    725          		goto SAVE_DATA;
    726          	}
    727          	if(!ptcfg->needSaveData)
    728          	{
    729          		if(ptcfg->disableProfile)
    730          		{
    731          			if(getPatchOnOff(ptcfg, 7))
    732          				ptcfg->patchonoff=0xFF;
    733          			else
    734          				ptcfg->patchonoff=0;
    735          		}
    736          		fwrite(f, &ptcfg->patchonoff, 1, &ferr);
    737          	}
    738          	else
    739          	{
    740          	SAVE_DATA:
    741          		zeromem(ptc_buf, PTC_SIZE);
   \                     ??savePatchConfig_3:
   \   000000C4   ........           LDR      R8,??DataTable11  ;; ptc_buf
   \   000000C8   801EA0E3           MOV      R1,#+2048
   \   000000CC   000098E5           LDR      R0,[R8, #+0]
   \   000000D0   1D0100EF           SWI      +285
    742          		if(ptcfg->disableProfile)
   \   000000D4   100094E5           LDR      R0,[R4, #+16]
   \   000000D8   000050E3           CMP      R0,#+0
   \   000000DC   1600000A           BEQ      ??savePatchConfig_4
    743          		{
    744          			if(getPatchOnOff(ptcfg, 7))
   \   000000E0   0710A0E3           MOV      R1,#+7
   \   000000E4   0400A0E1           MOV      R0,R4
   \   000000E8   ........           _BLF     getPatchOnOff,??getPatchOnOff??rA
   \   000000EC   000050E3           CMP      R0,#+0
   \   000000F0   0870C405           STRBEQ   R7,[R4, #+8]
    745          				ptcfg->patchonoff=0xFF;
   \   000000F4   0860C415           STRBNE   R6,[R4, #+8]
   \   000000F8   0F0000EA           B        ??savePatchConfig_4
    746          			else
    747          				ptcfg->patchonoff=0;
    748          		}
   \                     ??savePatchConfig_1:
   \   000000FC   0C0094E5           LDR      R0,[R4, #+12]
   \   00000100   000050E3           CMP      R0,#+0
   \   00000104   EEFFFF1A           BNE      ??savePatchConfig_3
   \   00000108   100094E5           LDR      R0,[R4, #+16]
   \   0000010C   000050E3           CMP      R0,#+0
   \   00000110   0500000A           BEQ      ??savePatchConfig_5
   \   00000114   0710A0E3           MOV      R1,#+7
   \   00000118   0400A0E1           MOV      R0,R4
   \   0000011C   ........           _BLF     getPatchOnOff,??getPatchOnOff??rA
   \   00000120   000050E3           CMP      R0,#+0
   \   00000124   0860C415           STRBNE   R6,[R4, #+8]
   \   00000128   0870C405           STRBEQ   R7,[R4, #+8]
   \                     ??savePatchConfig_5:
   \   0000012C   0D30A0E1           MOV      R3,SP
   \   00000130   0120A0E3           MOV      R2,#+1
   \   00000134   081084E2           ADD      R1,R4,#+8
   \   00000138   0C0000EA           B        ??savePatchConfig_6
    749          		ptc_buf[0]=ptcfg->patchonoff;
   \                     ??savePatchConfig_4:
   \   0000013C   0810D4E5           LDRB     R1,[R4, #+8]
   \   00000140   000098E5           LDR      R0,[R8, #+0]
   \   00000144   0010C0E5           STRB     R1,[R0, #+0]
    750          		fillItemDataToBuf(ptcfg->mainitem.item);	
   \   00000148   A00094E5           LDR      R0,[R4, #+160]
   \   0000014C   ........           BL       fillItemDataToBuf
    751          		if(ptcfg->memory)
   \   00000150   140094E5           LDR      R0,[R4, #+20]
   \   00000154   000050E3           CMP      R0,#+0
   \   00000158   0100001A           BNE      ??savePatchConfig_7
    752          			ptcsize=ptcfg->memory;
    753          		else
    754          			ptcsize=getPtcSize(ptcfg->mainitem.item);
   \   0000015C   A00094E5           LDR      R0,[R4, #+160]
   \   00000160   ........           BL       getPtcSize
    755          		fwrite(f, ptc_buf, ptcsize, &ferr);
   \                     ??savePatchConfig_7:
   \   00000164   001098E5           LDR      R1,[R8, #+0]
   \   00000168   0D30A0E1           MOV      R3,SP
   \   0000016C   0020A0E1           MOV      R2,R0
   \                     ??savePatchConfig_6:
   \   00000170   0500A0E1           MOV      R0,R5
   \   00000174   0C0000EF           SWI      +12
    756          	}
    757          	fclose(f, &ferr);
   \   00000178   0D10A0E1           MOV      R1,SP
   \   0000017C   0500A0E1           MOV      R0,R5
   \   00000180   0D0000EF           SWI      +13
    758          #endif
    759          }
   \                     ??savePatchConfig_2:
   \   00000184   94D08DE2           ADD      SP,SP,#+148      ;; stack cleaning
   \   00000188   F081BDE8           POP      {R4-R8,PC}       ;; return
    760          

   \                                 In segment CODE, align 4, keep-with-next
    761          void saveAllConfig(void)
    762          {
    763          	PTC_CONFIG *ptcfg=ptcfgtop;
   \                     saveAllConfig:
   \   00000000   24009FE5           LDR      R0,??saveAllConfig_0  ;; ptcfgtop
   \   00000004   10402DE9           PUSH     {R4,LR}
   \   00000008   004090E5           LDR      R4,[R0, #+0]
   \   0000000C   000054E3           CMP      R4,#+0
   \   00000010   1080BD08           POPEQ    {R4,PC}
    764          	while(ptcfg)
    765          	{
    766          		savePatchConfig(ptcfg);
   \                     ??saveAllConfig_1:
   \   00000014   0400A0E1           MOV      R0,R4
   \   00000018   ........           BL       savePatchConfig
    767          		ptcfg=ptcfg->next;
   \   0000001C   044094E5           LDR      R4,[R4, #+4]
    768          	}
   \   00000020   000054E3           CMP      R4,#+0
   \   00000024   FAFFFF1A           BNE      ??saveAllConfig_1
    769          }
   \   00000028   1080BDE8           POP      {R4,PC}          ;; return
   \                     ??saveAllConfig_0:
   \   0000002C   ........           DC32     ptcfgtop

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     `?<Constant "0:\\\\Misc\\\\Patches\\\\">`

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     `?<Constant "ptc\\\\">`

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     `?<Constant "%08s">`

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     `?<Constant ".ptc">`

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     ptc_buf

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "0:\\\\Misc\\\\Patches\\\\">`:
   \   00000000   303A5C4D6973       DC8 "0:\\Misc\\Patches\\"
   \              635C50617463
   \              6865735C00  
   \   00000011   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "ptc\\\\">`:
   \   00000000   7074635C00         DC8 "ptc\\"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "%08s">`:
   \   00000000   2530387300         DC8 "%08s"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant ".ptc">`:
   \   00000000   2E70746300         DC8 ".ptc"
   \   00000005   000000             DC8 0, 0, 0
    770          
    771          

   Maximum stack usage in bytes:

     Function               CSTACK
     --------               ------
     fillItemDataToBuf         16
     findNextBposItem          20
     getPtcSize                12
     getTheSameBPosCheckBox    20
     initPatchConfig          168
     initPatchItem             12
     saveAllConfig              8
     savePatchConfig          172


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     ptcfilesize                       4
     initPatchItem                   604
     initPatchConfig                 196
     findNextBposItem                180
     getTheSameBPosCheckBox          184
     fillItemDataToBuf               700
     getPtcSize                      276
     savePatchConfig                 396
     saveAllConfig                    48
     ??DataTable7                      4
     ??DataTable8                      4
     ??DataTable9                      4
     ??DataTable10                     4
     ??DataTable11                     4
     ?<Constant "0:\\Misc\\Patches\\">
                                      20
     ?<Constant "ptc\\">               8
     ?<Constant "%08s">                8
     ?<Constant ".ptc">                8
      Others                          56

 
 2 648 bytes in segment CODE
    44 bytes in segment DATA_C
     4 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
 2 604 bytes of CODE  memory (+ 56 bytes shared)
    44 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
